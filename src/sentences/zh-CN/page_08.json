[
    {
        "source": "Attribute macro applied to a static to register it as a global allocator.",
        "suggest": "å°†å±æ€§å®åº”ç”¨äºé™æ€ä»¥å°†å…¶æ³¨å†Œä¸ºåˆ†é…å™¨ã€‚",
        "translate": ""
    },
    {
        "source": "See also [`std::alloc::GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html).",
        "suggest": "å¦è¯·å‚è§ [`std::alloc::GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html)ã€‚",
        "translate": ""
    },
    {
        "source": "Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.",
        "suggest": "å¦‚æœå¯ä»¥è®¿é—®ä¼ é€’çš„è·¯å¾„ï¼Œåˆ™ä¿ç•™é€‚ç”¨äºå®ƒçš„é¡¹ï¼Œå¦åˆ™å°†å…¶åˆ é™¤ã€‚",
        "translate": ""
    },
    {
        "source": "Expands all `#[cfg]` and `#[cfg_attr]` attributes in the code fragment it's applied to.",
        "suggest": "æ‰©å±•å…¶æ‰€åº”ç”¨çš„ä»£ç ç‰‡æ®µä¸­çš„æ‰€æœ‰ `#[cfg]` å’Œ `#[cfg_attr]` å±æ€§ã€‚",
        "translate": ""
    },
    {
        "source": "Unstable implementation detail of the `rustc` compiler, do not use.",
        "suggest": "`rustc` ç¼–è¯‘å™¨çš„ä¸ç¨³å®šå®ç°ç»†èŠ‚ï¼Œè¯·å‹¿ä½¿ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Panics the current thread.",
        "suggest": "Panics å½“å‰çº¿ç¨‹ã€‚",
        "translate": ""
    },
    {
        "source": "This allows a program to terminate immediately and provide feedback to the caller of the program.",
        "suggest": "è¿™å…è®¸ç¨‹åºç«‹å³ç»ˆæ­¢å¹¶å‘ç¨‹åºçš„è°ƒç”¨è€…æä¾›åé¦ˆã€‚",
        "translate": ""
    },
    {
        "source": "should be used when a program reaches an unrecoverable state.",
        "suggest": "å½“ç¨‹åºè¾¾åˆ°ä¸å¯æ¢å¤çš„çŠ¶æ€æ—¶åº”ä½¿ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "This macro is the perfect way to assert conditions in example code and in tests.",
        "suggest": "æ­¤å®æ˜¯åœ¨ç¤ºä¾‹ä»£ç å’Œæµ‹è¯•ä¸­å£°æ˜æ¡ä»¶çš„ç†æƒ³æ–¹æ³•ã€‚",
        "translate": ""
    },
    {
        "source": "is closely tied with the `unwrap` method of both [`Option`][ounwrap] and [`Result`][runwrap] enums.",
        "suggest": "ä¸ [`Option`][ounwrap] å’Œ [`Result`][runwrap] æšä¸¾çš„ `unwrap` æ–¹æ³•ç´§å¯†ç›¸å…³ã€‚",
        "translate": ""
    },
    {
        "source": "Both implementations call `panic!` when they are set to [`None`] or [`Err`] variants.",
        "suggest": "ä¸¤ç§å®ç°éƒ½å°† `panic!` è®¾ç½®ä¸º [`None`] æˆ– [`Err`] æˆå‘˜æ—¶ã€‚",
        "translate": ""
    },
    {
        "source": "When using `panic!()` you can specify a string payload, that is built using the [`format!`] syntax.",
        "suggest": "ä½¿ç”¨ `panic!()` æ—¶ï¼Œå¯ä»¥æŒ‡å®šä½¿ç”¨ [`format!`] è¯­æ³•æ„å»ºçš„å­—ç¬¦ä¸²æœ‰æ•ˆè´Ÿè½½ã€‚",
        "translate": ""
    },
    {
        "source": "That payload is used when injecting the panic into the calling Rust thread, causing the thread to panic entirely.",
        "suggest": "å½“å°† panic æ³¨å…¥åˆ°è°ƒç”¨çš„ Rust çº¿ç¨‹ä¸­æ—¶ï¼Œå°†ä½¿ç”¨è¯¥æœ‰æ•ˆè´Ÿè½½ï¼Œä»è€Œå¯¼è‡´è¯¥çº¿ç¨‹å®Œå…¨å˜ä¸º panicã€‚",
        "translate": ""
    },
    {
        "source": "The behavior of the default `std` hook, i.e.",
        "suggest": "é»˜è®¤ `std` hook çš„è¡Œä¸ºï¼Œå³",
        "translate": ""
    },
    {
        "source": "the code that runs directly after the panic is invoked, is to print the message payload to `stderr` along with the file/line/column information of the `panic!()` call.",
        "suggest": "åœ¨è°ƒç”¨ panic ä¹‹åç›´æ¥è¿è¡Œçš„ä»£ç æ˜¯å°†æ¶ˆæ¯æœ‰æ•ˆè´Ÿè½½ä»¥åŠ `panic!()` è°ƒç”¨çš„ file/line/column ä¿¡æ¯æ‰“å°åˆ° `stderr`ã€‚",
        "translate": ""
    },
    {
        "source": "You can override the panic hook using [`std::panic::set_hook()`].",
        "suggest": "æ‚¨å¯ä»¥ä½¿ç”¨ [`std::panic::set_hook()`] è¦†ç›– panic hookã€‚",
        "translate": ""
    },
    {
        "source": "Inside the hook a panic can be accessed as a `&dyn Any + Send`, which contains either a `&str` or `String` for regular `panic!()` invocations.",
        "suggest": "åœ¨ hook å†…éƒ¨ï¼Œå¯ä»¥å°† X0panic0Z ä½œä¸º `&dyn Any + Send` è¿›è¡Œè®¿é—®ï¼Œå…¶ä¸­åŒ…å«ç”¨äºå¸¸è§„ `panic!()` è°ƒç”¨çš„ `&str` æˆ– `String`ã€‚",
        "translate": ""
    },
    {
        "source": "To panic with a value of another other type, [`panic_any`] can be used.",
        "suggest": "å¯¹äºå…·æœ‰å…¶ä»–ç±»å‹å€¼çš„ panicï¼Œå¯ä»¥ä½¿ç”¨ [`panic_any`]ã€‚",
        "translate": ""
    },
    {
        "source": "enum is often a better solution for recovering from errors than using the `panic!` macro.",
        "suggest": "ä¸ä½¿ç”¨ `panic!` å®ç›¸æ¯”ï¼Œæšä¸¾é€šå¸¸æ˜¯ä»é”™è¯¯ä¸­æ¢å¤çš„æ›´å¥½è§£å†³æ–¹æ¡ˆã€‚",
        "translate": ""
    },
    {
        "source": "This macro should be used to avoid proceeding using incorrect values, such as from external sources.",
        "suggest": "åº”è¯¥ä½¿ç”¨æ­¤å®æ¥é¿å…ç»§ç»­ä½¿ç”¨ä¸æ­£ç¡®çš„å€¼ï¼Œä¾‹å¦‚æ¥è‡ªå¤–éƒ¨æ¥æºçš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Detailed information about error handling is found in the [book].",
        "suggest": "æœ‰å…³é”™è¯¯å¤„ç†çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [book]ã€‚",
        "translate": ""
    },
    {
        "source": "See also the macro [`compile_error!`], for raising errors during compilation.",
        "suggest": "å¦è¯·å‚è§å® [`compile_error!`]ï¼Œä»¥è·å–ç¼–è¯‘æœŸé—´çš„é”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "If the main thread panics it will terminate all your threads and end your program with code `101`.",
        "suggest": "å¦‚æœä¸»çº¿ç¨‹ä¸º panicsï¼Œå®ƒå°†ç»ˆæ­¢æ‚¨çš„æ‰€æœ‰çº¿ç¨‹å¹¶ä»¥ä»£ç  `101` ç»“æŸæ‚¨çš„ç¨‹åºã€‚",
        "translate": ""
    },
    {
        "source": "// error: Sized is not implemented for [i32]",
        "suggest": "// é”™è¯¯: æ²¡æœ‰ä¸º [i32] å®ç°å¤§å°è°ƒæ•´",
        "translate": ""
    },
    {
        "source": "// error: the trait `Bar` cannot be made into an object",
        "suggest": "// é”™è¯¯: æ— æ³•å°† trait `Bar` åˆ›å»ºæˆå¯¹è±¡",
        "translate": ""
    },
    {
        "source": "has moved into `y`, and so cannot be used",
        "suggest": "å·²ç§»è‡³ `y`ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨",
        "translate": ""
    },
    {
        "source": "We can derive a `Copy` implementation.",
        "suggest": "æˆ‘ä»¬å¯ä»¥æ´¾ç”Ÿä¸€ä¸ª `Copy` å®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "is also required, as it's a supertrait of `Copy`.",
        "suggest": "ä¹Ÿæ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºå®ƒæ˜¯ `Copy` çš„ç‰¹å¾ã€‚",
        "translate": ""
    },
    {
        "source": "is a copy of `x`",
        "suggest": "æ˜¯ `x` çš„å‰¯æœ¬",
        "translate": ""
    },
    {
        "source": "We need a mutable reference to call `mem::replace`.",
        "suggest": "æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯å˜å¼•ç”¨æ¥è°ƒç”¨ `mem::replace`ã€‚",
        "translate": ""
    },
    {
        "source": "We can obtain such a reference by (implicitly) invoking `Pin::deref_mut`, but that is only possible because `String` implements `Unpin`.",
        "suggest": "æˆ‘ä»¬å¯ä»¥é€šè¿‡ (implicitly) è°ƒç”¨ `Pin::deref_mut` æ¥è·å¾—è¿™æ ·çš„å¼•ç”¨ï¼Œä½†è¿™ä»…æ˜¯å¯èƒ½çš„ï¼Œå› ä¸º `String` å®ç°äº† `Unpin`ã€‚",
        "translate": ""
    },
    {
        "source": "Primitive traits and types representing basic properties of types.",
        "suggest": "åŸå§‹ traits å’Œç±»å‹è¡¨ç¤ºç±»å‹çš„åŸºæœ¬å±æ€§ã€‚",
        "translate": ""
    },
    {
        "source": "Rust types can be classified in various useful ways according to their intrinsic properties.",
        "suggest": "Rust ç±»å‹å¯ä»¥æ ¹æ®å…¶å›ºæœ‰å±æ€§ä»¥å„ç§æœ‰ç”¨çš„æ–¹å¼è¿›è¡Œåˆ†ç±»ã€‚",
        "translate": ""
    },
    {
        "source": "These classifications are represented as traits.",
        "suggest": "è¿™äº›åˆ†ç±»è¡¨ç¤ºä¸º traitsã€‚",
        "translate": ""
    },
    {
        "source": "Types that can be transferred across thread boundaries.",
        "suggest": "å¯ä»¥è·¨çº¿ç¨‹è¾¹ç•Œä¼ è¾“çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "This trait is automatically implemented when the compiler determines it's appropriate.",
        "suggest": "å½“ç¼–è¯‘å™¨ç¡®å®šé€‚å½“æ—¶ï¼Œä¼šè‡ªåŠ¨å®ç°æ­¤ traitã€‚",
        "translate": ""
    },
    {
        "source": "An example of a non-`Send` type is the reference-counting pointer [`rc::Rc`][`Rc`].",
        "suggest": "é `Send` ç±»å‹çš„ä¸€ä¸ªç¤ºä¾‹æ˜¯å¼•ç”¨è®¡æ•°æŒ‡é’ˆ [`rc::Rc`][`Rc`]ã€‚",
        "translate": ""
    },
    {
        "source": "If two threads attempt to clone [`Rc`]s that point to the same reference-counted value, they might try to update the reference count at the same time, which is [undefined behavior][ub] because [`Rc`] doesn't use atomic operations.",
        "suggest": "å¦‚æœä¸¤ä¸ªçº¿ç¨‹è¯•å›¾å…‹éš†æŒ‡å‘ç›¸åŒå¼•ç”¨è®¡æ•°å€¼çš„ [`Rc`]ï¼Œå®ƒä»¬å¯èƒ½ä¼šåŒæ—¶å°è¯•æ›´æ–°å¼•ç”¨è®¡æ•°ï¼Œè¿™æ˜¯ [æœªå®šä¹‰è¡Œä¸º][ub] å› ä¸º [`Rc`] ä¸ä½¿ç”¨åŸå­æ“ä½œã€‚",
        "translate": ""
    },
    {
        "source": "Its cousin [`sync::Arc`][arc] does use atomic operations (incurring some overhead) and thus is `Send`.",
        "suggest": "å®ƒçš„è¡¨äº² [`sync::Arc`][arc] ç¡®å®ä½¿ç”¨åŸå­æ“ä½œ (äº§ç”Ÿä¸€äº›å¼€é”€)ï¼Œå› æ­¤å®ƒæ˜¯ `Send`ã€‚",
        "translate": ""
    },
    {
        "source": "See [the Nomicon](../../nomicon/send-and-sync.html) for more details.",
        "suggest": "æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [the Nomicon](../../nomicon/send-and-sync.html)ã€‚",
        "translate": ""
    },
    {
        "source": "Types with a constant size known at compile time.",
        "suggest": "åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¸¸é‡å¤§å°çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "All type parameters have an implicit bound of `Sized`.",
        "suggest": "æ‰€æœ‰ç±»å‹å‚æ•°çš„éšå«è¾¹ç•Œå‡ä¸º `Sized`ã€‚",
        "translate": ""
    },
    {
        "source": "The special syntax `?Sized` can be used to remove this bound if it's not appropriate.",
        "suggest": "å¦‚æœä¸åˆé€‚ï¼Œå¯ä»¥ä½¿ç”¨ç‰¹æ®Šè¯­æ³• `?Sized` åˆ é™¤æ­¤ç»‘å®šã€‚",
        "translate": ""
    },
    {
        "source": "The one exception is the implicit `Self` type of a trait.",
        "suggest": "ä¸€ä¸ªä¾‹å¤–æ˜¯ trait çš„éšå¼ `Self` ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "A trait does not have an implicit `Sized` bound as this is incompatible with [trait object]s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.",
        "suggest": "trait æ²¡æœ‰éšå¼ `Sized` ç»‘å®šï¼Œå› ä¸ºå®ƒä¸ [trait object] s ä¸å…¼å®¹ï¼Œæ ¹æ®å®šä¹‰ï¼Œtrait éœ€è¦ä¸æ‰€æœ‰å¯èƒ½çš„å®ç°è€…ä¸€èµ·ä½¿ç”¨ï¼Œå› æ­¤å¯ä»¥ä¸ºä»»æ„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "Although Rust will let you bind `Sized` to a trait, you won't be able to use it to form a trait object later:",
        "suggest": "å°½ç®¡ Rust å…è®¸æ‚¨å°† `Sized` ç»‘å®šåˆ° traitï¼Œä½†æ˜¯ä»¥åæ‚¨å°†æ— æ³•ä½¿ç”¨å®ƒæ¥å½¢æˆ trait å¯¹è±¡:",
        "translate": ""
    },
    {
        "source": "for Default, for example, which requires that `[T]: !Default` be evaluatable",
        "suggest": "ä¾‹å¦‚ï¼Œå¯¹äº Defaultï¼Œå®ƒè¦æ±‚ `[T]: !Default` å¿…é¡»æ˜¯å¯è¯„ä¼°çš„",
        "translate": ""
    },
    {
        "source": "Types that can be \"unsized\" to a dynamically-sized type.",
        "suggest": "å¯ä»¥æ˜¯æœªå®šä¹‰å¤§å°çš„ç±»å‹ä¹Ÿå¯ä»¥æ˜¯åŠ¨æ€å¤§å°çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "For example, the sized array type `[i8; 2]` implements `Unsize<[i8]>` and `Unsize<dyn fmt::Debug>`.",
        "suggest": "ä¾‹å¦‚ï¼ŒæŒ‰å¤§å°æ’åˆ—çš„æ•°ç»„ç±»å‹ `[i8; 2]` å®ç° `Unsize<[i8]>` å’Œ `Unsize<dyn fmt::Debug>`ã€‚",
        "translate": ""
    },
    {
        "source": "All implementations of `Unsize` are provided automatically by the compiler.",
        "suggest": "`Unsize` çš„æ‰€æœ‰å®ç°å‡ç”±ç¼–è¯‘å™¨è‡ªåŠ¨æä¾›ã€‚",
        "translate": ""
    },
    {
        "source": "is implemented for:",
        "suggest": "ä¸ºä»¥ä¸‹ç›®çš„å®ç°:",
        "translate": ""
    },
    {
        "source": "is `Unsize<[T]>`",
        "suggest": "æ˜¯ `Unsize<[T]>`",
        "translate": ""
    },
    {
        "source": "is `Unsize<dyn Trait>` when `T: Trait`",
        "suggest": "`T: Trait` æ—¶ä¸º `Unsize<dyn Trait>`",
        "translate": ""
    },
    {
        "source": "is `Unsize<Foo<..., U, ...>>` if:",
        "suggest": "å¦‚æœæ˜¯ï¼Œåˆ™ä¸º `Unsize<Foo<..., U, ...>>`:",
        "translate": ""
    },
    {
        "source": "Foo is a struct",
        "suggest": "Foo æ˜¯ä¸€ä¸ªç»“æ„ä½“",
        "translate": ""
    },
    {
        "source": "Only the last field of `Foo` has a type involving `T`",
        "suggest": "ä»… `Foo` çš„æœ€åä¸€ä¸ªå­—æ®µå…·æœ‰æ¶‰åŠ `T` çš„ç±»å‹",
        "translate": ""
    },
    {
        "source": "is not part of the type of any other fields",
        "suggest": "ä¸å±äºä»»ä½•å…¶ä»–å­—æ®µçš„ç±»å‹",
        "translate": ""
    },
    {
        "source": "if the last field of `Foo` has type `Bar<T>`",
        "suggest": "å¦‚æœ `Foo` çš„æœ€åä¸€ä¸ªå­—æ®µçš„ç±»å‹ä¸º `Bar<T>`",
        "translate": ""
    },
    {
        "source": "is used along with [`ops::CoerceUnsized`] to allow \"user-defined\" containers such as [`Rc`] to contain dynamically-sized types.",
        "suggest": "ä¸ [`ops::CoerceUnsized`] ä¸€èµ·ä½¿ç”¨å¯å…è®¸ \"user-defined\" å®¹å™¨ (ä¾‹å¦‚ [`Rc`]) åŒ…å«åŠ¨æ€å¤§å°çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "See the [DST coercion RFC][RFC982] and [the nomicon entry on coercion][nomicon-coerce] for more details.",
        "suggest": "æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [DST coercion RFC][RFC982] å’Œ [the nomicon entry on coercion][nomicon-coerce]ã€‚",
        "translate": ""
    },
    {
        "source": "Required trait for constants used in pattern matches.",
        "suggest": "æ¨¡å¼åŒ¹é…ä¸­ä½¿ç”¨çš„å¸¸é‡éœ€è¦ traitã€‚",
        "translate": ""
    },
    {
        "source": "Any type that derives `PartialEq` automatically implements this trait, *regardless* of whether its type-parameters implement `Eq`.",
        "suggest": "ä¸ç®¡å…¶ç±»å‹å‚æ•°æ˜¯å¦å®ç° `Eq`ï¼Œä»»ä½•æ´¾ç”Ÿ `PartialEq` çš„ç±»å‹éƒ½ä¼šè‡ªåŠ¨å®ç°æ­¤ traitã€‚",
        "translate": ""
    },
    {
        "source": "If a `const` item contains some type that does not implement this trait, then that type either (1.) does not implement `PartialEq` (which means the constant will not provide that comparison method, which code generation assumes is available), or (2.) it implements *its own* version of `PartialEq` (which we assume does not conform to a structural-equality comparison).",
        "suggest": "å¦‚æœ `const` é¡¹åŒ…å«æŸç§ä¸å®ç°æ­¤ trait çš„ç±»å‹ï¼Œåˆ™è¯¥ç±»å‹è¦ä¹ˆ (1.) ä¸å®ç° `PartialEq` (è¿™æ„å‘³ç€å¸¸é‡å°†ä¸æä¾›è¯¥æ¯”è¾ƒæ–¹æ³• (ä»£ç ç”Ÿæˆå‡å®šå¯ç”¨) )ï¼Œè¦ä¹ˆ (2.) è‡ªèº«å®ç° *its*`PartialEq` çš„ç‰ˆæœ¬ (æˆ‘ä»¬è®¤ä¸ºä¸ç¬¦åˆç»“æ„ç›¸ç­‰æ€§æ¯”è¾ƒ)ã€‚",
        "translate": ""
    },
    {
        "source": "In either of the two scenarios above, we reject usage of such a constant in a pattern match.",
        "suggest": "åœ¨ä»¥ä¸Šä¸¤ç§æƒ…å†µä¸­çš„ä»»ä½•ä¸€ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éƒ½æ‹’ç»åœ¨æ¨¡å¼åŒ¹é…ä¸­ä½¿ç”¨æ­¤ç±»å¸¸é‡ã€‚",
        "translate": ""
    },
    {
        "source": "See also the [structural match RFC][RFC1445], and [issue 63438] which motivated migrating from attribute-based design to this trait.",
        "suggest": "å¦è¯·å‚è§ [structural match RFC][RFC1445] å’Œ [issue 63438]ï¼Œå®ƒä»¬ä¿ƒä½¿ä»åŸºäºå±æ€§çš„è®¾è®¡è¿ç§»åˆ°æ­¤ traitã€‚",
        "translate": ""
    },
    {
        "source": "Any type that derives `Eq` automatically implements this trait, *regardless* of whether its type parameters implement `Eq`.",
        "suggest": "æ´¾ç”Ÿ `Eq` çš„ä»»ä½•ç±»å‹éƒ½ä¼šè‡ªåŠ¨å®ç°æ­¤ traitï¼Œæ— è®ºå…¶ç±»å‹å‚æ•°æ˜¯å¦å®ç° `Eq`ã€‚",
        "translate": ""
    },
    {
        "source": "This is a hack to work around a limitation in our type system.",
        "suggest": "è¿™æ˜¯ä¸€ç§è§£å†³æˆ‘ä»¬ç±»å‹ç³»ç»Ÿé™åˆ¶çš„æŠ€å·§ã€‚",
        "translate": ""
    },
    {
        "source": "We want to require that types of consts used in pattern matches have the attribute `#[derive(PartialEq, Eq)]`.",
        "suggest": "æˆ‘ä»¬è¦è¦æ±‚æ¨¡å¼åŒ¹é…ä¸­ä½¿ç”¨çš„ const ç±»å‹å…·æœ‰å±æ€§ `#[derive(PartialEq, Eq)]`ã€‚",
        "translate": ""
    },
    {
        "source": "In a more ideal world, we could check that requirement by just checking that the given type implements both the `StructuralPartialEq` trait *and* the `Eq` trait.",
        "suggest": "åœ¨æ›´ç†æƒ³çš„ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»…æ£€æŸ¥ç»™å®šç±»å‹æ˜¯å¦åŒæ—¶å®ç° `StructuralPartialEq` trait å’Œ `Eq` trait æ¥æ£€æŸ¥è¯¥è¦æ±‚ã€‚",
        "translate": ""
    },
    {
        "source": "However, you can have ADTs that *do* `derive(PartialEq, Eq)`, and be a case that we want the compiler to accept, and yet the constant's type fails to implement `Eq`.",
        "suggest": "ä½†æ˜¯ï¼Œæ‚¨å¯èƒ½æ‹¥æœ‰ *do*`derive(PartialEq, Eq)` çš„ ADTï¼Œè¿™æ˜¯æˆ‘ä»¬å¸Œæœ›ç¼–è¯‘å™¨æ¥å—çš„æƒ…å†µï¼Œä½†æ˜¯ const çš„ç±»å‹æ— æ³•å®ç° `Eq`ã€‚",
        "translate": ""
    },
    {
        "source": "Namely, a case like this:",
        "suggest": "å³ï¼Œè¿™æ ·çš„æƒ…å†µ:",
        "translate": ""
    },
    {
        "source": "(The problem in the above code is that `Wrap<fn(&())>` does not implement `PartialEq`, nor `Eq`, because `for<'a> fn(&'a _)` does not implement those traits.)",
        "suggest": "(ä»¥ä¸Šä»£ç ä¸­çš„é—®é¢˜æ˜¯ `Wrap<fn(&())>` æ—¢ä¸å®ç° `PartialEq` ä¹Ÿä¸å®ç° `Eq`ï¼Œå› ä¸º `for <'a> fn(&'a _)` does not implement those traits.)",
        "translate": ""
    },
    {
        "source": "Therefore, we cannot rely on naive check for `StructuralPartialEq` and mere `Eq`.",
        "suggest": "å› æ­¤ï¼Œæˆ‘ä»¬ä¸èƒ½ä»…ä»…ä¾é  `StructuralPartialEq` å’Œ `Eq` çš„å¹¼ç¨šæ£€æŸ¥ã€‚",
        "translate": ""
    },
    {
        "source": "As a hack to work around this, we use two separate traits injected by each of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check that both of them are present as part of structural-match checking.",
        "suggest": "è¦è§£å†³æ­¤é—®é¢˜ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªæ´¾ç”Ÿå¯¹è±¡ (`#[derive(PartialEq)]` å’Œ `#[derive(Eq)]`) ä¸­çš„æ¯ä¸ªæ´¾ç”Ÿæ³¨å…¥çš„ä¸¤ä¸ªå•ç‹¬çš„ traitsï¼Œå¹¶æ£€æŸ¥å®ƒä»¬æ˜¯å¦éƒ½ä½œä¸ºç»“æ„åŒ¹é…æ£€æŸ¥çš„ä¸€éƒ¨åˆ†å‡ºç°ã€‚",
        "translate": ""
    },
    {
        "source": "Types whose values can be duplicated simply by copying bits.",
        "suggest": "åªéœ€å¤åˆ¶ä½å³å¯å¤åˆ¶å…¶å€¼çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "By default, variable bindings have 'move semantics.' In other words:",
        "suggest": "é»˜è®¤æƒ…å†µä¸‹ï¼Œå˜é‡ç»‘å®šå…·æœ‰ç§»åŠ¨è¯­ä¹‰ã€‚æ¢å¥è¯è¯´:",
        "translate": ""
    },
    {
        "source": "However, if a type implements `Copy`, it instead has 'copy semantics':",
        "suggest": "ä½†æ˜¯ï¼Œå¦‚æœç±»å‹å®ç° `Copy`ï¼Œåˆ™å®ƒå…·æœ‰å¤åˆ¶è¯­ä¹‰:",
        "translate": ""
    },
    {
        "source": "It's important to note that in these two examples, the only difference is whether you are allowed to access `x` after the assignment.",
        "suggest": "é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œåœ¨è¿™ä¸¤ä¸ªç¤ºä¾‹ä¸­ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯åˆ†é…åæ˜¯å¦å…è®¸æ‚¨è®¿é—® `x`ã€‚",
        "translate": ""
    },
    {
        "source": "Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away.",
        "suggest": "åœ¨åå°ï¼Œå¤åˆ¶å’Œç§»åŠ¨éƒ½å¯èƒ½å¯¼è‡´å°†ä½å¤åˆ¶åˆ°å†…å­˜ä¸­ï¼Œå°½ç®¡æœ‰æ—¶ä¼šå¯¹å…¶è¿›è¡Œä¼˜åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "How can I implement `Copy`?",
        "suggest": "å¦‚ä½•å®ç° `Copy`?",
        "translate": ""
    },
    {
        "source": "There are two ways to implement `Copy` on your type.",
        "suggest": "æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åœ¨æ‚¨çš„ç±»å‹ä¸Šå®ç° `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "The simplest is to use `derive`:",
        "suggest": "æœ€ç®€å•çš„æ˜¯ä½¿ç”¨ `derive`:",
        "translate": ""
    },
    {
        "source": "You can also implement `Copy` and `Clone` manually:",
        "suggest": "æ‚¨è¿˜å¯ä»¥æ‰‹åŠ¨å®ç° `Copy` å’Œ `Clone`:",
        "translate": ""
    },
    {
        "source": "There is a small difference between the two: the `derive` strategy will also place a `Copy` bound on type parameters, which isn't always desired.",
        "suggest": "ä¸¤è€…ä¹‹é—´çš„åŒºåˆ«å¾ˆå°: `derive` ç­–ç•¥è¿˜å°† `Copy` ç»‘å®šåœ¨ç±»å‹å‚æ•°ä¸Šï¼Œè¿™å¹¶ä¸æ€»æ˜¯éœ€è¦çš„ã€‚",
        "translate": ""
    },
    {
        "source": "What's the difference between `Copy` and `Clone`?",
        "suggest": "`Copy` å’Œ `Clone` æœ‰ä»€ä¹ˆåŒºåˆ«?",
        "translate": ""
    },
    {
        "source": "Copies happen implicitly, for example as part of an assignment `y = x`.",
        "suggest": "å¤åˆ¶æ˜¯éšå¼å‘ç”Ÿçš„ï¼Œä¾‹å¦‚ä½œä¸ºå·¥ä½œ `y = x` çš„ä¸€éƒ¨åˆ†ã€‚",
        "translate": ""
    },
    {
        "source": "The behavior of `Copy` is not overloadable;",
        "suggest": "`Copy` çš„è¡Œä¸ºä¸å¯é‡è½½;",
        "translate": ""
    },
    {
        "source": "it is always a simple bit-wise copy.",
        "suggest": "å®ƒå§‹ç»ˆæ˜¯ç®€å•çš„æŒ‰ä½å¤åˆ¶ã€‚",
        "translate": ""
    },
    {
        "source": "Cloning is an explicit action, `x.clone()`.",
        "suggest": "å…‹éš†æ˜¯ä¸€ä¸ªæ˜ç¡®çš„åŠ¨ä½œ `x.clone()`ã€‚",
        "translate": ""
    },
    {
        "source": "The implementation of [`Clone`] can provide any type-specific behavior necessary to duplicate values safely.",
        "suggest": "[`Clone`] çš„å®ç°å¯ä»¥æä¾›å®‰å…¨å¤åˆ¶å€¼æ‰€éœ€çš„ä»»ä½•ç‰¹å®šäºç±»å‹çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "For example, the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string buffer in the heap.",
        "suggest": "ä¾‹å¦‚ï¼Œç”¨äº [`String`] çš„ [`Clone`] çš„å®ç°éœ€è¦åœ¨å †ä¸­å¤åˆ¶æŒ‡å‘å­—ç¬¦ä¸²çš„ç¼“å†²åŒºã€‚",
        "translate": ""
    },
    {
        "source": "A simple bitwise copy of [`String`] values would merely copy the pointer, leading to a double free down the line.",
        "suggest": "[`String`] å€¼çš„ç®€å•æŒ‰ä½å‰¯æœ¬å°†ä»…å¤åˆ¶æŒ‡é’ˆï¼Œä»è€Œå¯¼è‡´è¯¥è¡Œå‘ä¸‹åŒé‡é‡Šæ”¾ã€‚",
        "translate": ""
    },
    {
        "source": "For this reason, [`String`] is [`Clone`] but not `Copy`.",
        "suggest": "å› æ­¤ï¼Œ[`String`] æ˜¯ [`Clone`]ï¼Œä½†ä¸æ˜¯ `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "is a supertrait of `Copy`, so everything which is `Copy` must also implement [`Clone`].",
        "suggest": "æ˜¯ `Copy` çš„ç‰¹å¾ï¼Œå› æ­¤ `Copy` çš„æ‰€æœ‰å†…å®¹ä¹Ÿå¿…é¡»å®ç° [`Clone`]ã€‚",
        "translate": ""
    },
    {
        "source": "If a type is `Copy` then its [`Clone`] implementation only needs to return `*self` (see the example above).",
        "suggest": "å¦‚æœç±»å‹ä¸º `Copy`ï¼Œåˆ™å…¶ [`Clone`] å®ç°ä»…éœ€è¦è¿”å› `*self` (è¯·å‚è§ä¸Šé¢çš„ç¤ºä¾‹)ã€‚",
        "translate": ""
    },
    {
        "source": "When can my type be `Copy`?",
        "suggest": "ä»€ä¹ˆæ—¶å€™å¯ä»¥è¾“å…¥ `Copy`?",
        "translate": ""
    },
    {
        "source": "A type can implement `Copy` if all of its components implement `Copy`.",
        "suggest": "å¦‚æœç±»å‹çš„æ‰€æœ‰ç»„ä»¶éƒ½å®ç° `Copy`ï¼Œåˆ™å®ƒå¯ä»¥å®ç° `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "For example, this struct can be `Copy`:",
        "suggest": "ä¾‹å¦‚ï¼Œæ­¤ç»“æ„ä½“å¯ä»¥æ˜¯ `Copy`:",
        "translate": ""
    },
    {
        "source": "A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`.",
        "suggest": "ä¸€ä¸ªç»“æ„ä½“å¯ä»¥æ˜¯ `Copy`ï¼Œè€Œ [`i32`] æ˜¯ `Copy`ï¼Œå› æ­¤ `Point` æœ‰èµ„æ ¼æˆä¸º `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "By contrast, consider",
        "suggest": "ç›¸æ¯”ä¹‹ä¸‹ï¼Œè€ƒè™‘",
        "translate": ""
    },
    {
        "source": "The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`.",
        "suggest": "ç»“æ„ä½“ `PointList` æ— æ³•å®ç° `Copy`ï¼Œå› ä¸º [`Vec<T>`] ä¸æ˜¯ `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "If we attempt to derive a `Copy` implementation, we'll get an error:",
        "suggest": "å¦‚æœå°è¯•æ´¾ç”Ÿ `Copy` å®ç°ï¼Œåˆ™ä¼šæ”¶åˆ°é”™è¯¯æ¶ˆæ¯:",
        "translate": ""
    },
    {
        "source": "Shared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds shared references of types `T` that are *not* `Copy`.",
        "suggest": "å…±äº«å¼•ç”¨ (`&T`) ä¹Ÿæ˜¯ `Copy`ï¼Œå› æ­¤ï¼Œå³ä½¿ç±»å‹ä¸­åŒ…å« *04* ä¸æ˜¯*`Copy` ç±»å‹çš„å…±äº«å¼•ç”¨ `T`ï¼Œä¹Ÿå¯ä»¥æ˜¯ `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "Consider the following struct, which can implement `Copy`, because it only holds a *shared reference* to our non-`Copy` type `PointList` from above:",
        "suggest": "è€ƒè™‘ä¸‹é¢çš„ç»“æ„ä½“ï¼Œå®ƒå¯ä»¥å®ç° `Copy`ï¼Œå› ä¸ºå®ƒä»ä¸Šæ–¹ä»…å¯¹æˆ‘ä»¬çš„é Copy ç±»å‹ `PointList` æŒæœ‰ä¸€ä¸ª *shared å¼•ç”¨*:",
        "translate": ""
    },
    {
        "source": "When *can't* my type be `Copy`?",
        "suggest": "ä»€ä¹ˆæ—¶å€™æˆ‘çš„ç±»å‹ä¸èƒ½ä¸º `Copy`?",
        "translate": ""
    },
    {
        "source": "Some types can't be copied safely.",
        "suggest": "æŸäº›ç±»å‹æ— æ³•å®‰å…¨å¤åˆ¶ã€‚",
        "translate": ""
    },
    {
        "source": "For example, copying `&mut T` would create an aliased mutable reference.",
        "suggest": "ä¾‹å¦‚ï¼Œå¤åˆ¶ `&mut T` å°†åˆ›å»ºä¸€ä¸ªåˆ«åå¯å˜å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Copying [`String`] would duplicate responsibility for managing the [`String`]'s buffer, leading to a double free.",
        "suggest": "å¤åˆ¶ [`String`] å°†é‡å¤ç®¡ç† [String] ç¼“å†²åŒºçš„è´£ä»»ï¼Œä»è€Œå¯¼è‡´åŒé‡é‡Šæ”¾ã€‚",
        "translate": ""
    },
    {
        "source": "Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's managing some resource besides its own [`size_of::<T>`] bytes.",
        "suggest": "æ¦‚æ‹¬åä¸€ç§æƒ…å†µï¼Œä»»ä½•å®ç° [`Drop`] çš„ç±»å‹éƒ½ä¸èƒ½æ˜¯ `Copy`ï¼Œå› ä¸ºå®ƒé™¤äº†ç®¡ç†è‡ªå·±çš„ [`size_of::<T>`] å­—èŠ‚å¤–è¿˜ç®¡ç†ä¸€äº›èµ„æºã€‚",
        "translate": ""
    },
    {
        "source": "If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get the error [E0204].",
        "suggest": "æœæ‚¨å°è¯•åœ¨åŒ…å«é `Copy` æ•°æ®çš„ç»“æ„æˆ–æšä¸¾ä¸Šå®ç° `Copy`ï¼Œåˆ™ä¼šæ”¶åˆ° [E0204] é”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "When *should* my type be `Copy`?",
        "suggest": "ä»€ä¹ˆæ—¶å€™æˆ‘çš„ç±»å‹åº”è¯¥æ˜¯ `Copy`?",
        "translate": ""
    },
    {
        "source": "Generally speaking, if your type _can_ implement `Copy`, it should.",
        "suggest": "ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœæ‚¨çš„ç±»å‹å¯ä»¥å®ç° `Copy`ï¼Œåˆ™åº”è¯¥è¿™æ ·åšã€‚",
        "translate": ""
    },
    {
        "source": "Keep in mind, though, that implementing `Copy` is part of the public API of your type.",
        "suggest": "ä½†æ˜¯è¯·è®°ä½ï¼Œå®ç° `Copy` æ˜¯æ‚¨ç±»å‹çš„å…¬å…± API çš„ä¸€éƒ¨åˆ†ã€‚",
        "translate": ""
    },
    {
        "source": "If the type might become non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to avoid a breaking API change.",
        "suggest": "å¦‚æœè¯¥ç±»å‹å°†æ¥å¯èƒ½å˜ä¸ºé `Copy`ï¼Œåˆ™æœ€å¥½ç°åœ¨çœç•¥ `Copy` å®ç°ï¼Œä»¥é¿å… API å‘ç”Ÿé‡å¤§æ›´æ”¹ã€‚",
        "translate": ""
    },
    {
        "source": "In addition to the [implementors listed below][impls], the following types also implement `Copy`:",
        "suggest": "é™¤ [ä¸‹é¢åˆ—å‡ºçš„å®ç°è€…][impls] ä¹‹å¤–ï¼Œä»¥ä¸‹ç±»å‹è¿˜å®ç° `Copy`:",
        "translate": ""
    },
    {
        "source": "Array types, for all sizes, if the item type also implements `Copy` (e.g., `[i32; 123456]`)",
        "suggest": "å¦‚æœé¡¹ç±»å‹ä¹Ÿå®ç° `Copy` (ä¾‹å¦‚ `[i32; 123456]`)ï¼Œåˆ™æ‰€æœ‰å¤§å°çš„æ•°ç»„ç±»å‹",
        "translate": ""
    },
    {
        "source": "Tuple types, if each component also implements `Copy` (e.g., `()`, `(i32, bool)`)",
        "suggest": "å¦‚æœæ¯ä¸ªç»„ä»¶è¿˜å®ç° `Copy` (ä¾‹å¦‚ `()`ï¼Œ`(i32, bool)`)ï¼Œåˆ™ä¸ºå…ƒç»„ç±»å‹",
        "translate": ""
    },
    {
        "source": "Closure types, if they capture no value from the environment or if all such captured values implement `Copy` themselves.",
        "suggest": "é—­åŒ…ç±»å‹ï¼Œå¦‚æœå®ƒä»¬æ²¡æœ‰ä»ç¯å¢ƒä¸­æ•è·ä»»ä½•å€¼ï¼Œæˆ–è€…æ‰€æœ‰æ­¤ç±»æ•è·çš„å€¼æœ¬èº«éƒ½å®ç°äº† `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "Note that variables captured by shared reference always implement `Copy` (even if the referent doesn't), while variables captured by mutable reference never implement `Copy`.",
        "suggest": "è¯·æ³¨æ„ï¼Œç”±å…±äº«å¼•ç”¨æ•è·çš„å˜é‡å§‹ç»ˆå®ç° `Copy` (å³ä½¿å¼•ç”¨å¯¹è±¡æ²¡æœ‰å®ç°)ï¼Œè€Œç”±å˜é‡å¼•ç”¨æ•è·çš„å˜é‡ä»ä¸å®ç° `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "This allows copying a type that doesn't implement `Copy` because of unsatisfied lifetime bounds (copying `A<'_>` when only `A<'static>: Copy` and `A<'_>: Clone`).",
        "suggest": "è¿™å…è®¸å¤åˆ¶ç”±äºç”Ÿå‘½å‘¨æœŸç•Œé™ä¸ä»¤äººæ»¡æ„è€Œæ— æ³•å®ç° `Copy` çš„ç±»å‹ (ä»… `A<'static>: Copy` å’Œ `A<'_>: Clone` æ—¶å¤åˆ¶ `A<'_>`)ã€‚",
        "translate": ""
    },
    {
        "source": "We have this attribute here for now only because there are quite a few existing specializations on `Copy` that already exist in the standard library, and there's no way to safely have this behavior right now.",
        "suggest": "æˆ‘ä»¬ç°åœ¨åœ¨è¿™é‡Œå…·æœ‰æ­¤å±æ€§çš„åŸå› ä»…æ˜¯å› ä¸ºæ ‡å‡†åº“ä¸­å·²ç»å­˜åœ¨ `Copy` ä¸Šçš„è®¸å¤šç°æœ‰ä¸“é•¿ï¼Œå¹¶ä¸”ç›®å‰å°šæ— åŠæ³•å®‰å…¨åœ°å…·æœ‰æ­¤è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "Derive macro generating an impl of the trait `Copy`.",
        "suggest": "æ´¾ç”Ÿå®ï¼Œç”Ÿæˆ `Copy` trait çš„ implã€‚",
        "translate": ""
    },
    {
        "source": "Types for which it is safe to share references between threads.",
        "suggest": "å¯ä»¥åœ¨çº¿ç¨‹ä¹‹é—´å®‰å…¨å…±äº«å¼•ç”¨çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "The precise definition is: a type `T` is [`Sync`] if and only if `&T` is [`Send`].",
        "suggest": "ç²¾ç¡®çš„å®šä¹‰æ˜¯: å½“ä¸”ä»…å½“ `&T` æ˜¯ [`Send`] æ—¶ï¼Œç±»å‹ `T` æ‰æ˜¯ [`Sync`]ã€‚",
        "translate": ""
    },
    {
        "source": "In other words, if there is no possibility of [undefined behavior][ub] (including data races) when passing `&T` references between threads.",
        "suggest": "æ¢å¥è¯è¯´ï¼Œå¦‚æœåœ¨çº¿ç¨‹ä¹‹é—´ä¼ é€’ `&T` å¼•ç”¨æ—¶æ²¡æœ‰ [æœªå®šä¹‰çš„è¡Œä¸º][ub] (åŒ…æ‹¬æ•°æ®ç«äº‰) çš„å¯èƒ½æ€§ã€‚",
        "translate": ""
    },
    {
        "source": "As one would expect, primitive types like [`u8`] and [`f64`] are all [`Sync`], and so are simple aggregate types containing them, like tuples, structs and enums.",
        "suggest": "æ­£å¦‚äººä»¬æ‰€æœŸæœ›çš„é‚£æ ·ï¼ŒåŸå§‹ç±»å‹ (å¦‚ [`u8`] å’Œ [`f64`]) éƒ½æ˜¯ [`Sync`]ï¼ŒåŒ…å«å®ƒä»¬çš„ç®€å•èšåˆç±»å‹ (å¦‚å…ƒç»„ï¼Œç»“æ„ä½“å’Œæšä¸¾) ä¹Ÿæ˜¯å¦‚æ­¤ã€‚",
        "translate": ""
    },
    {
        "source": "More examples of basic [`Sync`] types include \"immutable\" types like `&T`, and those with simple inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and most other collection types.",
        "suggest": "åŸºæœ¬ [`Sync`] ç±»å‹çš„æ›´å¤šç¤ºä¾‹åŒ…æ‹¬ä¸å¯å˜ç±»å‹ (ä¾‹å¦‚ `&T`) ä»¥åŠå…·æœ‰ç®€å•ç»§æ‰¿çš„å¯å˜æ€§çš„ç±»å‹ï¼Œä¾‹å¦‚ [`Box<T>`][box]ï¼Œ[`Vec<T>`][vec] å’Œå¤§å¤šæ•°å…¶ä»–é›†åˆç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "(Generic parameters need to be [`Sync`] for their container to be [`Sync`].)",
        "suggest": "(æ³›å‹å‚æ•°å¿…é¡»ä¸º [`Sync`]ï¼Œå®¹å™¨æ‰èƒ½ [[Sync]]ã€‚)",
        "translate": ""
    },
    {
        "source": "A somewhat surprising consequence of the definition is that `&mut T` is `Sync` (if `T` is `Sync`) even though it seems like that might provide unsynchronized mutation.",
        "suggest": "è¯¥å®šä¹‰çš„ä¸€ä¸ªä»¤äººæƒŠè®¶çš„ç»“æœæ˜¯ `&mut T` æ˜¯ `Sync` (å¦‚æœ `T` æ˜¯ `Sync`)ï¼Œå³ä½¿çœ‹èµ·æ¥å¯èƒ½æä¾›äº†ä¸åŒæ­¥çš„å¯å˜çš„ã€‚",
        "translate": ""
    },
    {
        "source": "The trick is that a mutable reference behind a shared reference (that is, `& &mut T`) becomes read-only, as if it were a `& &T`.",
        "suggest": "è¯€çªæ˜¯ï¼Œå…±äº«å¼•ç”¨ (å³ `& &mut T`) åé¢çš„å¯å˜å¼•ç”¨å°†å˜ä¸ºåªè¯»ï¼Œå°±å¥½åƒå®ƒæ˜¯ `& &T` ä¸€æ ·ã€‚",
        "translate": ""
    },
    {
        "source": "Hence there is no risk of a data race.",
        "suggest": "å› æ­¤ï¼Œæ²¡æœ‰æ•°æ®ç«äº‰çš„é£é™©ã€‚",
        "translate": ""
    },
    {
        "source": "Types that are not `Sync` are those that have \"interior mutability\" in a non-thread-safe form, such as [`Cell`][cell] and [`RefCell`][refcell].",
        "suggest": "ä¸æ˜¯ `Sync` çš„ç±»å‹æ˜¯å…·æœ‰éçº¿ç¨‹å®‰å…¨å½¢å¼çš„ \"interior mutability\" çš„ç±»å‹ï¼Œä¾‹å¦‚ [`Cell`][cell] å’Œ [`RefCell`][refcell]ã€‚",
        "translate": ""
    },
    {
        "source": "These types allow for mutation of their contents even through an immutable, shared reference.",
        "suggest": "è¿™äº›ç±»å‹ç”šè‡³å…è®¸é€šè¿‡ä¸å¯å˜ï¼Œå…±äº«å¼•ç”¨æ¥æ›´æ”¹å…¶å†…å®¹ã€‚",
        "translate": ""
    },
    {
        "source": "For example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires only a shared reference [`&Cell<T>`][cell].",
        "suggest": "ä¾‹å¦‚ï¼Œ[`Cell<T>`][cell] ä¸Šçš„ `set` æ–¹æ³•é‡‡ç”¨ `&self`ï¼Œå› æ­¤å®ƒä»…éœ€è¦å…±äº«çš„å¼•ç”¨ [`&Cell<T>`][cell]ã€‚",
        "translate": ""
    },
    {
        "source": "The method performs no synchronization, thus [`Cell`][cell] cannot be `Sync`.",
        "suggest": "è¯¥æ–¹æ³•ä¸æ‰§è¡ŒåŒæ­¥ï¼Œå› æ­¤ [`Cell`][cell] ä¸èƒ½ä¸º `Sync`ã€‚",
        "translate": ""
    },
    {
        "source": "Another example of a non-`Sync` type is the reference-counting pointer [`Rc`][rc].",
        "suggest": "å¦ä¸€ä¸ªé `Sync` ç±»å‹çš„ä¾‹å­æ˜¯å¼•ç”¨è®¡æ•°æŒ‡é’ˆ [`Rc`][rc]ã€‚",
        "translate": ""
    },
    {
        "source": "Given any reference [`&Rc<T>`][rc], you can clone a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.",
        "suggest": "ç»™å®šä»»ä½•å¼•ç”¨ [`&Rc<T>`][rc]ï¼Œæ‚¨å¯ä»¥å…‹éš†æ–°çš„ [`Rc<T>`][rc]ï¼Œä»¥éåŸå­æ–¹å¼ä¿®æ”¹å¼•ç”¨è®¡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "For cases when one does need thread-safe interior mutability, Rust provides [atomic data types], as well as explicit locking via [`sync::Mutex`][mutex] and [`sync::RwLock`][rwlock].",
        "suggest": "å¯¹äºç¡®å®éœ€è¦çº¿ç¨‹å®‰å…¨çš„å†…éƒ¨å¯å˜æ€§çš„æƒ…å†µï¼ŒRust æä¾› [atomic data types] ä»¥åŠé€šè¿‡ [`sync::Mutex`][mutex] å’Œ [`sync::RwLock`][rwlock] è¿›è¡Œçš„æ˜¾å¼é”å®šã€‚",
        "translate": ""
    },
    {
        "source": "These types ensure that any mutation cannot cause data races, hence the types are `Sync`.",
        "suggest": "è¿™äº›ç±»å‹å¯ç¡®ä¿ä»»ä½•å¯å˜çš„éƒ½ä¸ä¼šå¼•èµ·æ•°æ®ç«äº‰ï¼Œå› æ­¤ç±»å‹ä¸º `Sync`ã€‚",
        "translate": ""
    },
    {
        "source": "Likewise, [`sync::Arc`][arc] provides a thread-safe analogue of [`Rc`][rc].",
        "suggest": "åŒæ ·ï¼Œ[`sync::Arc`][arc] æä¾›äº† [`Rc`][rc] çš„çº¿ç¨‹å®‰å…¨æ¨¡æ‹Ÿã€‚",
        "translate": ""
    },
    {
        "source": "Any types with interior mutability must also use the [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which can be mutated through a shared reference.",
        "suggest": "ä»»ä½•å…·æœ‰å†…éƒ¨å¯å˜æ€§çš„ç±»å‹è¿˜å¿…é¡»åœ¨ value(s) å‘¨å›´ä½¿ç”¨ [`cell::UnsafeCell`][unsafecell] åŒ…è£…å™¨ï¼Œè¯¥åŒ…è£…å™¨å¯ä»¥é€šè¿‡å…±äº«çš„å¼•ç”¨è¿›è¡Œæ›´æ”¹ã€‚",
        "translate": ""
    },
    {
        "source": "Failing to doing this is [undefined behavior][ub].",
        "suggest": "[æœªå®šä¹‰çš„è¡Œä¸º][ub] æ— æ³•åšåˆ°è¿™ä¸€ç‚¹ã€‚",
        "translate": ""
    },
    {
        "source": "For example, [`transmute`][transmute]-ing from `&T` to `&mut T` is invalid.",
        "suggest": "ä¾‹å¦‚ï¼Œä» `&T` åˆ° `&mut T` çš„ [`transmute`][transmute] æ— æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "See [the Nomicon][nomicon-send-and-sync] for more details about `Sync`.",
        "suggest": "æœ‰å…³ `Sync` çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [the Nomicon][nomicon-send-and-sync]ã€‚",
        "translate": ""
    },
    {
        "source": "once support to add notes in `rustc_on_unimplemented` lands in beta, and it has been extended to check whether a closure is anywhere in the requirement chain, extend it as such (#48534):",
        "suggest": "ä¸€æ—¦åœ¨ `rustc_on_unimplemented` ä¸­æ·»åŠ  note çš„æ”¯æŒè¿›å…¥ beta ç‰ˆæœ¬ï¼Œå¹¶ä¸”å·²ç»æ‰©å±•åˆ°æ£€æŸ¥é—­åŒ…æ˜¯å¦åœ¨éœ€æ±‚é“¾ä¸­çš„ä»»ä½•åœ°æ–¹ï¼Œå°±è¿™æ ·æ‰©å±•å®ƒ (#48534):",
        "translate": ""
    },
    {
        "source": "Zero-sized type used to mark things that \"act like\" they own a `T`.",
        "suggest": "é›¶å¤§å°çš„ç±»å‹ç”¨æ¥æ ‡è®°é‚£äº›è¡Œä¸ºåƒå®ƒä»¬æ‹¥æœ‰ä¸€ä¸ª `T` çš„ä¸œè¥¿ã€‚",
        "translate": ""
    },
    {
        "source": "Adding a `PhantomData<T>` field to your type tells the compiler that your type acts as though it stores a value of type `T`, even though it doesn't really.",
        "suggest": "å‘æ‚¨çš„ç±»å‹æ·»åŠ  `PhantomData<T>` å­—æ®µå°†å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæ‚¨çš„ç±»å‹çš„è¡Œä¸ºå°±åƒå®ƒå­˜å‚¨äº† `T` ç±»å‹çš„å€¼ä¸€æ ·ï¼Œå³ä½¿å®é™…ä¸Šå¹¶éå¦‚æ­¤ã€‚",
        "translate": ""
    },
    {
        "source": "This information is used when computing certain safety properties.",
        "suggest": "åœ¨è®¡ç®—æŸäº›å®‰å…¨å±æ€§æ—¶ä¼šä½¿ç”¨æ­¤ä¿¡æ¯ã€‚",
        "translate": ""
    },
    {
        "source": "For a more in-depth explanation of how to use `PhantomData<T>`, please see [the Nomicon](../../nomicon/phantom-data.html).",
        "suggest": "æœ‰å…³å¦‚ä½•ä½¿ç”¨ `PhantomData<T>` çš„æ›´æ·±å…¥çš„è¯´æ˜ï¼Œè¯·å‚è§ [the Nomicon](../../nomicon/phantom-data.html)ã€‚",
        "translate": ""
    },
    {
        "source": "A ghastly note ğŸ‘»ğŸ‘»ğŸ‘»",
        "suggest": "ä¸€ä¸ªå¯æ€•çš„ç¬”è®° ğŸ‘»ğŸ‘»ğŸ‘»",
        "translate": ""
    },
    {
        "source": "Though they both have scary names, `PhantomData` and 'phantom types' are related, but not identical.",
        "suggest": "å°½ç®¡å®ƒä»¬éƒ½æœ‰å¯æ€•çš„åç§°ï¼Œä½† `PhantomData` å’Œ phantom ç±»å‹æ˜¯ç›¸å…³çš„ï¼Œä½†å¹¶ä¸å®Œå…¨ç›¸åŒã€‚",
        "translate": ""
    },
    {
        "source": "A phantom type parameter is simply a type parameter which is never used.",
        "suggest": "phantom ç±»å‹å‚æ•°åªæ˜¯ä»æœªä½¿ç”¨è¿‡çš„ç±»å‹å‚æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "In Rust, this often causes the compiler to complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.",
        "suggest": "åœ¨ Rust ä¸­ï¼Œè¿™é€šå¸¸ä¼šå¯¼è‡´ç¼–è¯‘å™¨æŠ±æ€¨ï¼Œè€Œè§£å†³æ–¹æ¡ˆæ˜¯é€šè¿‡ `PhantomData` æ·»åŠ  \"dummy\" ç”¨é€”ã€‚",
        "translate": ""
    },
    {
        "source": "Unused lifetime parameters",
        "suggest": "æœªä½¿ç”¨çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°",
        "translate": ""
    },
    {
        "source": "Perhaps the most common use case for `PhantomData` is a struct that has an unused lifetime parameter, typically as part of some unsafe code.",
        "suggest": "`PhantomData` çš„æœ€å¸¸è§ç”¨ä¾‹ä¹Ÿè®¸æ˜¯å…·æœ‰æœªä½¿ç”¨çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„ç»“æ„ä½“ï¼Œé€šå¸¸å°†å…¶ç”¨ä½œæŸäº›ä¸å®‰å…¨ä»£ç çš„ä¸€éƒ¨åˆ†ã€‚",
        "translate": ""
    },
    {
        "source": "For example, here is a struct `Slice` that has two pointers of type `*const T`, presumably pointing into an array somewhere:",
        "suggest": "ä¾‹å¦‚ï¼Œè¿™æ˜¯ä¸€ä¸ªç»“æ„ä½“ `Slice`ï¼Œå®ƒå…·æœ‰ä¸¤ä¸ª `*const T` ç±»å‹çš„æŒ‡é’ˆï¼Œå¤§æ¦‚æŒ‡å‘æŸä¸ªåœ°æ–¹çš„æ•°ç»„:",
        "translate": ""
    },
    {
        "source": "The intention is that the underlying data is only valid for the lifetime `'a`, so `Slice` should not outlive `'a`.",
        "suggest": "ç›®çš„æ˜¯åŸºç¡€æ•°æ®ä»…å¯¹ç”Ÿå‘½å‘¨æœŸ `'a` æœ‰æ•ˆï¼Œå› æ­¤ `Slice` ä¸åº”è¶…è¿‡ `'a`ã€‚",
        "translate": ""
    },
    {
        "source": "However, this intent is not expressed in the code, since there are no uses of the lifetime `'a` and hence it is not clear what data it applies to.",
        "suggest": "ä½†æ˜¯ï¼Œæ­¤æ„å›¾æœªåœ¨ä»£ç ä¸­è¡¨è¾¾ï¼Œå› ä¸ºæ²¡æœ‰ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸ `'a`ï¼Œå› æ­¤å°šä¸æ¸…æ¥šå®ƒé€‚ç”¨äºä»€ä¹ˆæ•°æ®ã€‚",
        "translate": ""
    },
    {
        "source": "We can correct this by telling the compiler to act *as if* the `Slice` struct contained a reference `&'a T`:",
        "suggest": "æˆ‘ä»¬å¯ä»¥é€šè¿‡å‘Šè¯‰ç¼–è¯‘å™¨å¦‚æœ `Slice` ç»“æ„ä½“åŒ…å«å¼•ç”¨ `&'a T` æ¥æ‰§è¡Œ *as æ¥çº æ­£æ­¤é—®é¢˜:",
        "translate": ""
    },
    {
        "source": "This also in turn requires the annotation `T: 'a`, indicating that any references in `T` are valid over the lifetime `'a`.",
        "suggest": "è¿™ä¹Ÿéœ€è¦æ³¨è§£ `T: 'a`ï¼Œä»¥æŒ‡ç¤º `T` ä¸­çš„æ‰€æœ‰å¼•ç”¨åœ¨ç”Ÿå‘½å‘¨æœŸ `'a` ä¸Šå‡æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "When initializing a `Slice` you simply provide the value `PhantomData` for the field `phantom`:",
        "suggest": "åˆå§‹åŒ– `Slice` æ—¶ï¼Œåªéœ€ä¸ºå­—æ®µ `phantom` æä¾›å€¼ `PhantomData`:",
        "translate": ""
    },
    {
        "source": "Unused type parameters",
        "suggest": "æœªä½¿ç”¨çš„ç±»å‹å‚æ•°",
        "translate": ""
    },
    {
        "source": "It sometimes happens that you have unused type parameters which indicate what type of data a struct is \"tied\" to, even though that data is not actually found in the struct itself.",
        "suggest": "æœ‰æ—¶å¯èƒ½ä¼šå‘ç”Ÿæœªä½¿ç”¨çš„ç±»å‹å‚æ•°ï¼Œè¿™äº›å‚æ•°æŒ‡ç¤º \"tied\" å°†ç»“æ„ä½“æ•°æ®ç±»å‹åŒ–çš„æ•°æ®ï¼Œå³ä½¿è¯¥æ•°æ®å®é™…ä¸Šä¸æ˜¯åœ¨ç»“æ„ä½“æœ¬èº«ä¸­æ‰¾åˆ°çš„ä¹Ÿæ˜¯å¦‚æ­¤ã€‚",
        "translate": ""
    },
    {
        "source": "Here is an example where this arises with [FFI].",
        "suggest": "è¿™æ˜¯ [FFI] å‡ºç°æ­¤æƒ…å†µçš„ç¤ºä¾‹ã€‚",
        "translate": ""
    },
    {
        "source": "The foreign interface uses handles of type `*mut ()` to refer to Rust values of different types.",
        "suggest": "å¤–éƒ¨æ¥å£ä½¿ç”¨ `*mut ()` ç±»å‹çš„å¥æŸ„æ¥å¼•ç”¨ä¸åŒç±»å‹çš„ Rust å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "We track the Rust type using a phantom type parameter on the struct `ExternalResource` which wraps a handle.",
        "suggest": "æˆ‘ä»¬ä½¿ç”¨åŒ…è£¹å¥æŸ„çš„ç»“æ„ä½“ `ExternalResource` ä¸Šçš„ `phantom` ç±»å‹å‚æ•°æ¥è·Ÿè¸ª Rust ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Ownership and the drop check",
        "suggest": "æ‰€æœ‰æƒå’Œ drop æ£€æµ‹",
        "translate": ""
    },
    {
        "source": "Adding a field of type `PhantomData<T>` indicates that your type owns data of type `T`.",
        "suggest": "æ·»åŠ  `PhantomData<T>` ç±»å‹çš„å­—æ®µè¡¨ç¤ºæ‚¨çš„ç±»å‹æ‹¥æœ‰ `T` ç±»å‹çš„æ•°æ®ã€‚",
        "translate": ""
    },
    {
        "source": "This in turn implies that when your type is dropped, it may drop one or more instances of the type `T`.",
        "suggest": "åè¿‡æ¥ï¼Œè¿™æ„å‘³ç€ä¸¢å¼ƒæ‚¨çš„ç±»å‹æ—¶ï¼Œå®ƒå¯èƒ½ä¼šä¸¢å¼ƒä¸€ä¸ªæˆ–å¤šä¸ª `T` ç±»å‹çš„å®ä¾‹ã€‚",
        "translate": ""
    },
    {
        "source": "This has bearing on the Rust compiler's [drop check] analysis.",
        "suggest": "è¿™ä¸ Rust ç¼–è¯‘å™¨çš„ [drop check] åˆ†ææœ‰å…³ã€‚",
        "translate": ""
    },
    {
        "source": "If your struct does not in fact *own* the data of type `T`, it is better to use a reference type, like `PhantomData<&'a T>` (ideally) or `PhantomData<*const T>` (if no lifetime applies), so as not to indicate ownership.",
        "suggest": "å¦‚æœæ‚¨çš„ç»“æ„ä½“å®é™…ä¸Šå¹¶ä¸ *æ‹¥æœ‰*`T` ç±»å‹çš„æ•°æ®ï¼Œåˆ™æœ€å¥½ä½¿ç”¨å¼•ç”¨ç±»å‹ï¼Œä¾‹å¦‚ `PhantomData<&'a T>` (ideally) æˆ– `PhantomData<*const T>` (å¦‚æœæ²¡æœ‰ç”Ÿå‘½å‘¨æœŸé€‚ç”¨)ï¼Œä»¥å…è¡¨ç¤ºæ‰€æœ‰æƒã€‚",
        "translate": ""
    },
    {
        "source": "Compiler-internal trait used to indicate the type of enum discriminants.",
        "suggest": "ç¼–è¯‘å™¨å†…éƒ¨çš„ trait ç”¨äºæŒ‡ç¤ºæšä¸¾åˆ¤åˆ«å¼çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "This trait is automatically implemented for every type and does not add any guarantees to [`mem::Discriminant`].",
        "suggest": "trait ä¼šè‡ªåŠ¨ä¸ºæ¯ç§ç±»å‹å®ç°ï¼Œå¹¶ä¸”ä¸ä¼šä¸º [`mem::Discriminant`] æ·»åŠ ä»»ä½•ä¿è¯ã€‚",
        "translate": ""
    },
    {
        "source": "It is **undefined behavior** to transmute between `DiscriminantKind::Discriminant` and `mem::Discriminant`.",
        "suggest": "åœ¨ `DiscriminantKind::Discriminant` å’Œ `mem::Discriminant` ä¹‹é—´è½¬æ¢æ˜¯æœªå®šä¹‰çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "The type of the discriminant, which must satisfy the trait bounds required by `mem::Discriminant`.",
        "suggest": "åˆ¤åˆ«ç±»å‹ï¼Œå¿…é¡»æ»¡è¶³ `mem::Discriminant` è¦æ±‚çš„ trait boundsã€‚",
        "translate": ""
    },
    {
        "source": "Compiler-internal trait used to determine whether a type contains any `UnsafeCell` internally, but not through an indirection.",
        "suggest": "ç¼–è¯‘å™¨å†…éƒ¨çš„ trait ç”¨äºç¡®å®šç±»å‹æ˜¯å¦åœ¨å†…éƒ¨åŒ…å«ä»»ä½• `UnsafeCell`ï¼Œä½†ä¸æ˜¯é€šè¿‡é—´æ¥å¯»å€ã€‚",
        "translate": ""
    },
    {
        "source": "This affects, for example, whether a `static` of that type is placed in read-only static memory or writable static memory.",
        "suggest": "ä¾‹å¦‚ï¼Œè¿™ä¼šå½±å“è¯¥ç±»å‹çš„ `static` æ˜¯å¦æ”¾ç½®åœ¨åªè¯»é™æ€å­˜å‚¨å™¨æˆ–å¯å†™é™æ€å­˜å‚¨å™¨ä¸­ã€‚",
        "translate": ""
    },
    {
        "source": "Types that can be safely moved after being pinned.",
        "suggest": "å›ºå®šåå¯ä»¥å®‰å…¨ç§»åŠ¨çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Rust itself has no notion of immovable types, and considers moves (e.g., through assignment or [`mem::replace`]) to always be safe.",
        "suggest": "Rust æœ¬èº«æ²¡æœ‰å›ºå®šç±»å‹çš„æ¦‚å¿µï¼Œå¹¶è®¤ä¸ºç§»åŠ¨ (ä¾‹å¦‚ï¼Œé€šè¿‡èµ‹å€¼æˆ– [`mem::replace`]) å§‹ç»ˆæ˜¯å®‰å…¨çš„ã€‚",
        "translate": ""
    },
    {
        "source": "The [`Pin`][Pin] type is used instead to prevent moves through the type system.",
        "suggest": "[`Pin`][Pin] ç±»å‹ä»£æ›¿ä½¿ç”¨ï¼Œä»¥é˜²æ­¢åœ¨ç±»å‹ç³»ç»Ÿä¸­ç§»åŠ¨ã€‚",
        "translate": ""
    },
    {
        "source": "Pointers `P<T>` wrapped in the [`Pin<P<T>>`][Pin] wrapper can't be moved out of.",
        "suggest": "[`Pin<P<T>>`][Pin] åŒ…è£…å™¨ä¸­åŒ…è£¹çš„æŒ‡é’ˆ `P<T>` ä¸èƒ½ç§»å‡ºã€‚",
        "translate": ""
    },
    {
        "source": "See the [`pin` module] documentation for more information on pinning.",
        "suggest": "æœ‰å…³å›ºå®šçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ [`pin` module] æ–‡æ¡£ã€‚",
        "translate": ""
    },
    {
        "source": "Implementing the `Unpin` trait for `T` lifts the restrictions of pinning off the type, which then allows moving `T` out of [`Pin<P<T>>`][Pin] with functions such as [`mem::replace`].",
        "suggest": "ä¸º `T` å®ç° `Unpin` trait æ¶ˆé™¤äº†å›ºå®šè¯¥ç±»å‹çš„é™åˆ¶ï¼Œç„¶åå…è®¸ä½¿ç”¨è¯¸å¦‚ [`mem::replace`] ä¹‹ç±»çš„åŠŸèƒ½å°† `T` ä» [`Pin<P<T>>`][Pin] ä¸­ç§»å‡ºã€‚",
        "translate": ""
    },
    {
        "source": "has no consequence at all for non-pinned data.",
        "suggest": "å¯¹äºéå›ºå®šæ•°æ®å®Œå…¨æ²¡æœ‰å½±å“ã€‚",
        "translate": ""
    },
    {
        "source": "In particular, [`mem::replace`] happily moves `!Unpin` data (it works for any `&mut T`, not just when `T: Unpin`).",
        "suggest": "ç‰¹åˆ«æ˜¯ï¼Œ[`mem::replace`] å¯ä»¥æ„‰å¿«åœ°ç§»åŠ¨ `!Unpin` æ•°æ® (å®ƒé€‚ç”¨äºä»»ä½• `&mut T`ï¼Œè€Œä¸ä»…é™äº `T: Unpin`)ã€‚",
        "translate": ""
    },
    {
        "source": "However, you cannot use [`mem::replace`] on data wrapped inside a [`Pin<P<T>>`][Pin] because you cannot get the `&mut T` you need for that, and *that* is what makes this system work.",
        "suggest": "ä½†æ˜¯ï¼Œæ‚¨ä¸èƒ½å¯¹åŒ…è£…åœ¨ [`Pin<P<T>>`][Pin] å†…çš„æ•°æ®ä½¿ç”¨ [`mem::replace`]ï¼Œå› ä¸ºæ‚¨æ— æ³•è·å¾—æ‰€éœ€çš„ `&mut T`ï¼Œå¹¶ä¸” *that* æ˜¯ä½¿æ­¤ç³»ç»Ÿæ­£å¸¸å·¥ä½œçš„åŸå› ã€‚",
        "translate": ""
    },
    {
        "source": "So this, for example, can only be done on types implementing `Unpin`:",
        "suggest": "å› æ­¤ï¼Œä¾‹å¦‚ï¼Œè¿™åªèƒ½åœ¨å®ç° `Unpin` çš„ç±»å‹ä¸Šå®Œæˆ:",
        "translate": ""
    },
    {
        "source": "This trait is automatically implemented for almost every type.",
        "suggest": "trait å‡ ä¹é’ˆå¯¹æ¯ç§ç±»å‹è‡ªåŠ¨å®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "A marker type which does not implement `Unpin`.",
        "suggest": "æ²¡æœ‰å®ç° `Unpin` çš„æ ‡è®°ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "If a type contains a `PhantomPinned`, it will not implement `Unpin` by default.",
        "suggest": "å¦‚æœç±»å‹åŒ…å« `PhantomPinned`ï¼Œåˆ™é»˜è®¤æƒ…å†µä¸‹å°†ä¸å®ç° `Unpin`ã€‚",
        "translate": ""
    },
    {
        "source": "Implementations of `Copy` for primitive types.",
        "suggest": "`Copy` çš„åŸºæœ¬ç±»å‹çš„å®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "Shared references can be copied, but mutable references *cannot*!",
        "suggest": "å…±äº«çš„å¼•ç”¨å¯ä»¥å¤åˆ¶ï¼Œä½†æ˜¯å¯å˜å¼•ç”¨ *ä¸èƒ½*!",
        "translate": ""
    },
    {
        "source": "will be dropped after `children`.",
        "suggest": "å°†åœ¨ `children` ä¹‹åè¢«ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "Rust guarantees that fields are dropped in the order of declaration.",
        "suggest": "Rust ä¿è¯æŒ‰å£°æ˜é¡ºåºä¸¢å¼ƒå­—æ®µã€‚",
        "translate": ""
    },
    {
        "source": "You can still safely operate on the value",
        "suggest": "æ‚¨ä»ç„¶å¯ä»¥å®‰å…¨åœ°æ“ä½œå€¼",
        "translate": ""
    },
    {
        "source": "But `Drop` will not be run here",
        "suggest": "ä½†æ˜¯ `Drop` ä¸ä¼šåœ¨è¿™é‡Œè¿è¡Œ",
        "translate": ""
    },
    {
        "source": "This drops the `Box`.",
        "suggest": "è¿™å°†ä½¿ `Box` ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "A wrapper to inhibit compiler from automatically calling `T`â€™s destructor.",
        "suggest": "åŒ…è£…å™¨ï¼Œç”¨äºç¦æ­¢ç¼–è¯‘å™¨è‡ªåŠ¨è°ƒç”¨ T çš„ææ„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This wrapper is 0-cost.",
        "suggest": "è¯¥åŒ…è£…å™¨çš„æˆæœ¬ä¸º 0ã€‚",
        "translate": ""
    },
    {
        "source": "is subject to the same layout optimizations as `T`.",
        "suggest": "ä¸ `T` è¿›è¡Œç›¸åŒçš„å¸ƒå±€ä¼˜åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "As a consequence, it has *no effect* on the assumptions that the compiler makes about its contents.",
        "suggest": "å› æ­¤ï¼Œå®ƒåœ¨ç¼–è¯‘å™¨å¯¹å…¶å†…å®¹è¿›è¡Œå‡è®¾çš„å‰æä¸‹å…·æœ‰ *no æ•ˆæœ*ã€‚",
        "translate": ""
    },
    {
        "source": "For example, initializing a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.",
        "suggest": "ä¾‹å¦‚ï¼Œç”¨ [`mem::zeroed`] åˆå§‹åŒ– `ManuallyDrop<&mut T>` æ˜¯æœªå®šä¹‰çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.",
        "suggest": "å¦‚æœéœ€è¦å¤„ç†æœªåˆå§‹åŒ–çš„æ•°æ®ï¼Œè¯·æ”¹ç”¨ [`MaybeUninit<T>`]ã€‚",
        "translate": ""
    },
    {
        "source": "Note that accessing the value inside a `ManuallyDrop<T>` is safe.",
        "suggest": "è¯·æ³¨æ„ï¼Œè®¿é—® `ManuallyDrop<T>` å†…éƒ¨çš„å€¼æ˜¯å®‰å…¨çš„ã€‚",
        "translate": ""
    },
    {
        "source": "This means that a `ManuallyDrop<T>` whose content has been dropped must not be exposed through a public safe API.",
        "suggest": "è¿™æ„å‘³ç€å…¶å†…å®¹å·²è¢«ä¸¢å¼ƒçš„ `ManuallyDrop<T>` ä¸€å®šä¸èƒ½é€šè¿‡å…¬å…±å®‰å…¨ API å…¬å¼€ã€‚",
        "translate": ""
    },
    {
        "source": "Correspondingly, `ManuallyDrop::drop` is unsafe.",
        "suggest": "ç›¸åº”åœ°ï¼Œ`ManuallyDrop::drop` æ˜¯ä¸å®‰å…¨çš„ã€‚",
        "translate": ""
    },
    {
        "source": "and drop order.",
        "suggest": "å’Œ drop æŒ‡ä»¤ã€‚",
        "translate": ""
    },
    {
        "source": "Rust has a well-defined [drop order] of values.",
        "suggest": "Rust å…·æœ‰å®šä¹‰æ˜ç¡®çš„ [drop order] å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "To make sure that fields or locals are dropped in a specific order, reorder the declarations such that the implicit drop order is the correct one.",
        "suggest": "ä¸ºç¡®ä¿æŒ‰ç‰¹å®šé¡ºåºä¸¢å¼ƒå­—æ®µæˆ–å±€éƒ¨å˜é‡ï¼Œè¯·å¯¹å£°æ˜é‡æ–°æ’åºï¼Œä»¥ä½¿éšå¼ä¸¢å¼ƒé¡ºåºæ­£ç¡®ã€‚",
        "translate": ""
    },
    {
        "source": "It is possible to use `ManuallyDrop` to control the drop order, but this requires unsafe code and is hard to do correctly in the presence of unwinding.",
        "suggest": "å¯ä»¥ä½¿ç”¨ `ManuallyDrop` æ¥æ§åˆ¶ä¸¢å¼ƒé¡ºåºï¼Œä½†è¿™éœ€è¦ä¸å®‰å…¨çš„ä»£ç ï¼Œå¹¶ä¸”åœ¨å±•å¼€çŠ¶æ€ä¸‹å¾ˆéš¾æ­£ç¡®æ‰§è¡Œã€‚",
        "translate": ""
    },
    {
        "source": "For example, if you want to make sure that a specific field is dropped after the others, make it the last field of a struct:",
        "suggest": " ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æƒ³è¦ç¡®ä¿ä¸€ä¸ªç‰¹å®šçš„å­—æ®µåœ¨å…¶ä»–å­—æ®µä¹‹åè¢«ä¸¢å¼ƒï¼Œå°†å®ƒä½œä¸ºç»“æ„çš„æœ€åä¸€ä¸ªå­—æ®µ:",
        "translate": ""
    },
    {
        "source": "Wrap a value to be manually dropped.",
        "suggest": "åŒ…è£…ä¸€ä¸ªè¦æ‰‹åŠ¨ä¸¢å¼ƒçš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Extracts the value from the `ManuallyDrop` container.",
        "suggest": "ä» `ManuallyDrop` å®¹å™¨ä¸­æå–å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This allows the value to be dropped again.",
        "suggest": "è¿™æ ·å¯ä»¥å†æ¬¡ä¸¢å¼ƒè¯¥å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Takes the value from the `ManuallyDrop<T>` container out.",
        "suggest": "ä» `ManuallyDrop<T>` å®¹å™¨ä¸­å–å‡ºå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This method is primarily intended for moving out values in drop.",
        "suggest": "æ­¤æ–¹æ³•ä¸»è¦ç”¨äºåœ¨ drop ä¸­ç§»å‡ºå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Instead of using [`ManuallyDrop::drop`] to manually drop the value, you can use this method to take the value and use it however desired.",
        "suggest": "æ‚¨å¯ä»¥ä½¿ç”¨æ­¤æ–¹æ³•è·å–å€¼å¹¶æ ¹æ®éœ€è¦ä½¿ç”¨å®ƒï¼Œè€Œä¸æ˜¯ä½¿ç”¨ [`ManuallyDrop::drop`] æ‰‹åŠ¨åˆ é™¤è¯¥å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Whenever possible, it is preferable to use [`into_inner`][`ManuallyDrop::into_inner`] instead, which prevents duplicating the content of the `ManuallyDrop<T>`.",
        "suggest": "åªè¦æœ‰å¯èƒ½ï¼Œæœ€å¥½æ”¹ç”¨ [`into_inner`][`ManuallyDrop::into_inner`]ï¼Œè¿™æ ·å¯ä»¥é˜²æ­¢é‡å¤ `ManuallyDrop<T>` çš„å†…å®¹ã€‚",
        "translate": ""
    },
    {
        "source": "This function semantically moves out the contained value without preventing further usage, leaving the state of this container unchanged.",
        "suggest": "è¯¥å‡½æ•°ä»è¯­ä¹‰ä¸Šç§»å‡ºæ‰€åŒ…å«çš„å€¼ï¼Œè€Œä¸ä¼šé˜»æ­¢è¿›ä¸€æ­¥ä½¿ç”¨ï¼Œä»è€Œä½¿è¯¥å®¹å™¨çš„çŠ¶æ€ä¿æŒä¸å˜ã€‚",
        "translate": ""
    },
    {
        "source": "It is your responsibility to ensure that this `ManuallyDrop` is not used again.",
        "suggest": "æ‚¨æœ‰è´£ä»»ç¡®ä¿ä¸å†ä½¿ç”¨æ­¤ `ManuallyDrop`ã€‚",
        "translate": ""
    },
    {
        "source": "we are reading from a reference, which is guaranteed to be valid for reads.",
        "suggest": "æˆ‘ä»¬æ­£åœ¨ä»å¼•æ–‡ä¸­è¿›è¡Œè¯»å–ï¼Œè¯¥å¼•æ–‡ä¿è¯å¯¹è¯»å–æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "Manually drops the contained value.",
        "suggest": "æ‰‹åŠ¨ä¸¢å¼ƒåŒ…å«çš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This is exactly equivalent to calling [`ptr::drop_in_place`] with a pointer to the contained value.",
        "suggest": "è¿™å®Œå…¨ç­‰åŒäºä½¿ç”¨æŒ‡å‘æ‰€åŒ…å«å€¼çš„æŒ‡é’ˆæ¥è°ƒç”¨ [`ptr::drop_in_place`]ã€‚",
        "translate": ""
    },
    {
        "source": "As such, unless the contained value is a packed struct, the destructor will be called in-place without moving the value, and thus can be used to safely drop [pinned] data.",
        "suggest": "è¿™æ ·ï¼Œé™¤éæ‰€åŒ…å«çš„å€¼æ˜¯åŒ…è£…çš„ç»“æ„ä½“ï¼Œå¦åˆ™ææ„å‡½æ•°å°†åœ¨ä¸ç§»åŠ¨å€¼çš„æƒ…å†µä¸‹å°±åœ°è°ƒç”¨ï¼Œå› æ­¤å¯ç”¨äºå®‰å…¨åœ°ä¸¢å¼ƒ [pinned] æ•°æ®ã€‚",
        "translate": ""
    },
    {
        "source": "If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.",
        "suggest": "å¦‚æœæ‚¨æ‹¥æœ‰è¯¥å€¼çš„æ‰€æœ‰æƒï¼Œåˆ™å¯ä»¥æ”¹ç”¨ [`ManuallyDrop::into_inner`]ã€‚",
        "translate": ""
    },
    {
        "source": "This function runs the destructor of the contained value.",
        "suggest": "æ­¤å‡½æ•°è¿è¡ŒåŒ…å«å€¼çš„ææ„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Other than changes made by the destructor itself, the memory is left unchanged, and so as far as the compiler is concerned still holds a bit-pattern which is valid for the type `T`.",
        "suggest": "é™¤äº†ææ„å‡½æ•°æœ¬èº«æ‰€åšçš„æ›´æ”¹ä¹‹å¤–ï¼Œå†…å­˜ä¿æŒä¸å˜ï¼Œå› æ­¤å°±ç¼–è¯‘å™¨è€Œè¨€ï¼Œä»ç„¶ä¿ç•™ä¸€ç§å¯¹äº `T` ç±»å‹æœ‰æ•ˆçš„ä½æ¨¡å¼ã€‚",
        "translate": ""
    },
    {
        "source": "However, this \"zombie\" value should not be exposed to safe code, and this function should not be called more than once.",
        "suggest": "ä½†æ˜¯ï¼Œæ­¤ \"zombie\" å€¼ä¸åº”æš´éœ²ç»™å®‰å…¨ä»£ç ï¼Œå¹¶ä¸”ä¸åº”å¤šæ¬¡è°ƒç”¨æ­¤å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what `drop` does).",
        "suggest": "åœ¨ä¸¢å¼ƒå€¼æˆ–å¤šæ¬¡ä¸¢å¼ƒå€¼åä½¿ç”¨è¯¥å€¼å¯èƒ½ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸º (å–å†³äº `drop` çš„ä½œç”¨)ã€‚",
        "translate": ""
    },
    {
        "source": "This is normally prevented by the type system, but users of `ManuallyDrop` must uphold those guarantees without assistance from the compiler.",
        "suggest": "ç±»å‹ç³»ç»Ÿé€šå¸¸ä¼šé˜»æ­¢è¿™ç§æƒ…å†µï¼Œä½†æ˜¯ `ManuallyDrop` çš„ç”¨æˆ·å¿…é¡»åšæŒè¿™äº›ä¿è¯ï¼Œè€Œæ— éœ€ç¼–è¯‘å™¨çš„å¸®åŠ©ã€‚",
        "translate": ""
    },
    {
        "source": "we are dropping the value pointed to by a mutable reference which is guaranteed to be valid for writes.",
        "suggest": "æˆ‘ä»¬å°†ä¸¢å¼ƒå˜é‡å¼•ç”¨æ‰€æŒ‡å‘çš„å€¼ï¼Œè¯¥å€¼å¯¹äºå†™æ“ä½œæ˜¯æœ‰æ•ˆçš„ã€‚",
        "translate": ""
    },
    {
        "source": "It is up to the caller to make sure that `slot` isn't dropped again.",
        "suggest": "å–å†³äºè°ƒç”¨è€…ï¼Œä»¥ç¡®ä¿ä¸ä¼šå†æ¬¡ä¸¢å¼ƒ `slot`ã€‚",
        "translate": ""
    },
    {
        "source": "undefined behavior!",
        "suggest": "æœªå®šä¹‰çš„è¡Œä¸º!",
        "translate": ""
    },
    {
        "source": "The equivalent code with `MaybeUninit<&i32>`:",
        "suggest": "ä¸ `MaybeUninit<&i32>` ç­‰æ•ˆçš„ä»£ç :",
        "translate": ""
    },
    {
        "source": "The equivalent code with `MaybeUninit<bool>`:",
        "suggest": "ä¸ `MaybeUninit<bool>` ç­‰æ•ˆçš„ä»£ç :",
        "translate": ""
    },
    {
        "source": "The equivalent code with `MaybeUninit<i32>`:",
        "suggest": "ä¸ `MaybeUninit<i32>` ç­‰æ•ˆçš„ä»£ç :",
        "translate": ""
    },
    {
        "source": "Create an explicitly uninitialized reference.",
        "suggest": "åˆ›å»ºä¸€ä¸ªæ˜¾å¼æœªåˆå§‹åŒ–çš„å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "The compiler knows that data inside a `MaybeUninit<T>` may be invalid, and hence this is not UB:",
        "suggest": "ç¼–è¯‘å™¨çŸ¥é“ `MaybeUninit<T>` å†…éƒ¨çš„æ•°æ®å¯èƒ½æ— æ•ˆï¼Œå› æ­¤ä¸æ˜¯ UB:",
        "translate": ""
    },
    {
        "source": "Set it to a valid value.",
        "suggest": "å°†å…¶è®¾ç½®ä¸ºæœ‰æ•ˆå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Extract the initialized data -- this is only allowed *after* properly initializing `x`!",
        "suggest": "æå–å·²åˆå§‹åŒ–çš„æ•°æ® - ä»…åœ¨æ­£ç¡®åˆå§‹åŒ– `x` ä¹‹å * æ‰å…è®¸è¿™æ ·åš!",
        "translate": ""
    },
    {
        "source": "does not drop the old contents, which is important.",
        "suggest": "ä¸ä¼šä¸¢å¼ƒè€çš„å†…å®¹ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚",
        "translate": ""
    },
    {
        "source": "Now we know `v` is initialized!",
        "suggest": "ç°åœ¨æˆ‘ä»¬çŸ¥é“ `v` å·²åˆå§‹åŒ–!",
        "translate": ""
    },
    {
        "source": "This also makes sure the vector gets properly dropped.",
        "suggest": "è¿™ä¹Ÿå¯ä»¥ç¡®ä¿æ­£ç¡®ä¸¢å¼ƒ vectorã€‚",
        "translate": ""
    },
    {
        "source": "Create an uninitialized array of `MaybeUninit`.",
        "suggest": "åˆ›å»ºä¸€ä¸ªæœªåˆå§‹åŒ–çš„ `MaybeUninit` æ•°ç»„ã€‚",
        "translate": ""
    },
    {
        "source": "The `assume_init` is safe because the type we are claiming to have initialized here is a bunch of `MaybeUninit`s, which do not require initialization.",
        "suggest": "`assume_init` æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºæˆ‘ä»¬å£°ç§°è¿™é‡Œå·²ç»åˆå§‹åŒ–çš„ç±»å‹æ˜¯ä¸€å † `MaybeUninit`ï¼Œä¸éœ€è¦åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "Dropping a `MaybeUninit` does nothing.",
        "suggest": "ä¸¢å¼ƒ `MaybeUninit` ä¸ä¼šæ‰§è¡Œä»»ä½•æ“ä½œã€‚",
        "translate": ""
    },
    {
        "source": "Thus using raw pointer assignment instead of `ptr::write` does not cause the old uninitialized value to be dropped.",
        "suggest": "å› æ­¤ï¼Œä½¿ç”¨è£¸æŒ‡é’ˆåˆ†é…ä»£æ›¿ `ptr::write` ä¸ä¼šå¯¼è‡´æ—§çš„æœªåˆå§‹åŒ–å€¼è¢«ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "Also if there is a panic during this loop, we have a memory leak, but there is no memory safety issue.",
        "suggest": "æ­¤å¤–ï¼Œå¦‚æœåœ¨æ­¤å¾ªç¯æœŸé—´å­˜åœ¨ panicï¼Œåˆ™å¯èƒ½ä¼šå‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œä½†ä¸ä¼šå‡ºç°å†…å­˜å®‰å…¨é—®é¢˜ã€‚",
        "translate": ""
    },
    {
        "source": "Everything is initialized.",
        "suggest": "ä¸€åˆ‡éƒ½å·²åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "Transmute the array to the initialized type.",
        "suggest": "å°†æ•°ç»„è½¬æ¢ä¸ºåˆå§‹åŒ–çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Count the number of elements we have assigned.",
        "suggest": "è®¡ç®—æˆ‘ä»¬åˆ†é…çš„å…ƒç´ æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "For each item in the array, drop if we allocated it.",
        "suggest": "å¯¹äºæ•°ç»„ä¸­çš„æ¯ä¸ªé¡¹ï¼Œå¦‚æœæˆ‘ä»¬åˆ†é…äº†å®ƒï¼Œåˆ™å°†å…¶ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "Initializing the `name` field",
        "suggest": "åˆå§‹åŒ– `name` å­—æ®µ",
        "translate": ""
    },
    {
        "source": "Initializing the `list` field If there is a panic here, then the `String` in the `name` field leaks.",
        "suggest": "åˆå§‹åŒ– `list` å­—æ®µå¦‚æœæ­¤å¤„å­˜åœ¨ panicï¼Œåˆ™ `name` å­—æ®µä¸­çš„ `String` æ³„æ¼ã€‚",
        "translate": ""
    },
    {
        "source": "All the fields are initialized, so we call `assume_init` to get an initialized Foo.",
        "suggest": "æ‰€æœ‰å­—æ®µéƒ½å·²åˆå§‹åŒ–ï¼Œå› æ­¤æˆ‘ä»¬è°ƒç”¨ `assume_init` æ¥è·å–å·²åˆå§‹åŒ–çš„ Fooã€‚",
        "translate": ""
    },
    {
        "source": "Returns a (possibly smaller) slice of data that was actually read",
        "suggest": "è¿”å›å®é™…è¯»å–çš„ (å¯èƒ½è¾ƒå°çš„) æ•°æ®åˆ‡ç‰‡",
        "translate": ""
    },
    {
        "source": "Inside a pair, we create a `NotZero` that does not have a valid discriminant.",
        "suggest": "åœ¨ä¸€ä¸ªå¯¹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ²¡æœ‰æœ‰æ•ˆåˆ¤åˆ«å¼çš„ `NotZero`ã€‚",
        "translate": ""
    },
    {
        "source": "This is undefined behavior.",
        "suggest": "è¿™æ˜¯æœªå®šä¹‰çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "Create a reference into the `MaybeUninit<T>`.",
        "suggest": "åœ¨ `MaybeUninit<T>` ä¸­åˆ›å»ºå¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "This is okay because we initialized it.",
        "suggest": "å¯ä»¥ï¼Œå› ä¸ºæˆ‘ä»¬å·²å°†å…¶åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "We have created a reference to an uninitialized vector!",
        "suggest": "æˆ‘ä»¬åˆ›å»ºäº†å¯¹æœªåˆå§‹åŒ–çš„ vector çš„å¼•ç”¨!",
        "translate": ""
    },
    {
        "source": "Create a reference into the `MaybeUninit<Vec<u32>>`.",
        "suggest": "åœ¨ `MaybeUninit<Vec<u32>>` ä¸­åˆ›å»ºå¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "had not been initialized yet, so this last line caused undefined behavior.",
        "suggest": "å°šæœªåˆå§‹åŒ–ï¼Œå› æ­¤è¿™æœ€åä¸€è¡Œå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "is `Copy`, so we may read multiple times.",
        "suggest": "æ˜¯ `Copy`ï¼Œå› æ­¤æˆ‘ä»¬å¯èƒ½ä¼šå¤šæ¬¡è¯»å–ã€‚",
        "translate": ""
    },
    {
        "source": "Duplicating a `None` value is okay, so we may read multiple times.",
        "suggest": "å¤åˆ¶ `None` å€¼æ˜¯å¯ä»¥çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯èƒ½ä¼šå¤šæ¬¡è¯»å–ã€‚",
        "translate": ""
    },
    {
        "source": "We now created two copies of the same vector, leading to a double-free âš ï¸ when they both get dropped!",
        "suggest": "ç°åœ¨ï¼Œæˆ‘ä»¬åˆ›å»ºäº†åŒä¸€ vector çš„ä¸¤ä¸ªå‰¯æœ¬ï¼Œå½“å®ƒä»¬éƒ½è¢«ä¸¢å¼ƒæ—¶ï¼Œå°†å¯¼è‡´åŒé‡é‡Šæ”¾!",
        "translate": ""
    },
    {
        "source": "Initialize `x`:",
        "suggest": "åˆå§‹åŒ– `x`:",
        "translate": ""
    },
    {
        "source": "Now that our `MaybeUninit<_>` is known to be initialized, it is okay to create a shared reference to it:",
        "suggest": "ç°åœ¨å·²çŸ¥æˆ‘ä»¬çš„ `MaybeUninit<_>` å·²åˆå§‹åŒ–ï¼Œå¯ä»¥åˆ›å»ºå¯¹å…¶çš„å…±äº«å¼•ç”¨:",
        "translate": ""
    },
    {
        "source": "`x` has been initialized.",
        "suggest": "`x` å·²åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "Initialize the `MaybeUninit` using `Cell::set`:",
        "suggest": "ä½¿ç”¨ `Cell::set` åˆå§‹åŒ– `MaybeUninit`:",
        "translate": ""
    },
    {
        "source": "Reference to an uninitialized `Cell<bool>`: UB!",
        "suggest": "å¼•ç”¨æœªåˆå§‹åŒ–çš„ `Cell<bool>`: UB!",
        "translate": ""
    },
    {
        "source": "Initializes *all* the bytes of the input buffer.",
        "suggest": "åˆå§‹åŒ–æ‰€æœ‰è¾“å…¥ç¼“å†²åŒºçš„å­—èŠ‚ã€‚",
        "translate": ""
    },
    {
        "source": "Initialize `buf`:",
        "suggest": "åˆå§‹åŒ– `buf`:",
        "translate": ""
    },
    {
        "source": "Now we know that `buf` has been initialized, so we could `.assume_init()` it.",
        "suggest": "ç°åœ¨æˆ‘ä»¬çŸ¥é“ `buf` å·²è¢«åˆå§‹åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œ `.assume_init()`ã€‚",
        "translate": ""
    },
    {
        "source": "However, using `.assume_init()` may trigger a `memcpy` of the 2048 bytes.",
        "suggest": "ä½†æ˜¯ï¼Œä½¿ç”¨ `.assume_init()` å¯èƒ½ä¼šè§¦å‘ 2048 å­—èŠ‚çš„ `memcpy`ã€‚",
        "translate": ""
    },
    {
        "source": "To assert our buffer has been initialized without copying it, we upgrade the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:",
        "suggest": "è¦æ–­è¨€æˆ‘ä»¬çš„ç¼“å†²åŒºå·²è¢«åˆå§‹åŒ–è€Œä¸å¤åˆ¶å®ƒï¼Œæˆ‘ä»¬å°† `&mut MaybeUninit<[u8; 2048]>` å‡çº§åˆ° `&mut [u8; 2048]`:",
        "translate": ""
    },
    {
        "source": "`buf` has been initialized.",
        "suggest": "`buf` å·²åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "Now we can use `buf` as a normal slice:",
        "suggest": "ç°åœ¨æˆ‘ä»¬å¯ä»¥å°† `buf` ç”¨ä½œæ™®é€šåˆ‡ç‰‡:",
        "translate": ""
    },
    {
        "source": "We have created a (mutable) reference to an uninitialized `bool`!",
        "suggest": "æˆ‘ä»¬å·²ç»åˆ›å»ºäº† (mutable) å¼•ç”¨æœªåˆå§‹åŒ–çš„ `bool`!",
        "translate": ""
    },
    {
        "source": "reference to uninitialized memory!",
        "suggest": "å¼•ç”¨æœªåˆå§‹åŒ–çš„å†…å­˜!",
        "translate": ""
    },
    {
        "source": "Now safe as we initialised all elements",
        "suggest": "ç°åœ¨å®‰å…¨äº†ï¼Œå› ä¸ºæˆ‘ä»¬åˆå§‹åŒ–äº†æ‰€æœ‰å…ƒç´ ",
        "translate": ""
    },
    {
        "source": "we have just copied all the elements of len into the spare capacity the first src.len() elements of the vec are valid now.",
        "suggest": "æˆ‘ä»¬åˆšåˆšå°† len çš„æ‰€æœ‰å…ƒç´ å¤åˆ¶åˆ°äº†å¤‡ç”¨å®¹é‡ä¸­ï¼Œvec çš„ç¬¬ä¸€ä¸ª src.len() å…ƒç´ ç°åœ¨æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "we have just cloned all the elements of len into the spare capacity the first src.len() elements of the vec are valid now.",
        "suggest": "æˆ‘ä»¬åˆšåˆšå°† len çš„æ‰€æœ‰å…ƒç´ å…‹éš†åˆ°äº†å¤‡ç”¨å®¹é‡ä¸­ï¼Œvec çš„ç¬¬ä¸€ä¸ª src.len() å…ƒç´ ç°åœ¨æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "A wrapper type to construct uninitialized instances of `T`.",
        "suggest": "åŒ…è£…å™¨ç±»å‹ï¼Œç”¨äºåˆ›å»º `T` çš„æœªåˆå§‹åŒ–å®ä¾‹ã€‚",
        "translate": ""
    },
    {
        "source": "Initialization invariant",
        "suggest": "åˆå§‹åŒ–ä¸å˜å¼",
        "translate": ""
    },
    {
        "source": "The compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable's type.",
        "suggest": "é€šå¸¸ï¼Œç¼–è¯‘å™¨å‡å®šå·²æ ¹æ®å˜é‡ç±»å‹çš„è¦æ±‚æ­£ç¡®åˆå§‹åŒ–äº†å˜é‡ã€‚",
        "translate": ""
    },
    {
        "source": "For example, a variable of reference type must be aligned and non-NULL.",
        "suggest": "ä¾‹å¦‚ï¼Œå¼•ç”¨ç±»å‹çš„å˜é‡å¿…é¡»å¯¹é½å¹¶ä¸”ä¸èƒ½ä¸º NULLã€‚",
        "translate": ""
    },
    {
        "source": "This is an invariant that must *always* be upheld, even in unsafe code.",
        "suggest": "å³ä½¿åœ¨ä¸å®‰å…¨çš„ä»£ç ä¸­ï¼Œè¿™ä¹Ÿå¿…é¡»å§‹ç»ˆä¿æŒä¸å˜ã€‚",
        "translate": ""
    },
    {
        "source": "As a consequence, zero-initializing a variable of reference type causes instantaneous [undefined behavior][ub], no matter whether that reference ever gets used to access memory:",
        "suggest": "ç»“æœï¼Œå°†å¼•ç”¨ç±»å‹çš„å˜é‡åˆå§‹åŒ–ä¸ºé›¶ä¼šå¯¼è‡´ç¬æ—¶ [undefined behavior][ub]ï¼Œæ— è®ºå¼•ç”¨æ˜¯å¦æ›¾ç»è¢«ç”¨æ¥è®¿é—®å†…å­˜:",
        "translate": ""
    },
    {
        "source": "This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing `enum` layout.",
        "suggest": "ç¼–è¯‘å™¨å°†å…¶ç”¨äºå„ç§ä¼˜åŒ–ï¼Œä¾‹å¦‚æ¶ˆé™¤è¿è¡Œæ—¶æ£€æŸ¥å’Œä¼˜åŒ– `enum` å¸ƒå±€ã€‚",
        "translate": ""
    },
    {
        "source": "Similarly, entirely uninitialized memory may have any content, while a `bool` must always be `true` or `false`.",
        "suggest": "åŒæ ·ï¼Œå®Œå…¨æœªåˆå§‹åŒ–çš„å­˜å‚¨å™¨å¯ä»¥åŒ…å«ä»»ä½•å†…å®¹ï¼Œè€Œ `bool` å¿…é¡»å§‹ç»ˆä¸º `true` æˆ– `false`ã€‚",
        "translate": ""
    },
    {
        "source": "Hence, creating an uninitialized `bool` is undefined behavior:",
        "suggest": "å› æ­¤ï¼Œåˆ›å»ºæœªåˆå§‹åŒ–çš„ `bool` æ˜¯æœªå®šä¹‰çš„è¡Œä¸º:",
        "translate": ""
    },
    {
        "source": "Moreover, uninitialized memory is special in that it does not have a fixed value (\"fixed\" meaning \"it won't change without being written to\").",
        "suggest": "æ­¤å¤–ï¼Œæœªåˆå§‹åŒ–çš„å­˜å‚¨å™¨çš„ç‰¹æ®Šä¹‹å¤„åœ¨äºå®ƒæ²¡æœ‰å›ºå®šçš„å€¼ (\"fixed\" è¡¨ç¤º \"it won't change without being written to\")ã€‚",
        "translate": ""
    },
    {
        "source": "Reading the same uninitialized byte multiple times can give different results.",
        "suggest": "å¤šæ¬¡è¯»å–ç›¸åŒçš„æœªåˆå§‹åŒ–å­—èŠ‚ä¼šäº§ç”Ÿä¸åŒçš„ç»“æœã€‚",
        "translate": ""
    },
    {
        "source": "This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type, which otherwise can hold any *fixed* bit pattern:",
        "suggest": "è¿™ä½¿å¾—åœ¨å˜é‡ä¸­å…·æœ‰æœªåˆå§‹åŒ–çš„æ•°æ®æˆä¸ºæœªå®šä¹‰çš„è¡Œä¸ºï¼Œå³ä½¿è¯¥å˜é‡å…·æœ‰æ•´æ•°ç±»å‹ä¹Ÿå¯ä»¥ä¿ç•™ä»»ä½•å›ºå®šä½æ¨¡å¼",
        "translate": ""
    },
    {
        "source": "(Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)",
        "suggest": "(è¯·æ³¨æ„ï¼Œå…³äºæœªåˆå§‹åŒ–æ•´æ•°çš„è§„åˆ™å°šæœªæœ€ç»ˆç¡®å®šï¼Œä½†æ˜¯é™¤éè¢«ç¡®å®šï¼Œå¦åˆ™å»ºè®®é¿å…ä½¿ç”¨å®ƒä»¬ã€‚)",
        "translate": ""
    },
    {
        "source": "On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level.",
        "suggest": "æœ€é‡è¦çš„æ˜¯ï¼Œè¯·è®°ä½ï¼Œå¤§å¤šæ•°ç±»å‹å…·æœ‰å…¶ä»–ä¸å˜å¼ï¼Œè€Œä¸ä»…ä»…æ˜¯åœ¨ç±»å‹çº§åˆ«è¢«åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "For example, a `1`-initialized [`Vec<T>`] is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null.",
        "suggest": "ä¾‹å¦‚ï¼Œå°† `1` åˆå§‹åŒ–çš„ [`Vec<T>`] è§†ä¸ºå·²åˆå§‹åŒ– (åœ¨å½“å‰å®ç°ä¸‹; è¿™å¹¶ä¸æ„æˆç¨³å®šçš„ä¿è¯)ï¼Œå› ä¸ºç¼–è¯‘å™¨çŸ¥é“çš„å”¯ä¸€è¦æ±‚æ˜¯æ•°æ®æŒ‡é’ˆå¿…é¡»ä¸ºéç©ºå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Creating such a `Vec<T>` does not cause *immediate* undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).",
        "suggest": "åˆ›å»ºè¿™æ ·çš„ `Vec<T>` ä¸ä¼šç«‹å³å¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºï¼Œä½†æ˜¯åœ¨å¤§å¤šæ•°å®‰å…¨æ“ä½œ (åŒ…æ‹¬ä¸¢å¼ƒæ“ä½œ) ä¸­éƒ½å°†å¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "serves to enable unsafe code to deal with uninitialized data.",
        "suggest": "ç”¨äºä½¿ä¸å®‰å…¨çš„ä»£ç èƒ½å¤Ÿå¤„ç†æœªåˆå§‹åŒ–çš„æ•°æ®ã€‚",
        "translate": ""
    },
    {
        "source": "It is a signal to the compiler indicating that the data here might *not* be initialized:",
        "suggest": "è¿™æ˜¯å‘ç¼–è¯‘å™¨å‘å‡ºçš„ä¿¡å·ï¼ŒæŒ‡ç¤ºæ­¤å¤„çš„æ•°æ®å¯èƒ½ä¸è¢«åˆå§‹åŒ–:",
        "translate": ""
    },
    {
        "source": "The compiler then knows to not make any incorrect assumptions or optimizations on this code.",
        "suggest": "ç„¶åï¼Œç¼–è¯‘å™¨çŸ¥é“ä¸ä¼šå¯¹æ­¤ä»£ç è¿›è¡Œä»»ä½•é”™è¯¯çš„å‡è®¾æˆ–ä¼˜åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without any of the run-time tracking and without any of the safety checks.",
        "suggest": "æ‚¨å¯ä»¥è®¤ä¸º `MaybeUninit<T>` æœ‰ç‚¹åƒ `Option<T>`ï¼Œä½†æ˜¯æ²¡æœ‰ä»»ä½•è¿è¡Œæ—¶è·Ÿè¸ªä¸”æ²¡æœ‰ä»»ä½•å®‰å…¨æ£€æŸ¥ã€‚",
        "translate": ""
    },
    {
        "source": "You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data from a function, pass it a pointer to some (uninitialized) memory to put the result into.",
        "suggest": "æ‚¨å¯ä»¥ä½¿ç”¨ `MaybeUninit<T>` æ¥å®ç° \"out-pointers\": ä¸å…¶ä»å‡½æ•°ä¸­è¿”å›æ•°æ®ï¼Œè¿˜ä¸å¦‚å°†å…¶ä¼ é€’ç»™æŸä¸ª (uninitialized) å†…å­˜çš„æŒ‡é’ˆä»¥å°†ç»“æœæ”¾å…¥å…¶ä¸­ã€‚",
        "translate": ""
    },
    {
        "source": "This can be useful when it is important for the caller to control how the memory the result is stored in gets allocated, and you want to avoid unnecessary moves.",
        "suggest": "å½“å¯¹è°ƒç”¨æ–¹æ¥è¯´ï¼Œæ§åˆ¶ç»“æœå­˜å‚¨åœ¨å†…å­˜ä¸­çš„åˆ†é…æ–¹å¼å¾ˆé‡è¦å¹¶ä¸”æ‚¨å¸Œæœ›é¿å…ä¸å¿…è¦çš„ç§»åŠ¨æ—¶ï¼Œè¿™å¾ˆæœ‰ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Initializing an array element-by-element",
        "suggest": "é€å…ƒç´ åˆå§‹åŒ–æ•°ç»„",
        "translate": ""
    },
    {
        "source": "can be used to initialize a large array element-by-element:",
        "suggest": "å¯ç”¨äºæŒ‰å…ƒç´ åˆå§‹åŒ–å¤§å‹æ•°ç»„:",
        "translate": ""
    },
    {
        "source": "You can also work with partially initialized arrays, which could be found in low-level datastructures.",
        "suggest": "æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨éƒ¨åˆ†åˆå§‹åŒ–çš„æ•°ç»„ï¼Œè¿™äº›æ•°ç»„å¯ä»¥åœ¨ä¸ç¨³å®šçš„æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°ã€‚",
        "translate": ""
    },
    {
        "source": "Initializing a struct field-by-field",
        "suggest": "é€åœºåˆå§‹åŒ–ç»“æ„ä½“",
        "translate": ""
    },
    {
        "source": "You can use `MaybeUninit<T>`, and the [`std::ptr::addr_of_mut`] macro, to initialize structs field by field:",
        "suggest": "æ‚¨å¯ä»¥ä½¿ç”¨ `MaybeUninit<T>` å’Œ [`std::ptr::addr_of_mut`] å®æ¥é€å­—æ®µåˆå§‹åŒ–ç»“æ„ä½“:",
        "translate": ""
    },
    {
        "source": "is guaranteed to have the same size, alignment, and ABI as `T`:",
        "suggest": "ä¿è¯å…·æœ‰ä¸ `T` ç›¸åŒçš„å¤§å°ï¼Œå¯¹é½æ–¹å¼å’Œ ABI:",
        "translate": ""
    },
    {
        "source": "However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same layout;",
        "suggest": "ä½†æ˜¯è¯·è®°ä½ï¼Œ*åŒ…å«*`MaybeUninit<T>` çš„ç±»å‹ä¸ä¸€å®šæ˜¯ç›¸åŒçš„å¸ƒå±€ã€‚",
        "translate": ""
    },
    {
        "source": "Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as a `Foo<U>` even if `T` and `U` have the same size and alignment.",
        "suggest": "Rust é€šå¸¸ä¸ä¿è¯ `Foo<T>` çš„å­—æ®µå…·æœ‰ä¸ `Foo<U>` ç›¸åŒçš„é¡ºåºï¼Œå³ä½¿ `T` å’Œ `U` å…·æœ‰ç›¸åŒçš„å¤§å°å’Œå¯¹é½æ–¹å¼ã€‚",
        "translate": ""
    },
    {
        "source": "Furthermore because any bit value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:",
        "suggest": "æ­¤å¤–ï¼Œç”±äºä»»ä½•ä½å€¼å¯¹äº `MaybeUninit<T>` éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œå› æ­¤ç¼–è¯‘å™¨æ— æ³•åº”ç”¨ non-zero/niche-filling ä¼˜åŒ–ï¼Œä»è€Œå¯èƒ½å¯¼è‡´æ›´å¤§çš„å¤§å°:",
        "translate": ""
    },
    {
        "source": "If `T` is FFI-safe, then so is `MaybeUninit<T>`.",
        "suggest": "å¦‚æœ `T` æ˜¯ FFI å®‰å…¨çš„ï¼Œåˆ™ `MaybeUninit<T>` ä¹Ÿæ˜¯å¦‚æ­¤ã€‚",
        "translate": ""
    },
    {
        "source": "While `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size, alignment, and ABI as `T`), this does *not* change any of the previous caveats.",
        "suggest": "è™½ç„¶ `MaybeUninit` æ˜¯ `#[repr(transparent)]` (è¡¨ç¤ºå®ƒä¿è¯ä¸ `T` ç›¸åŒçš„å¤§å°ï¼Œå¯¹é½æ–¹å¼å’Œ ABI)ï¼Œä½†æ˜¯è¿™ *ä¸ä¼š* æ›´æ”¹ä»»ä½•å…ˆå‰çš„è­¦å‘Šã€‚",
        "translate": ""
    },
    {
        "source": "and `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.",
        "suggest": "å’Œ `Option<MaybeUninit<T>>` å¯èƒ½ä»å…·æœ‰ä¸åŒçš„å¤§å°ï¼Œå¹¶ä¸”åŒ…å« `T` ç±»å‹çš„å­—æ®µçš„ç±»å‹çš„å¸ƒå±€ (å’Œå¤§å°) å¯èƒ½ä¸è¯¥å­—æ®µä¸º `MaybeUninit<T>` çš„æƒ…å†µä¸åŒã€‚",
        "translate": ""
    },
    {
        "source": "is a union type, and `#[repr(transparent)]` on unions is unstable (see [the tracking issue](https://github.com/rust-lang/rust/issues/60405)).",
        "suggest": "æ˜¯ä¸€ä¸ªæ˜¯è”åˆç±»å‹ï¼Œå¹¶ä¸” union ä¸Šçš„ `#[repr(transparent)]` æ˜¯ä¸ç¨³å®šçš„ (è¯·å‚è§ [è·Ÿè¸ªé—®é¢˜](https://github.com/rust-lang/rust/issues/60405))ã€‚",
        "translate": ""
    },
    {
        "source": "Over time, the exact guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not remain `#[repr(transparent)]`.",
        "suggest": "éšç€æ—¶é—´çš„æ¨ç§»ï¼Œå¯¹ union çš„ `#[repr(transparent)]` çš„ç¡®åˆ‡ä¿è¯å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå¹¶ä¸” `MaybeUninit` å¯èƒ½ä¼šæˆ–å¯èƒ½ä¸ä¼šä¿ç•™ `#[repr(transparent)]`ã€‚",
        "translate": ""
    },
    {
        "source": "That said, `MaybeUninit<T>` will *always* guarantee that it has the same size, alignment, and ABI as `T`;",
        "suggest": "å°±æ˜¯è¯´ï¼Œ`MaybeUninit<T>` å°†æ€»æ˜¯ä¿è¯å®ƒå…·æœ‰ä¸ `T` æœ‰ç›¸åŒçš„å¤§å°ã€å¯¹é½æ–¹å¼å’Œ ABI;",
        "translate": ""
    },
    {
        "source": "it's just that the way `MaybeUninit` implements that guarantee may evolve.",
        "suggest": "åªæ˜¯ `MaybeUninit` å®ç°ä¿è¯çš„æ–¹å¼å¯èƒ½ä¼šæ¼”å˜ã€‚",
        "translate": ""
    },
    {
        "source": "Lang item so we can wrap other types in it.",
        "suggest": "Lang é¡¹ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨å…¶ä¸­åŒ…è£…å…¶ä»–ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "This is useful for generators.",
        "suggest": "è¿™å¯¹äºç”Ÿæˆå™¨å¾ˆæœ‰ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Not calling `T::clone()`, we cannot know if we are initialized enough for that.",
        "suggest": "ä¸è°ƒç”¨ `T::clone()`ï¼Œæˆ‘ä»¬ä¸çŸ¥é“æˆ‘ä»¬æ˜¯å¦å·²è¶³å¤Ÿåˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "Creates a new `MaybeUninit<T>` initialized with the given value.",
        "suggest": "åˆ›å»ºä¸€ä¸ªä½¿ç”¨ç»™å®šå€¼åˆå§‹åŒ–çš„æ–° `MaybeUninit<T>`ã€‚",
        "translate": ""
    },
    {
        "source": "It is safe to call [`assume_init`] on the return value of this function.",
        "suggest": "åœ¨æ­¤å‡½æ•°çš„è¿”å›å€¼ä¸Šè°ƒç”¨ [`assume_init`] æ˜¯å®‰å…¨çš„ã€‚",
        "translate": ""
    },
    {
        "source": "Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.",
        "suggest": "æ³¨æ„ï¼Œä¸¢å¼ƒ `MaybeUninit<T>` æ°¸è¿œä¸ä¼šè°ƒç”¨ T çš„ä¸¢å¼ƒä»£ç ã€‚",
        "translate": ""
    },
    {
        "source": "It is your responsibility to make sure `T` gets dropped if it got initialized.",
        "suggest": "ç¡®ä¿ `T` åœ¨åˆå§‹åŒ–æ—¶è¢«ä¸¢å¼ƒæ˜¯æ‚¨çš„è´£ä»»ã€‚",
        "translate": ""
    },
    {
        "source": "Creates a new `MaybeUninit<T>` in an uninitialized state.",
        "suggest": "ä»¥æœªåˆå§‹åŒ–çš„çŠ¶æ€åˆ›å»ºä¸€ä¸ªæ–°çš„ `MaybeUninit<T>`ã€‚",
        "translate": ""
    },
    {
        "source": "See the [type-level documentation][MaybeUninit] for some examples.",
        "suggest": "æœ‰å…³ä¸€äº›ç¤ºä¾‹ï¼Œè¯·å‚è§ [type-level documentation][MaybeUninit]ã€‚",
        "translate": ""
    },
    {
        "source": "Create a new array of `MaybeUninit<T>` items, in an uninitialized state.",
        "suggest": "åœ¨æœªåˆå§‹åŒ–çŠ¶æ€ä¸‹åˆ›å»º `MaybeUninit<T>` é¡¹çš„æ–°æ•°ç»„ã€‚",
        "translate": ""
    },
    {
        "source": "in a future Rust version this method may become unnecessary when array literal syntax allows [repeating const expressions](https://github.com/rust-lang/rust/issues/49147).",
        "suggest": "åœ¨ future Rust ç‰ˆæœ¬ä¸­ï¼Œå½“æ•°ç»„å­—é¢é‡è¯­æ³•å…è®¸ [é‡å¤å¸¸é‡è¡¨è¾¾å¼](https://github.com/rust-lang/rust/issues/49147) æ—¶ï¼Œæ­¤æ–¹æ³•å¯èƒ½å˜å¾—ä¸å¿…è¦ã€‚",
        "translate": ""
    },
    {
        "source": "The example below could then use `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`.",
        "suggest": "ç„¶åï¼Œä¸‹é¢çš„ç¤ºä¾‹å¯ä»¥ä½¿ç”¨ `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`ã€‚",
        "translate": ""
    },
    {
        "source": "An uninitialized `[MaybeUninit<_>; LEN]` is valid.",
        "suggest": "æœªåˆå§‹åŒ–çš„ `[MaybeUninit<_>; LEN]` æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being filled with `0` bytes.",
        "suggest": "åœ¨æœªåˆå§‹åŒ–çŠ¶æ€ä¸‹åˆ›å»ºæ–°çš„ `MaybeUninit<T>`ï¼Œå¹¶ç”¨ `0` å­—èŠ‚å¡«å……å†…å­˜ã€‚",
        "translate": ""
    },
    {
        "source": "It depends on `T` whether that already makes for proper initialization.",
        "suggest": "å–å†³äº `T` æ˜¯å¦å·²ç»è¿›è¡Œäº†æ­£ç¡®çš„åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "For example, `MaybeUninit<usize>::zeroed()` is initialized, but `MaybeUninit<&'static i32>::zeroed()` is not because references must not be null.",
        "suggest": "ä¾‹å¦‚ï¼Œåˆå§‹åŒ– `MaybeUninit<usize>::zeroed()`ï¼Œä½†ä¸åˆå§‹åŒ– `MaybeUninit<&'static i32>::zeroed()`ï¼Œå› ä¸ºå¼•ç”¨ä¸èƒ½ä¸ºç©ºã€‚",
        "translate": ""
    },
    {
        "source": "Correct usage of this function: initializing a struct with zero, where all fields of the struct can hold the bit-pattern 0 as a valid value.",
        "suggest": "æ­¤å‡½æ•°çš„æ­£ç¡®ç”¨æ³•: ç”¨é›¶åˆå§‹åŒ–ç»“æ„ä½“ï¼Œå…¶ä¸­ç»“æ„ä½“çš„æ‰€æœ‰å­—æ®µéƒ½å¯ä»¥å°†ä½æ¨¡å¼ 0 ä¿ç•™ä¸ºæœ‰æ•ˆå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage of this function: calling `x.zeroed().assume_init()` when `0` is not a valid bit-pattern for the type:",
        "suggest": "è¯¥å‡½æ•°çš„ *é”™è¯¯* ç”¨æ³•: å½“ `0` ä¸æ˜¯è¯¥ç±»å‹çš„æœ‰æ•ˆä½æ¨¡å¼æ—¶ï¼Œè°ƒç”¨ `x.zeroed().assume_init()`:",
        "translate": ""
    },
    {
        "source": "`u.as_mut_ptr()` points to allocated memory.",
        "suggest": "`u.as_mut_ptr()` æŒ‡å‘åˆ†é…çš„å†…å­˜ã€‚",
        "translate": ""
    },
    {
        "source": "Sets the value of the `MaybeUninit<T>`.",
        "suggest": "è®¾ç½® `MaybeUninit<T>` çš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This overwrites any previous value without dropping it, so be careful not to use this twice unless you want to skip running the destructor.",
        "suggest": "è¿™å°†è¦†ç›–ä»»ä½•å…ˆå‰çš„å€¼è€Œä¸å°†å…¶ä¸¢å¼ƒï¼Œå› æ­¤è¯·æ³¨æ„ä¸è¦é‡å¤ä½¿ç”¨æ­¤ä¸¤æ¬¡ï¼Œé™¤éæ‚¨è¦è·³è¿‡è¿è¡Œææ„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "For your convenience, this also returns a mutable reference to the (now safely initialized) contents of `self`.",
        "suggest": "ä¸ºäº†æ‚¨çš„æ–¹ä¾¿ï¼Œè¿™ä¹Ÿå°† `self` çš„å†…å®¹ (ç°åœ¨å·²å®‰å…¨åˆå§‹åŒ–) è¿”å›å˜é‡å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "We just initialized this value.",
        "suggest": "æˆ‘ä»¬åªæ˜¯åˆå§‹åŒ–äº†è¿™ä¸ªå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Gets a pointer to the contained value.",
        "suggest": "è·å–æŒ‡å‘åŒ…å«å€¼çš„æŒ‡é’ˆã€‚",
        "translate": ""
    },
    {
        "source": "Reading from this pointer or turning it into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.",
        "suggest": "é™¤éåˆå§‹åŒ– `MaybeUninit<T>`ï¼Œå¦åˆ™ä»è¯¥æŒ‡é’ˆè¯»å–æˆ–å°†å…¶è½¬æ¢ä¸º quot æ˜¯æœªå®šä¹‰çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "Writing to memory that this pointer (non-transitively) points to is undefined behavior (except inside an `UnsafeCell<T>`).",
        "suggest": "å†™å…¥è¯¥æŒ‡é’ˆ (non-transitively) æŒ‡å‘çš„å†…å­˜æ˜¯æœªå®šä¹‰çš„è¡Œä¸º (`UnsafeCell<T>` å†…éƒ¨é™¤å¤–)ã€‚",
        "translate": ""
    },
    {
        "source": "Correct usage of this method:",
        "suggest": "æ­£ç¡®ä½¿ç”¨æ­¤æ–¹æ³•:",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage of this method:",
        "suggest": "è¿™ä¸ªæ–¹æ³•çš„é”™è¯¯ç”¨æ³•:",
        "translate": ""
    },
    {
        "source": "(Notice that the rules around references to uninitialized data are not finalized yet, but until they are, it is advisable to avoid them.)",
        "suggest": "(è¯·æ³¨æ„ï¼Œå›´ç»•æœªåˆå§‹åŒ–æ•°æ®å¼•ç”¨çš„è§„åˆ™å°šæœªæœ€ç»ˆç¡®å®šï¼Œä½†æ˜¯é™¤éè¢«ç¡®å®šï¼Œå¦åˆ™å»ºè®®é¿å…ä½¿ç”¨å®ƒä»¬ã€‚)",
        "translate": ""
    },
    {
        "source": "and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.",
        "suggest": "å’Œ `ManuallyDrop` éƒ½æ˜¯ `repr(transparent)`ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¼ºåˆ¶è½¬æ¢æŒ‡é’ˆã€‚",
        "translate": ""
    },
    {
        "source": "Gets a mutable pointer to the contained value.",
        "suggest": "è·å–æŒ‡å‘åŒ…å«å€¼çš„å¯å˜æŒ‡é’ˆã€‚",
        "translate": ""
    },
    {
        "source": "Extracts the value from the `MaybeUninit<T>` container.",
        "suggest": "ä» `MaybeUninit<T>` å®¹å™¨ä¸­æå–å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This is a great way to ensure that the data will get dropped, because the resulting `T` is subject to the usual drop handling.",
        "suggest": "è¿™æ˜¯ç¡®ä¿æ•°æ®å°†è¢«ä¸¢å¼ƒçš„å¥½æ–¹æ³•ï¼Œå› ä¸ºç”Ÿæˆçš„ `T` å—åˆ°é€šå¸¸çš„ä¸¢å¼ƒå¤„ç†ã€‚",
        "translate": ""
    },
    {
        "source": "It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state.",
        "suggest": "å–å†³äºè°ƒç”¨æ–¹ï¼Œä»¥ç¡®ä¿ `MaybeUninit<T>` ç¡®å®å¤„äºåˆå§‹åŒ–çŠ¶æ€ã€‚",
        "translate": ""
    },
    {
        "source": "The [type-level documentation][inv] contains more information about this initialization invariant.",
        "suggest": "[type-level documentation][inv] åŒ…å«æœ‰å…³æ­¤åˆå§‹åŒ–ä¸å¯å˜å˜é‡çš„æ›´å¤šä¿¡æ¯ã€‚",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` is initialized.",
        "suggest": "è°ƒç”¨è€…å¿…é¡»ä¿è¯ `self` å·²åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "This also means that `self` must be a `value` variant.",
        "suggest": "è¿™ä¹Ÿæ„å‘³ç€ `self` å¿…é¡»æ˜¯ `value` æˆå‘˜ã€‚",
        "translate": ""
    },
    {
        "source": "Reads the value from the `MaybeUninit<T>` container.",
        "suggest": "ä» `MaybeUninit<T>` å®¹å™¨ä¸­è¯»å–å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "The resulting `T` is subject to the usual drop handling.",
        "suggest": "ç»“æœ `T` å—é€šå¸¸çš„ drop å¤„ç†å½±å“ã€‚",
        "translate": ""
    },
    {
        "source": "Whenever possible, it is preferable to use [`assume_init`] instead, which prevents duplicating the content of the `MaybeUninit<T>`.",
        "suggest": "åªè¦æœ‰å¯èƒ½ï¼Œæœ€å¥½æ”¹ç”¨ [`assume_init`]ï¼Œè¿™æ ·å¯ä»¥é˜²æ­¢é‡å¤ `MaybeUninit<T>` çš„å†…å®¹ã€‚",
        "translate": ""
    },
    {
        "source": "Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`.",
        "suggest": "è€Œä¸”ï¼Œè¿™ä¼šå°†ç›¸åŒæ•°æ®çš„å‰¯æœ¬ç•™åœ¨ `MaybeUninit<T>` ä¸­ã€‚",
        "translate": ""
    },
    {
        "source": "When using multiple copies of the data (by calling `assume_init_read` multiple times, or first calling `assume_init_read` and then [`assume_init`]), it is your responsibility to ensure that that data may indeed be duplicated.",
        "suggest": "ä½¿ç”¨æ•°æ®çš„å¤šä¸ªå‰¯æœ¬æ—¶ (é€šè¿‡å¤šæ¬¡è°ƒç”¨ `assume_init_read`ï¼Œæˆ–å…ˆè°ƒç”¨ `assume_init_read`ï¼Œç„¶åå†è°ƒç”¨ [`assume_init`])ï¼Œæ‚¨æœ‰è´£ä»»ç¡®ä¿ç¡®å®å¯ä»¥å¤åˆ¶æ•°æ®ã€‚",
        "translate": ""
    },
    {
        "source": "Reading from `self.as_ptr()` is safe since `self` should be initialized.",
        "suggest": "ä» `self.as_ptr()` è¯»å–æ•°æ®æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºåº”è¯¥åˆå§‹åŒ– `self`ã€‚",
        "translate": ""
    },
    {
        "source": "Drops the contained value in place.",
        "suggest": "å°†åŒ…å«çš„å€¼æ”¾ç½®åˆ°ä½ã€‚",
        "translate": ""
    },
    {
        "source": "If you have ownership of the `MaybeUninit`, you can use [`assume_init`] instead.",
        "suggest": "å¦‚æœæ‚¨æ‹¥æœ‰ `MaybeUninit` çš„æ‰€æœ‰æƒï¼Œåˆ™å¯ä»¥æ”¹ç”¨ [`assume_init`]ã€‚",
        "translate": ""
    },
    {
        "source": "On top of that, all additional invariants of the type `T` must be satisfied, as the `Drop` implementation of `T` (or its members) may rely on this.",
        "suggest": "æœ€é‡è¦çš„æ˜¯ï¼Œå¿…é¡»æ»¡è¶³ç±»å‹ `T` çš„æ‰€æœ‰å…¶ä»–ä¸å¯å˜å˜é‡ï¼Œå› ä¸º `T` (æˆ–å…¶æˆå‘˜) çš„ `Drop` å®ç°å¯èƒ½ä¾èµ–äºæ­¤ã€‚",
        "translate": ""
    },
    {
        "source": "Dropping such a `Vec<T>` however will cause undefined behaviour.",
        "suggest": "ä½†æ˜¯ï¼Œä¸¢å¼ƒè¿™æ ·çš„ `Vec<T>` ä¼šå¯¼è‡´ä¸ç¡®å®šçš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` is initialized and satisfies all invariants of `T`.",
        "suggest": "è°ƒç”¨è€…å¿…é¡»ä¿è¯ `self` å·²åˆå§‹åŒ–å¹¶ä¸”æ»¡è¶³ `T` çš„æ‰€æœ‰ä¸å¯å˜å˜é‡ã€‚",
        "translate": ""
    },
    {
        "source": "Dropping the value in place is safe if that is the case.",
        "suggest": "åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°†å€¼æ”¾åˆ°é€‚å½“çš„ä½ç½®æ˜¯å®‰å…¨çš„ã€‚",
        "translate": ""
    },
    {
        "source": "Gets a shared reference to the contained value.",
        "suggest": "è·å–å¯¹åŒ…å«å€¼çš„å…±äº«å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "This can be useful when we want to access a `MaybeUninit` that has been initialized but don't have ownership of the `MaybeUninit` (preventing the use of `.assume_init()`).",
        "suggest": "å½“æˆ‘ä»¬è¦è®¿é—®å·²åˆå§‹åŒ–ä½†æ²¡æœ‰ `MaybeUninit` æ‰€æœ‰æƒ (é˜²æ­¢ä½¿ç”¨ `.assume_init()`) çš„ `MaybeUninit` æ—¶ï¼Œè¿™å¾ˆæœ‰ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Calling this when the content is not yet fully initialized causes undefined behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state.",
        "suggest": "åœ¨å†…å®¹å°šæœªå®Œå…¨åˆå§‹åŒ–æ—¶è°ƒç”¨æ­¤æ–¹æ³•ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸º: å–å†³äºè°ƒç”¨æ–¹ï¼Œä»¥ç¡®ä¿ `MaybeUninit<T>` ç¡®å®å¤„äºåˆå§‹åŒ–çŠ¶æ€ã€‚",
        "translate": ""
    },
    {
        "source": "*Incorrect* usages of this method:",
        "suggest": "è¿™ä¸ªæ–¹æ³•çš„é”™è¯¯ç”¨æ³•:",
        "translate": ""
    },
    {
        "source": "Gets a mutable (unique) reference to the contained value.",
        "suggest": "è·å–æ‰€åŒ…å«å€¼çš„å¯å˜ (unique) å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "For instance, `.assume_init_mut()` cannot be used to initialize a `MaybeUninit`.",
        "suggest": "ä¾‹å¦‚ï¼Œ`.assume_init_mut()` ä¸èƒ½ç”¨äºåˆå§‹åŒ– `MaybeUninit`ã€‚",
        "translate": ""
    },
    {
        "source": "You cannot use `.assume_init_mut()` to initialize a value:",
        "suggest": "æ‚¨ä¸èƒ½ä½¿ç”¨ `.assume_init_mut()` åˆå§‹åŒ–å€¼:",
        "translate": ""
    },
    {
        "source": "For instance, you cannot [`Read`] into an uninitialized buffer:",
        "suggest": "ä¾‹å¦‚ï¼Œæ‚¨ä¸èƒ½ [`Read`] è¿›å…¥æœªåˆå§‹åŒ–çš„ç¼“å†²åŒº:",
        "translate": ""
    },
    {
        "source": "Nor can you use direct field access to do field-by-field gradual initialization:",
        "suggest": "ä¹Ÿä¸èƒ½ä½¿ç”¨ç›´æ¥å­—æ®µè®¿é—®æ¥è¿›è¡Œé€å­—æ®µé€æ­¥åˆå§‹åŒ–:",
        "translate": ""
    },
    {
        "source": "We currently rely on the above being incorrect, i.e., we have references to uninitialized data (e.g., in `libcore/fmt/float.rs`).",
        "suggest": "å½“å‰ï¼Œæˆ‘ä»¬ä¾èµ–äºä¸Šè¿°é”™è¯¯ä¿¡æ¯ï¼Œå³ï¼Œæˆ‘ä»¬å¯¹æœªåˆå§‹åŒ–çš„æ•°æ® (ä¾‹å¦‚ï¼Œåœ¨ `libcore/fmt/float.rs` ä¸­) è¿›è¡Œäº†å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "We should make a final decision about the rules before stabilization.",
        "suggest": "åœ¨ç¨³å®šä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥å¯¹è§„åˆ™åšå‡ºæœ€åå†³å®šã€‚",
        "translate": ""
    },
    {
        "source": "Extracts the values from an array of `MaybeUninit` containers.",
        "suggest": "ä» `MaybeUninit` å®¹å™¨æ•°ç»„ä¸­æå–å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "It is up to the caller to guarantee that all elements of the array are in an initialized state.",
        "suggest": "è°ƒç”¨æ–¹æœ‰è´£ä»»ä¿è¯æ•°ç»„çš„æ‰€æœ‰å…ƒç´ éƒ½å¤„äºåˆå§‹åŒ–çŠ¶æ€ã€‚",
        "translate": ""
    },
    {
        "source": "The caller guarantees that all elements of the array are initialized",
        "suggest": "è°ƒç”¨è€…ä¿è¯æ•°ç»„çš„æ‰€æœ‰å…ƒç´ éƒ½å·²åˆå§‹åŒ–",
        "translate": ""
    },
    {
        "source": "and T are guaranteed to have the same layout",
        "suggest": "å’Œ T ä¿è¯å…·æœ‰ç›¸åŒçš„å¸ƒå±€",
        "translate": ""
    },
    {
        "source": "MaybeUnint does not drop, so there are no double-frees And thus the conversion is safe",
        "suggest": "ä¹Ÿè®¸ Unint ä¸ä¼šä¸¢å¼ƒï¼Œæ‰€ä»¥æ²¡æœ‰åŒé‡é‡Šæ”¾ï¼Œå› æ­¤è½¬æ¢æ˜¯å®‰å…¨çš„",
        "translate": ""
    },
    {
        "source": "Assuming all the elements are initialized, get a slice to them.",
        "suggest": "å‡è®¾æ‰€æœ‰å…ƒç´ éƒ½å·²åˆå§‹åŒ–ï¼Œè¯·å¯¹å…¶è¿›è¡Œåˆ‡ç‰‡ã€‚",
        "translate": ""
    },
    {
        "source": "It is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state.",
        "suggest": "å–å†³äºè°ƒç”¨æ–¹ï¼Œä»¥ç¡®ä¿ `MaybeUninit<T>` å…ƒç´ ç¡®å®å¤„äºåˆå§‹åŒ–çŠ¶æ€ã€‚",
        "translate": ""
    },
    {
        "source": "Calling this when the content is not yet fully initialized causes undefined behavior.",
        "suggest": "åœ¨å†…å®¹å°šæœªå®Œå…¨åˆå§‹åŒ–æ—¶è°ƒç”¨æ­¤æ–¹æ³•ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚",
        "translate": ""
    },
    {
        "source": "See [`assume_init_ref`] for more details and examples.",
        "suggest": "æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯å’Œç¤ºä¾‹ï¼Œè¯·å‚è§ [`assume_init_ref`]ã€‚",
        "translate": ""
    },
    {
        "source": "casting slice to a `*const [T]` is safe since the caller guarantees that `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.",
        "suggest": "å°†åˆ‡ç‰‡è½¬æ¢ä¸º `*const [T]` æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºè°ƒç”¨æ–¹ä¿è¯å·²åˆå§‹åŒ– `slice`ï¼Œå¹¶ä¿è¯ `MaybeUninit` å…·æœ‰ä¸ `T` ç›¸åŒçš„å¸ƒå±€ã€‚",
        "translate": ""
    },
    {
        "source": "The pointer obtained is valid since it refers to memory owned by `slice` which is a reference and thus guaranteed to be valid for reads.",
        "suggest": "æ‰€è·å¾—çš„æŒ‡é’ˆæ˜¯æœ‰æ•ˆçš„ï¼Œå› ä¸ºå®ƒå¼•ç”¨ `slice` æ‹¥æœ‰çš„å†…å­˜ï¼Œè¯¥å†…å­˜æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œå› æ­¤å¯ä»¥ä¿è¯å¯¹è¯»å–æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "Assuming all the elements are initialized, get a mutable slice to them.",
        "suggest": "å‡è®¾æ‰€æœ‰å…ƒç´ éƒ½å·²åˆå§‹åŒ–ï¼Œè¯·ä¸ºå…¶è·å–å¯å˜åˆ‡ç‰‡ã€‚",
        "translate": ""
    },
    {
        "source": "See [`assume_init_mut`] for more details and examples.",
        "suggest": "æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯å’Œç¤ºä¾‹ï¼Œè¯·å‚è§ [`assume_init_mut`]ã€‚",
        "translate": ""
    },
    {
        "source": "similar to safety notes for `slice_get_ref`, but we have a mutable reference which is also guaranteed to be valid for writes.",
        "suggest": "ç±»ä¼¼äº `slice_get_ref` çš„å®‰å…¨è¯´æ˜ï¼Œä½†æˆ‘ä»¬æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œä¹Ÿä¿è¯å¯¹å†™æ“ä½œæœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "Gets a pointer to the first element of the array.",
        "suggest": "è·å–ä¸€ä¸ªæŒ‡å‘æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆã€‚",
        "translate": ""
    },
    {
        "source": "Gets a mutable pointer to the first element of the array.",
        "suggest": "è·å–æŒ‡å‘æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¯å˜æŒ‡é’ˆã€‚",
        "translate": ""
    },
    {
        "source": "Copies the elements from `src` to `this`, returning a mutable reference to the now initalized contents of `this`.",
        "suggest": "å°†å…ƒç´ ä» `src` å¤åˆ¶åˆ° `this`ï¼Œå¹¶å°†å˜é‡å¼•ç”¨è¿”å›åˆ° `this` çš„ç°åœ¨åˆå§‹åŒ–çš„å†…å®¹ã€‚",
        "translate": ""
    },
    {
        "source": "If `T` does not implement `Copy`, use [`write_slice_cloned`]",
        "suggest": "å¦‚æœ `T` æœªå®ç° `Copy`ï¼Œè¯·ä½¿ç”¨ [`write_slice_cloned`]",
        "translate": ""
    },
    {
        "source": "This is similar to [`slice::copy_from_slice`].",
        "suggest": "è¿™ç±»ä¼¼äº [`slice::copy_from_slice`]ã€‚",
        "translate": ""
    },
    {
        "source": "This function will panic if the two slices have different lengths.",
        "suggest": "å¦‚æœä¸¤ä¸ªåˆ‡ç‰‡çš„é•¿åº¦ä¸åŒï¼Œåˆ™æ­¤å‡½æ•°å°†ä¸º panicã€‚",
        "translate": ""
    },
    {
        "source": "&[T] and &[MaybeUninit<T>] have the same layout",
        "suggest": "&[T] and &[MaybeUninit<T>] å…·æœ‰ç›¸åŒçš„å¸ƒå±€",
        "translate": ""
    },
    {
        "source": "Valid elements have just been copied into `this` so it is initalized",
        "suggest": "æœ‰æ•ˆå…ƒç´ åˆšåˆšè¢«å¤åˆ¶åˆ° `this` ä¸­ï¼Œå› æ­¤è¢«åˆå§‹åŒ–",
        "translate": ""
    },
    {
        "source": "Clones the elements from `src` to `this`, returning a mutable reference to the now initalized contents of `this`.",
        "suggest": "å°†å…ƒç´ ä» `src` å…‹éš†åˆ° `this`ï¼Œå°†å˜é‡å¼•ç”¨è¿”å›åˆ° `this` çš„ç°åœ¨åˆå§‹åŒ–çš„å†…å®¹ã€‚",
        "translate": ""
    },
    {
        "source": "Any already initalized elements will not be dropped.",
        "suggest": "ä»»ä½•å·²ç»åˆå§‹åŒ–çš„å…ƒç´ éƒ½ä¸ä¼šè¢«ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "If `T` implements `Copy`, use [`write_slice`]",
        "suggest": "å¦‚æœ `T` å®ç° `Copy`ï¼Œè¯·ä½¿ç”¨ [`write_slice`]",
        "translate": ""
    },
    {
        "source": "This is similar to [`slice::clone_from_slice`] but does not drop existing elements.",
        "suggest": "è¿™ç±»ä¼¼äº [`slice::clone_from_slice`]ï¼Œä½†ä¸ä¼šä¸¢å¼ƒç°æœ‰å…ƒç´ ã€‚",
        "translate": ""
    },
    {
        "source": "This function will panic if the two slices have different lengths, or if the implementation of `Clone` panics.",
        "suggest": "å¦‚æœä¸¤ä¸ªåˆ‡ç‰‡çš„é•¿åº¦ä¸åŒï¼Œæˆ–è€… `Clone` panics çš„å®ç°ï¼Œåˆ™æ­¤å‡½æ•°å°†ä¸º panicã€‚",
        "translate": ""
    },
    {
        "source": "If there is a panic, the already cloned elements will be dropped.",
        "suggest": "å¦‚æœå­˜åœ¨ panicï¼Œå°†ä¸¢å¼ƒå·²ç»å…‹éš†çš„å…ƒç´ ã€‚",
        "translate": ""
    },
    {
        "source": "unlike copy_from_slice this does not call clone_from_slice on the slice this is because `MaybeUninit<T: Clone>` does not implement Clone.",
        "suggest": "ä¸ copy_from_slice ä¸åŒï¼Œè¿™ä¸ä¼šåœ¨åˆ‡ç‰‡ä¸Šè°ƒç”¨ clone_from_sliceï¼Œè¿™æ˜¯å› ä¸º `MaybeUninit<T: Clone>` æ²¡æœ‰å®ç° Cloneã€‚",
        "translate": ""
    },
    {
        "source": "this raw slice will contain only initialized objects that's why, it is allowed to drop it.",
        "suggest": "æ­¤åŸå§‹åˆ‡ç‰‡å°†ä»…åŒ…å«åˆå§‹åŒ–çš„å¯¹è±¡ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆå…è®¸å°†å…¶ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "We need to explicitly slice them to the same length for bounds checking to be elided, and the optimizer will generate memcpy for simple cases (for example T = u8).",
        "suggest": "æˆ‘ä»¬éœ€è¦æ˜¾å¼åœ°å°†å®ƒä»¬åˆ‡æˆç›¸åŒçš„é•¿åº¦ï¼Œä»¥æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ï¼Œä¼˜åŒ–å™¨å°†ä¸ºç®€å•æƒ…å†µç”Ÿæˆ memcpy (ä¾‹å¦‚ T= u8)ã€‚",
        "translate": ""
    },
    {
        "source": "guard is needed b/c panic might happen during a clone",
        "suggest": "éœ€è¦ä¿æŠ¤ b/c åœ¨å…‹éš†è¿‡ç¨‹ä¸­å¯èƒ½ä¼šå‘ç”Ÿ panic",
        "translate": ""
    },
    {
        "source": "Valid elements have just been written into `this` so it is initalized",
        "suggest": "æœ‰æ•ˆå…ƒç´ åˆšåˆšè¢«å†™å…¥ `this`ï¼Œæ‰€ä»¥å®ƒæ˜¯åˆå§‹åŒ–çš„",
        "translate": ""
    },
    {
        "source": "Build a `String` using the contents of `v`",
        "suggest": "ä½¿ç”¨ `v` çš„å†…å®¹æ„å»º `String`",
        "translate": ""
    },
    {
        "source": "leak `v` because its memory is now managed by `s`",
        "suggest": "æ³„æ¼ `v`ï¼Œå› ä¸ºå®ƒçš„å†…å­˜ç°åœ¨ç”± `s` ç®¡ç†",
        "translate": ""
    },
    {
        "source": "ERROR - v is invalid and must not be passed to a function",
        "suggest": "é”™è¯¯ - v æ— æ•ˆï¼Œä¸å¾—å°†å…¶ä¼ é€’ç»™å‡½æ•°",
        "translate": ""
    },
    {
        "source": "is implicitly dropped and its memory deallocated.",
        "suggest": "è¢«éšå¼ä¸¢å¼ƒï¼Œå¹¶ä¸”å…¶å†…å­˜è¢«é‡Šæ”¾ã€‚",
        "translate": ""
    },
    {
        "source": "Before we disassemble `v` into its raw parts, make sure it does not get dropped!",
        "suggest": "åœ¨å°† `v` æ‹†è§£ä¸ºåŸå§‹é›¶ä»¶ä¹‹å‰ï¼Œè¯·ç¡®ä¿å®ƒä¸ä¼šä¸¢å¼ƒæ‰!",
        "translate": ""
    },
    {
        "source": "Now disassemble `v`.",
        "suggest": "ç°åœ¨æ‹†å¸ `v`ã€‚",
        "translate": ""
    },
    {
        "source": "These operations cannot panic, so there cannot be a leak.",
        "suggest": "è¿™äº›æ“ä½œä¸èƒ½ panicï¼Œå› æ­¤ä¸ä¼šæœ‰æ³„æ¼ã€‚",
        "translate": ""
    },
    {
        "source": "Finally, build a `String`.",
        "suggest": "æœ€åï¼Œæ„å»ºä¸€ä¸ª `String`ã€‚",
        "translate": ""
    },
    {
        "source": "Some primitives",
        "suggest": "ä¸€äº›åŸè¯­",
        "translate": ""
    },
    {
        "source": "Some arrays",
        "suggest": "ä¸€äº›æ•°ç»„",
        "translate": ""
    },
    {
        "source": "Pointer size equality",
        "suggest": "æŒ‡é’ˆå¤§å°ç›¸ç­‰",
        "translate": ""
    },
    {
        "source": "The size of the first field is 1, so add 1 to the size.",
        "suggest": "ç¬¬ä¸€ä¸ªå­—æ®µçš„å¤§å°ä¸º 1ï¼Œå› æ­¤è¯·åœ¨å¤§å°ä¸ŠåŠ  1ã€‚",
        "translate": ""
    },
    {
        "source": "Size is 1.",
        "suggest": "å¤§å°ä¸º 1ã€‚",
        "translate": ""
    },
    {
        "source": "The alignment of the second field is 2, so add 1 to the size for padding.",
        "suggest": "ç¬¬äºŒä¸ªå­—æ®µçš„å¯¹é½æ–¹å¼ä¸º 2ï¼Œå› æ­¤åœ¨å¡«å……å¤§å°ä¸ŠåŠ  1ã€‚",
        "translate": ""
    },
    {
        "source": "Size is 2.",
        "suggest": "å¤§å°ä¸º 2ã€‚",
        "translate": ""
    },
    {
        "source": "The size of the second field is 2, so add 2 to the size.",
        "suggest": "ç¬¬äºŒä¸ªå­—æ®µçš„å¤§å°ä¸º 2ï¼Œå› æ­¤å°†å¤§å°åŠ  2ã€‚",
        "translate": ""
    },
    {
        "source": "Size is 4.",
        "suggest": "å¤§å°ä¸º 4ã€‚",
        "translate": ""
    },
    {
        "source": "The alignment of the third field is 1, so add 0 to the size for padding.",
        "suggest": "ç¬¬ä¸‰ä¸ªå­—æ®µçš„å¯¹é½æ–¹å¼ä¸º 1ï¼Œå› æ­¤è¯·åœ¨å¡«å……å¤§å°ä¸ŠåŠ ä¸Š 0ã€‚",
        "translate": ""
    },
    {
        "source": "The size of the third field is 1, so add 1 to the size.",
        "suggest": "ç¬¬ä¸‰ä¸ªå­—æ®µçš„å¤§å°ä¸º 1ï¼Œå› æ­¤è¯·åœ¨å¤§å°ä¸ŠåŠ  1ã€‚",
        "translate": ""
    },
    {
        "source": "Size is 5.",
        "suggest": "å¤§å°ä¸º 5ã€‚",
        "translate": ""
    },
    {
        "source": "Finally, the alignment of the struct is 2 (because the largest alignment amongst its fields is 2), so add 1 to the size for padding.",
        "suggest": "æœ€åï¼Œç»“æ„ä½“çš„å¯¹é½æ–¹å¼ä¸º 2 (å› ä¸ºå…¶å­—æ®µä¹‹é—´çš„æœ€å¤§å¯¹é½æ–¹å¼ä¸º 2)ï¼Œæ‰€ä»¥åœ¨å¡«å……çš„å¤§å°ä¸ŠåŠ  1ã€‚",
        "translate": ""
    },
    {
        "source": "Size is 6.",
        "suggest": "å¤§å°ä¸º 6ã€‚",
        "translate": ""
    },
    {
        "source": "Tuple structs follow the same rules.",
        "suggest": "å…ƒç»„ç»“æ„ä½“éµå¾ªç›¸åŒçš„è§„åˆ™ã€‚",
        "translate": ""
    },
    {
        "source": "Note that reordering the fields can lower the size.",
        "suggest": "è¯·æ³¨æ„ï¼Œå¯¹å­—æ®µé‡æ–°æ’åºå¯ä»¥å‡å°å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "We can remove both padding bytes by putting `third` before `second`.",
        "suggest": "æˆ‘ä»¬å¯ä»¥é€šè¿‡å°† `third` æ”¾åœ¨ `second` ä¹‹å‰åˆ é™¤ä¸¤ä¸ªå¡«å……å­—èŠ‚ã€‚",
        "translate": ""
    },
    {
        "source": "Union size is the size of the largest field.",
        "suggest": "union çš„å¤§å°æ˜¯æœ€å¤§å­—æ®µçš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "drop the data",
        "suggest": "ä¸¢å¼ƒæ•°æ®",
        "translate": ""
    },
    {
        "source": "Undefined behavior!",
        "suggest": "æœªå®šä¹‰çš„è¡Œä¸º!",
        "translate": ""
    },
    {
        "source": "And again!",
        "suggest": "ç„¶åå†æ¬¡!",
        "translate": ""
    },
    {
        "source": "error: cannot move out of dereference of `&mut`-pointer",
        "suggest": "é”™è¯¯: æ— æ³•ç§»å‡º & mut-pointer æŒ‡é’ˆçš„è§£å¼•ç”¨",
        "translate": ""
    },
    {
        "source": "explicitly drop the vector",
        "suggest": "æ˜¾å¼ä¸¢å¼ƒ vector",
        "translate": ""
    },
    {
        "source": "relinquish the mutable borrow on this slot",
        "suggest": "æ”¾å¼ƒè¯¥æ’æ§½ä¸Šçš„å¯å˜å€Ÿç”¨",
        "translate": ""
    },
    {
        "source": "a copy of `x` is moved and dropped",
        "suggest": "`x` çš„å‰¯æœ¬å·²ç§»åŠ¨å¹¶ä¸¢å¼ƒ",
        "translate": ""
    },
    {
        "source": "a copy of `y` is moved and dropped",
        "suggest": "`y` çš„å‰¯æœ¬å·²ç§»åŠ¨å¹¶ä¸¢å¼ƒ",
        "translate": ""
    },
    {
        "source": "still available",
        "suggest": "ä»ç„¶å¯ç”¨",
        "translate": ""
    },
    {
        "source": "Copy the data from 'foo_array' and treat it as a 'Foo'",
        "suggest": "ä» 'foo_array' å¤åˆ¶æ•°æ®å¹¶å°†å…¶è§†ä¸º 'Foo'",
        "translate": ""
    },
    {
        "source": "Modify the copied data",
        "suggest": "ä¿®æ”¹å¤åˆ¶çš„æ•°æ®",
        "translate": ""
    },
    {
        "source": "The contents of 'foo_array' should not have changed",
        "suggest": "'foo_array' çš„å†…å®¹ä¸åº”æ›´æ”¹",
        "translate": ""
    },
    {
        "source": "Basic functions for dealing with memory.",
        "suggest": "å¤„ç†å†…å­˜çš„åŸºæœ¬å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This module contains functions for querying the size and alignment of types, initializing and manipulating memory.",
        "suggest": "è¯¥æ¨¡å—åŒ…å«ç”¨äºæŸ¥è¯¢ç±»å‹çš„å¤§å°å’Œå¯¹é½ï¼Œåˆå§‹åŒ–å’Œæ“ä½œå†…å­˜çš„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Takes ownership and \"forgets\" about the value **without running its destructor**.",
        "suggest": "åœ¨ä¸è¿è¡Œå…¶ææ„å‡½æ•° **çš„æƒ…å†µä¸‹ï¼Œè·å–æ‰€æœ‰æƒå’Œ \"forgets\" å€¼**ã€‚",
        "translate": ""
    },
    {
        "source": "Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state.",
        "suggest": "è¯¥å€¼ç®¡ç†çš„ä»»ä½•èµ„æº (ä¾‹å¦‚å †å†…å­˜æˆ–æ–‡ä»¶å¥æŸ„) å°†æ°¸è¿œå¤„äºæ— æ³•è®¿é—®çš„çŠ¶æ€ã€‚",
        "translate": ""
    },
    {
        "source": "However, it does not guarantee that pointers to this memory will remain valid.",
        "suggest": "ä½†æ˜¯ï¼Œå®ƒä¸èƒ½ä¿è¯æŒ‡å‘è¯¥å†…å­˜çš„æŒ‡é’ˆå°†ä¿æŒæœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "If you want to leak memory, see [`Box::leak`].",
        "suggest": "å¦‚æœè¦æ³„æ¼å†…å­˜ï¼Œè¯·å‚è§ [`Box::leak`]ã€‚",
        "translate": ""
    },
    {
        "source": "If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].",
        "suggest": "å¦‚æœè¦è·å–å†…å­˜çš„è£¸æŒ‡é’ˆï¼Œè¯·å‚è§ [`Box::into_raw`]ã€‚",
        "translate": ""
    },
    {
        "source": "If you want to dispose of a value properly, running its destructor, see [`mem::drop`].",
        "suggest": "å¦‚æœè¦æ­£ç¡®å¤„ç†æŸä¸ªå€¼ï¼Œè¯·è¿è¡Œå…¶ææ„å‡½æ•°ï¼Œè¯·å‚è§ [`mem::drop`]ã€‚",
        "translate": ""
    },
    {
        "source": "is not marked as `unsafe`, because Rust's safety guarantees do not include a guarantee that destructors will always run.",
        "suggest": "æœªå°†å…¶æ ‡è®°ä¸º `unsafe`ï¼Œå› ä¸º Rust çš„å®‰å…¨ä¿è¯ä¸åŒ…æ‹¬ææ„å‡½æ•°å°†å§‹ç»ˆè¿è¡Œçš„ä¿è¯ã€‚",
        "translate": ""
    },
    {
        "source": "For example, a program can create a reference cycle using [`Rc`][rc], or call [`process::exit`][exit] to exit without running destructors.",
        "suggest": "ä¾‹å¦‚ï¼Œç¨‹åºå¯ä»¥ä½¿ç”¨ [`Rc`][rc] åˆ›å»ºå¼•ç”¨å¾ªç¯ï¼Œæˆ–è°ƒç”¨ [`process::exit`][exit] é€€å‡ºè€Œä¸è¿è¡Œææ„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Thus, allowing `mem::forget` from safe code does not fundamentally change Rust's safety guarantees.",
        "suggest": "å› æ­¤ï¼Œä»å®‰å…¨ä»£ç å…è®¸ `mem::forget` ä¸ä¼šä»æ ¹æœ¬ä¸Šæ”¹å˜ Rust çš„å®‰å…¨ä¿è¯ã€‚",
        "translate": ""
    },
    {
        "source": "That said, leaking resources such as memory or I/O objects is usually undesirable.",
        "suggest": "ä¹Ÿå°±æ˜¯è¯´ï¼Œé€šå¸¸ä¸å¸Œæœ›æ³„æ¼è¯¸å¦‚å†…å­˜æˆ– I/O å¯¹è±¡ä¹‹ç±»çš„èµ„æºã€‚",
        "translate": ""
    },
    {
        "source": "The need comes up in some specialized use cases for FFI or unsafe code, but even then, [`ManuallyDrop`] is typically preferred.",
        "suggest": "åœ¨æŸäº›ç‰¹æ®Šçš„ç”¨ä¾‹ä¸­ï¼Œå¯¹äº FFI æˆ–ä¸å®‰å…¨ä»£ç æå‡ºäº†éœ€æ±‚ï¼Œä½†å³ä½¿è¿™æ ·ï¼Œé€šå¸¸è¿˜æ˜¯é¦–é€‰ [`ManuallyDrop`]ã€‚",
        "translate": ""
    },
    {
        "source": "Because forgetting a value is allowed, any `unsafe` code you write must allow for this possibility.",
        "suggest": "å› ä¸ºå…è®¸å¿˜è®°ä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥æ‚¨ç¼–å†™çš„ä»»ä½• `unsafe` ä»£ç éƒ½å¿…é¡»å…è®¸è¿™ç§å¯èƒ½æ€§ã€‚",
        "translate": ""
    },
    {
        "source": "You cannot return a value and expect that the caller will necessarily run the value's destructor.",
        "suggest": "æ‚¨ä¸èƒ½è¿”å›å€¼ï¼Œå¹¶ä¸”æœŸæœ›è°ƒç”¨è€…ä¸€å®šä¼šè¿è¡Œè¯¥å€¼çš„ææ„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The canonical safe use of `mem::forget` is to circumvent a value's destructor implemented by the `Drop` trait.",
        "suggest": "`mem::forget` çš„è§„èŒƒå®‰å…¨ä½¿ç”¨æ˜¯ä¸ºäº†é¿å… `Drop` trait å®ç°çš„å€¼çš„ææ„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "For example, this will leak a `File`, i.e.",
        "suggest": "ä¾‹å¦‚ï¼Œè¿™å°†æ³„æ¼ `File`ï¼Œå³",
        "translate": ""
    },
    {
        "source": "reclaim the space taken by the variable but never close the underlying system resource:",
        "suggest": "å›æ”¶å˜é‡å ç”¨çš„ç©ºé—´ï¼Œä½†ä¸è¦å…³é—­åŸºç¡€ç³»ç»Ÿèµ„æº:",
        "translate": ""
    },
    {
        "source": "This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.",
        "suggest": "å½“åŸºç¡€èµ„æºçš„æ‰€æœ‰æƒå…ˆå‰å·²è½¬ç§»åˆ° Rust ä¹‹å¤–çš„ä»£ç æ—¶ (ä¾‹å¦‚ï¼Œé€šè¿‡å°†åŸå§‹æ–‡ä»¶æè¿°ç¬¦ä¼ è¾“åˆ° C ä»£ç )ï¼Œè¿™å¾ˆæœ‰ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Relationship with `ManuallyDrop`",
        "suggest": "ä¸ `ManuallyDrop` çš„å…³ç³»",
        "translate": ""
    },
    {
        "source": "While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.",
        "suggest": "è™½ç„¶ `mem::forget` ä¹Ÿå¯ä»¥ç”¨äºè½¬ç§» *å†…å­˜* æ‰€æœ‰æƒï¼Œä½†æ˜¯è¿™æ ·åšå¾ˆå®¹æ˜“å‡ºé”™ã€‚",
        "translate": ""
    },
    {
        "source": "should be used instead.",
        "suggest": "åº”è¯¥æ”¹ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Consider, for example, this code:",
        "suggest": "ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ä»£ç :",
        "translate": ""
    },
    {
        "source": "There are two issues with the above example:",
        "suggest": "ä¸Šé¢çš„ç¤ºä¾‹æœ‰ä¸¤ä¸ªé—®é¢˜:",
        "translate": ""
    },
    {
        "source": "If more code were added between the construction of `String` and the invocation of `mem::forget()`, a panic within it would cause a double free because the same memory is handled by both `v` and `s`.",
        "suggest": "å¦‚æœåœ¨ `String` çš„æ„é€ ä¸ `mem::forget()` çš„è°ƒç”¨ä¹‹é—´æ·»åŠ äº†æ›´å¤šä»£ç ï¼Œåˆ™å…¶ä¸­çš„ panic å°†å¯¼è‡´åŒé‡é‡Šæ”¾ï¼Œå› ä¸º `v` å’Œ `s` å‡å¤„ç†åŒä¸€å†…å­˜ã€‚",
        "translate": ""
    },
    {
        "source": "After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`, the `v` value is invalid.",
        "suggest": "è°ƒç”¨ `v.as_mut_ptr()` å¹¶å°†æ•°æ®æ‰€æœ‰æƒä¼ è¾“åˆ° `s` ä¹‹åï¼Œ`v` å€¼æ— æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "Even when a value is just moved to `mem::forget` (which won't inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned.",
        "suggest": "å³ä½¿å°†å€¼ä»…ç§»åŠ¨åˆ° `mem::forget` (ä¸ä¼šæ£€æŸ¥å®ƒ)ï¼ŒæŸäº›ç±»å‹å¯¹å…¶å€¼ä¹Ÿæœ‰ä¸¥æ ¼çš„è¦æ±‚ï¼Œä»¥ä½¿å®ƒä»¬åœ¨æ‚¬ç©ºæˆ–ä¸å†æ‹¥æœ‰æ—¶æ— æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.",
        "suggest": "ä»¥ä»»ä½•æ–¹å¼ä½¿ç”¨æ— æ•ˆå€¼ï¼ŒåŒ…æ‹¬å°†å®ƒä»¬ä¼ é€’ç»™å‡½æ•°æˆ–ä»å‡½æ•°ä¸­è¿”å›å®ƒä»¬ï¼Œéƒ½æ„æˆæœªå®šä¹‰çš„è¡Œä¸ºï¼Œå¹¶ä¸”å¯èƒ½ä¼šç ´åç¼–è¯‘å™¨æ‰€åšçš„å‡è®¾ã€‚",
        "translate": ""
    },
    {
        "source": "Switching to `ManuallyDrop` avoids both issues:",
        "suggest": "åˆ‡æ¢åˆ° `ManuallyDrop` å¯ä»¥é¿å…ä¸¤ä¸ªé—®é¢˜:",
        "translate": ""
    },
    {
        "source": "robustly prevents double-free because we disable `v`'s destructor before doing anything else.",
        "suggest": "å¼ºæœ‰åŠ›åœ°é˜²æ­¢äº†åŒé‡é‡Šæ”¾ï¼Œå› ä¸ºåœ¨æ‰§è¡Œå…¶ä»–ä»»ä½•æ“ä½œä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆç¦ç”¨äº† v çš„ææ„å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "doesn't allow this because it consumes its argument, forcing us to call it only after extracting anything we need from `v`.",
        "suggest": "ä¸å…è®¸è¿™æ ·åšï¼Œå› ä¸ºå®ƒæ¶ˆè€—äº†å…¶å‚æ•°ï¼Œä»…åœ¨ä» `v` ä¸­æå–äº†æˆ‘ä»¬éœ€è¦çš„æ‰€æœ‰å†…å®¹åï¼Œæ‰è¿«ä½¿æˆ‘ä»¬è°ƒç”¨å®ƒã€‚",
        "translate": ""
    },
    {
        "source": "Even if a panic were introduced between construction of `ManuallyDrop` and building the string (which cannot happen in the code as shown), it would result in a leak and not a double free.",
        "suggest": "å³ä½¿åœ¨ `ManuallyDrop` çš„æ„å»ºä¸å­—ç¬¦ä¸²çš„æ„å»ºä¹‹é—´å¼•å…¥äº† panic (è¿™åœ¨æ‰€ç¤ºçš„ä»£ç ä¸­ä¸èƒ½å‘ç”Ÿ)ï¼Œä¹Ÿå°†å¯¼è‡´æ³„æ¼ï¼Œè€Œä¸æ˜¯åŒé‡é‡Šæ”¾ã€‚",
        "translate": ""
    },
    {
        "source": "In other words, `ManuallyDrop` errs on the side of leaking instead of erring on the side of (double-)dropping.",
        "suggest": "æ¢å¥è¯è¯´ï¼Œ`ManuallyDrop` åœ¨æ³„æ¼çš„ä¸€ä¾§å‘ç”Ÿé”™è¯¯ï¼Œè€Œä¸æ˜¯åœ¨ (ä¸¤æ¬¡) ä¸¢å¼ƒçš„ä¸€ä¾§å‘ç”Ÿé”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the ownership to `s` â€” the final step of interacting with `v` to dispose of it without running its destructor is entirely avoided.",
        "suggest": "åŒæ ·ï¼Œ`ManuallyDrop` é¿å…äº†åœ¨å°†æ‰€æœ‰æƒè½¬è®©ç»™ `s` ä¹‹åå¿…é¡»ä½¿ç”¨ \"touch\" `v` çš„æƒ…å†µ-å®Œå…¨é¿å…äº†ä¸ `v` äº¤äº’ä»¥å¤„ç½®å®ƒè€Œä¸è¿è¡Œå…¶ææ„å‡½æ•°çš„æœ€åä¸€æ­¥ã€‚",
        "translate": ""
    },
    {
        "source": "Like [`forget`], but also accepts unsized values.",
        "suggest": "ä¸ [`forget`] ä¸€æ ·ï¼Œä½†ä¹Ÿæ¥å—æœªå®šä¹‰å¤§å°çš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This function is just a shim intended to be removed when the `unsized_locals` feature gets stabilized.",
        "suggest": "è¯¥å‡½æ•°åªæ˜¯ `unsized_locals` åŠŸèƒ½ç¨³å®šåè¦åˆ é™¤çš„å«ç‰‡ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the size of a type in bytes.",
        "suggest": "è¿”å›ç±»å‹çš„å¤§å° (ä»¥å­—èŠ‚ä¸ºå•ä½)ã€‚",
        "translate": ""
    },
    {
        "source": "More specifically, this is the offset in bytes between successive elements in an array with that item type including alignment padding.",
        "suggest": "æ›´å…·ä½“åœ°è¯´ï¼Œè¿™æ˜¯å…·æœ‰è¯¥é¡¹ç±»å‹ (åŒ…æ‹¬å¯¹é½å¡«å……) çš„æ•°ç»„ä¸­è¿ç»­å…ƒç´ ä¹‹é—´çš„å­—èŠ‚åç§»é‡ã€‚",
        "translate": ""
    },
    {
        "source": "Thus, for any type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.",
        "suggest": "å› æ­¤ï¼Œå¯¹äºä»»ä½•ç±»å‹çš„ `T` å’Œé•¿åº¦ `n`ï¼Œ`[T; n]` çš„å¤§å°éƒ½æ˜¯ `n * size_of::<T>()`ã€‚",
        "translate": ""
    },
    {
        "source": "In general, the size of a type is not stable across compilations, but specific types such as primitives are.",
        "suggest": "é€šå¸¸ï¼Œç±»å‹çš„å¤§å°åœ¨æ•´ä¸ªç¼–è¯‘è¿‡ç¨‹ä¸­ä¸ç¨³å®šï¼Œä½†æ˜¯ç‰¹å®šç±»å‹ (ä¾‹å¦‚åŸºå…ƒ) æ˜¯ç¨³å®šçš„ã€‚",
        "translate": ""
    },
    {
        "source": "The following table gives the size for primitives.",
        "suggest": "ä¸‹è¡¨æä¾›äº†åŸºå…ƒçš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "Furthermore, `usize` and `isize` have the same size.",
        "suggest": "æ­¤å¤–ï¼Œ`usize` å’Œ `isize` å…·æœ‰ç›¸åŒçš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have the same size.",
        "suggest": "`*const T`ï¼Œ`&T`ï¼Œ`Box<T>`ï¼Œ`Option<&T>` å’Œ `Option<Box<T>>` ç±»å‹å‡å…·æœ‰ç›¸åŒçš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "If `T` is Sized, all of those types have the same size as `usize`.",
        "suggest": "å¦‚æœå°† `T` è°ƒæ•´ä¸ºå¤§å°ï¼Œåˆ™æ‰€æœ‰è¿™äº›ç±»å‹çš„å¤§å°å‡ä¸ `usize` ç›¸åŒã€‚",
        "translate": ""
    },
    {
        "source": "The mutability of a pointer does not change its size.",
        "suggest": "æŒ‡é’ˆçš„å¯å˜æ€§ä¸ä¼šæ”¹å˜å…¶å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "As such, `&T` and `&mut T` have the same size.",
        "suggest": "è¿™æ ·ï¼Œ`&T` å’Œ `&mut T` å…·æœ‰ç›¸åŒçš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "Likewise for `*const T` and `*mut T`.",
        "suggest": "å¯¹äº `*const T` å’Œ `* mut T` åŒæ ·ã€‚",
        "translate": ""
    },
    {
        "source": "Size of `#[repr(C)]` items",
        "suggest": "`#[repr(C)]` é¡¹çš„å¤§å°",
        "translate": ""
    },
    {
        "source": "The `C` representation for items has a defined layout.",
        "suggest": "é¡¹çš„ `C` è¡¨ç¤ºå…·æœ‰å·²å®šä¹‰çš„å¸ƒå±€ã€‚",
        "translate": ""
    },
    {
        "source": "With this layout, the size of items is also stable as long as all fields have a stable size.",
        "suggest": "ä½¿ç”¨æ­¤å¸ƒå±€ï¼Œåªè¦æ‰€æœ‰å­—æ®µçš„å¤§å°éƒ½ç¨³å®šï¼Œåˆ™é¡¹çš„å¤§å°ä¹Ÿå°†ä¿æŒç¨³å®šã€‚",
        "translate": ""
    },
    {
        "source": "Size of Structs",
        "suggest": "ç»“æ„ä½“çš„å¤§å°",
        "translate": ""
    },
    {
        "source": "For `structs`, the size is determined by the following algorithm.",
        "suggest": "å¯¹äº `structs`ï¼Œå¤§å°ç”±ä»¥ä¸‹ç®—æ³•ç¡®å®šã€‚",
        "translate": ""
    },
    {
        "source": "For each field in the struct ordered by declaration order:",
        "suggest": "å¯¹äºç»“æ„ä½“ä¸­æŒ‰å£°æ˜é¡ºåºæ’åºçš„æ¯ä¸ªå­—æ®µ:",
        "translate": ""
    },
    {
        "source": "Add the size of the field.",
        "suggest": "æ·»åŠ å­—æ®µçš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "Round up the current size to the nearest multiple of the next field's [alignment].",
        "suggest": "å°†å½“å‰å¤§å°å››èˆäº”å…¥åˆ°ä¸‹ä¸€ä¸ªå­—æ®µçš„ [alignment] çš„æœ€æ¥è¿‘å€æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Finally, round the size of the struct to the nearest multiple of its [alignment].",
        "suggest": "æœ€åï¼Œå°†ç»“æ„ä½“çš„å¤§å°å››èˆäº”å…¥åˆ°å…¶ [alignment] çš„æœ€æ¥è¿‘å€æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The alignment of the struct is usually the largest alignment of all its fields;",
        "suggest": "ç»“æ„ä½“çš„æ’åˆ—é€šå¸¸æ˜¯å…¶æ‰€æœ‰å­—æ®µä¸­æœ€å¤§çš„æ’åˆ—;",
        "translate": ""
    },
    {
        "source": "this can be changed with the use of `repr(align(N))`.",
        "suggest": "è¿™å¯ä»¥é€šè¿‡ä½¿ç”¨ `repr(align(N))` è¿›è¡Œæ›´æ”¹ã€‚",
        "translate": ""
    },
    {
        "source": "Unlike `C`, zero sized structs are not rounded up to one byte in size.",
        "suggest": "ä¸ `C` ä¸åŒï¼Œé›¶å¤§å°çš„ç»“æ„ä½“ä¸ä¼šå››èˆäº”å…¥ä¸ºä¸€ä¸ªå­—èŠ‚ã€‚",
        "translate": ""
    },
    {
        "source": "Size of Enums",
        "suggest": "æšä¸¾çš„å¤§å°",
        "translate": ""
    },
    {
        "source": "Enums that carry no data other than the discriminant have the same size as C enums on the platform they are compiled for.",
        "suggest": "é™¤åˆ¤åˆ«å¼å¤–ä¸åŒ…å«ä»»ä½•æ•°æ®çš„æšä¸¾çš„å¤§å°ä¸ä¸ºå…¶ç¼–è¯‘çš„å¹³å°ä¸Šçš„ C æšä¸¾çš„å¤§å°ç›¸åŒã€‚",
        "translate": ""
    },
    {
        "source": "Size of Unions",
        "suggest": "union çš„å¤§å°",
        "translate": ""
    },
    {
        "source": "The size of a union is the size of its largest field.",
        "suggest": "union çš„å¤§å°æ˜¯å…¶æœ€å¤§å­—æ®µçš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "Unlike `C`, zero sized unions are not rounded up to one byte in size.",
        "suggest": "ä¸ `C` ä¸åŒï¼Œé›¶å¤§å°çš„ union ä¸ä¼šè¢«å››èˆäº”å…¥åˆ°ä¸€ä¸ªå­—èŠ‚çš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "Using `#[repr(C)]`.",
        "suggest": "ä½¿ç”¨ `#[repr(C)]`ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the size of the pointed-to value in bytes.",
        "suggest": "è¿”å›æ‰€æŒ‡å‘çš„å€¼çš„å¤§å° (ä»¥å­—èŠ‚ä¸ºå•ä½)ã€‚",
        "translate": ""
    },
    {
        "source": "This is usually the same as `size_of::<T>()`.",
        "suggest": "è¿™é€šå¸¸ä¸ `size_of::<T>()` ç›¸åŒã€‚",
        "translate": ""
    },
    {
        "source": "However, when `T` *has* no statically-known size, e.g., a slice [`[T]`][slice] or a [trait object], then `size_of_val` can be used to get the dynamically-known size.",
        "suggest": "ä½†æ˜¯ï¼Œå½“ `T` æ²¡æœ‰é™æ€å·²çŸ¥çš„å¤§å° (ä¾‹å¦‚ï¼Œåˆ‡ç‰‡ [`[T]`][slice] æˆ– [trait object]) æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `size_of_val` è·å¾—åŠ¨æ€å·²çŸ¥çš„å¤§å°ã€‚",
        "translate": ""
    },
    {
        "source": "`val` is a reference, so it's a valid raw pointer",
        "suggest": "`val` æ˜¯å¼•ç”¨ï¼Œå› æ­¤å®ƒæ˜¯æœ‰æ•ˆçš„è£¸æŒ‡é’ˆ",
        "translate": ""
    },
    {
        "source": "a [slice], then the length of the slice tail must be an initialized integer, and the size of the *entire value* (dynamic tail length + statically sized prefix) must fit in `isize`.",
        "suggest": "[slice]ï¼Œåˆ™åˆ‡ç‰‡å°¾éƒ¨çš„é•¿åº¦å¿…é¡»æ˜¯åˆå§‹åŒ–çš„æ•´æ•°ï¼Œå¹¶ä¸” *entire å€¼*(åŠ¨æ€å°¾éƒ¨é•¿åº¦ + é™æ€å¤§å°çš„å‰ç¼€) çš„å¤§å°å¿…é¡»é€‚åˆ `isize`ã€‚",
        "translate": ""
    },
    {
        "source": "a [trait object], then the vtable part of the pointer must point to a valid vtable acquired by an unsizing coercion, and the size of the *entire value* (dynamic tail length + statically sized prefix) must fit in `isize`.",
        "suggest": "[trait object]ï¼Œåˆ™æŒ‡é’ˆçš„ vtable éƒ¨åˆ†å¿…é¡»æŒ‡å‘é€šè¿‡å–æ¶ˆå¤§å°è°ƒæ•´å¼ºåˆ¶è·å–çš„æœ‰æ•ˆ vtableï¼Œå¹¶ä¸” *entire å€¼*(åŠ¨æ€å°¾éƒ¨é•¿åº¦ + é™æ€å¤§å°çš„å‰ç¼€) çš„å¤§å°å¿…é¡»é€‚åˆ `isize`ã€‚",
        "translate": ""
    },
    {
        "source": "This is the same behavior as [`size_of_val`] on a reference to a type with an extern type tail.",
        "suggest": "è¿™ä¸å¸¦æœ‰å¤–éƒ¨ç±»å‹å°¾éƒ¨çš„ç±»å‹çš„å¼•ç”¨ä¸Šçš„ [`size_of_val`] è¡Œä¸ºç›¸åŒã€‚",
        "translate": ""
    },
    {
        "source": "the caller must provide a valid raw pointer",
        "suggest": "è°ƒç”¨è€…å¿…é¡»æä¾›æœ‰æ•ˆçš„è£¸æŒ‡é’ˆ",
        "translate": ""
    },
    {
        "source": "Returns the [ABI]-required minimum alignment of a type.",
        "suggest": "è¿”å› [ABI] è¦æ±‚çš„ç±»å‹çš„æœ€å°å¯¹é½æ–¹å¼ã€‚",
        "translate": ""
    },
    {
        "source": "Every reference to a value of the type `T` must be a multiple of this number.",
        "suggest": "`T` ç±»å‹çš„å€¼çš„æ¯ä¸ªå¼•ç”¨å¿…é¡»æ˜¯è¯¥æ•°å­—çš„å€æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This is the alignment used for struct fields.",
        "suggest": "è¿™æ˜¯ç”¨äºç»“æ„ä½“å­—æ®µçš„è·¯çº¿ã€‚",
        "translate": ""
    },
    {
        "source": "It may be smaller than the preferred alignment.",
        "suggest": "å®ƒå¯èƒ½å°äºé¦–é€‰çš„å¯¹é½æ–¹å¼ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",
        "suggest": "è¿”å› [ABI] æ‰€éœ€çš„ `val` æŒ‡å‘çš„å€¼çš„ç±»å‹çš„æœ€å°å¯¹é½æ–¹å¼ã€‚",
        "translate": ""
    },
    {
        "source": "val is a reference, so it's a valid raw pointer",
        "suggest": "val æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œå› æ­¤å®ƒæ˜¯æœ‰æ•ˆçš„è£¸æŒ‡é’ˆ",
        "translate": ""
    },
    {
        "source": "This is the same behavior as [`align_of_val`] on a reference to a type with an extern type tail.",
        "suggest": "è¿™ä¸å¸¦æœ‰å¤–éƒ¨ç±»å‹å°¾éƒ¨çš„ç±»å‹çš„å¼•ç”¨ä¸Šçš„ [`align_of_val`] è¡Œä¸ºç›¸åŒã€‚",
        "translate": ""
    },
    {
        "source": "Returns `true` if dropping values of type `T` matters.",
        "suggest": "å¦‚æœä¸¢å¼ƒç±»å‹ä¸º `T` çš„å€¼å¾ˆé‡è¦ï¼Œåˆ™è¿”å› `true`ã€‚",
        "translate": ""
    },
    {
        "source": "This is purely an optimization hint, and may be implemented conservatively:",
        "suggest": "è¿™çº¯ç²¹æ˜¯ä¸€ä¸ªä¼˜åŒ–æç¤ºï¼Œå¯ä»¥ä¿å®ˆåœ°å®ç°:",
        "translate": ""
    },
    {
        "source": "it may return `true` for types that don't actually need to be dropped.",
        "suggest": "å¯¹äºå®é™…ä¸Šä¸éœ€è¦ä¸¢å¼ƒçš„ç±»å‹ï¼Œå®ƒå¯èƒ½è¿”å› `true`ã€‚",
        "translate": ""
    },
    {
        "source": "As such always returning `true` would be a valid implementation of this function.",
        "suggest": "å› æ­¤ï¼Œå§‹ç»ˆè¿”å› `true` å°†æ˜¯æ­¤å‡½æ•°çš„æœ‰æ•ˆå®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "However if this function actually returns `false`, then you can be certain dropping `T` has no side effect.",
        "suggest": "ä½†æ˜¯ï¼Œå¦‚æœæ­¤å‡½æ•°å®é™…è¿”å› `false`ï¼Œåˆ™å¯ä»¥ç¡®å®šä¸¢å¼ƒ `T` æ²¡æœ‰å‰¯ä½œç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Low level implementations of things like collections, which need to manually drop their data, should use this function to avoid unnecessarily trying to drop all their contents when they are destroyed.",
        "suggest": "éœ€è¦æ‰‹åŠ¨ä¸¢å¼ƒå…¶æ•°æ®çš„è¯¸å¦‚é›†åˆä¹‹ç±»çš„åº•å±‚å®ç°ï¼Œåº”ä½¿ç”¨æ­¤å‡½æ•°æ¥é¿å…åœ¨é”€æ¯å®ƒä»¬æ—¶ä¸å¿…è¦åœ°ä¸¢å¼ƒå…¶æ‰€æœ‰å†…å®¹ã€‚",
        "translate": ""
    },
    {
        "source": "This might not make a difference in release builds (where a loop that has no side-effects is easily detected and eliminated), but is often a big win for debug builds.",
        "suggest": "è¿™å¯èƒ½ä¸ä¼šå¯¹å‘è¡Œç‰ˆæœ¬äº§ç”Ÿå½±å“ (å¯ä»¥è½»æ¾æ£€æµ‹å¹¶æ¶ˆé™¤æ²¡æœ‰å‰¯ä½œç”¨çš„å¾ªç¯)ï¼Œä½†æ˜¯å¯¹äºè°ƒè¯•ç‰ˆæœ¬è€Œè¨€ï¼Œè¿™é€šå¸¸æ˜¯ä¸€ä¸ªå¤§èƒœåˆ©ã€‚",
        "translate": ""
    },
    {
        "source": "Note that [`drop_in_place`] already performs this check, so if your workload can be reduced to some small number of [`drop_in_place`] calls, using this is unnecessary.",
        "suggest": "è¯·æ³¨æ„ï¼Œ[`drop_in_place`] å·²ç»æ‰§è¡Œäº†æ­¤æ£€æŸ¥ï¼Œå› æ­¤ï¼Œå¦‚æœæ‚¨çš„å·¥ä½œé‡å¯ä»¥å‡å°‘åˆ°å°‘é‡çš„ [`drop_in_place`] è°ƒç”¨ï¼Œåˆ™æ— éœ€ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚",
        "translate": ""
    },
    {
        "source": "In particular note that you can [`drop_in_place`] a slice, and that will do a single needs_drop check for all the values.",
        "suggest": "ç‰¹åˆ«è¦æ³¨æ„çš„æ˜¯ï¼Œæ‚¨å¯ä»¥ [`drop_in_place`] ä¸€ä¸ªåˆ‡ç‰‡ï¼Œè¿™å°†å¯¹æ‰€æœ‰å€¼è¿›è¡Œä¸€æ¬¡ needs_drop æ£€æŸ¥ã€‚",
        "translate": ""
    },
    {
        "source": "Types like Vec therefore just `drop_in_place(&mut self[..])` without using `needs_drop` explicitly.",
        "suggest": "å› æ­¤ï¼Œåƒ Vec è¿™æ ·çš„ç±»å‹åªæ˜¯ `drop_in_place(&mut self[..])`ï¼Œè€Œæ²¡æœ‰æ˜¾å¼ä½¿ç”¨ `needs_drop`ã€‚",
        "translate": ""
    },
    {
        "source": "Types like [`HashMap`], on the other hand, have to drop values one at a time and should use this API.",
        "suggest": "å¦ä¸€æ–¹é¢ï¼Œåƒ [`HashMap`] è¿™æ ·çš„ç±»å‹å¿…é¡»ä¸€æ¬¡ä¸¢å¼ƒä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”åº”ä½¿ç”¨æ­¤ APIã€‚",
        "translate": ""
    },
    {
        "source": "Here's an example of how a collection might make use of `needs_drop`:",
        "suggest": "è¿™æ˜¯ä¸€ä¸ªé›†åˆå¦‚ä½•åˆ©ç”¨ `needs_drop` çš„ç¤ºä¾‹:",
        "translate": ""
    },
    {
        "source": "Returns the value of type `T` represented by the all-zero byte-pattern.",
        "suggest": "è¿”å›ç”±å…¨é›¶å­—èŠ‚æ¨¡å¼è¡¨ç¤ºçš„ `T` ç±»å‹çš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This means that, for example, the padding byte in `(u8, u16)` is not necessarily zeroed.",
        "suggest": "è¿™æ„å‘³ç€ï¼Œä¾‹å¦‚ï¼Œ`(u8, u16)` ä¸­çš„å¡«å……å­—èŠ‚ä¸å¿…ä¸ºé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "There is no guarantee that an all-zero byte-pattern represents a valid value of some type `T`.",
        "suggest": "ä¸èƒ½ä¿è¯å…¨é›¶å­—èŠ‚æ¨¡å¼ä»£è¡¨æŸç§ `T` ç±»å‹çš„æœ‰æ•ˆå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "For example, the all-zero byte-pattern is not a valid value for reference types (`&T`, `&mut T`) and functions pointers.",
        "suggest": "ä¾‹å¦‚ï¼Œå¯¹äºå¼•ç”¨ç±»å‹ (`&T`ï¼Œ`&mut T`) å’Œå‡½æ•°æŒ‡é’ˆï¼Œå…¨é›¶å­—èŠ‚æ¨¡å¼ä¸æ˜¯æœ‰æ•ˆå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Using `zeroed` on such types causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv] that there always is a valid value in a variable it considers initialized.",
        "suggest": "åœ¨æ­¤ç±»ç±»å‹ä¸Šä½¿ç”¨ `zeroed` ä¼šç«‹å³å¯¼è‡´ [undefined behavior][ub]ï¼Œå› ä¸º [the Rust compiler assumes][inv] åœ¨å®ƒè®¤ä¸ºå·²åˆå§‹åŒ–çš„å˜é‡ä¸­å§‹ç»ˆå­˜åœ¨æœ‰æ•ˆå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].",
        "suggest": "ä¸ [`MaybeUninit::zeroed().assume_init()`][zeroed] å…·æœ‰ç›¸åŒçš„ä½œç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "It is useful for FFI sometimes, but should generally be avoided.",
        "suggest": "æœ‰æ—¶å¯¹ FFI å¾ˆæœ‰ç”¨ï¼Œä½†é€šå¸¸åº”é¿å…ä½¿ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Correct usage of this function: initializing an integer with zero.",
        "suggest": "æ­¤å‡½æ•°çš„æ­£ç¡®ç”¨æ³•: ç”¨é›¶åˆå§‹åŒ–ä¸€ä¸ªæ•´æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage of this function: initializing a reference with zero.",
        "suggest": "è¯¥å‡½æ•°çš„ *é”™è¯¯* ç”¨æ³•: ç”¨é›¶åˆå§‹åŒ–å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that an all-zero value is valid for `T`.",
        "suggest": "è°ƒç”¨è€…å¿…é¡»ä¿è¯å…¨é›¶å€¼å¯¹ `T` æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type `T`, while doing nothing at all.",
        "suggest": "å‡è£…äº§ç”Ÿ `T` ç±»å‹çš„å€¼ï¼Œè€Œå®é™…ä¸Šä»€ä¹ˆä¹Ÿä¸åšï¼Œä»è€Œç»•è¿‡ Rust çš„å¸¸è§„å†…å­˜åˆå§‹åŒ–æ£€æŸ¥ã€‚",
        "translate": ""
    },
    {
        "source": "**This function is deprecated.** Use [`MaybeUninit<T>`] instead.",
        "suggest": "**ä¸æ¨èä½¿ç”¨æ­¤å‡½æ•°ã€‚** è¯·æ”¹ç”¨ [`MaybeUninit<T>`]ã€‚",
        "translate": ""
    },
    {
        "source": "The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as [`MaybeUninit::uninit().assume_init()`][uninit].",
        "suggest": "å¼ƒç”¨çš„åŸå› æ˜¯è¯¥å‡½æ•°åŸºæœ¬ä¸Šä¸èƒ½æ­£ç¡®ä½¿ç”¨: å®ƒå…·æœ‰ä¸ [`MaybeUninit::uninit().assume_init()`][uninit] ç›¸åŒçš„ä½œç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "As the [`assume_init` documentation][assume_init] explains, [the Rust compiler assumes][inv] that values are properly initialized.",
        "suggest": "æ­£å¦‚ [`assume_init` documentation][assume_init] æ‰€è§£é‡Šçš„é‚£æ ·ï¼Œ[the Rust compiler assumes][inv] å€¼å·²æ­£ç¡®åˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "As a consequence, calling e.g.",
        "suggest": "å› æ­¤ï¼Œè°ƒç”¨ä¾‹å¦‚",
        "translate": ""
    },
    {
        "source": "causes immediate undefined behavior for returning a `bool` that is not definitely either `true` or `false`.",
        "suggest": "å¯¼è‡´ç«‹å³è¿”å›è¿”å›çš„ `bool` çš„ä¸ç¡®å®šè¡Œä¸ºï¼Œè¯¥ `bool` ä¸ä¸€å®šæ˜¯ `true` æˆ– `false`ã€‚",
        "translate": ""
    },
    {
        "source": "Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value.",
        "suggest": "æ›´ç³Ÿç³•çš„æ˜¯ï¼ŒçœŸæ­£çš„æœªåˆå§‹åŒ–å†…å­˜ (å¦‚æ­¤å¤„è¿”å›çš„å†…å­˜) çš„ç‰¹æ®Šä¹‹å¤„åœ¨äºï¼Œç¼–è¯‘å™¨çŸ¥é“å®ƒæ²¡æœ‰å›ºå®šçš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type.",
        "suggest": "è¿™ä½¿å¾—åœ¨å˜é‡ä¸­å…·æœ‰æœªåˆå§‹åŒ–çš„æ•°æ®æˆä¸ºä¸ç¡®å®šçš„è¡Œä¸ºï¼Œå³ä½¿è¯¥å˜é‡å…·æœ‰æ•´æ•°ç±»å‹ä¹Ÿæ˜¯å¦‚æ­¤ã€‚",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that an unitialized value is valid for `T`.",
        "suggest": "è°ƒç”¨è€…å¿…é¡»ä¿è¯å¯¹ `T` æœ‰æ•ˆçš„å•ä½åŒ–å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Swaps the values at two mutable locations, without deinitializing either one.",
        "suggest": "åœ¨ä¸¤ä¸ªå¯å˜ä½ç½®äº¤æ¢å€¼ï¼Œè€Œæ— éœ€å¯¹å…¶ä¸­ä¸€ä¸ªè¿›è¡Œåˆå§‹åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "If you want to swap with a default or dummy value, see [`take`].",
        "suggest": "å¦‚æœè¦äº¤æ¢é»˜è®¤å€¼æˆ–è™šæ‹Ÿå€¼ï¼Œè¯·å‚è§ [`take`]ã€‚",
        "translate": ""
    },
    {
        "source": "If you want to swap with a passed value, returning the old value, see [`replace`].",
        "suggest": "å¦‚æœè¦ä¸ä¼ é€’çš„å€¼äº¤æ¢ï¼Œè¿”å›æ—§å€¼ï¼Œè¯·å‚è§ [`replace`]ã€‚",
        "translate": ""
    },
    {
        "source": "the raw pointers have been created from safe mutable references satisfying all the constraints on `ptr::swap_nonoverlapping_one`",
        "suggest": "è£¸æŒ‡é’ˆæ˜¯æ ¹æ®å®‰å…¨å¯å˜å¼•ç”¨åˆ›å»ºçš„ï¼Œæ»¡è¶³ `ptr::swap_nonoverlapping_one` ä¸Šçš„æ‰€æœ‰çº¦æŸ",
        "translate": ""
    },
    {
        "source": "Replaces `dest` with the default value of `T`, returning the previous `dest` value.",
        "suggest": "ç”¨é»˜è®¤å€¼ `T` æ›¿æ¢ `dest`ï¼Œå¹¶è¿”å›ä»¥å‰çš„ `dest` å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "If you want to replace the values of two variables, see [`swap`].",
        "suggest": "å¦‚æœè¦æ›¿æ¢ä¸¤ä¸ªå˜é‡çš„å€¼ï¼Œè¯·å‚è§ [`swap`]ã€‚",
        "translate": ""
    },
    {
        "source": "If you want to replace with a passed value instead of the default value, see [`replace`].",
        "suggest": "å¦‚æœè¦æ›¿æ¢ä¸ºä¼ é€’çš„å€¼è€Œä¸æ˜¯é»˜è®¤å€¼ï¼Œè¯·å‚è§ [`replace`]ã€‚",
        "translate": ""
    },
    {
        "source": "A simple example:",
        "suggest": "ä¸€ä¸ªç®€å•çš„ä¾‹å­:",
        "translate": ""
    },
    {
        "source": "allows taking ownership of a struct field by replacing it with an \"empty\" value.",
        "suggest": "å…è®¸é€šè¿‡å°†ç»“æ„ä½“å­—æ®µæ›¿æ¢ä¸º \"empty\" å€¼æ¥è·å¾—ç»“æ„ä½“å­—æ®µçš„æ‰€æœ‰æƒã€‚",
        "translate": ""
    },
    {
        "source": "Without `take` you can run into issues like these:",
        "suggest": "æ²¡æœ‰ `take`ï¼Œæ‚¨å¯èƒ½ä¼šé‡åˆ°ä»¥ä¸‹é—®é¢˜:",
        "translate": ""
    },
    {
        "source": "Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset `self.buf`.",
        "suggest": "è¯·æ³¨æ„ï¼Œ`T` ä¸ä¸€å®šå®ç° [`Clone`]ï¼Œå› æ­¤å®ƒç”šè‡³æ— æ³•å…‹éš†å’Œé‡ç½® `self.buf`ã€‚",
        "translate": ""
    },
    {
        "source": "But `take` can be used to disassociate the original value of `self.buf` from `self`, allowing it to be returned:",
        "suggest": "ä½†æ˜¯ `take` å¯ä»¥ç”¨äºå–æ¶ˆ `self.buf` çš„åŸå§‹å€¼ä¸ `self` çš„å…³è”ï¼Œä»è€Œå¯ä»¥å°†å…¶è¿”å›:",
        "translate": ""
    },
    {
        "source": "Moves `src` into the referenced `dest`, returning the previous `dest` value.",
        "suggest": "å°† `src` ç§»è‡³å¼•ç”¨çš„ `dest`ï¼Œè¿”å›å…ˆå‰çš„ `dest` å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Neither value is dropped.",
        "suggest": "è¿™ä¸¤ä¸ªå€¼éƒ½ä¸ä¼šè¢«ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "If you want to replace with a default value, see [`take`].",
        "suggest": "å¦‚æœè¦æ›¿æ¢ä¸ºé»˜è®¤å€¼ï¼Œè¯·å‚è§ [`take`]ã€‚",
        "translate": ""
    },
    {
        "source": "allows consumption of a struct field by replacing it with another value.",
        "suggest": "å…è®¸é€šè¿‡ç”¨å¦ä¸€ä¸ªå€¼æ›¿æ¢ç»“æ„ä½“å­—æ®µæ¥ä½¿ç”¨å®ƒã€‚",
        "translate": ""
    },
    {
        "source": "Without `replace` you can run into issues like these:",
        "suggest": "æ²¡æœ‰ `replace`ï¼Œæ‚¨å¯èƒ½ä¼šé‡åˆ°ä»¥ä¸‹é—®é¢˜:",
        "translate": ""
    },
    {
        "source": "Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to avoid the move.",
        "suggest": "è¯·æ³¨æ„ï¼Œ`T` ä¸ä¸€å®šå®ç° [`Clone`]ï¼Œå› æ­¤æˆ‘ä»¬ç”šè‡³æ— æ³•å…‹éš† `self.buf[i]` ä»¥é¿å…æ­¤ä¸¾ã€‚",
        "translate": ""
    },
    {
        "source": "But `replace` can be used to disassociate the original value at that index from `self`, allowing it to be returned:",
        "suggest": "ä½†æ˜¯ `replace` å¯ä»¥ç”¨äºå–æ¶ˆè¯¥ç´¢å¼•å¤„çš„åŸå§‹å€¼ä¸ `self` çš„å…³è”ï¼Œä»è€Œå¯ä»¥å°†å…¶è¿”å›:",
        "translate": ""
    },
    {
        "source": "We read from `dest` but directly write `src` into it afterwards, such that the old value is not duplicated.",
        "suggest": "æˆ‘ä»¬ä» `dest` è¯»å–ï¼Œä½†ä¹‹åç›´æ¥å°† `src` å†™å…¥å…¶ä¸­ï¼Œè¿™æ ·å°±ä¸ä¼šé‡å¤æ—§å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Nothing is dropped and nothing here can panic.",
        "suggest": "ä»€ä¹ˆéƒ½ä¸ä¼šè¢«ä¸¢å¼ƒæ‰ï¼Œä¹Ÿä»€ä¹ˆéƒ½ä¸ä¼š panicã€‚",
        "translate": ""
    },
    {
        "source": "Disposes of a value.",
        "suggest": "å¤„ç†ä¸€ä¸ªå€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This does so by calling the argument's implementation of [`Drop`][drop].",
        "suggest": "é€šè¿‡è°ƒç”¨ [`Drop`][drop] çš„å‚æ•°å®ç°æ¥å®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "This effectively does nothing for types which implement `Copy`, e.g.",
        "suggest": "è¿™å¯¹äºå®ç° `Copy` çš„ç±»å‹å®é™…ä¸Šä¸èµ·ä½œç”¨ï¼Œä¾‹å¦‚",
        "translate": ""
    },
    {
        "source": "Such values are copied and _then_ moved into the function, so the value persists after this function call.",
        "suggest": "è¿™æ ·çš„å€¼è¢«å¤åˆ¶å¹¶å°† _then_ ç§»åˆ°å‡½æ•°ä¸­ï¼Œå› æ­¤è¯¥å€¼åœ¨æ­¤å‡½æ•°è°ƒç”¨ä¹‹åä»ç„¶å­˜åœ¨ã€‚",
        "translate": ""
    },
    {
        "source": "This function is not magic;",
        "suggest": "è¿™ä¸ªåŠŸèƒ½å¹¶ä¸ç¥å¥‡ã€‚",
        "translate": ""
    },
    {
        "source": "it is literally defined as",
        "suggest": "å®ƒçš„å­—é¢å®šä¹‰ä¸º",
        "translate": ""
    },
    {
        "source": "Because `_x` is moved into the function, it is automatically dropped before the function returns.",
        "suggest": "ç”±äº `_x` å·²ç§»å…¥å‡½æ•°ï¼Œå› æ­¤å®ƒä¼šåœ¨å‡½æ•°è¿”å›ä¹‹å‰è‡ªåŠ¨ä¸¢å¼ƒã€‚",
        "translate": ""
    },
    {
        "source": "Since [`RefCell`] enforces the borrow rules at runtime, `drop` can release a [`RefCell`] borrow:",
        "suggest": "ç”±äº [`RefCell`] åœ¨è¿è¡Œæ—¶å¼ºåˆ¶æ‰§è¡Œå€Ÿç”¨è§„åˆ™ï¼Œå› æ­¤ `drop` å¯ä»¥å‘å¸ƒ [`RefCell`] å€Ÿç”¨:",
        "translate": ""
    },
    {
        "source": "Integers and other types implementing [`Copy`] are unaffected by `drop`.",
        "suggest": "å®ç° [`Copy`] çš„æ•´æ•°å’Œå…¶ä»–ç±»å‹ä¸å— `drop` çš„å½±å“ã€‚",
        "translate": ""
    },
    {
        "source": "Interprets `src` as having type `&U`, and then reads `src` without moving the contained value.",
        "suggest": "å°† `src` è§£é‡Šä¸ºå…·æœ‰ `&U` ç±»å‹ï¼Œç„¶ååœ¨ä¸ç§»åŠ¨æ‰€åŒ…å«çš„å€¼çš„æƒ…å†µä¸‹è¯»å– `src`ã€‚",
        "translate": ""
    },
    {
        "source": "This function will unsafely assume the pointer `src` is valid for [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading the `&U` (except that this is done in a way that is correct even when `&U` makes stricter alignment requirements than `&T`).",
        "suggest": "é€šè¿‡å°† `&T` è½¬æ¢ä¸º `&U`ï¼Œç„¶åè¯»å– `&U`ï¼Œæ­¤å‡½æ•°å°†ä¸å®‰å…¨åœ°å‡å®šæŒ‡é’ˆ `src` å¯¹ [`size_of::<U>`][size_of] å­—èŠ‚æœ‰æ•ˆ (é™¤éè¿™æ ·åšçš„æ­£ç¡®æ–¹å¼æ˜¯ï¼Œå³ä½¿ `&U` çš„å¯¹é½è¦æ±‚æ¯” `&T` ä¸¥æ ¼)ã€‚",
        "translate": ""
    },
    {
        "source": "It will also unsafely create a copy of the contained value instead of moving out of `src`.",
        "suggest": "å®ƒè¿˜å°†ä¸å®‰å…¨åœ°åˆ›å»ºæ‰€åŒ…å«å€¼çš„å‰¯æœ¬ï¼Œè€Œä¸æ˜¯ç§»å‡º `src`ã€‚",
        "translate": ""
    },
    {
        "source": "It is not a compile-time error if `T` and `U` have different sizes, but it is highly encouraged to only invoke this function where `T` and `U` have the same size.",
        "suggest": "å¦‚æœ `T` å’Œ `U` å…·æœ‰ä¸åŒçš„å¤§å°ï¼Œåˆ™ä¸æ˜¯ç¼–è¯‘æ—¶é”™è¯¯ï¼Œä½†æ˜¯å¼ºçƒˆå»ºè®®ä»…åœ¨ `T` å’Œ `U` å…·æœ‰ç›¸åŒçš„å¤§å°æ—¶è°ƒç”¨æ­¤å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This function triggers [undefined behavior][ub] if `U` is larger than `T`.",
        "suggest": "å¦‚æœ `U` å¤§äº `T`ï¼Œåˆ™æ­¤å‡½æ•°å°†è§¦å‘ [undefined behavior][ub]ã€‚",
        "translate": ""
    },
    {
        "source": "If U has a higher alignment requirement, src may not be suitably aligned.",
        "suggest": "å¦‚æœ U å…·æœ‰æ›´é«˜çš„å¯¹é½è¦æ±‚ï¼Œåˆ™ src å¯èƒ½æ— æ³•é€‚å½“å¯¹é½ã€‚",
        "translate": ""
    },
    {
        "source": "`src` is a reference which is guaranteed to be valid for reads.",
        "suggest": "`src` æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œå®ƒä¿è¯å¯¹è¯»å–æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "The caller must guarantee that the actual transmutation is safe.",
        "suggest": "è°ƒç”¨è€…å¿…é¡»ä¿è¯å®é™…çš„è½¬æ¢æ˜¯å®‰å…¨çš„ã€‚",
        "translate": ""
    },
    {
        "source": "We just checked that `src as *const U` was properly aligned.",
        "suggest": "æˆ‘ä»¬åªæ˜¯æ£€æŸ¥ `src as *const U` æ˜¯å¦æ­£ç¡®å¯¹é½ã€‚",
        "translate": ""
    },
    {
        "source": "Opaque type representing the discriminant of an enum.",
        "suggest": "ä»£è¡¨æšä¸¾çš„ä¸é€æ˜ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "See the [`discriminant`] function in this module for more information.",
        "suggest": "æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§æ­¤æ¨¡å—ä¸­çš„ [`discriminant`] å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "These trait implementations cannot be derived because we don't want any bounds on T.",
        "suggest": "æ— æ³•å¯¼å‡ºè¿™äº› trait å®ç°ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦ T çš„ä»»ä½•ç•Œé™ã€‚",
        "translate": ""
    },
    {
        "source": "Returns a value uniquely identifying the enum variant in `v`.",
        "suggest": "è¿”å›å”¯ä¸€æ ‡è¯† `v` ä¸­çš„æšä¸¾æˆå‘˜çš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "If `T` is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.",
        "suggest": "å¦‚æœ `T` ä¸æ˜¯æšä¸¾ï¼Œåˆ™è°ƒç”¨æ­¤å‡½æ•°ä¸ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºï¼Œä½†è¿”å›å€¼æ˜¯æœªæŒ‡å®šçš„ã€‚",
        "translate": ""
    },
    {
        "source": "The discriminant of an enum variant may change if the enum definition changes.",
        "suggest": "å¦‚æœæšä¸¾å®šä¹‰æ›´æ”¹ï¼Œåˆ™æšä¸¾æˆå‘˜çš„åˆ¤åˆ«å¼å¯èƒ½ä¼šæ›´æ”¹ã€‚",
        "translate": ""
    },
    {
        "source": "A discriminant of some variant will not change between compilations with the same compiler.",
        "suggest": "åœ¨å…·æœ‰ç›¸åŒç¼–è¯‘å™¨çš„ç¼–è¯‘ä¹‹é—´ï¼Œå¯¹æŸäº›æˆå‘˜çš„åˆ¤åˆ«å°†ä¸ä¼šå‘ç”Ÿå˜åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "This can be used to compare enums that carry data, while disregarding the actual data:",
        "suggest": "è¿™å¯ä»¥ç”¨æ¥æ¯”è¾ƒæºå¸¦æ•°æ®çš„æšä¸¾ï¼Œè€Œå¿½ç•¥å®é™…æ•°æ®:",
        "translate": ""
    },
    {
        "source": "Returns the number of variants in the enum type `T`.",
        "suggest": "è¿”å›æšä¸¾ç±»å‹ `T` ä¸­çš„æˆå‘˜æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Equally, if `T` is an enum with more variants than `usize::MAX` the return value is unspecified.",
        "suggest": "åŒæ ·ï¼Œå¦‚æœ `T` æ˜¯æˆå‘˜æ•°å¤§äº `usize::MAX` çš„æšä¸¾ï¼Œåˆ™æœªæŒ‡å®šè¿”å›å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Custom arbitrary-precision number (bignum) implementation.",
        "suggest": "è‡ªå®šä¹‰ä»»æ„ç²¾åº¦æ•°å­— (bignum) çš„å®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "This is designed to avoid the heap allocation at expense of stack memory.",
        "suggest": "è¿™æ ·åšæ˜¯ä¸ºäº†é¿å…ä»¥åˆ†é…å †å†…å­˜ä¸ºä»£ä»·æ¥é¿å…å †åˆ†é…ã€‚",
        "translate": ""
    },
    {
        "source": "The most used bignum type, `Big32x40`, is limited by 32 Ã— 40 = 1,280 bits and will take at most 160 bytes of stack memory.",
        "suggest": "æœ€å¸¸ç”¨çš„ bignum ç±»å‹ `Big32x40` å— 32Ã—40=1,280 ä½çš„é™åˆ¶ï¼Œæœ€å¤šå ç”¨ 160 ä¸ªå­—èŠ‚çš„æ ˆå†…å­˜ã€‚",
        "translate": ""
    },
    {
        "source": "This is more than enough for round-tripping all possible finite `f64` values.",
        "suggest": "å¯¹äºå¾€è¿”æ‰€æœ‰å¯èƒ½çš„æœ‰é™ `f64` å€¼è€Œè¨€ï¼Œè¿™ç»°ç»°æœ‰ä½™ã€‚",
        "translate": ""
    },
    {
        "source": "In principle it is possible to have multiple bignum types for different inputs, but we don't do so to avoid the code bloat.",
        "suggest": "åŸåˆ™ä¸Šï¼Œå¯ä»¥ä¸ºä¸åŒçš„è¾“å…¥ä½¿ç”¨å¤šä¸ª bignum ç±»å‹ï¼Œä½†æ˜¯æˆ‘ä»¬è¿™æ ·åšå¹¶ä¸æ˜¯ä¸ºäº†é¿å…ä»£ç è†¨èƒ€ã€‚",
        "translate": ""
    },
    {
        "source": "Each bignum is still tracked for the actual usages, so it normally doesn't matter.",
        "suggest": "ä»ç„¶ä¼šè·Ÿè¸ªæ¯ä¸ª bignum çš„å®é™…ç”¨æ³•ï¼Œå› æ­¤é€šå¸¸æ²¡æœ‰å…³ç³»ã€‚",
        "translate": ""
    },
    {
        "source": "This module is only for dec2flt and flt2dec, and only public because of coretests.",
        "suggest": "è¯¥æ¨¡å—ä»…ç”¨äº dec2flt å’Œ flt2decï¼Œå¹¶ä¸”ç”±äº coretests è€Œä»…ç”¨äºå…¬å…±æ¨¡å—ã€‚",
        "translate": ""
    },
    {
        "source": "It is not intended to ever be stabilized.",
        "suggest": "å®ƒæ°¸è¿œéƒ½ä¸ä¼šç¨³å®šä¸‹æ¥ã€‚",
        "translate": ""
    },
    {
        "source": "Arithmetic operations required by bignums.",
        "suggest": "bignums éœ€è¦çš„ç®—æœ¯è¿ç®—ã€‚",
        "translate": ""
    },
    {
        "source": "Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`, where `W` is the number of bits in `Self`.",
        "suggest": "è¿”å› `(carry', v')`ï¼Œä½¿å¾— `carry' * 2^W + v' = self + other + carry`ï¼Œå…¶ä¸­ `W` æ˜¯ `Self` ä¸­çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`, where `W` is the number of bits in `Self`.",
        "suggest": "è¿”å› `(carry', v')`ï¼Œä½¿å¾— `carry'*2^W + v' = self* other + carry`ï¼Œå…¶ä¸­ `W` æ˜¯ `Self` ä¸­çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`, where `W` is the number of bits in `Self`.",
        "suggest": "è¿”å› `(carry', v')`ï¼Œä½¿å¾— `carry'*2^W + v' = self* other + other2 + carry`ï¼Œå…¶ä¸­ `W` æ˜¯ `Self` ä¸­çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem` and `0 <= rem < other`, where `W` is the number of bits in `Self`.",
        "suggest": "è¿”å› `(quo, rem)`ï¼Œä½¿å¾— `borrow *2^W + self = quo* other + rem` å’Œ `0 <= rem < other`ï¼Œå…¶ä¸­ `W` æ˜¯ `Self` ä¸­çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This cannot overflow;",
        "suggest": "è¿™ä¸ä¼šæº¢å‡º;",
        "translate": ""
    },
    {
        "source": "the output is between `0` and `2 * 2^nbits - 1`.",
        "suggest": "è¾“å‡ºåœ¨ `0` å’Œ `2 * 2^nbits - 1` ä¹‹é—´ã€‚",
        "translate": ""
    },
    {
        "source": "will LLVM optimize this into ADC or similar?",
        "suggest": "LLVM ä¼šå°†å…¶ä¼˜åŒ–åˆ° ADC æˆ–ç±»ä¼¼äº§å“ä¸­å—?",
        "translate": ""
    },
    {
        "source": "the output is between `0` and `2^nbits * (2^nbits - 1)`.",
        "suggest": "è¾“å‡ºåœ¨ `0` å’Œ `2^nbits * (2^nbits - 1)` ä¹‹é—´ã€‚",
        "translate": ""
    },
    {
        "source": "See RFC #521 for enabling this.",
        "suggest": "æœ‰å…³å¯ç”¨æ­¤åŠŸèƒ½çš„ä¿¡æ¯ï¼Œè¯·å‚è§ RFC #521ã€‚",
        "translate": ""
    },
    {
        "source": "add(intrinsics::u64_add_with_overflow), mul/div(u128);",
        "suggest": "add(intrinsics::u64_add_with_overflow)ï¼Œmul/div (u128) ;",
        "translate": ""
    },
    {
        "source": "Table of powers of 5 representable in digits.",
        "suggest": "5 çš„å¹‚è¡¨å¯ç”¨æ•°å­—è¡¨ç¤ºã€‚",
        "translate": ""
    },
    {
        "source": "Specifically, the largest {u8, u16, u32} value that's a power of five, plus the corresponding exponent.",
        "suggest": "å…·ä½“æ¥è¯´ï¼Œæœ€å¤§çš„ {u8, u16, u32} å€¼æ˜¯ 5 çš„å¹‚ï¼Œå†åŠ ä¸Šç›¸åº”çš„æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Used in `mul_pow5`.",
        "suggest": "åœ¨ `mul_pow5` ä¸­ä½¿ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Stack-allocated arbitrary-precision (up to certain limit) integer.",
        "suggest": "æ ˆåˆ†é…çš„ä»»æ„ç²¾åº¦ (è¾¾åˆ°ä¸€å®šé™åˆ¶) æ•´æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This is backed by a fixed-size array of given type (\"digit\").",
        "suggest": "è¿™ç”±ç»™å®šç±»å‹ (\"digit\") çš„å›ºå®šå¤§å°çš„æ•°ç»„æ”¯æŒã€‚",
        "translate": ""
    },
    {
        "source": "While the array is not very large (normally some hundred bytes), copying it recklessly may result in the performance hit.",
        "suggest": "å°½ç®¡æ•°ç»„ä¸æ˜¯å¾ˆå¤§ (é€šå¸¸ä¸ºå‡ ç™¾ä¸ªå­—èŠ‚)ï¼Œä½†ä¸è®¡åæœåœ°å¤åˆ¶å®ƒå¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚",
        "translate": ""
    },
    {
        "source": "Thus this is intentionally not `Copy`.",
        "suggest": "å› æ­¤ï¼Œè¿™ä¸æ˜¯ `Copy`ã€‚",
        "translate": ""
    },
    {
        "source": "All operations available to bignums panic in the case of overflows.",
        "suggest": "å‘ç”Ÿæº¢å‡ºæ—¶ï¼Œbignums panic å¯ä»¥ä½¿ç”¨æ‰€æœ‰æ“ä½œã€‚",
        "translate": ""
    },
    {
        "source": "The caller is responsible to use large enough bignum types.",
        "suggest": "è°ƒç”¨æ–¹è´Ÿè´£ä½¿ç”¨è¶³å¤Ÿå¤§çš„ bignum ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "One plus the offset to the maximum \"digit\" in use.",
        "suggest": "ä¸€åŠ åç§»é‡åˆ°æ­£åœ¨ä½¿ç”¨çš„æœ€å¤§ \"digit\"ã€‚",
        "translate": ""
    },
    {
        "source": "This does not decrease, so be aware of the computation order.",
        "suggest": "è¿™ä¸ä¼šå‡å°‘ï¼Œå› æ­¤è¯·æ³¨æ„è®¡ç®—é¡ºåºã€‚",
        "translate": ""
    },
    {
        "source": "should be zero.",
        "suggest": "åº”è¯¥ä¸ºé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "represents `a + b*2^W + c*2^(2W) + ...` where `W` is the number of bits in the digit type.",
        "suggest": "è¡¨ç¤º `a + b *2^W + c* 2^(2W) + ...`ï¼Œå…¶ä¸­ `W` æ˜¯æ•°å­—ç±»å‹çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Makes a bignum from one digit.",
        "suggest": "ä»ä¸€ä½æ•°äº§ç”Ÿä¸€ä¸ªå¤§æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Makes a bignum from `u64` value.",
        "suggest": "ä» `u64` å€¼å¾—åˆ°ä¸€ä¸ªå¤§æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the internal digits as a slice `[a, b, c, ...]` such that the numeric value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in the digit type.",
        "suggest": "è¿”å›å†…éƒ¨æ•°å­—ä½œä¸ºåˆ‡ç‰‡ `[a, b, c, ...]`ï¼Œä»¥ä½¿æ•°å€¼ä¸º `a + b *2^W + c* 2^(2W) + ...`ï¼Œå…¶ä¸­ `W` æ˜¯æ•°å­—ç±»å‹ä¸­çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the `i`-th bit where bit 0 is the least significant one.",
        "suggest": "è¿”å›ç¬¬ i ä½ï¼Œå…¶ä¸­ä½ 0 æ˜¯æœ€ä½æœ‰æ•ˆä½ã€‚",
        "translate": ""
    },
    {
        "source": "In other words, the bit with weight `2^i`.",
        "suggest": "æ¢å¥è¯è¯´ï¼Œé’»å¤´çš„é‡é‡ä¸º `2^i`ã€‚",
        "translate": ""
    },
    {
        "source": "Returns `true` if the bignum is zero.",
        "suggest": "å¦‚æœ bignum ä¸ºé›¶ï¼Œåˆ™è¿”å› `true`ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the number of bits necessary to represent this value.",
        "suggest": "è¿”å›è¡¨ç¤ºæ­¤å€¼æ‰€éœ€çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Note that zero is considered to need 0 bits.",
        "suggest": "æ³¨æ„ï¼Œé›¶è¢«è®¤ä¸ºéœ€è¦ 0 ä½ã€‚",
        "translate": ""
    },
    {
        "source": "Skip over the most significant digits which are zero.",
        "suggest": "è·³è¿‡æœ€é«˜æœ‰æ•ˆæ•°å­—é›¶ã€‚",
        "translate": ""
    },
    {
        "source": "There are no non-zero digits, i.e., the number is zero.",
        "suggest": "æ²¡æœ‰éé›¶æ•°å­—ï¼Œå³æ•°å­—ä¸ºé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "This could be optimized with leading_zeros() and bit shifts, but that's probably not worth the hassle.",
        "suggest": "å¯ä»¥ä½¿ç”¨ leading_zeros() å’Œä½ç§»æ¥ä¼˜åŒ–å®ƒï¼Œä½†è¿™å¯èƒ½ä¸å€¼å¾—éº»çƒ¦ã€‚",
        "translate": ""
    },
    {
        "source": "Adds `other` to itself and returns its own mutable reference.",
        "suggest": "å‘å…¶è‡ªèº«æ·»åŠ  `other`ï¼Œå¹¶è¿”å›å…¶è‡ªå·±çš„å¯å˜å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Subtracts `other` from itself and returns its own mutable reference.",
        "suggest": "ä»è‡ªèº«ä¸­å‡å» `other`ï¼Œå¹¶è¿”å›å…¶è‡ªå·±çš„å¯å˜å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Multiplies itself by a digit-sized `other` and returns its own mutable reference.",
        "suggest": "å°†è‡ªèº«ä¹˜ä»¥æ•°å­—å¤§å°çš„ `other` å¹¶è¿”å›å…¶è‡ªå·±çš„å¯å˜å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Multiplies itself by `2^bits` and returns its own mutable reference.",
        "suggest": "å°†è‡ªèº«ä¹˜ä»¥ `2^bits` å¹¶è¿”å›è‡ªå·±çš„å˜é‡å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "shift by `digits * digitbits` bits",
        "suggest": "ç§»ä½ `digits * digitbits` ä½",
        "translate": ""
    },
    {
        "source": "shift by `bits` bits",
        "suggest": "ç§»ä½ `bits` ä½",
        "translate": ""
    },
    {
        "source": "self.base[..digits] is zero, no need to shift",
        "suggest": "self.base [.. digits] ä¸ºé›¶ï¼Œæ— éœ€ç§»ä½",
        "translate": ""
    },
    {
        "source": "Multiplies itself by `5^e` and returns its own mutable reference.",
        "suggest": "å°†è‡ªèº«ä¹˜ä»¥ `5^e` å¹¶è¿”å›è‡ªå·±çš„å˜é‡å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "There are exactly n trailing zeros on 2^n, and the only relevant digit sizes are consecutive powers of two, so this is well suited index for the table.",
        "suggest": "åœ¨ 2 ^ n ä¸Šæ­£å¥½æœ‰ n ä¸ªå°¾éšé›¶ï¼Œå¹¶ä¸”å”¯ä¸€ç›¸å…³çš„æ•°å­—å¤§å°æ˜¯ 2 çš„è¿ç»­å¹‚ï¼Œå› æ­¤è¿™éå¸¸é€‚åˆè¯¥è¡¨çš„ç´¢å¼•ã€‚",
        "translate": ""
    },
    {
        "source": "Multiply with the largest single-digit power as long as possible ...",
        "suggest": "å°½å¯èƒ½é•¿åœ°ä¹˜ä»¥æœ€å¤§çš„ä¸€ä½æ•°åŠŸç‡...",
        "translate": ""
    },
    {
        "source": "then finish off the remainder.",
        "suggest": "ç„¶åç»“æŸå‰©ä½™çš„éƒ¨åˆ†ã€‚",
        "translate": ""
    },
    {
        "source": "Multiplies itself by a number described by `other[0] + other[1] * 2^W + other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type) and returns its own mutable reference.",
        "suggest": "å°†è‡ªèº«ä¹˜ä»¥ `other[0] + other[1]*2^W + other[2]* 2^(2W) + ...` æè¿°çš„æ•°å­— (å…¶ä¸­ `W` æ˜¯æ•°å­—ç±»å‹çš„ä½æ•°)ï¼Œå¹¶è¿”å›å…¶è‡ªå·±çš„å¯å˜å¼•ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "the internal routine.",
        "suggest": "å†…éƒ¨ä¾‹ç¨‹ã€‚",
        "translate": ""
    },
    {
        "source": "works best when aa.len() <= bb.len().",
        "suggest": "å½“ aa.len() <= bb.len() æ—¶ï¼Œæ•ˆæœæœ€ä½³ã€‚",
        "translate": ""
    },
    {
        "source": "Divides itself by a digit-sized `other` and returns its own mutable reference *and* the remainder.",
        "suggest": "ç”¨æ•°å­—å¤§å°çš„ `other` é™¤ä»¥è‡ªèº«ï¼Œå¹¶è¿”å›å…¶è‡ªèº«çš„å˜é‡å¼•ç”¨ *ï¼Œå…¶ä½™ä¸º*ã€‚",
        "translate": ""
    },
    {
        "source": "Divide self by another bignum, overwriting `q` with the quotient and `r` with the remainder.",
        "suggest": "å°†è‡ªèº«é™¤ä»¥å¦ä¸€ä¸ªå¤§æ•°ï¼Œç”¨å•†è¦†ç›– `q`ï¼Œç”¨ä½™æ•°è¦†ç›– `r`ã€‚",
        "translate": ""
    },
    {
        "source": "Stupid slow base-2 long division taken from",
        "suggest": "æ„šè ¢çš„æ…¢ base-2 é•¿é™¤æ³•å–è‡ª",
        "translate": ""
    },
    {
        "source": "FIXME use a greater base ($ty) for the long division.",
        "suggest": "FIXME å¯¹äºé•¿é™¤æ³•ä½¿ç”¨æ›´å¤§çš„åŸºæ•° ($ty)ã€‚",
        "translate": ""
    },
    {
        "source": "Set bit `i` of q to 1.",
        "suggest": "å°† q çš„ `i` ä½è®¾ç½®ä¸º 1ã€‚",
        "translate": ""
    },
    {
        "source": "The digit type for `Big32x40`.",
        "suggest": "`Big32x40` çš„æ•°å­—ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "this one is used for testing only.",
        "suggest": "æ­¤ä»…ç”¨äºæµ‹è¯•ã€‚",
        "translate": ""
    },
    {
        "source": "The various algorithms from the paper.",
        "suggest": "æœ¬æ–‡ä¸­çš„å„ç§ç®—æ³•ã€‚",
        "translate": ""
    },
    {
        "source": "Number of significand bits in Fp",
        "suggest": "Fp ä¸­çš„æœ‰æ•ˆä½æ•°",
        "translate": ""
    },
    {
        "source": "We simply store the best approximation for *all* exponents, so the variable \"h\" and the associated conditions can be omitted.",
        "suggest": "æˆ‘ä»¬ä»…å­˜å‚¨ *all* æŒ‡æ•°çš„æœ€ä½³è¿‘ä¼¼å€¼ï¼Œå› æ­¤å¯ä»¥çœç•¥å˜é‡ \"h\" å’Œç›¸å…³æ¡ä»¶ã€‚",
        "translate": ""
    },
    {
        "source": "This trades performance for a couple kilobytes of space.",
        "suggest": "è¿™å°†æ€§èƒ½æ¢æˆå‡ åƒå­—èŠ‚çš„ç©ºé—´ã€‚",
        "translate": ""
    },
    {
        "source": "In most architectures, floating point operations have an explicit bit size, therefore the precision of the computation is determined on a per-operation basis.",
        "suggest": "åœ¨å¤§å¤šæ•°ä½“ç³»ç»“æ„ä¸­ï¼Œæµ®ç‚¹è¿ç®—å…·æœ‰æ˜¾å¼çš„ä½å¤§å°ï¼Œå› æ­¤è®¡ç®—çš„ç²¾åº¦å–å†³äºæ¯ä¸ªè¿ç®—ã€‚",
        "translate": ""
    },
    {
        "source": "On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.",
        "suggest": "åœ¨ x86 ä¸Šï¼Œå¦‚æœ SSE/SSE2 æ‰©å±•ä¸å¯ç”¨ï¼Œåˆ™å°† x87 FPU ç”¨äºæµ®åŠ¨æ“ä½œã€‚",
        "translate": ""
    },
    {
        "source": "The x87 FPU operates with 80 bits of precision by default, which means that operations will round to 80 bits causing double rounding to happen when values are eventually represented as",
        "suggest": "x87 FPU é»˜è®¤æƒ…å†µä¸‹ä»¥ 80 ä½ç²¾åº¦è¿è¡Œï¼Œè¿™æ„å‘³ç€è¿ç®—å°†èˆå…¥åˆ° 80 ä½ï¼Œä»è€Œåœ¨æœ€ç»ˆå°†å€¼è¡¨ç¤ºä¸ºæ—¶å°†å‘ç”ŸåŒèˆå…¥",
        "translate": ""
    },
    {
        "source": "bit float values.",
        "suggest": "ä½æµ®ç‚¹å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "To overcome this, the FPU control word can be set so that the computations are performed in the desired precision.",
        "suggest": "ä¸ºäº†å…‹æœè¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥è®¾ç½® FPU æ§åˆ¶å­—ï¼Œä»¥ä¾¿ä»¥æ‰€éœ€çš„ç²¾åº¦æ‰§è¡Œè®¡ç®—ã€‚",
        "translate": ""
    },
    {
        "source": "A structure used to preserve the original value of the FPU control word, so that it can be restored when the structure is dropped.",
        "suggest": "ä¸€ç§ç»“æ„ä½“ï¼Œç”¨äºä¿ç•™ FPU æ§åˆ¶å­—çš„åŸå§‹å€¼ï¼Œä»¥ä¾¿åœ¨ä¸¢å¼ƒè¯¥ç»“æ„ä½“æ—¶å¯ä»¥å°†å…¶æ¢å¤ã€‚",
        "translate": ""
    },
    {
        "source": "The x87 FPU is a 16-bits register whose fields are as follows:",
        "suggest": "x87 FPU æ˜¯ä¸€ä¸ª 16 ä½å¯„å­˜å™¨ï¼Œå…¶å­—æ®µå¦‚ä¸‹:",
        "translate": ""
    },
    {
        "source": "The documentation for all of the fields is available in the IA-32 Architectures Software Developer's Manual (Volume 1).",
        "suggest": "IA-32 ä½“ç³»ç»“æ„è½¯ä»¶å¼€å‘äººå‘˜æ‰‹å†Œ (ç¬¬ 1 å·) ä¸­æä¾›äº†æ‰€æœ‰å­—æ®µçš„æ–‡æ¡£ã€‚",
        "translate": ""
    },
    {
        "source": "The only field which is relevant for the following code is PC, Precision Control.",
        "suggest": "ä¸ä»¥ä¸‹ä»£ç ç›¸å…³çš„å”¯ä¸€å­—æ®µæ˜¯ PCï¼ŒPrecision Controlã€‚",
        "translate": ""
    },
    {
        "source": "This field determines the precision of the operations performed by the  FPU.",
        "suggest": "è¯¥å­—æ®µç¡®å®š FPU æ‰§è¡Œçš„æ“ä½œçš„ç²¾åº¦ã€‚",
        "translate": ""
    },
    {
        "source": "It can be set to:",
        "suggest": "å¯ä»¥è®¾ç½®ä¸º:",
        "translate": ""
    },
    {
        "source": "0b00, single precision i.e., 32-bits",
        "suggest": "0b00ï¼Œå•ç²¾åº¦ï¼Œå³ 32 ä½",
        "translate": ""
    },
    {
        "source": "0b10, double precision i.e., 64-bits",
        "suggest": "0b10ï¼ŒåŒç²¾åº¦ï¼Œå³ 64 ä½",
        "translate": ""
    },
    {
        "source": "0b11, double extended precision i.e., 80-bits (default state) The 0b01 value is reserved and should not be used.",
        "suggest": "0b11ï¼ŒåŒç²¾åº¦æ‰©å±•ç²¾åº¦ï¼Œå³ 80 ä½ (é»˜è®¤çŠ¶æ€) 0b01 å€¼æ˜¯ä¿ç•™çš„ï¼Œä¸åº”ä½¿ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "the `fldcw` instruction has been audited to be able to work correctly with any `u16`",
        "suggest": "`fldcw` æŒ‡ä»¤å·²é€šè¿‡å®¡æ ¸ï¼Œå¯ä»¥ä¸ä»»ä½• `u16` ä¸€èµ·æ­£å¸¸ä½¿ç”¨",
        "translate": ""
    },
    {
        "source": "We are using ATT syntax to support LLVM 8 and LLVM 9.",
        "suggest": "æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ ATT è¯­æ³•æ¥æ”¯æŒ LLVM 8 å’Œ LLVM 9ã€‚",
        "translate": ""
    },
    {
        "source": "Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.",
        "suggest": "å°† FPU çš„ precision å­—æ®µè®¾ç½®ä¸º `T` å¹¶è¿”å› `FPUControlWord`ã€‚",
        "translate": ""
    },
    {
        "source": "Compute the value for the Precision Control field that is appropriate for `T`.",
        "suggest": "è®¡ç®—é€‚ç”¨äº `T` çš„ Precision Control å­—æ®µçš„å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "32 bits",
        "suggest": "32 ä½",
        "translate": ""
    },
    {
        "source": "64 bits",
        "suggest": "64 ä½",
        "translate": ""
    },
    {
        "source": "default, 80 bits",
        "suggest": "é»˜è®¤ä¸º 80 ä½",
        "translate": ""
    },
    {
        "source": "Get the original value of the control word to restore it later, when the `FPUControlWord` structure is dropped",
        "suggest": "ä¸¢å¼ƒ `FPUControlWord` ç»“æ„ä½“æ—¶ï¼Œè·å–æ§åˆ¶å­—çš„åŸå§‹å€¼ä»¥åœ¨ä»¥åè¿˜åŸå®ƒ",
        "translate": ""
    },
    {
        "source": "the `fnstcw` instruction has been audited to be able to work correctly with any `u16`",
        "suggest": "`fnstcw` æŒ‡ä»¤å·²é€šè¿‡å®¡æ ¸ï¼Œå¯ä»¥ä¸ä»»ä½• `u16` ä¸€èµ·æ­£å¸¸ä½¿ç”¨",
        "translate": ""
    },
    {
        "source": "Set the control word to the desired precision.",
        "suggest": "å°†æ§åˆ¶å­—è®¾ç½®ä¸ºæ‰€éœ€çš„ç²¾åº¦ã€‚",
        "translate": ""
    },
    {
        "source": "This is achieved by masking away the old precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.",
        "suggest": "è¿™å¯ä»¥é€šè¿‡æ©ç›–æ—§çš„ç²¾åº¦ (ä½ 8 å’Œ 9ï¼Œ0x300) å¹¶å°†å…¶æ›¿æ¢ä¸ºä¸Šé¢è®¡ç®—çš„ç²¾åº¦æ ‡å¿—æ¥å®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "The fast path of Bellerophon using machine-sized integers and floats.",
        "suggest": "Bellerophon ä½¿ç”¨æœºå™¨å¤§å°çš„æ•´æ•°å’Œæµ®ç‚¹æ•°çš„å¿«é€Ÿè·¯å¾„ã€‚",
        "translate": ""
    },
    {
        "source": "This is extracted into a separate function so that it can be attempted before constructing a bignum.",
        "suggest": "å°†å…¶æå–åˆ°å•ç‹¬çš„å‡½æ•°ä¸­ï¼Œä»¥ä¾¿å¯ä»¥åœ¨åˆ›å»º bignum ä¹‹å‰å°è¯•ä½¿ç”¨å®ƒã€‚",
        "translate": ""
    },
    {
        "source": "~ 15.95.",
        "suggest": "ã€œ15.95ã€‚",
        "translate": ""
    },
    {
        "source": "We compare the exact value to MAX_SIG near the end, this is just a quick, cheap rejection (and also frees the rest of the code from worrying about underflow).",
        "suggest": "æˆ‘ä»¬å°†ç²¾ç¡®å€¼ä¸æœ«å°¾çš„ MAX_SIG è¿›è¡Œæ¯”è¾ƒï¼Œè¿™åªæ˜¯ä¸€ä¸ªå¿«é€Ÿï¼Œå»‰ä»·çš„æ‹’ç»æ–¹æ³• (å¹¶ä¸”ä½¿å…¶ä½™ä»£ç å…äºæ‹…å¿ƒä¸‹æº¢çš„éº»çƒ¦)ã€‚",
        "translate": ""
    },
    {
        "source": "The fast path crucially depends on arithmetic being rounded to the correct number of bits without any intermediate rounding.",
        "suggest": "å¿«é€Ÿè·¯å¾„è‡³å…³é‡è¦åœ°å–å†³äºå°†ç®—æœ¯å››èˆäº”å…¥åˆ°æ­£ç¡®çš„ä½æ•°ï¼Œè€Œæ— éœ€ä»»ä½•ä¸­é—´èˆå…¥ã€‚",
        "translate": ""
    },
    {
        "source": "On x86 (without SSE or SSE2) this requires the precision of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.",
        "suggest": "åœ¨ x86 (ä¸å¸¦ SSE æˆ– SSE2) ä¸Šï¼Œè¿™éœ€è¦æ›´æ”¹ x87 FPU æ ˆçš„ç²¾åº¦ï¼Œä»¥ä¾¿ç›´æ¥å°†å…¶èˆå…¥ä¸º 64/32 ä½ã€‚",
        "translate": ""
    },
    {
        "source": "The `set_precision` function takes care of setting the precision on architectures which require setting it by changing the global state (like the control word of the x87 FPU).",
        "suggest": "`set_precision` å‡½æ•°è´Ÿè´£åœ¨éœ€è¦é€šè¿‡æ›´æ”¹ ^ çŠ¶æ€ (ä¾‹å¦‚ x87 FPU çš„æ§åˆ¶å­—) è¿›è¡Œè®¾ç½®çš„ä½“ç³»ç»“æ„ä¸Šè®¾ç½®ç²¾åº¦ã€‚",
        "translate": ""
    },
    {
        "source": "The case e < 0 cannot be folded into the other branch.",
        "suggest": "e <0 çš„æƒ…å†µä¸èƒ½æŠ˜å åˆ°å¦ä¸€ä¸ªåˆ†æ”¯ä¸­ã€‚",
        "translate": ""
    },
    {
        "source": "Negative powers result in a repeating fractional part in binary, which are rounded, which causes real (and occasionally quite significant!) errors in the final result.",
        "suggest": "è´Ÿå¹‚ä¼šå¯¼è‡´äºŒè¿›åˆ¶ä¸­é‡å¤çš„å°æ•°éƒ¨åˆ†å››èˆäº”å…¥ï¼Œè¿™ä¼šåœ¨æœ€ç»ˆç»“æœä¸­å¼•èµ·å®é™…çš„ (æœ‰æ—¶æ˜¯ç›¸å½“å¤§çš„! ) é”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.",
        "suggest": "ç®—æ³• Bellerophon æ˜¯é€šè¿‡éå¹³å‡¡æ•°å€¼åˆ†æè¯æ˜çš„å¹³å‡¡ä»£ç ã€‚",
        "translate": ""
    },
    {
        "source": "It rounds ``f`` to a float with 64 bit significand and multiplies it by the best approximation of `10^e` (in the same floating point format).",
        "suggest": "å®ƒå°† ``f`` å››èˆäº”å…¥ä¸ºæœ‰æ•ˆä½æ•°ä¸º 64 ä½çš„æµ®ç‚¹æ•°ï¼Œå¹¶å°†å…¶ä¹˜ä»¥ `10^e` çš„æœ€ä½³è¿‘ä¼¼å€¼ (ä»¥ç›¸åŒçš„æµ®ç‚¹æ ¼å¼)ã€‚",
        "translate": ""
    },
    {
        "source": "This is often enough to get the correct result.",
        "suggest": "é€šå¸¸è¿™è¶³ä»¥è·å¾—æ­£ç¡®çš„ç»“æœã€‚",
        "translate": ""
    },
    {
        "source": "However, when the result is close to halfway between two adjacent (ordinary) floats, the compound rounding error from multiplying two approximation means the result may be off by a few bits.",
        "suggest": "ä½†æ˜¯ï¼Œå½“ç»“æœæ¥è¿‘ä¸¤ä¸ªç›¸é‚» (ordinary) æµ®ç‚¹æ•°ä¹‹é—´çš„ä¸€åŠæ—¶ï¼Œä¹˜ä»¥ä¸¤ä¸ªè¿‘ä¼¼å€¼ä¼šäº§ç”Ÿå¤åˆèˆå…¥è¯¯å·®ï¼Œè¿™æ„å‘³ç€ç»“æœå¯èƒ½ä¼šåç¦»å‡ ä½ã€‚",
        "translate": ""
    },
    {
        "source": "When this happens, the iterative Algorithm R fixes things up.",
        "suggest": "å‘ç”Ÿè¿™ç§æƒ…å†µæ—¶ï¼Œè¿­ä»£ç®—æ³• R ä¼šè§£å†³é—®é¢˜ã€‚",
        "translate": ""
    },
    {
        "source": "The hand-wavy \"close to halfway\" is made precise by the numeric analysis in the paper.",
        "suggest": "é€šè¿‡æœ¬æ–‡ä¸­çš„æ•°å€¼åˆ†æï¼Œå¯ä»¥ä½¿æ‰‹å·¥æ³¢æµª \"close to halfway\" å˜å¾—ç²¾ç¡®ã€‚",
        "translate": ""
    },
    {
        "source": "In the words of Clinger:",
        "suggest": "ç”¨ Clinger çš„è¯æ¥è¯´:",
        "translate": ""
    },
    {
        "source": "Slop, expressed in units of the least significant bit, is an inclusive bound for the error",
        "suggest": "ä»¥æœ€ä½æœ‰æ•ˆä½ä¸ºå•ä½è¡¨ç¤ºçš„æ–œç‡æ˜¯è¯¯å·®çš„åŒ…å«èŒƒå›´",
        "translate": ""
    },
    {
        "source": "accumulated during the floating point calculation of the approximation to f * 10^e.",
        "suggest": "åœ¨å¯¹ f * 10 ^ e è¿›è¡Œè¿‘ä¼¼çš„æµ®ç‚¹è®¡ç®—è¿‡ç¨‹ä¸­ç´¯ç§¯ã€‚",
        "translate": ""
    },
    {
        "source": "(Slop is",
        "suggest": "(æ–œç‡æ˜¯",
        "translate": ""
    },
    {
        "source": "not a bound for the true error, but bounds the difference between the approximation z and",
        "suggest": "ä¸æ˜¯çœŸæ­£è¯¯å·®çš„ç•Œé™ï¼Œè€Œæ˜¯å°†è¿‘ä¼¼å€¼ z ä¸",
        "translate": ""
    },
    {
        "source": "the best possible approximation that uses p bits of significand.)",
        "suggest": "ä½¿ç”¨ p ä¸ªæœ‰æ•ˆä½æ•°çš„æœ€ä½³è¿‘ä¼¼å€¼ã€‚)",
        "translate": ""
    },
    {
        "source": "The cases abs(e) < log5(2^N) are in fast_path()",
        "suggest": "abs(e) <log5(2^N) çš„æƒ…å†µåœ¨ fast_path() ä¸­",
        "translate": ""
    },
    {
        "source": "Is the slop large enough to make a difference when rounding to n bits?",
        "suggest": "èˆå…¥åˆ° n ä½æ—¶ï¼Œæ–œç‡æ˜¯å¦è¶³å¤Ÿå¤§ä»¥äº§ç”Ÿå½±å“?",
        "translate": ""
    },
    {
        "source": "An iterative algorithm that improves a floating point approximation of `f * 10^e`.",
        "suggest": "ä¸€ç§æ”¹è¿› `f * 10^e` æµ®ç‚¹è¿‘ä¼¼çš„è¿­ä»£ç®—æ³•ã€‚",
        "translate": ""
    },
    {
        "source": "Each iteration gets one unit in the last place closer, which of course takes terribly long to converge if `z0` is even mildly off.",
        "suggest": "æ¯æ¬¡è¿­ä»£éƒ½ä¼šåœ¨æœ€åä¸€ä¸ªä½ç½®è·å¾—ä¸€ä¸ªå•å…ƒï¼Œå¦‚æœ `z0` ç¨å¾®å…³é—­ï¼Œåˆ™æ”¶æ•›å½“ç„¶ä¼šèŠ±è´¹éå¸¸é•¿çš„æ—¶é—´ã€‚",
        "translate": ""
    },
    {
        "source": "Luckily, when used as fallback for Bellerophon, the starting approximation is off by at most one ULP.",
        "suggest": "å¹¸è¿çš„æ˜¯ï¼Œå½“ç”¨ä½œ Bellerophon çš„åå¤‡æ—¶ï¼Œèµ·å§‹è¿‘ä¼¼å€¼æœ€å¤šå¯ä»¥æœ‰ä¸€ä¸ª ULPã€‚",
        "translate": ""
    },
    {
        "source": "Find positive integers `x`, `y` such that `x / y` is exactly `(f * 10^e) / (m * 2^k)`.",
        "suggest": "æ‰¾åˆ°æ­£æ•´æ•° `x`ï¼Œ`y`ï¼Œä½¿ `x / y` æ°å¥½æ˜¯ `(f *10^e) / (m* 2^k)`ã€‚",
        "translate": ""
    },
    {
        "source": "This not only avoids dealing with the signs of `e` and `k`, we also eliminate the power of two common to `10^e` and `2^k` to make the numbers smaller.",
        "suggest": "è¿™ä¸ä»…é¿å…äº†å¤„ç† `e` å’Œ `k` çš„ç¬¦å·ï¼Œè€Œä¸”è¿˜æ¶ˆé™¤äº† `10^e` å’Œ `2^k` çš„ä¸¤ä¸ªå…±åŒä¹‹å¤„ï¼Œä»¥ä½¿æ•°å­—æ›´å°ã€‚",
        "translate": ""
    },
    {
        "source": "This is written a bit awkwardly because our bignums don't support negative numbers, so we use the absolute value + sign information.",
        "suggest": "è¿™æ ·åšæœ‰ç‚¹å°´å°¬ï¼Œå› ä¸ºæˆ‘ä»¬çš„ bignum ä¸æ”¯æŒè´Ÿæ•°ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨ç»å¯¹å€¼ + ç¬¦å·ä¿¡æ¯ã€‚",
        "translate": ""
    },
    {
        "source": "The multiplication with m_digits can't overflow.",
        "suggest": "ä¸ m_digits çš„ä¹˜æ³•ä¸ä¼šæº¢å‡ºã€‚",
        "translate": ""
    },
    {
        "source": "If `x` or `y` are large enough that we need to worry about overflow, then they are also large enough that `make_ratio` has reduced the fraction by a factor of 2^64 or more.",
        "suggest": "å¦‚æœ `x` æˆ– `y` è¶³å¤Ÿå¤§ï¼Œæˆ‘ä»¬éœ€è¦æ‹…å¿ƒæº¢å‡ºï¼Œé‚£ä¹ˆå®ƒä»¬ä¹Ÿè¶³å¤Ÿå¤§ï¼Œä»¥è‡³äº `make_ratio` å°†åˆ†æ•°å‡å°‘äº† 2 ^ 64 æˆ–æ›´å¤šã€‚",
        "translate": ""
    },
    {
        "source": "Don't need x any more, save a clone().",
        "suggest": "ä¸å†éœ€è¦ xï¼Œä¿å­˜ clone()ã€‚",
        "translate": ""
    },
    {
        "source": "Still need y - make a copy.",
        "suggest": "ä»ç„¶éœ€è¦ y - è¿›è¡Œå¤åˆ¶ã€‚",
        "translate": ""
    },
    {
        "source": "Given `x = f` and `y = m` where `f` represent input decimal digits as usual and `m` is the significand of a floating point approximation, make the ratio `x / y` equal to `(f * 10^e) / (m * 2^k)`, possibly reduced by a power of two both have in common.",
        "suggest": "ç»™å®š `x = f` å’Œ `y = m`ï¼Œå…¶ä¸­ `f` ç…§å¸¸è¡¨ç¤ºè¾“å…¥çš„åè¿›åˆ¶æ•°å­—ï¼Œè€Œ `m` æ˜¯æµ®ç‚¹è¿‘ä¼¼å€¼çš„æœ‰æ•ˆæ•°å­—ï¼Œä½¿æ¯”ç‡ `x / y` ç­‰äº `(f *10^e) / (m* 2^k)`ï¼Œå¯èƒ½ä¼šå‡å°‘ä¸¤è€…çš„å¹‚ã€‚",
        "translate": ""
    },
    {
        "source": "x = f * 10^e, y = m * 2^k, except that we reduce the fraction by some power of two.",
        "suggest": "x = f * 10^e, y = m * 2^kï¼Œé™¤äº†æˆ‘ä»¬å°†åˆ†æ•°å‡å°ä¸¤å€ã€‚",
        "translate": ""
    },
    {
        "source": "x = f * 10^e * 2^abs(k), y = m This can't overflow because it requires positive `e` and negative `k`, which can only happen for values extremely close to 1, which means that `e` and `k` will be comparatively tiny.",
        "suggest": "x = f * 10^e * 2^abs(k)ï¼Œy = m è¿™ä¸ä¼šæº¢å‡ºï¼Œå› ä¸ºå®ƒéœ€è¦æ­£ `e` å’Œè´Ÿ `k`ï¼Œè¿™ä»…åœ¨å€¼éå¸¸æ¥è¿‘ 1 æ—¶æ‰ä¼šå‘ç”Ÿï¼Œè¿™æ„å‘³ç€ `e` å’Œ `k` å°†ç›¸å¯¹è¾ƒå°ã€‚",
        "translate": ""
    },
    {
        "source": "x = f, y = m * 10^abs(e) * 2^k This can't overflow either, see above.",
        "suggest": "x = f, y = m * 10^abs(e) * 2^k è¿™ä¹Ÿä¸ä¼šæº¢å‡ºï¼Œè¯·å‚è§ä¸Šæ–‡ã€‚",
        "translate": ""
    },
    {
        "source": "x = f * 2^abs(k), y = m * 10^abs(e), again reducing by a common power of two.",
        "suggest": "x = f * 2^abs(k), y = m * 10^abs(e)ï¼Œå†æ¬¡å‡å°ä¸º 2 çš„å…¬æ–¹æ¬¡å¹‚ã€‚",
        "translate": ""
    },
    {
        "source": "Conceptually, Algorithm M is the simplest way to convert a decimal to a float.",
        "suggest": "ä»æ¦‚å¿µä¸Šè®²ï¼Œç®—æ³• M æ˜¯å°†å°æ•°è½¬æ¢ä¸ºæµ®ç‚¹æ•°çš„æœ€ç®€å•æ–¹æ³•ã€‚",
        "translate": ""
    },
    {
        "source": "We form a ratio that is equal to `f * 10^e`, then throwing in powers of two until it gives a valid float significand.",
        "suggest": "æˆ‘ä»¬å½¢æˆä¸€ä¸ªç­‰äº `f * 10^e` çš„æ¯”ç‡ï¼Œç„¶åå°†å…¶ä¹˜ä»¥ 2ï¼Œç›´åˆ°ç»™å‡ºæœ‰æ•ˆçš„æœ‰æ•ˆæµ®ç‚¹æ•°ä¸ºæ­¢ã€‚",
        "translate": ""
    },
    {
        "source": "The binary exponent `k` is the number of times we multiplied numerator or denominator by two, i.e., at all times `f * 10^e` equals `(u / v) * 2^k`.",
        "suggest": "äºŒè¿›åˆ¶æŒ‡æ•° `k` æ˜¯åˆ†å­æˆ–åˆ†æ¯ä¹˜ä»¥ 2 çš„æ¬¡æ•°ï¼Œå³ `f *10^e` å§‹ç»ˆç­‰äº `(u / v)* 2^k`ã€‚",
        "translate": ""
    },
    {
        "source": "When we have found out significand, we only need to round by inspecting the remainder of the division, which is done in helper functions further below.",
        "suggest": "å½“æˆ‘ä»¬å‘ç°æœ‰æ•ˆä½æ•°æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦æ£€æŸ¥é™¤æ³•çš„å…¶ä½™éƒ¨åˆ†å°±å¯ä»¥è¿›è¡Œå››èˆäº”å…¥ï¼Œè¿™å°†åœ¨ä¸‹é¢çš„è¾…åŠ©å‡½æ•°ä¸­å®Œæˆã€‚",
        "translate": ""
    },
    {
        "source": "This algorithm is super slow, even with the optimization described in `quick_start()`.",
        "suggest": "å³ä½¿ä½¿ç”¨ `quick_start()` ä¸­æè¿°çš„ä¼˜åŒ–æ–¹æ³•ï¼Œè¯¥ç®—æ³•ä¹Ÿéå¸¸æ…¢ã€‚",
        "translate": ""
    },
    {
        "source": "However, it's the simplest of the algorithms to adapt for overflow, underflow, and subnormal results.",
        "suggest": "ä½†æ˜¯ï¼Œå®ƒæ˜¯æœ€é€‚åˆäºä¸Šæº¢ï¼Œä¸‹æº¢å’Œæ¬¡æ­£è§„ç»“æœçš„ç®—æ³•ã€‚",
        "translate": ""
    },
    {
        "source": "This implementation takes over when Bellerophon and Algorithm R are overwhelmed.",
        "suggest": "å½“ Bellerophon å’Œ Algorithm R ä¸å ªé‡è´Ÿæ—¶ï¼Œæ­¤å®ç°å°†æ¥æ‰‹ã€‚",
        "translate": ""
    },
    {
        "source": "Detecting underflow and overflow is easy: The ratio still isn't an in-range significand, yet the minimum/maximum exponent has been reached.",
        "suggest": "æ£€æµ‹ä¸‹æº¢å’Œä¸Šæº¢å¾ˆå®¹æ˜“: è¯¥æ¯”ç‡ä»ç„¶ä¸æ˜¯æœ‰æ•ˆèŒƒå›´ï¼Œä½†å·²è¾¾åˆ° minimum/maximum æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "In the case of overflow, we simply return infinity.",
        "suggest": "åœ¨æº¢å‡ºçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªæ˜¯è¿”å›æ— ç©·å¤§ã€‚",
        "translate": ""
    },
    {
        "source": "Handling underflow and subnormals is trickier.",
        "suggest": "å¤„ç†ä¸‹æº¢å’Œæ¬¡å¸¸æ€å¼‚å¸¸æ¯”è¾ƒæ£˜æ‰‹ã€‚",
        "translate": ""
    },
    {
        "source": "One big problem is that, with the minimum exponent, the ratio might still be too large for a significand.",
        "suggest": "ä¸€ä¸ªå¤§é—®é¢˜æ˜¯ï¼Œå¦‚æœä½¿ç”¨æœ€å°æŒ‡æ•°ï¼Œåˆ™è¯¥æ¯”ç‡å¯èƒ½ä»ç„¶å¤ªå¤§è€Œæ— æ³•å®ç°ã€‚",
        "translate": ""
    },
    {
        "source": "See underflow() for details.",
        "suggest": "æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ underflow()ã€‚",
        "translate": ""
    },
    {
        "source": "FIXME possible optimization: generalize big_to_fp so that we can do the equivalent of fp_to_float(big_to_fp(u)) here, only without the double rounding.",
        "suggest": "FIXME å¯èƒ½çš„ä¼˜åŒ–: æ³›åŒ– big_to_fpï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œ fp_to_float(big_to_fp(u)) çš„ç­‰æ•ˆåŠŸèƒ½ï¼Œè€Œæ— éœ€è¿›è¡ŒåŒå–æ•´ã€‚",
        "translate": ""
    },
    {
        "source": "We have to stop at the minimum exponent, if we wait until `k < T::MIN_EXP_INT`, then we'd be off by a factor of two.",
        "suggest": "æˆ‘ä»¬å¿…é¡»åœ¨æœ€å°æŒ‡æ•°å¤„åœæ­¢ï¼Œå¦‚æœæˆ‘ä»¬ç­‰åˆ° `k < T::MIN_EXP_INT`ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†ç›¸å·® 2 å€ã€‚",
        "translate": ""
    },
    {
        "source": "Unfortunately this means we have to special- case normal numbers with the minimum exponent.",
        "suggest": "ä¸å¹¸çš„æ˜¯ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¿…é¡»å¯¹å…·æœ‰æœ€å°æŒ‡æ•°çš„æ­£æ€æ•°è¿›è¡Œç‰¹æ®Šå¤„ç†ã€‚",
        "translate": ""
    },
    {
        "source": "FIXME find a more elegant formulation, but run the `tiny-pow10` test to make sure that it's actually correct!",
        "suggest": "FIXME æ‰¾åˆ°äº†ä¸€ä¸ªæ›´ä¼˜é›…çš„å…¬å¼ï¼Œä½†æ˜¯è¿è¡Œ `tiny-pow10` æµ‹è¯•ä»¥ç¡®ä¿å®ƒå®é™…ä¸Šæ˜¯æ­£ç¡®çš„!",
        "translate": ""
    },
    {
        "source": "Skips over most Algorithm M iterations by checking the bit length.",
        "suggest": "é€šè¿‡æ£€æŸ¥ä½é•¿è·³è¿‡å¤§å¤šæ•°ç®—æ³• M è¿­ä»£ã€‚",
        "translate": ""
    },
    {
        "source": "The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).",
        "suggest": "ä½é•¿æ˜¯ä»¥ 2 ä¸ºåº•çš„å¯¹æ•°çš„ä¼°è®¡å€¼ï¼Œå¹¶ä¸” log(u / v) = log(u)-log(v)ã€‚",
        "translate": ""
    },
    {
        "source": "The estimate is off by at most 1, but always an under-estimate, so the error on log(u) and log(v) are of the same sign and cancel out (if both are large).",
        "suggest": "ä¼°è®¡æœ€å¤šåç§» 1ï¼Œä½†å§‹ç»ˆè¢«ä½ä¼°ï¼Œå› æ­¤ log(u) å’Œ log(v) ä¸Šçš„é”™è¯¯å…·æœ‰ç›¸åŒçš„ç¬¦å·å¹¶è¢«æŠµæ¶ˆ (å¦‚æœä¸¤è€…éƒ½å¾ˆå¤§)ã€‚",
        "translate": ""
    },
    {
        "source": "Therefore the error for log(u / v) is at most one as well.",
        "suggest": "å› æ­¤ï¼Œlog(u / v) çš„é”™è¯¯æœ€å¤šä¹Ÿä¸º 1ã€‚",
        "translate": ""
    },
    {
        "source": "The target ratio is one where u/v is in an in-range significand.",
        "suggest": "ç›®æ ‡æ¯”ç‡æ˜¯ u/v åœ¨æœ‰æ•ˆèŒƒå›´å†…çš„æ¯”ç‡ã€‚",
        "translate": ""
    },
    {
        "source": "Thus our termination condition is log2(u / v) being the significand bits, plus/minus one.",
        "suggest": "å› æ­¤ï¼Œæˆ‘ä»¬çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ log2(u / v) ä¸ºæœ‰æ•ˆä½ï¼Œplus/minus ä¸º 1ã€‚",
        "translate": ""
    },
    {
        "source": "FIXME Looking at the second bit could improve the estimate and avoid some more divisions.",
        "suggest": "FIXME æŸ¥çœ‹ç¬¬äºŒä½å¯ä»¥æ”¹å–„ä¼°è®¡å¹¶é¿å…æ›´å¤šåˆ’åˆ†ã€‚",
        "translate": ""
    },
    {
        "source": "Underflow or subnormal.",
        "suggest": "ä¸‹æº¢æˆ–ä½äºæ­£å¸¸æ°´å¹³ã€‚",
        "translate": ""
    },
    {
        "source": "Leave it to the main function.",
        "suggest": "ç•™ç»™ä¸»å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Overflow. Leave it to the main function.",
        "suggest": "æº¢å‡ºã€‚ç•™ç»™ä¸»å‡½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Ratio isn't an in-range significand with the minimum exponent, so we need to round off excess bits and adjust the exponent accordingly.",
        "suggest": "æ¯”ç‡ä¸æ˜¯æœ€å°æŒ‡æ•°çš„æœ‰æ•ˆèŒƒå›´ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦èˆå…¥å¤šä½™çš„ä½å¹¶ç›¸åº”åœ°è°ƒæ•´æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The real value now looks like this:",
        "suggest": "ç°åœ¨ï¼Œå®é™…å€¼å¦‚ä¸‹æ‰€ç¤º:",
        "translate": ""
    },
    {
        "source": "Therefore, when the rounded-off bits are != 0.5 ULP, they decide the rounding on their own.",
        "suggest": "å› æ­¤ï¼Œå½“èˆå…¥ä½ä¸º! = 0.5 ULP æ—¶ï¼Œå®ƒä»¬å°†è‡ªè¡Œå†³å®šèˆå…¥ã€‚",
        "translate": ""
    },
    {
        "source": "When they are equal and the remainder is non-zero, the value still needs to be rounded up.",
        "suggest": "å½“å®ƒä»¬ç›¸ç­‰ä¸”ä½™æ•°ä¸ä¸ºé›¶æ—¶ï¼Œè¯¥å€¼ä»éœ€è¦å››èˆäº”å…¥ã€‚",
        "translate": ""
    },
    {
        "source": "Only when the rounded off bits are 1/2 and the remainder is zero, we have a half-to-even situation.",
        "suggest": "åªæœ‰å½“å››èˆäº”å…¥çš„ä½æ˜¯ 1/2 ä¸”å…¶ä½™éƒ¨åˆ†ä¸ºé›¶æ—¶ï¼Œæˆ‘ä»¬æ‰æœ‰ä¸€åŠåˆ°å¶æ•°çš„æƒ…å†µã€‚",
        "translate": ""
    },
    {
        "source": "Ordinary round-to-even, obfuscated by having to round based on the remainder of a division.",
        "suggest": "æ™®é€šçš„å–æ•´åˆ°å¶æ•°ï¼Œç”±äºå¿…é¡»é™¤ä»¥é™¤æ³•çš„ä½™æ•°è€Œå–æ•´ã€‚",
        "translate": ""
    },
    {
        "source": "Converting decimal strings into IEEE 754 binary floating point numbers.",
        "suggest": "å°†åè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸º IEEE 754 äºŒè¿›åˆ¶æµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Problem statement",
        "suggest": "é—®é¢˜é™ˆè¿°",
        "translate": ""
    },
    {
        "source": "We are given a decimal string such as `12.34e56`.",
        "suggest": "æˆ‘ä»¬ç»™äº†ä¸€ä¸ªåè¿›åˆ¶å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ `12.34e56`ã€‚",
        "translate": ""
    },
    {
        "source": "This string consists of integral (`12`), fractional (`34`), and exponent (`56`) parts.",
        "suggest": "è¯¥å­—ç¬¦ä¸²ç”±æ•´æ•° (`12`)ï¼Œå°æ•° (`34`) å’ŒæŒ‡æ•° (`56`) ç»„æˆã€‚",
        "translate": ""
    },
    {
        "source": "All parts are optional and interpreted as zero when missing.",
        "suggest": "æ‰€æœ‰éƒ¨åˆ†éƒ½æ˜¯å¯é€‰çš„ï¼Œç¼ºå°‘åˆ™è§£é‡Šä¸ºé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "We seek the IEEE 754 floating point number that is closest to the exact value of the decimal string.",
        "suggest": "æˆ‘ä»¬å¯»æ±‚æœ€æ¥è¿‘åè¿›åˆ¶å­—ç¬¦ä¸²ç¡®åˆ‡å€¼çš„ IEEE 754 æµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "It is well-known that many decimal strings do not have terminating representations in base two, so we round to 0.5 units in the last place (in other words, as well as possible).",
        "suggest": "ä¼—æ‰€å‘¨çŸ¥ï¼Œè®¸å¤šåè¿›åˆ¶å­—ç¬¦ä¸²åœ¨åŸºæ•° 2 ä¸­éƒ½æ²¡æœ‰ç»ˆæ­¢è¡¨ç¤ºï¼Œå› æ­¤æˆ‘ä»¬å°† 0.5 å•ä½æœ€åèˆå…¥ (æ¢å¥è¯è¯´ï¼Œå°½å¯èƒ½)ã€‚",
        "translate": ""
    },
    {
        "source": "Ties, decimal values exactly half-way between two consecutive floats, are resolved with the half-to-even strategy, also known as banker's rounding.",
        "suggest": "é¢†å¸¦ (ç²¾ç¡®åˆ°ä¸¤ä¸ªè¿ç»­æµ®ç‚¹ä¹‹é—´çš„ä¸­é—´çš„åè¿›åˆ¶å€¼) é€šè¿‡åŠå¯¹å¶ç­–ç•¥ (ä¹Ÿç§°ä¸ºé“¶è¡Œå®¶èˆå…¥) æ¥è§£å†³ã€‚",
        "translate": ""
    },
    {
        "source": "Needless to say, this is quite hard, both in terms of implementation complexity and in terms of CPU cycles taken.",
        "suggest": "ä¸ç”¨è¯´ï¼Œè¿™åœ¨å®ç°å¤æ‚æ€§å’Œæ‰€ç”¨çš„ CPU å‘¨æœŸæ–¹é¢éƒ½ç›¸å½“å›°éš¾ã€‚",
        "translate": ""
    },
    {
        "source": "First, we ignore signs.",
        "suggest": "é¦–å…ˆï¼Œæˆ‘ä»¬å¿½ç•¥è¿¹è±¡ã€‚",
        "translate": ""
    },
    {
        "source": "Or rather, we remove it at the very beginning of the conversion process and re-apply it at the very end.",
        "suggest": "æˆ–è€…æ›´ç¡®åˆ‡åœ°è¯´ï¼Œæˆ‘ä»¬åœ¨è½¬æ¢è¿‡ç¨‹çš„å¼€å§‹å°±å°†å…¶åˆ é™¤ï¼Œç„¶ååœ¨ç»“æŸæ—¶å°†å…¶é‡æ–°åº”ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "This is correct in all edge cases since IEEE floats are symmetric around zero, negating one simply flips the first bit.",
        "suggest": "è¿™åœ¨æ‰€æœ‰ edge æƒ…å†µä¸‹éƒ½æ˜¯æ­£ç¡®çš„ï¼Œå› ä¸º IEEE æµ®ç‚¹æ•°å¯¹ç§°äºé›¶å·¦å³ï¼Œå–ååˆ™ä»…ç¿»è½¬ç¬¬ä¸€ä½ã€‚",
        "translate": ""
    },
    {
        "source": "Then we remove the decimal point by adjusting the exponent: Conceptually, `12.34e56` turns into `1234e54`, which we describe with a positive integer `f = 1234` and an integer `e = 54`.",
        "suggest": "ç„¶åï¼Œæˆ‘ä»¬é€šè¿‡è°ƒæ•´æŒ‡æ•°æ¥åˆ é™¤å°æ•°ç‚¹: ä»æ¦‚å¿µä¸Šè®²ï¼Œ`12.34e56` å˜ä¸º `1234e54`ï¼Œæˆ‘ä»¬ç”¨æ­£æ•´æ•° `f = 1234` å’Œæ•´æ•° `e = 54` å¯¹å…¶è¿›è¡Œæè¿°ã€‚",
        "translate": ""
    },
    {
        "source": "The `(f, e)` representation is used by almost all code past the parsing stage.",
        "suggest": "åœ¨è§£æé˜¶æ®µä¹‹åï¼Œå‡ ä¹æ‰€æœ‰ä»£ç éƒ½ä½¿ç”¨ `(f, e)` è¡¨ç¤ºå½¢å¼ã€‚",
        "translate": ""
    },
    {
        "source": "We then try a long chain of progressively more general and expensive special cases using machine-sized integers and small, fixed-sized floating point numbers (first `f32`/`f64`, then a type with 64 bit significand, `Fp`).",
        "suggest": "ç„¶åï¼Œæˆ‘ä»¬å°è¯•ä½¿ç”¨æœºå™¨å¤§å°çš„æ•´æ•°å’Œè¾ƒå°çš„ï¼Œå›ºå®šå¤§å°çš„æµ®ç‚¹æ•° (é¦–å…ˆæ˜¯ `f32`/`f64`ï¼Œç„¶åæ˜¯å…·æœ‰ 64 ä½æœ‰æ•ˆæ•°å­—çš„ç±»å‹ `Fp`)ï¼Œå°è¯•ä¸€é•¿ä¸²è¶Šæ¥è¶Šæ™®é€šå’Œæ˜‚è´µçš„ç‰¹æ®Šæƒ…å†µã€‚",
        "translate": ""
    },
    {
        "source": "When all these fail, we bite the bullet and resort to a simple but very slow algorithm that involved computing `f * 10^e` fully and doing an iterative search for the best approximation.",
        "suggest": "å¦‚æœæ‰€æœ‰è¿™äº›æ–¹æ³•éƒ½å¤±è´¥äº†ï¼Œæˆ‘ä»¬ä¼šç¡¬ç€å¤´çš®ï¼Œè¯‰è¯¸äºä¸€ç§ç®€å•ä½†éå¸¸ç¼“æ…¢çš„ç®—æ³•ï¼Œè¯¥ç®—æ³•éœ€è¦å®Œå…¨è®¡ç®— `f * 10^e`ï¼Œç„¶åè¿›è¡Œè¿­ä»£æœç´¢ä»¥å¯»æ±‚æœ€ä½³è¿‘ä¼¼å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "Primarily, this module and its children implement the algorithms described in:",
        "suggest": "é¦–å…ˆï¼Œæ­¤æ¨¡å—åŠå…¶å­çº§å®ç°ä»¥ä¸‹ç®—æ³•:",
        "translate": ""
    },
    {
        "source": "In addition, there are numerous helper functions that are used in the paper but not available in Rust (or at least in core).",
        "suggest": "æ­¤å¤–ï¼Œæœ¬æ–‡ä¸­ä½¿ç”¨äº†è®¸å¤šè¾…åŠ©å‡½æ•°ï¼Œä½† Rust (æˆ–è‡³å°‘åœ¨å†…æ ¸ä¸­) ä¸å¯ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Our version is additionally complicated by the need to handle overflow and underflow and the desire to handle subnormal numbers.",
        "suggest": "æˆ‘ä»¬çš„ç‰ˆæœ¬ç”±äºéœ€è¦å¤„ç†ä¸Šæº¢å’Œä¸‹æº¢ä»¥åŠå¤„ç†æ¬¡æ­£è§„æ•°çš„éœ€æ±‚è€Œå˜å¾—æ›´åŠ å¤æ‚ã€‚",
        "translate": ""
    },
    {
        "source": "Bellerophon and Algorithm R have trouble with overflow, subnormals, and underflow.",
        "suggest": "Bellerophon å’Œç®—æ³• R åœ¨ä¸Šæº¢ï¼Œå­æ­£å¸¸å’Œä¸‹æº¢æ–¹é¢å­˜åœ¨é—®é¢˜ã€‚",
        "translate": ""
    },
    {
        "source": "We conservatively switch to Algorithm M (with the modifications described in section 8 of the paper) well before the inputs get into the critical region.",
        "suggest": "åœ¨è¾“å…¥è¿›å…¥å…³é”®åŒºåŸŸä¹‹å‰ï¼Œæˆ‘ä»¬ä¼šä¿å®ˆåœ°åˆ‡æ¢åˆ°ç®—æ³• M (å…·æœ‰æœ¬æ–‡ç¬¬ 8 èŠ‚ä¸­æè¿°çš„ä¿®æ”¹)ã€‚",
        "translate": ""
    },
    {
        "source": "Another aspect that needs attention is the ``RawFloat`` trait by which almost all functions are parametrized.",
        "suggest": "éœ€è¦æ³¨æ„çš„å¦ä¸€ä¸ªæ–¹é¢æ˜¯ ``RawFloat`` traitï¼Œå‡ ä¹æ‰€æœ‰å‡½æ•°éƒ½é€šè¿‡ ``RawFloat`` trait è¿›è¡Œäº†å‚æ•°åŒ–ã€‚",
        "translate": ""
    },
    {
        "source": "One might think that it's enough to parse to `f64` and cast the result to `f32`.",
        "suggest": "æœ‰äººå¯èƒ½è®¤ä¸ºè§£æä¸º `f64` å¹¶å°†ç»“æœè½¬æ¢ä¸º `f32` å°±è¶³å¤Ÿäº†ã€‚",
        "translate": ""
    },
    {
        "source": "Unfortunately this is not the world we live in, and this has nothing to do with using base two or half-to-even rounding.",
        "suggest": "ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸æ˜¯æˆ‘ä»¬ç”Ÿæ´»çš„ä¸–ç•Œï¼Œè¿™ä¸ä½¿ç”¨åŸºæ•°äºŒè¿›ä½æˆ–åŠåˆ°å››èˆäº”å…¥å››èˆäº”å…¥æ— å…³ã€‚",
        "translate": ""
    },
    {
        "source": "Consider for example two types `d2` and `d4` representing a decimal type with two decimal digits and four decimal digits each and take \"0.01499\" as input.",
        "suggest": "ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸¤ç§ç±»å‹çš„ `d2` å’Œ `d4`ï¼Œå®ƒä»¬ä»£è¡¨å…·æœ‰ä¸¤ä¸ªåè¿›åˆ¶æ•°å­—å’Œå››ä¸ªåè¿›åˆ¶æ•°å­—çš„åè¿›åˆ¶ç±»å‹ï¼Œå¹¶ä»¥ \"0.01499\" ä½œä¸ºè¾“å…¥ã€‚",
        "translate": ""
    },
    {
        "source": "Let's use half-up rounding.",
        "suggest": "è®©æˆ‘ä»¬ä½¿ç”¨ä¸ŠåŠèˆå…¥ã€‚",
        "translate": ""
    },
    {
        "source": "Going directly to two decimal digits gives `0.01`, but if we round to four digits first, we get `0.0150`, which is then rounded up to `0.02`.",
        "suggest": "ç›´æ¥è½¬åˆ°ä¸¤ä½åè¿›åˆ¶æ•°å­—å°†å¾—åˆ° `0.01`ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬é¦–å…ˆå››èˆäº”å…¥åˆ°å››ä½æ•°å­—ï¼Œåˆ™ä¼šå¾—åˆ° `0.0150`ï¼Œç„¶åå°†å…¶å››èˆäº”å…¥ä¸º `0.02`ã€‚",
        "translate": ""
    },
    {
        "source": "The same principle applies to other operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision and round *exactly once, at the end*, by considering all truncated bits at once.",
        "suggest": "åŒæ ·çš„åŸç†ä¹Ÿé€‚ç”¨äºå…¶ä»–æ“ä½œï¼Œå¦‚æœè¦è·å¾— 0.5 ULP ç²¾åº¦ï¼Œåˆ™éœ€è¦ *è¿›è¡Œå…¨ç²¾åº¦çš„æ‰€æœ‰æ“ä½œï¼Œå¹¶åœ¨æœ«å°¾å°†* exactly once èˆå…¥*ï¼ŒåŒæ—¶è€ƒè™‘æ‰€æœ‰æˆªæ–­çš„ä½ã€‚",
        "translate": ""
    },
    {
        "source": "Although some code duplication is necessary, perhaps parts of the code could be shuffled around such that less code is duplicated.",
        "suggest": "å°½ç®¡æŸäº›ä»£ç é‡å¤æ˜¯å¿…è¦çš„ï¼Œä½†ä¹Ÿè®¸å¯ä»¥å¯¹éƒ¨åˆ†ä»£ç è¿›è¡Œæ··æ´—ï¼Œä»¥ä¾¿å‡å°‘é‡å¤çš„ä»£ç ã€‚",
        "translate": ""
    },
    {
        "source": "Large parts of the algorithms are independent of the float type to output, or only needs access to a few constants, which could be passed in as parameters.",
        "suggest": "ç®—æ³•çš„å¤§éƒ¨åˆ†ä¸ä¾èµ–äº float ç±»å‹æ¥è¾“å‡ºï¼Œæˆ–è€…ä»…éœ€è¦è®¿é—®ä¸€äº›å¸¸é‡å³å¯ä½œä¸ºå‚æ•°ä¼ é€’ã€‚",
        "translate": ""
    },
    {
        "source": "The conversion should *never* panic.",
        "suggest": "è½¬æ¢åº” *ä»ä¸* panicã€‚",
        "translate": ""
    },
    {
        "source": "There are assertions and explicit panics in the code, but they should never be triggered and only serve as internal sanity checks.",
        "suggest": "åœ¨ä»£ç ä¸­æœ‰æ–­è¨€å’Œæ˜¾å¼çš„ panicsï¼Œä½†æ˜¯å®ƒä»¬ç»ä¸åº”è¯¥è¢«è§¦å‘ï¼Œè€Œä»…ç”¨ä½œå†…éƒ¨çš„å¥å…¨æ€§æ£€æŸ¥ã€‚",
        "translate": ""
    },
    {
        "source": "Any panics should be considered a bug.",
        "suggest": "ä»»ä½• panics éƒ½åº”è§†ä¸ºé”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "There are unit tests but they are woefully inadequate at ensuring correctness, they only cover a small percentage of possible errors.",
        "suggest": "è™½ç„¶æœ‰å•å…ƒæµ‹è¯•ï¼Œä½†å®ƒä»¬åœ¨ç¡®ä¿æ­£ç¡®æ€§ä¸Šè¿˜è¿œè¿œä¸å¤Ÿï¼Œå®ƒä»¬åªè¦†ç›–äº†å¾ˆå°ä¸€éƒ¨åˆ†å¯èƒ½çš„é”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "Far more extensive tests are located in the directory `src/etc/test-float-parse` as a Python script.",
        "suggest": "æ›´å¹¿æ³›çš„æµ‹è¯•ä½œä¸º Python è„šæœ¬ä½äºç›®å½• `src/etc/test-float-parse` ä¸­ã€‚",
        "translate": ""
    },
    {
        "source": "A note on integer overflow: Many parts of this file perform arithmetic with the decimal exponent `e`.",
        "suggest": "å…³äºæ•´å‹æº¢å‡ºçš„æ³¨æ„äº‹é¡¹: è¯¥æ–‡ä»¶çš„è®¸å¤šéƒ¨åˆ†éƒ½ä½¿ç”¨åè¿›åˆ¶æŒ‡æ•° `e` æ¥æ‰§è¡Œç®—æœ¯è¿ç®—ã€‚",
        "translate": ""
    },
    {
        "source": "Primarily, we shift the decimal point around: Before the first decimal digit, after the last decimal digit, and so on.",
        "suggest": "é¦–å…ˆï¼Œæˆ‘ä»¬å°†å°æ•°ç‚¹ç§»åŠ¨: åœ¨ç¬¬ä¸€ä¸ªåè¿›åˆ¶æ•°å­—ä¹‹å‰ï¼Œåœ¨æœ€åä¸€ä¸ªåè¿›åˆ¶æ•°å­—ä¹‹åï¼Œä¾æ­¤ç±»æ¨ã€‚",
        "translate": ""
    },
    {
        "source": "This could overflow if done carelessly.",
        "suggest": "å¦‚æœä¸å°å¿ƒè¿™æ ·åšå¯èƒ½ä¼šæº¢å‡ºã€‚",
        "translate": ""
    },
    {
        "source": "We rely on the parsing submodule to only hand out sufficiently small exponents, where \"sufficient\" means \"such that the exponent +/- the number of decimal digits fits into a 64 bit integer\".",
        "suggest": "æˆ‘ä»¬ä¾é è§£æå­æ¨¡å—ä»…åˆ†å‘è¶³å¤Ÿå°çš„æŒ‡æ•°ï¼Œå…¶ä¸­ \"sufficient\" è¡¨ç¤º \"such that the exponent +/- the number of decimal digits fits into a 64 bit integer\"ã€‚",
        "translate": ""
    },
    {
        "source": "Larger exponents are accepted, but we don't do arithmetic with them, they are immediately turned into {positive,negative} {zero,infinity}.",
        "suggest": "è¾ƒå¤§çš„æŒ‡æ•°è¢«æ¥å—ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸å¯¹å®ƒä»¬è¿›è¡Œç®—æœ¯è¿ç®—ï¼Œå®ƒä»¬ç«‹å³å˜æˆ {positive,negative} {zero,infinity}ã€‚",
        "translate": ""
    },
    {
        "source": "These two have their own tests.",
        "suggest": "è¿™ä¸¤ä¸ªæœ‰è‡ªå·±çš„æµ‹è¯•ã€‚",
        "translate": ""
    },
    {
        "source": "Converts a string in base 10 to a float.",
        "suggest": "å°†ä»¥ 10 ä¸ºåº•çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºæµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Accepts an optional decimal exponent.",
        "suggest": "æ¥å—å¯é€‰çš„åè¿›åˆ¶æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This function accepts strings such as",
        "suggest": "è¯¥å‡½æ•°æ¥å—è¯¸å¦‚ä»¥ä¸‹çš„å­—ç¬¦ä¸²",
        "translate": ""
    },
    {
        "source": "or equivalently,",
        "suggest": "æˆ–ç­‰æ•ˆåœ°ï¼Œ",
        "translate": ""
    },
    {
        "source": "or, equivalently,",
        "suggest": "æˆ–è€…ï¼Œç­‰æ•ˆåœ°ï¼Œ",
        "translate": ""
    },
    {
        "source": "Leading and trailing whitespace represent an error.",
        "suggest": "å‰å¯¼å’Œå°¾éšç©ºæ ¼è¡¨ç¤ºé”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "All strings that adhere to the following [EBNF] grammar will result in an [`Ok`] being returned:",
        "suggest": "éµå¾ªä»¥ä¸‹ [EBNF] è¯­æ³•çš„æ‰€æœ‰å­—ç¬¦ä¸²éƒ½å°†å¯¼è‡´è¿”å› [`Ok`]:",
        "translate": ""
    },
    {
        "source": "Known bugs",
        "suggest": "å·²çŸ¥é”™è¯¯",
        "translate": ""
    },
    {
        "source": "In some situations, some strings that should create a valid float instead return an error.",
        "suggest": "åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œåº”è¯¥åˆ›å»ºæœ‰æ•ˆæµ®ç‚¹æ•°çš„æŸäº›å­—ç¬¦ä¸²ä¼šè¿”å›é”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "See [issue #31407] for details.",
        "suggest": "æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [issue #31407]ã€‚",
        "translate": ""
    },
    {
        "source": "src - A string",
        "suggest": "src - å­—ç¬¦ä¸²",
        "translate": ""
    },
    {
        "source": "if the string did not represent a valid number.",
        "suggest": "å¦‚æœå­—ç¬¦ä¸²ä¸ä»£è¡¨æœ‰æ•ˆæ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.",
        "suggest": "å¦åˆ™ï¼Œä¸º `Ok(n)`ï¼Œå…¶ä¸­ `n` æ˜¯ `src` è¡¨ç¤ºçš„æµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "An error which can be returned when parsing a float.",
        "suggest": "è§£ææµ®ç‚¹æ•°æ—¶å¯ä»¥è¿”å›çš„é”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "This error is used as the error type for the [`FromStr`] implementation for [`f32`] and [`f64`].",
        "suggest": "è¯¥é”™è¯¯ç”¨ä½œ [`f32`] å’Œ [`f64`] çš„ [`FromStr`] å®ç°çš„é”™è¯¯ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Splits a decimal string into sign and the rest, without inspecting or validating the rest.",
        "suggest": "å°†åè¿›åˆ¶å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºç¬¦å·å’Œå‰©ä½™éƒ¨åˆ†ï¼Œè€Œæ— éœ€æ£€æŸ¥æˆ–éªŒè¯å…¶ä½™éƒ¨åˆ†ã€‚",
        "translate": ""
    },
    {
        "source": "If the string is invalid, we never use the sign, so we don't need to validate here.",
        "suggest": "å¦‚æœå­—ç¬¦ä¸²æ— æ•ˆï¼Œåˆ™æˆ‘ä»¬æ°¸è¿œä¸ä¼šä½¿ç”¨ç¬¦å·ï¼Œå› æ­¤æˆ‘ä»¬æ— éœ€åœ¨æ­¤å¤„è¿›è¡ŒéªŒè¯ã€‚",
        "translate": ""
    },
    {
        "source": "Converts a decimal string into a floating point number.",
        "suggest": "å°†åè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºæµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing and figure out which algorithm should do the actual conversion.",
        "suggest": "åè¿›åˆ¶åˆ°æµ®ç‚¹è½¬æ¢çš„ä¸»è¦åŠ¨åŠ›: ç»Ÿç­¹æ‰€æœ‰é¢„å¤„ç†å¹¶ç¡®å®šå“ªç§ç®—æ³•åº”è¿›è¡Œå®é™…è½¬æ¢ã€‚",
        "translate": ""
    },
    {
        "source": "out the decimal point.",
        "suggest": "æ‰å°æ•°ç‚¹",
        "translate": ""
    },
    {
        "source": "Big32x40 is limited to 1280 bits, which translates to about 385 decimal digits.",
        "suggest": "Big32x40 é™åˆ¶ä¸º 1280 ä½ï¼Œå³å¤§çº¦ 385 ä¸ªåè¿›åˆ¶æ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "If we exceed this, we'll crash, so we error out before getting too close (within 10^10).",
        "suggest": "å¦‚æœè¶…è¿‡æ­¤å€¼ï¼Œæˆ‘ä»¬å°†å´©æºƒï¼Œå› æ­¤æˆ‘ä»¬ä¼šåœ¨è·ç¦»å¤ªè¿‘ (åœ¨ 10 ^ 10 ä»¥å†…) ä¹‹å‰å‡ºé”™ã€‚",
        "translate": ""
    },
    {
        "source": "Now the exponent certainly fits in 16 bit, which is used throughout the main algorithms.",
        "suggest": "ç°åœ¨ï¼ŒæŒ‡æ•°è‚¯å®šé€‚åˆ 16 ä½ï¼Œæ•´ä¸ªä¸»è¦ç®—æ³•éƒ½ä½¿ç”¨è¯¥ä½ã€‚",
        "translate": ""
    },
    {
        "source": "FIXME These bounds are rather conservative.",
        "suggest": "FIXME è¿™äº›ç•Œé™ç›¸å½“ä¿å®ˆã€‚",
        "translate": ""
    },
    {
        "source": "A more careful analysis of the failure modes of Bellerophon could allow using it in more cases for a massive speed up.",
        "suggest": "å¯¹ Bellerophon çš„æ•…éšœæ¨¡å¼è¿›è¡Œæ›´ä»”ç»†çš„åˆ†æå¯èƒ½ä¼šå…è®¸åœ¨æ›´å¤šæƒ…å†µä¸‹ä½¿ç”¨å®ƒï¼Œä»è€Œå¤§å¹…åº¦æé«˜é€Ÿåº¦ã€‚",
        "translate": ""
    },
    {
        "source": "As written, this optimizes badly (see #27130, though it refers to an old version of the code).",
        "suggest": "å¦‚æ‰€å†™ï¼Œè¿™ä¼šå¯¼è‡´ä¼˜åŒ–æ•ˆæœä¸ä½³ (è¯·å‚è§ #27130ï¼Œå°½ç®¡å®ƒå¼•ç”¨çš„æ˜¯æ—§ç‰ˆæœ¬çš„ä»£ç )ã€‚",
        "translate": ""
    },
    {
        "source": "is a workaround for that.",
        "suggest": "æ˜¯ä¸€ç§è§£å†³æ–¹æ³•ã€‚",
        "translate": ""
    },
    {
        "source": "There are only two call sites overall and it doesn't make code size worse.",
        "suggest": "æ€»ä½“ä¸Šåªæœ‰ä¸¤ä¸ªè°ƒç”¨ç«™ç‚¹ï¼Œå¹¶ä¸”ä¸ä¼šä½¿ä»£ç å¤§å°å˜ç³Ÿã€‚",
        "translate": ""
    },
    {
        "source": "Strip zeros where possible, even when this requires changing the exponent",
        "suggest": "å³ä½¿å¯èƒ½éœ€è¦å»é™¤æŒ‡æ•°ï¼Œä¹Ÿåº”å°½å¯èƒ½å»é™¤é›¶",
        "translate": ""
    },
    {
        "source": "Trimming these zeros does not change anything but may enable the fast path (< 15 digits).",
        "suggest": "ä¿®å‰ªè¿™äº›é›¶ä¸ä¼šæ”¹å˜ä»»ä½•å†…å®¹ï¼Œä½†å¯ä»¥å¯ç”¨å¿«é€Ÿè·¯å¾„ (<15 ä½æ•°å­—)ã€‚",
        "translate": ""
    },
    {
        "source": "Simplify numbers of the form 0.0...x and x...0.0, adjusting the exponent accordingly.",
        "suggest": "ç®€åŒ–å½¢å¼ä¸º 0.0...x å’Œ x...0.0 çš„æ•°å­—ï¼Œå¹¶ç›¸åº”åœ°è°ƒæ•´æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This may not always be a win (possibly pushes some numbers out of the fast path), but it simplifies other parts significantly (notably, approximating the magnitude of the value).",
        "suggest": "è¿™å¯èƒ½å¹¶ä¸æ€»æ˜¯ä¸€ä¸ªèƒœåˆ© (å¯èƒ½ä¼šå°†ä¸€äº›æ•°å­—æ’é™¤åœ¨å¿«é€Ÿè·¯å¾„ä¹‹å¤–)ï¼Œä½†ä¼šæ˜¾ç€ç®€åŒ–å…¶ä»–éƒ¨åˆ† (å°¤å…¶æ˜¯è¿‘ä¼¼å€¼çš„å¤§å°)ã€‚",
        "translate": ""
    },
    {
        "source": "Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R and Algorithm M will compute while working on the given decimal.",
        "suggest": "è¿”å›ç®—æ³• R å’Œç®—æ³• M åœ¨å¤„ç†ç»™å®šå°æ•°æ—¶å°†è®¡ç®—çš„æœ€å¤§å€¼çš„å¤§å° (log10) çš„å¿«é€Ÿè„ä¸Šé™ã€‚",
        "translate": ""
    },
    {
        "source": "We don't need to worry too much about overflow here thanks to trivial_cases() and the parser, which filter out the most extreme inputs for us.",
        "suggest": "ç”±äº trivial_cases() å’Œè§£æå™¨ä¸ºæˆ‘ä»¬ç­›é€‰å‡ºäº†æœ€æç«¯çš„è¾“å…¥ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¿…æ‹…å¿ƒè¿™é‡Œçš„æº¢å‡ºã€‚",
        "translate": ""
    },
    {
        "source": "In the case e >= 0, both algorithms compute about `f * 10^e`.",
        "suggest": "åœ¨ e >= 0 çš„æƒ…å†µä¸‹ï¼Œä¸¤ç§ç®—æ³•éƒ½è®¡ç®—å¤§çº¦ `f * 10^e`ã€‚",
        "translate": ""
    },
    {
        "source": "Algorithm R proceeds to do some complicated calculations with this but we can ignore that for the upper bound because it also reduces the fraction beforehand, so we have plenty of buffer there.",
        "suggest": "ç®—æ³• R å¯¹æ­¤è¿›è¡Œäº†ä¸€äº›å¤æ‚çš„è®¡ç®—ï¼Œä½†æ˜¯å¯¹äºä¸Šé™ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥å®ƒï¼Œå› ä¸ºå®ƒè¿˜ä¼šé¢„å…ˆå‡å°åˆ†æ•°ï¼Œå› æ­¤æˆ‘ä»¬åœ¨é‚£é‡Œæœ‰å¾ˆå¤šç¼“å†²åŒºã€‚",
        "translate": ""
    },
    {
        "source": "If e < 0, Algorithm R does roughly the same thing, but Algorithm M differs:",
        "suggest": "å¦‚æœ e < 0ï¼Œåˆ™ç®—æ³• R åšå¤§è‡´ç›¸åŒçš„äº‹æƒ…ï¼Œä½†æ˜¯ç®—æ³• M ä¸åŒ:",
        "translate": ""
    },
    {
        "source": "It tries to find a positive number k such that `f << k / 10^e` is an in-range significand.",
        "suggest": "å®ƒè¯•å›¾æ‰¾åˆ°ä¸€ä¸ªæ­£æ•° kï¼Œä»¥ä½¿ `f << k / 10^e` æ˜¯æœ‰æ•ˆèŒƒå›´å†…çš„æœ‰æ•ˆæ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "This will result in about `2^53 * f * 10^e` < `10^17 * f * 10^e`.",
        "suggest": "è¿™å°†å¯¼è‡´å¤§çº¦ `2^53 *f* 10^e` <`10^17 *f* 10^e`ã€‚",
        "translate": ""
    },
    {
        "source": "One input that triggers this is 0.33...33 (375 x 3).",
        "suggest": "è§¦å‘æ­¤æ“ä½œçš„ä¸€ä¸ªè¾“å…¥ä¸º 0.33 ... 33 (375 x 3)ã€‚",
        "translate": ""
    },
    {
        "source": "Detects obvious overflows and underflows without even looking at the decimal digits.",
        "suggest": "æ— éœ€æŸ¥çœ‹åè¿›åˆ¶æ•°å­—å³å¯æ£€æµ‹åˆ°æ˜æ˜¾çš„ä¸Šæº¢å’Œä¸‹æº¢ã€‚",
        "translate": ""
    },
    {
        "source": "There were zeros but they were stripped by simplify()",
        "suggest": "æœ‰é›¶ï¼Œä½†å®ƒä»¬è¢« simplify() å»æ‰äº†",
        "translate": ""
    },
    {
        "source": "This is a crude approximation of ceil(log10(the real value)).",
        "suggest": "è¿™æ˜¯ ceil(log10(the real value)) çš„ç²—ç•¥è¿‘ä¼¼å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "We don't need to worry too much about overflow here because the input length is tiny (at least compared to 2^64) and the parser already handles exponents whose absolute value is greater than 10^18 (which is still 10^19 short of 2^64).",
        "suggest": "æˆ‘ä»¬åœ¨è¿™é‡Œä¸å¿…æ‹…å¿ƒæº¢å‡ºé—®é¢˜ï¼Œå› ä¸ºè¾“å…¥é•¿åº¦å¾ˆå° (è‡³å°‘ä¸ 2 ^ 64 ç›¸æ¯”)ï¼Œå¹¶ä¸”è§£æå™¨å·²ç»å¤„ç†äº†ç»å¯¹å€¼å¤§äº 10 ^ 18 (ä»ç„¶çŸ­ 10 ^ 19 çš„æŒ‡æ•°) 2 ^ 64)ã€‚",
        "translate": ""
    },
    {
        "source": "Utility functions for bignums that don't make too much sense to turn into methods.",
        "suggest": "ç”¨äº bignum çš„å®ç”¨ç¨‹åºå‡½æ•°ï¼Œè½¬æ¢ä¸ºæ–¹æ³•æ²¡æœ‰å¤ªå¤§æ„ä¹‰ã€‚",
        "translate": ""
    },
    {
        "source": "FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.",
        "suggest": "FIXME è¿™ä¸ªæ¨¡å—çš„åç§°æœ‰ç‚¹ä¸å¹¸ï¼Œå› ä¸ºå…¶ä»–æ¨¡å—ä¹Ÿå¯¼å…¥ `core::num`ã€‚",
        "translate": ""
    },
    {
        "source": "Test whether truncating all bits less significant than `ones_place` introduces a relative error less, equal, or greater than 0.5 ULP.",
        "suggest": "æµ‹è¯•æ˜¯å¦å°†æ‰€æœ‰ä¸é‡è¦äº `ones_place` çš„ä½æˆªæ–­æ˜¯å¦å¼•å…¥äº†å°äºï¼Œç­‰äºæˆ–å¤§äº 0.5 ULP çš„ç›¸å¯¹è¯¯å·®ã€‚",
        "translate": ""
    },
    {
        "source": "If all remaining bits are zero, it's = 0.5 ULP, otherwise > 0.5 If there are no more bits (half_bit == 0), the below also correctly returns Equal.",
        "suggest": "å¦‚æœæ‰€æœ‰å‰©ä½™ä½å‡ä¸ºé›¶ï¼Œåˆ™ä¸º = 0.5 ULPï¼Œå¦åˆ™ > 0.5 å¦‚æœæ²¡æœ‰æ›´å¤šä½ (half_bit == 0)ï¼Œåˆ™ä»¥ä¸‹å†…å®¹ä¹Ÿå°†æ­£ç¡®è¿”å› Equalã€‚",
        "translate": ""
    },
    {
        "source": "Converts an ASCII string containing only decimal digits to a `u64`.",
        "suggest": "å°†ä»…åŒ…å«åè¿›åˆ¶æ•°å­—çš„ ASCII å­—ç¬¦ä¸²è½¬æ¢ä¸º `u64`ã€‚",
        "translate": ""
    },
    {
        "source": "Does not perform checks for overflow or invalid characters, so if the caller is not careful, the result is bogus and can panic (though it won't be `unsafe`).",
        "suggest": "ä¸æ£€æŸ¥æº¢å‡ºæˆ–æ— æ•ˆå­—ç¬¦ï¼Œå› æ­¤ï¼Œå¦‚æœè°ƒç”¨è€…ä¸å°å¿ƒï¼Œç»“æœå°†æ˜¯è™šå‡çš„ï¼Œå¹¶ä¸”å¯èƒ½ä¸º panic (å°½ç®¡ä¸ä¼šæ˜¯ `unsafe`)ã€‚",
        "translate": ""
    },
    {
        "source": "Additionally, empty strings are treated as zero.",
        "suggest": "æ­¤å¤–ï¼Œç©ºå­—ç¬¦ä¸²è¢«è§†ä¸ºé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "This function exists because",
        "suggest": "ä¹‹æ‰€ä»¥å­˜åœ¨è¯¥å‡½æ•°ï¼Œæ˜¯å› ä¸º",
        "translate": ""
    },
    {
        "source": "using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and",
        "suggest": "åœ¨ `&[u8]` ä¸Šä½¿ç”¨ `FromStr` éœ€è¦ `from_utf8_unchecked`ï¼Œè¿™å¾ˆç³Ÿç³•ï¼Œå¹¶ä¸”",
        "translate": ""
    },
    {
        "source": "piecing together the results of `integral.parse()` and `fractional.parse()` is more complicated than this entire function.",
        "suggest": "å°† `integral.parse()` å’Œ `fractional.parse()` çš„ç»“æœç»„åˆåœ¨ä¸€èµ·æ¯”æ•´ä¸ªå‡½æ•°è¦å¤æ‚å¾—å¤šã€‚",
        "translate": ""
    },
    {
        "source": "Converts a string of ASCII digits into a bignum.",
        "suggest": "å°† ASCII æ•°å­—å­—ç¬¦ä¸²è½¬æ¢ä¸º bignumã€‚",
        "translate": ""
    },
    {
        "source": "Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.",
        "suggest": "åƒ `from_str_unchecked` ä¸€æ ·ï¼Œæ­¤å‡½æ•°ä¾é è§£æå™¨æ¸…é™¤éæ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "Unwraps a bignum into a 64 bit integer.",
        "suggest": "å°† bignum è§£åŒ…ä¸º 64 ä½æ•´æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Panics if the number is too large.",
        "suggest": "Panics å¦‚æœæ•°å­—å¤ªå¤§ã€‚",
        "translate": ""
    },
    {
        "source": "Extracts a range of bits.",
        "suggest": "æå–ä¸€å®šèŒƒå›´çš„ä½ã€‚",
        "translate": ""
    },
    {
        "source": "Index 0 is the least significant bit and the range is half-open as usual.",
        "suggest": "ç´¢å¼• 0 æ˜¯æœ€ä½æœ‰æ•ˆä½ï¼Œå¹¶ä¸”è¯¥èŒƒå›´åƒå¾€å¸¸ä¸€æ ·æ˜¯åŠå¼€çš„ã€‚",
        "translate": ""
    },
    {
        "source": "Panics if asked to extract more bits than fit into the return type.",
        "suggest": "Panicsï¼Œå¦‚æœè¦æ±‚æå–è¶…å‡ºè¿”å›ç±»å‹çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Validating and decomposing a decimal string of the form:",
        "suggest": "éªŒè¯å¹¶åˆ†è§£ä»¥ä¸‹å½¢å¼çš„åè¿›åˆ¶å­—ç¬¦ä¸²:",
        "translate": ""
    },
    {
        "source": "In other words, standard floating-point syntax, with two exceptions: No sign, and no handling of \"inf\" and \"NaN\".",
        "suggest": "æ¢å¥è¯è¯´ï¼Œæ˜¯æ ‡å‡†çš„æµ®ç‚¹è¯­æ³•ï¼Œä½†æœ‰ä¸¤ä¸ªä¾‹å¤–: æ— ç¬¦å·ï¼Œå¹¶ä¸”ä¸å¤„ç† \"inf\" å’Œ \"NaN\"ã€‚",
        "translate": ""
    },
    {
        "source": "These are handled by the driver function (super::dec2flt).",
        "suggest": "è¿™äº›ç”±é©±åŠ¨ç¨‹åºå‡½æ•° (super::dec2flt) å¤„ç†ã€‚",
        "translate": ""
    },
    {
        "source": "Although recognizing valid inputs is relatively easy, this module also has to reject the countless invalid variations, never panic, and perform numerous checks that the other modules rely on to not panic (or overflow) in turn.",
        "suggest": "å°½ç®¡è¯†åˆ«æœ‰æ•ˆè¾“å…¥ç›¸å¯¹å®¹æ˜“ï¼Œä½†è¯¥æ¨¡å—è¿˜å¿…é¡»æ‹’ç»æ— æ•°æ— æ•ˆå˜é‡ï¼Œä»ä¸æ‹’ç» panicï¼Œå¹¶æ‰§è¡Œå…¶ä»–æ¨¡å—ä¸ä¾èµ–äº panic çš„å¤§é‡æ£€æŸ¥ (æˆ–æº¢å‡º)ã€‚",
        "translate": ""
    },
    {
        "source": "To make matters worse, all that happens in a single pass over the input.",
        "suggest": "æ›´ç³Ÿçš„æ˜¯ï¼Œæ‰€æœ‰è¿™äº›éƒ½åœ¨è¾“å…¥ä¸Šä¸€æ¬¡å®Œæˆã€‚",
        "translate": ""
    },
    {
        "source": "So, be careful when modifying anything, and double-check with the other modules.",
        "suggest": "å› æ­¤ï¼Œä¿®æ”¹ä»»ä½•å†…å®¹æ—¶éƒ½è¦å°å¿ƒï¼Œå¹¶ä»”ç»†æ£€æŸ¥å…¶ä»–æ¨¡å—ã€‚",
        "translate": ""
    },
    {
        "source": "The interesting parts of a decimal string.",
        "suggest": "åè¿›åˆ¶å­—ç¬¦ä¸²çš„æœ‰è¶£éƒ¨åˆ†ã€‚",
        "translate": ""
    },
    {
        "source": "The decimal exponent, guaranteed to have fewer than 18 decimal digits.",
        "suggest": "åè¿›åˆ¶æŒ‡æ•°ï¼Œä¿è¯å°‘äº 18 ä¸ªåè¿›åˆ¶æ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "Checks if the input string is a valid floating point number and if so, locate the integral part, the fractional part, and the exponent in it.",
        "suggest": "æ£€æŸ¥è¾“å…¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æµ®ç‚¹æ•°ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™åœ¨å…¶ä¸­æ‰¾åˆ°æ•´æ•°éƒ¨åˆ†ï¼Œå°æ•°éƒ¨åˆ†å’ŒæŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Does not handle signs.",
        "suggest": "ä¸å¤„ç†æ ‡å¿—ã€‚",
        "translate": ""
    },
    {
        "source": "No digits before 'e'",
        "suggest": "'e' ä¹‹å‰æ²¡æœ‰æ•°å­—",
        "translate": ""
    },
    {
        "source": "We require at least a single digit before or after the point.",
        "suggest": "åœ¨è¯¥ç‚¹ä¹‹å‰æˆ–ä¹‹åï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦ä¸€ä½æ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "Trailing junk after fractional part",
        "suggest": "å°æ•°éƒ¨åˆ†åçš„å°¾éšåƒåœ¾",
        "translate": ""
    },
    {
        "source": "Trailing junk after first digit string",
        "suggest": "ç¬¬ä¸€ä¸ªæ•°å­—å­—ç¬¦ä¸²åçš„ç»“å°¾åƒåœ¾",
        "translate": ""
    },
    {
        "source": "Carves off decimal digits up to the first non-digit character.",
        "suggest": "åˆ†å‰²åè¿›åˆ¶æ•°å­—ï¼Œç›´åˆ°ç¬¬ä¸€ä¸ªéæ•°å­—å­—ç¬¦ã€‚",
        "translate": ""
    },
    {
        "source": "Exponent extraction and error checking.",
        "suggest": "æŒ‡æ•°æå–å’Œé”™è¯¯æ£€æŸ¥ã€‚",
        "translate": ""
    },
    {
        "source": "Trailing junk after exponent",
        "suggest": "æŒ‡æ•°åçš„å°¾éšåƒåœ¾",
        "translate": ""
    },
    {
        "source": "Empty exponent",
        "suggest": "ç©ºæŒ‡æ•°",
        "translate": ""
    },
    {
        "source": "At this point, we certainly have a valid string of digits.",
        "suggest": "åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬å½“ç„¶æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—å­—ç¬¦ä¸²ã€‚",
        "translate": ""
    },
    {
        "source": "It may be too long to put into an `i64`, but if it's that huge, the input is certainly zero or infinity.",
        "suggest": "æ”¾å…¥ `i64` å¯èƒ½å¤ªé•¿äº†ï¼Œä½†å¦‚æœå¤ªå¤§ï¼Œåˆ™è¾“å…¥è‚¯å®šä¸ºé›¶æˆ–æ— ç©·å¤§ã€‚",
        "translate": ""
    },
    {
        "source": "Since each zero in the decimal digits only adjusts the exponent by +/- 1, at exp = 10^18 the input would have to be 17 exabyte (!) of zeros to get even remotely close to being finite.",
        "suggest": "ç”±äºåè¿›åˆ¶æ•°å­—ä¸­çš„æ¯ä¸ªé›¶ä»…å°†æŒ‡æ•°è°ƒæ•´ +/-1ï¼Œå› æ­¤åœ¨ exp=10 ^ 18 æ—¶ï¼Œè¾“å…¥å¿…é¡»ä¸º 17 exabyte (!) é›¶ï¼Œæ‰èƒ½å‡ ä¹æ¥è¿‘äºæœ‰é™å€¼ã€‚",
        "translate": ""
    },
    {
        "source": "This is not exactly a use case we need to cater to.",
        "suggest": "è¿™ä¸æ˜¯æˆ‘ä»¬éœ€è¦è¿åˆçš„ç”¨ä¾‹ã€‚",
        "translate": ""
    },
    {
        "source": "Bit fiddling on positive IEEE 754 floats.",
        "suggest": "æ­£å‘ IEEE 754 æµ®ç‚¹æ•°çš„ fiddlingã€‚",
        "translate": ""
    },
    {
        "source": "Negative numbers aren't and needn't be handled.",
        "suggest": "è´Ÿæ•°ä¸æ˜¯ï¼Œä¹Ÿä¸éœ€è¦å¤„ç†ã€‚",
        "translate": ""
    },
    {
        "source": "Normal floating point numbers have a canonical representation as (frac, exp) such that the value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.",
        "suggest": "æ™®é€šæµ®ç‚¹æ•°çš„è§„èŒƒè¡¨ç¤ºä¸º (fracï¼Œexp)ï¼Œå› æ­¤å€¼æ˜¯ 2 <sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>))ï¼Œå…¶ä¸­ N æ˜¯ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Subnormals are slightly different and weird, but the same principle applies.",
        "suggest": "Subnormals æ³•åˆ™ç•¥æœ‰ä¸åŒå’Œå¥‡æ€ªï¼Œä½†é€‚ç”¨ç›¸åŒçš„åŸç†ã€‚",
        "translate": ""
    },
    {
        "source": "Here, however, we represent them as (sig, k) with f positive, such that the value is f *",
        "suggest": "ä½†æ˜¯ï¼Œåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†å®ƒä»¬è¡¨ç¤ºä¸º (sigï¼Œk)ï¼Œä¸” f ä¸ºæ­£ï¼Œå› æ­¤å€¼ä¸º f *",
        "translate": ""
    },
    {
        "source": "2<sup>e</sup>. Besides making the \"hidden bit\" explicit, this changes the exponent by the so-called mantissa shift.",
        "suggest": "2 <sup>e</sup>ã€‚é™¤äº†ä½¿ \"hidden bit\" æ˜¾å¼æ˜¾ç¤ºä¹‹å¤–ï¼Œè¿™è¿˜é€šè¿‡æ‰€è°“çš„å°¾æ•°è½¬æ¢æ¥æ›´æ”¹æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Put another way, normally floats are written as (1) but here they are written as (2):",
        "suggest": "æ¢å¥è¯è¯´ï¼Œé€šå¸¸å°†æµ®ç‚¹æ•°å†™ä¸º (1)ï¼Œä½†åœ¨è¿™é‡Œå°†å®ƒä»¬å†™ä¸º (2):",
        "translate": ""
    },
    {
        "source": "We call (1) the **fractional representation** and (2) the **integral representation**.",
        "suggest": "æˆ‘ä»¬å°† (1) ç§°ä¸ºåˆ†æ•°è¡¨ç¤ºï¼Œå°† (2) ç§°ä¸ºç§¯åˆ†è¡¨ç¤ºã€‚",
        "translate": ""
    },
    {
        "source": "Many functions in this module only handle normal numbers.",
        "suggest": "æ­¤æ¨¡å—ä¸­çš„è®¸å¤šå‡½æ•°ä»…å¤„ç†æ™®é€šæ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The dec2flt routines conservatively take the universally-correct slow path (Algorithm M) for very small and very large numbers.",
        "suggest": "å¯¹äºéå¸¸å°çš„æ•°å­—å’Œéå¸¸å¤§çš„æ•°å­—ï¼Œdec2flt ä¾‹ç¨‹ä¿å®ˆåœ°é‡‡ç”¨é€šç”¨æ­£ç¡®çš„æ…¢è·¯å¾„ (ç®—æ³• M)ã€‚",
        "translate": ""
    },
    {
        "source": "That algorithm needs only next_float() which does handle subnormals and zeros.",
        "suggest": "è¯¥ç®—æ³•ä»…éœ€è¦ next_float()ï¼Œå³å¯å¤„ç†æ¬¡æ€å’Œé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.",
        "suggest": "ä¸€ä¸ªå¸®åŠ©ç¨‹åº traitï¼Œå¯ä»¥é¿å…åŸºæœ¬ä¸Šå¤åˆ¶ `f32` å’Œ `f64` çš„æ‰€æœ‰è½¬æ¢ä»£ç ã€‚",
        "translate": ""
    },
    {
        "source": "See the parent module's doc comment for why this is necessary.",
        "suggest": "æœ‰å…³ä¸ºä»€ä¹ˆè¿™æ ·åšçš„å¿…è¦ä¿¡æ¯ï¼Œè¯·å‚è§çˆ¶æ¨¡å—çš„æ–‡æ¡£æ³¨é‡Šã€‚",
        "translate": ""
    },
    {
        "source": "Should **never ever** be implemented for other types or be used outside the dec2flt module.",
        "suggest": "**æ°¸è¿œä¸è¦** ä¸ºå…¶ä»–ç±»å‹å®ç°æˆ–åœ¨ dec2flt æ¨¡å—å¤–éƒ¨ä½¿ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "Type used by `to_bits` and `from_bits`.",
        "suggest": "`to_bits` å’Œ `from_bits` ä½¿ç”¨çš„ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Performs a raw transmutation to an integer.",
        "suggest": "æ‰§è¡ŒåŸå§‹è½¬æ¢ä¸ºæ•´æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Performs a raw transmutation from an integer.",
        "suggest": "ä»æ•´æ•°æ‰§è¡ŒåŸå§‹è½¬æ¢ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the category that this number falls into.",
        "suggest": "è¿”å›æ­¤æ•°å­—æ‰€å±çš„ç±»åˆ«ã€‚",
        "translate": ""
    },
    {
        "source": "Returns the mantissa, exponent and sign as integers.",
        "suggest": "ä»¥æ•´æ•°å½¢å¼è¿”å›å°¾æ•°ï¼ŒæŒ‡æ•°å’Œç¬¦å·ã€‚",
        "translate": ""
    },
    {
        "source": "Decodes the float.",
        "suggest": "è§£ç æµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Casts from a small integer that can be represented exactly.",
        "suggest": "ä»å¯ä»¥ç²¾ç¡®è¡¨ç¤ºçš„å°æ•´æ•°è¿›è¡Œè½¬æ¢ã€‚",
        "translate": ""
    },
    {
        "source": "Panic if the integer can't be represented, the other code in this module makes sure to never let that happen.",
        "suggest": "Panic å¦‚æœæ— æ³•è¡¨ç¤ºæ•´æ•°ï¼Œåˆ™æ­¤æ¨¡å—ä¸­çš„å…¶ä»–ä»£ç ç¡®ä¿æ°¸ä¸è®©è¿™ç§æƒ…å†µå‘ç”Ÿã€‚",
        "translate": ""
    },
    {
        "source": "Gets the value 10<sup>e</sup> from a pre-computed table.",
        "suggest": "ä»é¢„å…ˆè®¡ç®—çš„è¡¨ä¸­è·å–å€¼ 10 <sup>e</sup>ã€‚",
        "translate": ""
    },
    {
        "source": "What the name says.",
        "suggest": "åå­—æ€ä¹ˆè¯´ã€‚",
        "translate": ""
    },
    {
        "source": "It's easier to hard code than juggling intrinsics and hoping LLVM constant folds it.",
        "suggest": "ç¡¬ç¼–ç æ¯”æ‚å‡‘å†…è”å‡½æ•°å’Œå¸Œæœ› LLVM å¸¸é‡å°†å…¶æŠ˜å èµ·æ¥å®¹æ˜“ã€‚",
        "translate": ""
    },
    {
        "source": "A conservative bound on the decimal digits of inputs that can't produce overflow or zero or",
        "suggest": "è¾“å…¥çš„å°æ•°ä½æ•°çš„ä¿å®ˆç•Œé™ï¼Œä¸ä¼šäº§ç”Ÿæº¢å‡ºæˆ–é›¶æˆ–",
        "translate": ""
    },
    {
        "source": "subnormals. Probably the decimal exponent of the maximum normal value, hence the name.",
        "suggest": "subnormalsã€‚å¯èƒ½æ˜¯æœ€å¤§å€¼çš„åè¿›åˆ¶æŒ‡æ•°ï¼Œå› æ­¤å¾—åã€‚",
        "translate": ""
    },
    {
        "source": "When the most significant decimal digit has a place value greater than this, the number is certainly rounded to infinity.",
        "suggest": "å½“æœ€é«˜æœ‰æ•ˆåè¿›åˆ¶æ•°å­—çš„ä½æ•°å¤§äºè¯¥æ•°å€¼æ—¶ï¼Œè¯¥æ•°å­—è‚¯å®šä¼šå››èˆäº”å…¥ä¸ºæ— ç©·å¤§ã€‚",
        "translate": ""
    },
    {
        "source": "When the most significant decimal digit has a place value less than this, the number is certainly rounded to zero.",
        "suggest": "å½“æœ€é«˜æœ‰æ•ˆåè¿›åˆ¶æ•°å­—çš„ä½æ•°å°äºæ­¤ä½æ•°æ—¶ï¼Œè¯¥æ•°å­—è‚¯å®šä¼šå››èˆäº”å…¥ä¸ºé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "The number of bits in the exponent.",
        "suggest": "æŒ‡æ•°ä¸­çš„ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The number of bits in the significand, *including* the hidden bit.",
        "suggest": "æœ‰æ•ˆä½æ•°çš„ä½æ•°ï¼Œ*åŒ…æ‹¬* éšè—ä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The number of bits in the significand, *excluding* the hidden bit.",
        "suggest": "æœ‰æ•ˆä½æ•°çš„ä½æ•°ï¼Œ*ä¸åŒ…æ‹¬* éšè—ä½ã€‚",
        "translate": ""
    },
    {
        "source": "The maximum legal exponent in fractional representation.",
        "suggest": "å°æ•°è¡¨ç¤ºå½¢å¼ä¸­çš„æœ€å¤§åˆæ³•æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The minimum legal exponent in fractional representation, excluding subnormals.",
        "suggest": "åˆ†æ•°è¡¨ç¤ºå½¢å¼ä¸­çš„æœ€å°åˆæ³•æŒ‡æ•°ï¼Œä¸åŒ…æ‹¬æ¬¡æ­£è§„æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "for integral representation, i.e., with the shift applied.",
        "suggest": "ç”¨äºç§¯åˆ†è¡¨ç¤ºï¼Œå³åº”ç”¨äº†ç§»ä½ã€‚",
        "translate": ""
    },
    {
        "source": "encoded (i.e., with offset bias)",
        "suggest": "ç¼–ç  (å³å…·æœ‰åç§»åç½®)",
        "translate": ""
    },
    {
        "source": "The maximum normalized significand in integral representation.",
        "suggest": "æ•´æ•°è¡¨ç¤ºå½¢å¼ä¸­çš„æœ€å¤§å½’ä¸€åŒ–æœ‰æ•ˆä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The minimal normalized significand in integral representation.",
        "suggest": "æ•´æ•°è¡¨ç¤ºå½¢å¼ä¸­çš„æœ€å°å½’ä¸€åŒ–æœ‰æ•ˆä½æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Mostly a workaround for #34344.",
        "suggest": "é€šå¸¸æ˜¯ #34344 çš„è§£å†³æ–¹æ³•ã€‚",
        "translate": ""
    },
    {
        "source": "Exponent bias + mantissa shift",
        "suggest": "æŒ‡æ•°åå·® + å°¾æ•°åç§»",
        "translate": ""
    },
    {
        "source": "rkruppe is uncertain whether `as` rounds correctly on all platforms.",
        "suggest": "rkruppe ä¸ç¡®å®š `as` æ˜¯å¦åœ¨æ‰€æœ‰å¹³å°ä¸Šéƒ½èƒ½æ­£ç¡®å–æ•´ã€‚",
        "translate": ""
    },
    {
        "source": "Converts an `Fp` to the closest machine float type.",
        "suggest": "å°† `Fp` è½¬æ¢ä¸ºæœ€æ¥è¿‘çš„æœºå™¨æµ®ç‚¹ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Does not handle subnormal results.",
        "suggest": "ä¸å¤„ç†ä¸æ­£å¸¸çš„ç»“æœã€‚",
        "translate": ""
    },
    {
        "source": "is 64 bit, so x.e has a mantissa shift of 63",
        "suggest": "æ˜¯ 64 ä½ï¼Œå› æ­¤ x.e çš„å°¾æ•°åç§»ä¸º 63",
        "translate": ""
    },
    {
        "source": "Round the 64-bit significand to T::SIG_BITS bits with half-to-even.",
        "suggest": "å°† 64 ä½æœ‰æ•ˆä½æ•°å››èˆäº”å…¥ä¸º T::SIG_BITS ä½ã€‚",
        "translate": ""
    },
    {
        "source": "Does not handle exponent overflow.",
        "suggest": "ä¸å¤„ç†æŒ‡æ•°æº¢å‡ºã€‚",
        "translate": ""
    },
    {
        "source": "Adjust mantissa shift",
        "suggest": "è°ƒæ•´å°¾æ•°åç§»",
        "translate": ""
    },
    {
        "source": "Inverse of `RawFloat::unpack()` for normalized numbers.",
        "suggest": "`RawFloat::unpack()` çš„å€’æ•°ï¼Œç”¨äºå½’ä¸€åŒ–çš„æ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "Panics if the significand or exponent are not valid for normalized numbers.",
        "suggest": "Panics (å¦‚æœæœ‰æ•ˆä½æ•°æˆ–æŒ‡æ•°å¯¹äºæ ‡å‡†åŒ–æ•°å­—æ— æ•ˆ)ã€‚",
        "translate": ""
    },
    {
        "source": "Remove the hidden bit",
        "suggest": "åˆ é™¤éšè—çš„ä½",
        "translate": ""
    },
    {
        "source": "Adjust the exponent for exponent bias and mantissa shift",
        "suggest": "è°ƒæ•´æŒ‡æ•°ä»¥å®ç°æŒ‡æ•°åå·®å’Œå°¾æ•°åç§»",
        "translate": ""
    },
    {
        "source": "Leave sign bit at 0 (\"+\"), our numbers are all positive",
        "suggest": "åœ¨ 0 (\"+\") å¤„ä¿ç•™ç¬¦å·ä½ï¼Œæˆ‘ä»¬çš„æ•°å­—å‡ä¸ºæ­£",
        "translate": ""
    },
    {
        "source": "Construct a subnormal.",
        "suggest": "åˆ›å»ºä¸€ä¸ªæ¬¡æ­£è§„çš„ã€‚",
        "translate": ""
    },
    {
        "source": "A mantissa of 0 is allowed and constructs zero.",
        "suggest": "å…è®¸å°¾æ•°ä¸º 0ï¼Œæ„é€ ä¸º 0ã€‚",
        "translate": ""
    },
    {
        "source": "Encoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.",
        "suggest": "ç¼–ç æŒ‡æ•°ä¸º 0ï¼Œç¬¦å·ä½ä¸º 0ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦é‡æ–°è§£é‡Šè¿™äº›ä½å³å¯ã€‚",
        "translate": ""
    },
    {
        "source": "Approximate a bignum with an Fp.",
        "suggest": "å¤§çº¦æœ‰ Fp çš„ bignumã€‚",
        "translate": ""
    },
    {
        "source": "Rounds within 0.5 ULP with half-to-even.",
        "suggest": "åœ¨ 0.5 ULP ä¸­å››èˆäº”å…¥è‡³åŠæ•°ã€‚",
        "translate": ""
    },
    {
        "source": "We cut off all bits prior to the index `start`, i.e., we effectively right-shift by an amount of `start`, so this is also the exponent we need.",
        "suggest": "æˆ‘ä»¬å°†ç´¢å¼• `start` ä¹‹å‰çš„æ‰€æœ‰ä½éƒ½åˆ‡é™¤ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å®é™…ä¸Šå³ç§»äº† `start`ï¼Œå› æ­¤è¿™ä¹Ÿæ˜¯æˆ‘ä»¬éœ€è¦çš„æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Round (half-to-even) depending on the truncated bits.",
        "suggest": "æ ¹æ®æˆªæ–­çš„ä½èˆå…¥ (half-to-even)ã€‚",
        "translate": ""
    },
    {
        "source": "Finds the largest floating point number strictly smaller than the argument.",
        "suggest": "æŸ¥æ‰¾ä¸¥æ ¼å°äºå‚æ•°çš„æœ€å¤§æµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Does not handle subnormals, zero, or exponent underflow.",
        "suggest": "ä¸å¤„ç†æ¬¡æ­£è§„é‡ï¼Œé›¶æˆ–æŒ‡æ•°ä¸‹æº¢ã€‚",
        "translate": ""
    },
    {
        "source": "Find the smallest floating point number strictly larger than the argument.",
        "suggest": "æ‰¾åˆ°ä¸¥æ ¼å¤§äºå‚æ•°çš„æœ€å°æµ®ç‚¹æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This operation is saturating, i.e., next_float(inf) == inf.",
        "suggest": "æ­¤æ“ä½œé¥±å’Œï¼Œå³ next_float(inf) == infã€‚",
        "translate": ""
    },
    {
        "source": "Unlike most code in this module, this function does handle zero, subnormals, and infinities.",
        "suggest": "ä¸è¯¥æ¨¡å—ä¸­çš„å¤§å¤šæ•°ä»£ç ä¸åŒï¼Œæ­¤å‡½æ•°ç¡®å®å¤„ç†é›¶ï¼Œæ¬¡æ­£æ€å’Œæ— ç©·å¤§ã€‚",
        "translate": ""
    },
    {
        "source": "However, like all other code here, it does not deal with NaN and negative numbers.",
        "suggest": "ä½†æ˜¯ï¼Œåƒè¿™é‡Œçš„æ‰€æœ‰å…¶ä»–ä»£ç ä¸€æ ·ï¼Œå®ƒä¸å¤„ç† NaN å’Œè´Ÿæ•°ã€‚",
        "translate": ""
    },
    {
        "source": "This seems too good to be true, but it works.",
        "suggest": "è¿™ä¼¼ä¹å¤ªå¥½äº†ï¼Œéš¾ä»¥ç½®ä¿¡ï¼Œä½†å®ƒç¡®å®æœ‰æ•ˆã€‚",
        "translate": ""
    },
    {
        "source": "is encoded as the all-zero word.",
        "suggest": "è¢«ç¼–ç ä¸ºå…¨é›¶å­—ã€‚",
        "translate": ""
    },
    {
        "source": "subnormals are 0x000m...m where m is the mantissa.",
        "suggest": "subnormals ä¸º 0x000m...mï¼Œå…¶ä¸­ m ä¸ºå°¾æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F.",
        "suggest": "ç‰¹åˆ«æ˜¯ï¼Œæœ€å°çš„æ¬¡æ­£è§„å€¼ä¸º 0x0...01ï¼Œæœ€å¤§çš„ä¸º 0x000F...Fã€‚",
        "translate": ""
    },
    {
        "source": "The smallest normal number is 0x0010...0, so this corner case works as well.",
        "suggest": "æœ€å°çš„æ­£å¸¸æ•°å­—æ˜¯ 0x0010...0ï¼Œæ‰€ä»¥è¿™ä¸ªæç«¯æƒ…å†µä¹Ÿé€‚ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "If the increment overflows the mantissa, the carry bit increments the exponent as we want, and the mantissa bits become zero.",
        "suggest": "å¦‚æœå¢é‡ä½¿å°¾æ•°æº¢å‡ºï¼Œåˆ™è¿›ä½å°†æ ¹æ®éœ€è¦é€’å¢æŒ‡æ•°ï¼Œå¹¶ä¸”å°¾æ•°ä½å˜ä¸ºé›¶ã€‚",
        "translate": ""
    },
    {
        "source": "Because of the hidden bit convention, this too is exactly what we want!",
        "suggest": "ç”±äºéšè—çš„ä½çº¦å®šï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬æƒ³è¦çš„!",
        "translate": ""
    },
    {
        "source": "Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.",
        "suggest": "æœ€åï¼Œ`f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY`ã€‚",
        "translate": ""
    },
    {
        "source": "Tables of approximations of powers of ten.",
        "suggest": "åæ¬¡å¹‚çš„è¿‘ä¼¼è¡¨ã€‚",
        "translate": ""
    },
    {
        "source": "DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`",
        "suggest": "ä¸ä¿®æ”¹: ç”± `src/etc/dec2flt_table.py` ç”Ÿæˆ",
        "translate": ""
    },
    {
        "source": "Extended precision \"soft float\", for internal use only.",
        "suggest": "æ‰©å±•ç²¾åº¦ \"soft float\"ï¼Œä»…ä¾›å†…éƒ¨ä½¿ç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "A custom 64-bit floating point type, representing `f * 2^e`.",
        "suggest": "è‡ªå®šä¹‰çš„ 64 ä½æµ®ç‚¹ç±»å‹ï¼Œè¡¨ç¤º `f * 2^e`ã€‚",
        "translate": ""
    },
    {
        "source": "The integer mantissa.",
        "suggest": "æ•´æ•°å°¾æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "The exponent in base 2.",
        "suggest": "ä»¥ 2 ä¸ºåº•çš„æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "Returns a correctly rounded product of itself and `other`.",
        "suggest": "è¿”å›å…¶è‡ªèº«å’Œ `other` çš„æ­£ç¡®èˆå…¥ä¹˜ç§¯ã€‚",
        "translate": ""
    },
    {
        "source": "Normalizes itself so that the resulting mantissa is at least `2^63`.",
        "suggest": "å¯¹å…¶è‡ªèº«è¿›è¡Œè§„èŒƒåŒ–ï¼Œä»¥ä½¿æ‰€å¾—çš„å°¾æ•°è‡³å°‘ä¸º `2^63`ã€‚",
        "translate": ""
    },
    {
        "source": "Normalizes itself to have the shared exponent.",
        "suggest": "æ ‡å‡†åŒ–è‡ªå·±ä»¥å…·æœ‰å…±äº«æŒ‡æ•°ã€‚",
        "translate": ""
    },
    {
        "source": "It can only decrease the exponent (and thus increase the mantissa).",
        "suggest": "å®ƒåªèƒ½å‡å°‘æŒ‡æ•° (ä»è€Œå¢åŠ å°¾æ•°)ã€‚",
        "translate": ""
    },
    {
        "source": "Error types for conversion to integral types.",
        "suggest": "è½¬æ¢ä¸ºæ•´æ•°ç±»å‹çš„é”™è¯¯ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "The error type returned when a checked integral type conversion fails.",
        "suggest": "å½“æ£€æŸ¥çš„æ•´æ•°ç±»å‹è½¬æ¢å¤±è´¥æ—¶ï¼Œè¿”å›é”™è¯¯ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Match rather than coerce to make sure that code like `From<Infallible> for TryFromIntError` above will keep working when `Infallible` becomes an alias to `!`.",
        "suggest": "åŒ¹é…è€Œä¸æ˜¯å¼ºåˆ¶ï¼Œä»¥ç¡®ä¿å½“ `Infallible` æˆä¸º `!` çš„åˆ«åæ—¶ï¼Œä¸Šè¿° `From<Infallible> for TryFromIntError` è¿™æ ·çš„ä»£ç å°†ç»§ç»­èµ·ä½œç”¨ã€‚",
        "translate": ""
    },
    {
        "source": "An error which can be returned when parsing an integer.",
        "suggest": "è§£ææ•´æ•°æ—¶å¯ä»¥è¿”å›çš„é”™è¯¯ã€‚",
        "translate": ""
    },
    {
        "source": "This error is used as the error type for the `from_str_radix()` functions on the primitive integer types, such as [`i8::from_str_radix`].",
        "suggest": "æ­¤é”™è¯¯ç”¨ä½œåŸå§‹æ•´æ•°ç±»å‹ (ä¾‹å¦‚ [`i8::from_str_radix`]) ä¸Š `from_str_radix()` å‡½æ•°çš„é”™è¯¯ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Potential causes",
        "suggest": "æ½œåœ¨åŸå› ",
        "translate": ""
    },
    {
        "source": "Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace in the string e.g., when it is obtained from the standard input.",
        "suggest": "é™¤å…¶ä»–åŸå› å¤–ï¼Œä¾‹å¦‚ï¼Œå½“ä»æ ‡å‡†è¾“å…¥ä¸­è·å– `ParseIntError` æ—¶ï¼Œå¯èƒ½ä¼šç”±äºå­—ç¬¦ä¸²ä¸­çš„å‰å¯¼æˆ–å°¾éšç©ºæ ¼è€ŒæŠ›å‡º `ParseIntError`ã€‚",
        "translate": ""
    },
    {
        "source": "Using the [`str::trim()`] method ensures that no whitespace remains before parsing.",
        "suggest": "ä½¿ç”¨ [`str::trim()`] æ–¹æ³•å¯ç¡®ä¿åœ¨è§£æä¹‹å‰ä¸ç•™ç©ºæ ¼ã€‚",
        "translate": ""
    },
    {
        "source": "Enum to store the various types of errors that can cause parsing an integer to fail.",
        "suggest": "æšä¸¾å­˜å‚¨å„ç§ç±»å‹çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯å¯èƒ½å¯¼è‡´è§£ææ•´æ•°å¤±è´¥ã€‚",
        "translate": ""
    },
    {
        "source": "Value being parsed is empty.",
        "suggest": "è¢«è§£æçš„å€¼æ˜¯ç©ºçš„ã€‚",
        "translate": ""
    },
    {
        "source": "Among other causes, this variant will be constructed when parsing an empty string.",
        "suggest": "é™¤å…¶ä»–åŸå› å¤–ï¼Œè§£æç©ºå­—ç¬¦ä¸²æ—¶ä¼šåˆ›å»ºè¿™ä¸ªå˜é‡ã€‚",
        "translate": ""
    },
    {
        "source": "Contains an invalid digit in its context.",
        "suggest": "åœ¨å…¶ä¸Šä¸‹æ–‡ä¸­åŒ…å«æ— æ•ˆæ•°å­—ã€‚",
        "translate": ""
    },
    {
        "source": "Among other causes, this variant will be constructed when parsing a string that contains a non-ASCII char.",
        "suggest": "é™¤å…¶ä»–åŸå› å¤–ï¼Œå½“è§£æåŒ…å«é ASCII å­—ç¬¦çš„å­—ç¬¦ä¸²æ—¶ï¼Œå°†åˆ›å»ºè¿™ä¸ªå˜é‡ã€‚",
        "translate": ""
    },
    {
        "source": "This variant is also constructed when a `+` or `-` is misplaced within a string either on its own or in the middle of a number.",
        "suggest": "å½“ `+` æˆ– `-` å•ç‹¬æ”¾ç½®åœ¨å­—ç¬¦ä¸²ä¸­æˆ–æ”¾ç½®åœ¨æ•°å­—ä¸­é—´æ—¶ï¼Œä¹Ÿä¼šåˆ›å»ºæ­¤å˜é‡ã€‚",
        "translate": ""
    },
    {
        "source": "Integer is too large to store in target integer type.",
        "suggest": "æ•´æ•°å¤ªå¤§ï¼Œæ— æ³•å­˜å‚¨ä¸ºç›®æ ‡æ•´æ•°ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Integer is too small to store in target integer type.",
        "suggest": "æ•´æ•°å¤ªå°ï¼Œæ— æ³•å­˜å‚¨ä¸ºç›®æ ‡æ•´æ•°ç±»å‹ã€‚",
        "translate": ""
    },
    {
        "source": "Value was Zero",
        "suggest": "å€¼ä¸ºé›¶",
        "translate": ""
    },
    {
        "source": "This variant will be emitted when the parsing string has a value of zero, which would be illegal for non-zero types.",
        "suggest": "å½“è§£æå­—ç¬¦ä¸²çš„å€¼ä¸ºé›¶æ—¶å°†å‘å‡ºæ­¤æˆå‘˜ï¼Œè¿™å¯¹äºéé›¶ç±»å‹æ˜¯éæ³•çš„ã€‚",
        "translate": ""
    }
]
