[
    {
        "source": "Write this post padding.",
        "suggest": "写这篇文章补充。",
        "translate": ""
    },
    {
        "source": "We want to change this",
        "suggest": "我们要改变这个",
        "translate": ""
    },
    {
        "source": "And preserve these",
        "suggest": "并保留这些",
        "translate": ""
    },
    {
        "source": "Helper methods used for padding and processing formatting arguments that all formatting traits can use.",
        "suggest": "用于填充和处理格式化参数的辅助方法，所有格式化 traits 都可以使用。",
        "translate": ""
    },
    {
        "source": "Performs the correct padding for an integer which has already been emitted into a str.",
        "suggest": "对已经发出到 str 中的整数执行正确的填充。",
        "translate": ""
    },
    {
        "source": "The str should *not* contain the sign for the integer, that will be added by this method.",
        "suggest": "str *不应* 包含整数的符号，该符号将通过此方法添加。",
        "translate": ""
    },
    {
        "source": "is_nonnegative - whether the original integer was either positive or zero.",
        "suggest": "is_nonnegative - 原始整数是正数还是零。",
        "translate": ""
    },
    {
        "source": "prefix - if the '#' character (Alternate) is provided, this is the prefix to put in front of the number.",
        "suggest": "prefix - 如果提供了 '#' 字符 (Alternate)，则这是放在数字前面的前缀。",
        "translate": ""
    },
    {
        "source": "buf - the byte array that the number has been formatted into",
        "suggest": "buf - 数字已格式化为的字节数组",
        "translate": ""
    },
    {
        "source": "This function will correctly account for the flags provided as well as the minimum width.",
        "suggest": "此函数将正确说明提供的标志以及最小宽度。",
        "translate": ""
    },
    {
        "source": "It will not take precision into account.",
        "suggest": "它不会考虑精度。",
        "translate": ""
    },
    {
        "source": "Writes the sign if it exists, and then the prefix if it was requested",
        "suggest": "写入符号 (如果存在)，然后写入前缀 (如果已请求)",
        "translate": ""
    },
    {
        "source": "The `width` field is more of a `min-width` parameter at this point.",
        "suggest": "此时，`width` 字段更多是 `min-width` 参数。",
        "translate": ""
    },
    {
        "source": "If there's no minimum length requirements then we can just write the bytes.",
        "suggest": "如果没有最小长度要求，那么我们可以写字节。",
        "translate": ""
    },
    {
        "source": "Check if we're over the minimum width, if so then we can also just write the bytes.",
        "suggest": "检查是否超过最小宽度，如果是，那么我们也可以只写字节。",
        "translate": ""
    },
    {
        "source": "The sign and prefix goes before the padding if the fill character is zero",
        "suggest": "如果填充字符为零，则符号和前缀位于填充之前",
        "translate": ""
    },
    {
        "source": "Otherwise, the sign and prefix goes after the padding",
        "suggest": "否则，符号和前缀在填充之后",
        "translate": ""
    },
    {
        "source": "This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified.",
        "suggest": "应用指定的相关格式设置标志后，此函数将获取一个字符串片段并将其发送到内部缓冲区。",
        "translate": ""
    },
    {
        "source": "The flags recognized for generic strings are:",
        "suggest": "泛型字符串可识别的标志为:",
        "translate": ""
    },
    {
        "source": "width - the minimum width of what to emit",
        "suggest": "width - 发射的最小宽度",
        "translate": ""
    },
    {
        "source": "what to emit and where to emit it if the string provided needs to be padded",
        "suggest": "如果提供的字符串需要填充，发出什么以及在哪里发出",
        "translate": ""
    },
    {
        "source": "precision - the maximum length to emit, the string is truncated if it is longer than this length",
        "suggest": "precision - 发出的最大长度，如果字符串长于该长度，则字符串将被截断",
        "translate": ""
    },
    {
        "source": "Notably this function ignores the `flag` parameters.",
        "suggest": "值得注意的是，此函数将忽略 `flag` 参数。",
        "translate": ""
    },
    {
        "source": "Make sure there's a fast path up front",
        "suggest": "确保前面有一条快速路",
        "translate": ""
    },
    {
        "source": "The `precision` field can be interpreted as a `max-width` for the string being formatted.",
        "suggest": "对于要格式化的字符串，`precision` 字段可以解释为 `max-width`。",
        "translate": ""
    },
    {
        "source": "If our string is longer that the precision, then we must have truncation.",
        "suggest": "如果我们的字符串比精度更长，那么我们必须将其截断。",
        "translate": ""
    },
    {
        "source": "However other flags like `fill`, `width` and `align` must act as always.",
        "suggest": "但是，其他标志 (例如 `fill`，`width` 和 `align`) 必须照常运行。",
        "translate": ""
    },
    {
        "source": "LLVM here can't prove that `..i` won't panic `&s[..i]`, but we know that it can't panic.",
        "suggest": "此处的 LLVM 不能证明 `..i` 不会 panic `&s[..i]`，但是我们知道它不能 panic。",
        "translate": ""
    },
    {
        "source": "Use `get` + `unwrap_or` to avoid `unsafe` and otherwise don't emit any panic-related code here.",
        "suggest": "使用 `get` + `unwrap_or` 避免使用 `unsafe`，否则请不要在此处发出任何与 panic 相关的代码。",
        "translate": ""
    },
    {
        "source": "If we're under the maximum length, and there's no minimum length requirements, then we can just emit the string",
        "suggest": "如果我们在最大长度以下，并且没有最小长度要求，那么我们就可以发出字符串",
        "translate": ""
    },
    {
        "source": "If we're under the maximum width, check if we're over the minimum width, if so it's as easy as just emitting the string.",
        "suggest": "如果我们在最大宽度之下，请检查我们是否在最小宽度之上，如果是，那么就和发出字符串一样容易。",
        "translate": ""
    },
    {
        "source": "If we're under both the maximum and the minimum width, then fill up the minimum width with the specified string + some alignment.",
        "suggest": "如果我们同时处于最大和最小宽度之下，则使用指定的字符串 + 某些对齐方式来填充最小宽度。",
        "translate": ""
    },
    {
        "source": "Write the pre-padding and return the unwritten post-padding.",
        "suggest": "编写前填充并返回未写的后填充。",
        "translate": ""
    },
    {
        "source": "Callers are responsible for ensuring post-padding is written after the thing that is being padded.",
        "suggest": "调用者有责任确保在填充内容之后编写填充后的内容。",
        "translate": ""
    },
    {
        "source": "Takes the formatted parts and applies the padding.",
        "suggest": "取出格式化的部分并应用填充。",
        "translate": ""
    },
    {
        "source": "Assumes that the caller already has rendered the parts with required precision, so that `self.precision` can be ignored.",
        "suggest": "假定调用者已经以所需的精度渲染了零件，因此可以忽略 `self.precision`。",
        "translate": ""
    },
    {
        "source": "for the sign-aware zero padding, we render the sign first and behave as if we had no sign from the beginning.",
        "suggest": "对于可识别符号的零填充，我们首先渲染符号，然后从一开始就表现为没有符号。",
        "translate": ""
    },
    {
        "source": "a sign always goes first",
        "suggest": "符号总是最先",
        "translate": ""
    },
    {
        "source": "remove the sign from the formatted parts",
        "suggest": "从格式化部分中删除符号",
        "translate": ""
    },
    {
        "source": "remaining parts go through the ordinary padding process.",
        "suggest": "其余部分则经过普通的填充过程。",
        "translate": ""
    },
    {
        "source": "no padding",
        "suggest": "没有填充",
        "translate": ""
    },
    {
        "source": "this is the common case and we take a shortcut",
        "suggest": "这是常见的情况，我们采取捷径",
        "translate": ""
    },
    {
        "source": "This is used for `flt2dec::Part::Num` and `flt2dec::Part::Copy`.",
        "suggest": "这用于 `flt2dec::Part::Num` 和 `flt2dec::Part::Copy`。",
        "translate": ""
    },
    {
        "source": "It's safe to use for `flt2dec::Part::Num` since every char `c` is between `b'0'` and `b'9'`, which means `s` is valid UTF-8.",
        "suggest": "`flt2dec::Part::Num` 可以安全使用，因为每个字符 `c` 都在 `b'0'` 和 `b'9'` 之间，这意味着 `s` 是有效的 UTF-8。",
        "translate": ""
    },
    {
        "source": "It's also probably safe in practice to use for `flt2dec::Part::Copy(buf)` since `buf` should be plain ASCII, but it's possible for someone to pass in a bad value for `buf` into `flt2dec::to_shortest_str` since it is a public function.",
        "suggest": "实际上，在 `flt2dec::Part::Copy(buf)` 上使用 `flt2dec::Part::Copy(buf)` 也是安全的，因为 `buf` 应该是纯 ASCII，但是由于 `buf` 是公共函数，因此可能有人将 `buf` 的错误值传递给 `flt2dec::to_shortest_str`。",
        "translate": ""
    },
    {
        "source": "Determine whether this could result in UB.",
        "suggest": "确定这是否会导致 UB。",
        "translate": ""
    },
    {
        "source": "64 zeroes",
        "suggest": "64 个零",
        "translate": ""
    },
    {
        "source": "Writes some data to the underlying buffer contained within this formatter.",
        "suggest": "将一些数据写入此格式化程序中包含的基础缓冲区。",
        "translate": ""
    },
    {
        "source": "Writes some formatted information into this instance.",
        "suggest": "将一些格式化的信息写入此实例。",
        "translate": ""
    },
    {
        "source": "Flags for formatting",
        "suggest": "格式化标志",
        "translate": ""
    },
    {
        "source": "Character used as 'fill' whenever there is alignment.",
        "suggest": "对齐时用作 'fill' 的字符。",
        "translate": ""
    },
    {
        "source": "Flag indicating what form of alignment was requested.",
        "suggest": "指示请求对齐方式的标志。",
        "translate": ""
    },
    {
        "source": "Optionally specified integer width that the output should be.",
        "suggest": "(可选) 指定输出应为的整数宽度。",
        "translate": ""
    },
    {
        "source": "Optionally specified precision for numeric types.",
        "suggest": "可选地为数字类型指定精度。",
        "translate": ""
    },
    {
        "source": "Alternatively, the maximum width for string types.",
        "suggest": "或者，为字符串类型的最大宽度。",
        "translate": ""
    },
    {
        "source": "Determines if the `+` flag was specified.",
        "suggest": "确定是否指定了 `+` 标志。",
        "translate": ""
    },
    {
        "source": "Determines if the `-` flag was specified.",
        "suggest": "确定是否指定了 `-` 标志。",
        "translate": ""
    },
    {
        "source": "Determines if the `#` flag was specified.",
        "suggest": "确定是否指定了 `#` 标志。",
        "translate": ""
    },
    {
        "source": "Determines if the `0` flag was specified.",
        "suggest": "确定是否指定了 `0` 标志。",
        "translate": ""
    },
    {
        "source": "Decide what public API we want for these two flags.",
        "suggest": "确定我们要为这两个标志使用的公共 API。",
        "translate": ""
    },
    {
        "source": "Creates a [`DebugStruct`] builder designed to assist with creation of [`fmt::Debug`] implementations for structs.",
        "suggest": "创建一个 [`DebugStruct`] 构建器，该构建器旨在帮助创建结构体的 [`fmt::Debug`] 实现。",
        "translate": ""
    },
    {
        "source": "Creates a `DebugTuple` builder designed to assist with creation of `fmt::Debug` implementations for tuple structs.",
        "suggest": "创建一个 `DebugTuple` 构建器，该构建器旨在协助创建元组结构体的 `fmt::Debug` 实现。",
        "translate": ""
    },
    {
        "source": "Creates a `DebugList` builder designed to assist with creation of `fmt::Debug` implementations for list-like structures.",
        "suggest": "创建一个 `DebugList` 构建器，该构建器旨在帮助为类似列表的结构创建 `fmt::Debug` 实现。",
        "translate": ""
    },
    {
        "source": "Creates a `DebugSet` builder designed to assist with creation of `fmt::Debug` implementations for set-like structures.",
        "suggest": "创建一个 `DebugSet` 构建器，该构建器旨在帮助为类似集合的结构创建 `fmt::Debug` 实现。",
        "translate": ""
    },
    {
        "source": "In this more complex example, we use [`format_args!`] and `.debug_set()` to build a list of match arms:",
        "suggest": "在这个更复杂的示例中，我们使用 [`format_args!`] 和 `.debug_set()` 来构建匹配分支的列表:",
        "translate": ""
    },
    {
        "source": "Creates a `DebugMap` builder designed to assist with creation of `fmt::Debug` implementations for map-like structures.",
        "suggest": "创建一个 `DebugMap` 构建器，该构建器旨在帮助为类似 map 的结构创建 `fmt::Debug` 实现。",
        "translate": ""
    },
    {
        "source": "Implementations of the core formatting traits",
        "suggest": "核心格式 traits 的实现",
        "translate": ""
    },
    {
        "source": "If char needs escaping, flush backlog so far and write, else skip",
        "suggest": "如果 char 需要转义，请清除到目前为止的积压并编写，否则跳过",
        "translate": ""
    },
    {
        "source": "The alternate flag is already treated by LowerHex as being special- it denotes whether to prefix with 0x.",
        "suggest": "LowerHex 已将替代标志视为特殊标志，它表示是否以 0x 作为前缀。",
        "translate": ""
    },
    {
        "source": "We use it to work out whether or not to zero extend, and then unconditionally set it to get the prefix.",
        "suggest": "我们使用它来计算是否为零扩展，然后无条件地将其设置为获取前缀。",
        "translate": ""
    },
    {
        "source": "Implementation of Display/Debug for various core types",
        "suggest": "Display/Debug 在各种核心类型上的实现",
        "translate": ""
    },
    {
        "source": "The RefCell is mutably borrowed so we can't look at its value here.",
        "suggest": "RefCell 是可变地借用的，因此我们在这里无法查看其值。",
        "translate": ""
    },
    {
        "source": "Show a placeholder instead.",
        "suggest": "改为显示一个占位符。",
        "translate": ""
    },
    {
        "source": "If you expected tests to be here, look instead at the core/tests/fmt.rs file, it's a lot easier than creating all of the rt::Piece structures here.",
        "suggest": "如果您希望测试在这里，请查看 core/tests/fmt.rs 文件，这比在此处创建所有 rt::Piece 结构要容易得多。",
        "translate": ""
    },
    {
        "source": "There are also tests in the alloc crate, for those that need allocations.",
        "suggest": "alloc crate 中也有测试，用于那些需要分配的测试。",
        "translate": ""
    },
    {
        "source": "Integer and floating-point number formatting",
        "suggest": "整数和浮点数格式",
        "translate": ""
    },
    {
        "source": "A type that represents a specific radix",
        "suggest": "代表特定基数的类型",
        "translate": ""
    },
    {
        "source": "The number of digits.",
        "suggest": "数字位数。",
        "translate": ""
    },
    {
        "source": "A radix-specific prefix string.",
        "suggest": "一个特定于基数的前缀字符串。",
        "translate": ""
    },
    {
        "source": "Converts an integer to corresponding radix digit.",
        "suggest": "将整数转换为相应的基数数字。",
        "translate": ""
    },
    {
        "source": "Format an integer using the radix using a formatter.",
        "suggest": "使用格式化程序使用基数格式化整数。",
        "translate": ""
    },
    {
        "source": "The radix can be as low as 2, so we need a buffer of at least 128 characters for a base 2 number.",
        "suggest": "基数可以低至 2，因此对于基数为 2 的数字，我们需要至少 128 个字符的缓冲区。",
        "translate": ""
    },
    {
        "source": "Accumulate each digit of the number from the least significant to the most significant figure.",
        "suggest": "从最低有效数字到最高有效数字累积数字的每个数字。",
        "translate": ""
    },
    {
        "source": "Get the current place value.",
        "suggest": "获取当前位置值。",
        "translate": ""
    },
    {
        "source": "Deaccumulate the number.",
        "suggest": "对数字进行累加。",
        "translate": ""
    },
    {
        "source": "Store the digit in the buffer.",
        "suggest": "将数字存储在缓冲区中。",
        "translate": ""
    },
    {
        "source": "No more digits left to accumulate.",
        "suggest": "没有更多的数字可累加。",
        "translate": ""
    },
    {
        "source": "Do the same as above, but accounting for two's complement.",
        "suggest": "进行与上述相同的操作，但要考虑到二进制补码。",
        "translate": ""
    },
    {
        "source": "The only chars in `buf` are created by `Self::digit` which are assumed to be valid UTF-8",
        "suggest": "`buf` 中唯一的字符由 `Self::digit` 创建，并被假定为有效的 UTF-8。",
        "translate": ""
    },
    {
        "source": "A binary (base 2) radix",
        "suggest": "二进制 (以 2 为底) 基数",
        "translate": ""
    },
    {
        "source": "An octal (base 8) radix",
        "suggest": "八进制 (基数为 8) 的基数",
        "translate": ""
    },
    {
        "source": "A hexadecimal (base 16) radix, formatted with lower-case characters",
        "suggest": "十六进制 (以 16 为底) 基数，格式为小写字符",
        "translate": ""
    },
    {
        "source": "A hexadecimal (base 16) radix, formatted with upper-case characters",
        "suggest": "十六进制 (以 16 为底) 基数，格式为大写字符",
        "translate": ""
    },
    {
        "source": "2 digit decimal look up table",
        "suggest": "2 位十进制查询表",
        "translate": ""
    },
    {
        "source": "2^128 is about 3*10^38, so 39 gives an extra byte of space",
        "suggest": "2^128 大约是 3*10^38，所以 39 给出了一个额外的字节空间",
        "translate": ""
    },
    {
        "source": "Since `d1` and `d2` are always less than or equal to `198`, we can copy from `lut_ptr[d1..d1 + 1]` and `lut_ptr[d2..d2 + 1]`.",
        "suggest": "由于 `d1` 和 `d2` 始终小于或等于 `198`，因此我们可以从 `lut_ptr[d1..d1 + 1]` 和 `lut_ptr[d2..d2 + 1]` 复制。",
        "translate": ""
    },
    {
        "source": "To show that it's OK to copy into `buf_ptr`, notice that at the beginning `curr == buf.len() == 39 > log(n)` since `n < 2^128 < 10^39`, and at each step this is kept the same as `n` is divided.",
        "suggest": "为了表明可以复制到 `buf_ptr`，请注意，从 `n < 2^128 < 10^39` 开始在 `curr == buf.len() == 39 > log(n)` 的开头，并且在每一步都与 `n` 相同。",
        "translate": ""
    },
    {
        "source": "Since `n` is always non-negative, this means that `curr > 0` so `buf_ptr[curr..curr + 1]` is safe to access.",
        "suggest": "由于 `n` 始终为非负数，这意味着 `curr > 0` 可以安全地访问 `buf_ptr[curr..curr + 1]`。",
        "translate": ""
    },
    {
        "source": "need at least 16 bits for the 4-characters-at-a-time to work.",
        "suggest": "一次至少需要 4 个字符才能使用至少 16 位。",
        "translate": ""
    },
    {
        "source": "eagerly decode 4 characters at a time",
        "suggest": "一次一次地解码 4 个字符",
        "translate": ""
    },
    {
        "source": "We are allowed to copy to `buf_ptr[curr..curr + 3]` here since otherwise `curr < 0`.",
        "suggest": "我们可以在这里复制到 `buf_ptr[curr..curr + 3]`，否则 `curr < 0`。",
        "translate": ""
    },
    {
        "source": "But then `n` was originally at least `10000^10` which is `10^40 > 2^128 > n`.",
        "suggest": "但是后来 `n` 至少是 `10000^10`，也就是 `10^40 > 2^128 > n`。",
        "translate": ""
    },
    {
        "source": "if we reach here numbers are <= 9999, so at most 4 chars long",
        "suggest": "如果我们到达此处，数字是 <= 9999，那么最多为 4 个字符",
        "translate": ""
    },
    {
        "source": "possibly reduce 64bit math",
        "suggest": "可能减少 64 位数学",
        "translate": ""
    },
    {
        "source": "decode 2 more chars, if > 2 chars",
        "suggest": "如果大于 2 个字符，则再解码 2 个字符",
        "translate": ""
    },
    {
        "source": "decode last 1 or 2 chars",
        "suggest": "解码最后 1 个或 2 个字符",
        "translate": ""
    },
    {
        "source": "`curr` > 0 (since we made `buf` large enough), and all the chars are valid UTF-8 since `DEC_DIGITS_LUT` is",
        "suggest": "`curr`> 0 (因为我们使 `buf` 足够大)，并且所有字符都是有效的 UTF-8，因为 `DEC_DIGITS_LUT` 是",
        "translate": ""
    },
    {
        "source": "convert the negative num to positive by summing 1 to it's 2 complement",
        "suggest": "通过将 1 加 2 来将负数转换为正数",
        "translate": ""
    },
    {
        "source": "count and remove trailing decimal zeroes",
        "suggest": "计算并删除尾随的十进制零",
        "translate": ""
    },
    {
        "source": "number of decimal digits minus 1",
        "suggest": "小数位数减 1",
        "translate": ""
    },
    {
        "source": "round up last digit",
        "suggest": "四舍五入最后一位数字",
        "translate": ""
    },
    {
        "source": "39 digits (worst case u128) + .",
        "suggest": "39 位数 (最坏情况 u128) +。",
        "translate": ""
    },
    {
        "source": "40 Since `curr` always decreases by the number of digits copied, this means that `curr >= 0`.",
        "suggest": "40 由于 `curr` 总是减少复制的位数，因此表示 `curr >= 0`。",
        "translate": ""
    },
    {
        "source": "index for buf",
        "suggest": "buf 的索引",
        "translate": ""
    },
    {
        "source": "decode 2 chars at a time",
        "suggest": "一次解码 2 个字符",
        "translate": ""
    },
    {
        "source": "`d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since `DEC_DIGITS_LUT` has a length of 200.",
        "suggest": "`d1 <= 198`，因此我们可以从 `lut_ptr[d1..d1 + 2]` 复制，因为 `DEC_DIGITS_LUT` 的长度为 200。",
        "translate": ""
    },
    {
        "source": "n is <= 99, so at most 2 chars long",
        "suggest": "n <= 99，因此最多 2 个字符",
        "translate": ""
    },
    {
        "source": "decode second-to-last character",
        "suggest": "倒数第二个字符",
        "translate": ""
    },
    {
        "source": "Safe since `40 > curr >= 0` (see comment)",
        "suggest": "自 `40 > curr >= 0` 起安全 (请参见注释)",
        "translate": ""
    },
    {
        "source": "add decimal point iff >1 mantissa digit will be printed",
        "suggest": "添加小数点 iff> 1 尾数将被打印",
        "translate": ""
    },
    {
        "source": "Safe since `40 > curr >= 0`",
        "suggest": "当 `40 > curr >= 0` 时安全",
        "translate": ""
    },
    {
        "source": "decode last character",
        "suggest": "解码最后一个字符",
        "translate": ""
    },
    {
        "source": "stores 'e' (or 'E') and the up to 2-digit exponent",
        "suggest": "存储 'e' (或 'E') 和最多 2 位数的指数",
        "translate": ""
    },
    {
        "source": "In either case, `exp_buf` is written within bounds and `exp_ptr[..len]` is contained within `exp_buf` since `len <= 3`.",
        "suggest": "在这两种情况下，自 `len <= 3` 开始，`exp_buf` 都被写在边界内，而 `exp_ptr[..len]` 被包含在 `exp_buf` 内。",
        "translate": ""
    },
    {
        "source": "Include wasm32 in here since it doesn't reflect the native pointer size, and often cares strongly about getting a smaller code size.",
        "suggest": "在此处包括 wasm32，因为它不反映原生指针的大小，并且通常非常在意如何减小代码大小。",
        "translate": ""
    },
    {
        "source": "Helper function for writing a u64 into `buf` going from last to first, with `curr`.",
        "suggest": "辅助函数，用于使用 `curr` 从最后到第一个将 u64 写入 `buf`。",
        "translate": ""
    },
    {
        "source": "Writes at most 19 characters into the buffer.",
        "suggest": "最多将 19 个字符写入缓冲区。",
        "translate": ""
    },
    {
        "source": "Guaranteed that any ptr into LUT is at most",
        "suggest": "保证进入 LUT 的任何 ptr 最多",
        "translate": ""
    },
    {
        "source": "198, so will never OOB.",
        "suggest": "198，所以永远不会 OOB。",
        "translate": ""
    },
    {
        "source": "There is a check above that there are at least 19 characters remaining.",
        "suggest": "上面有一个检查，是否至少剩余 19 个字符。",
        "translate": ""
    },
    {
        "source": "Some of these are nops but it looks more elegant this way.",
        "suggest": "其中一些是点头的，但这种方式看起来更优雅。",
        "translate": ""
    },
    {
        "source": "Specialized optimization for u128.",
        "suggest": "u128 的专业优化。",
        "translate": ""
    },
    {
        "source": "Instead of taking two items at a time, it splits into at most 2 u64s, and then chunks by 10e16, 10e8, 10e4, 10e2, and then 10e1.",
        "suggest": "它不会一次占用两个项，而是最多分成两个 u64，然后按 10e16、10e8、10e4、10e2 和 10e1 进行分块。",
        "translate": ""
    },
    {
        "source": "It also has to handle 1 last item, as 10^40 > 2^128 > 10^39, whereas",
        "suggest": "它还必须处理最后 1 个项，例如 10 ^ 40> 2 ^ 128> 10 ^ 39，而",
        "translate": ""
    },
    {
        "source": "0 pad up to point",
        "suggest": "0 填充到点",
        "translate": ""
    },
    {
        "source": "Guaranteed that we wrote at most 19 bytes, and there must be space remaining since it has length 39",
        "suggest": "保证我们最多写入 19 个字节，并且由于长度为 39，因此必须有剩余空间",
        "translate": ""
    },
    {
        "source": "Should this following branch be annotated with unlikely?",
        "suggest": "下面这个分支应该用不太可能来注释吗？",
        "translate": ""
    },
    {
        "source": "The raw `buf_ptr` pointer is only valid until `buf` is used the next time, buf `buf` is not used in this scope so we are good.",
        "suggest": "原始 `buf_ptr` 指针仅在下一次使用 `buf` 之前有效，在此作用域中未使用 buf `buf`，所以我们很好。",
        "translate": ""
    },
    {
        "source": "At this point we wrote at most 38 bytes, pad up to that point, There can only be at most 1 digit remaining.",
        "suggest": "在这一点上，我们最多写入 38 个字节，直到该点为止，最多只能剩余 1 位数字。",
        "translate": ""
    },
    {
        "source": "Partition of `n` into n > 1e19 and rem <= 1e19",
        "suggest": "`n` 分为 n> 1e19 和 rem <= 1e19",
        "translate": ""
    },
    {
        "source": "Integer division algorithm is based on the following paper:",
        "suggest": "整数除法算法基于以下论文:",
        "translate": ""
    },
    {
        "source": "T. Granlund and P.",
        "suggest": "T. Granlund 和 P.",
        "translate": ""
    },
    {
        "source": "Montgomery, “Division by Invariant Integers Using Multiplication” in Proc.",
        "suggest": "Montgomery，Proc 中的使用乘法除以不变整数。",
        "translate": ""
    },
    {
        "source": "of the SIGPLAN94 Conference on Programming Language Design and Implementation, 1994, pp.",
        "suggest": "SIGPLAN94 编程语言设计与实现会议，1994 年，第 134 页。",
        "translate": ""
    },
    {
        "source": "Multiply unsigned 128 bit integers, return upper 128 bits of the result",
        "suggest": "将无符号的 128 位整数相乘，返回结果的高 128 位",
        "translate": ""
    },
    {
        "source": "handle possibility of overflow",
        "suggest": "处理溢出的可能性",
        "translate": ""
    },
    {
        "source": "This is an internal module used by the ifmt!",
        "suggest": "这是 ifmt 使用的内部模块!",
        "translate": ""
    },
    {
        "source": "runtime. These structures are emitted to static arrays to precompile format strings ahead of time.",
        "suggest": "运行时。这些结构会被发送到静态数组，以提前对格式字符串进行预编译。",
        "translate": ""
    },
    {
        "source": "These definitions are similar to their `ct` equivalents, but differ in that these can be statically allocated and are slightly optimized for the runtime",
        "suggest": "这些定义与它们的 `ct` 等效项相似，但不同之处在于它们可以静态分配，并针对运行时进行了略微优化。",
        "translate": ""
    },
    {
        "source": "Possible alignments that can be requested as part of a formatting directive.",
        "suggest": "可以作为格式设置指令的一部分请求的可能的对齐方式。",
        "translate": ""
    },
    {
        "source": "No alignment was requested.",
        "suggest": "没有要求对齐。",
        "translate": ""
    },
    {
        "source": "Used by [width](https://doc.rust-lang.org/std/fmt/#width) and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.",
        "suggest": "由 [width](https://doc.rust-lang.org/std/fmt/#width) 和 [precision](https://doc.rust-lang.org/std/fmt/#precision) 说明符使用。",
        "translate": ""
    },
    {
        "source": "Specified with a literal number, stores the value",
        "suggest": "用字面量数字指定，存储该值",
        "translate": ""
    },
    {
        "source": "Specified using `$` and `*` syntaxes, stores the index into `args`",
        "suggest": "使用 `$` 和 `*` 语法指定，将索引存储到 `args`",
        "translate": ""
    },
    {
        "source": "Not specified",
        "suggest": "未标明",
        "translate": ""
    },
    {
        "source": "A future represents an asynchronous computation.",
        "suggest": "future 表示异步计算。",
        "translate": ""
    },
    {
        "source": "A future is a value that may not have finished computing yet.",
        "suggest": "future 是一个可能尚未完成计算的值。",
        "translate": ""
    },
    {
        "source": "This kind of \"asynchronous value\" makes it possible for a thread to continue doing useful work while it waits for the value to become available.",
        "suggest": "这种异步值使得，线程在等待值变为可用时，可以继续执行有用的工作。",
        "translate": ""
    },
    {
        "source": "The `poll` method",
        "suggest": "`poll` 方法",
        "translate": ""
    },
    {
        "source": "The core method of future, `poll`, *attempts* to resolve the future into a final value.",
        "suggest": "future 的核心方法 `poll` 试图将 future 解析为最终值。",
        "translate": ""
    },
    {
        "source": "This method does not block if the value is not ready.",
        "suggest": "如果值未准备好，则此方法不会阻塞。",
        "translate": ""
    },
    {
        "source": "Instead, the current task is scheduled to be woken up when it's possible to make further progress by `poll`ing again.",
        "suggest": "取而代之的是，如果有可能通过再次轮询来取得进一步的进展，则计划将当前任务唤醒。",
        "translate": ""
    },
    {
        "source": "The `context` passed to the `poll` method can provide a [`Waker`], which is a handle for waking up the current task.",
        "suggest": "传递给 `poll` 方法的 `context` 可以提供 [`Waker`]，它是唤醒当前任务的句柄。",
        "translate": ""
    },
    {
        "source": "When using a future, you generally won't call `poll` directly, but instead `.await` the value.",
        "suggest": "当使用 future 时，通常不会直接调用 `poll`，而是 `.await` 该值。",
        "translate": ""
    },
    {
        "source": "The type of value produced on completion.",
        "suggest": "完成时产生的值类型。",
        "translate": ""
    },
    {
        "source": "Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.",
        "suggest": "尝试将 future 解析为最终值，如果该值尚不可用，请注册当前任务以进行唤醒。",
        "translate": ""
    },
    {
        "source": "Return value",
        "suggest": "返回值",
        "translate": ""
    },
    {
        "source": "This function returns:",
        "suggest": "该函数返回:",
        "translate": ""
    },
    {
        "source": "if the future is not ready yet",
        "suggest": "如果 future 还没有准备好",
        "translate": ""
    },
    {
        "source": "with the result `val` of this future if it finished successfully.",
        "suggest": "如果成功完成，则返回 future 的结果 `val`。",
        "translate": ""
    },
    {
        "source": "Once a future has finished, clients should not `poll` it again.",
        "suggest": "future 完成后，客户端不应再次对其进行 `poll`。",
        "translate": ""
    },
    {
        "source": "When a future is not ready yet, `poll` returns `Poll::Pending` and stores a clone of the [`Waker`] copied from the current [`Context`].",
        "suggest": "当 future 尚未准备好时，`poll` 返回 `Poll::Pending` 并存储从当前 [`Context`] 复制的 [`Waker`] 的副本。",
        "translate": ""
    },
    {
        "source": "This [`Waker`] is then woken once the future can make progress.",
        "suggest": "future 可以取得进展后，将唤醒该 [`Waker`]。",
        "translate": ""
    },
    {
        "source": "For example, a future waiting for a socket to become readable would call `.clone()` on the [`Waker`] and store it.",
        "suggest": "例如，等待套接字可读的 future 将在 [`Waker`] 上调用 `.clone()` 并将其存储。",
        "translate": ""
    },
    {
        "source": "When a signal arrives elsewhere indicating that the socket is readable, [`Waker::wake`] is called and the socket future's task is awoken.",
        "suggest": "当信号到达其他地方指示套接字可读时，将调用 [`Waker::wake`]，并且唤醒套接字 future 的任务。",
        "translate": ""
    },
    {
        "source": "Once a task has been woken up, it should attempt to `poll` the future again, which may or may not produce a final value.",
        "suggest": "一旦任务被唤醒，它应该尝试再次 `poll` future，这可能会或可能不会产生最终值。",
        "translate": ""
    },
    {
        "source": "Note that on multiple calls to `poll`, only the [`Waker`] from the [`Context`] passed to the most recent call should be scheduled to receive a wakeup.",
        "suggest": "请注意，在多次调用 `poll` 时，应仅计划将 [`Context`] 中传递给最新调用的 [`Waker`] 接收唤醒。",
        "translate": ""
    },
    {
        "source": "Runtime characteristics",
        "suggest": "运行时特征",
        "translate": ""
    },
    {
        "source": "Futures alone are *inert*;",
        "suggest": "单独的 Futures 是惰性的;",
        "translate": ""
    },
    {
        "source": "they must be *actively* `poll`ed to make progress, meaning that each time the current task is woken up, it should actively re-`poll` pending futures that it still has an interest in.",
        "suggest": "必须对它们进行主动轮询以取得进展，这意味着每次唤醒当前任务时，它都应主动重新轮询以等待仍对其感兴趣的 futures。",
        "translate": ""
    },
    {
        "source": "The `poll` function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling `wake()`).",
        "suggest": "`poll` 函数不会在紧密循环中重复调用 - 而是仅在 future 指示已准备好进行调用时 (通过调用 `wake()`) 才应调用它。",
        "translate": ""
    },
    {
        "source": "If you're familiar with the `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures typically do *not* suffer the same problems of \"all wakeups must poll all events\";",
        "suggest": "如果您熟悉 Unix 上的 `poll(2)` 或 `select(2)` 系统调用，则值得注意的是 futures 通常不会遭受与 \"所有唤醒都必须轮询所有事件\" 相同的问题;",
        "translate": ""
    },
    {
        "source": "they are more like `epoll(4)`.",
        "suggest": "他们更像 `epoll(4)`。",
        "translate": ""
    },
    {
        "source": "An implementation of `poll` should strive to return quickly, and should not block.",
        "suggest": "`poll` 的实现应努力迅速返回，并且不应阻塞。",
        "translate": ""
    },
    {
        "source": "Returning quickly prevents unnecessarily clogging up threads or event loops.",
        "suggest": "快速返回可防止不必要地阻塞线程或事件循环。",
        "translate": ""
    },
    {
        "source": "If it is known ahead of time that a call to `poll` may end up taking awhile, the work should be offloaded to a thread pool (or something similar) to ensure that `poll` can return quickly.",
        "suggest": "如果提前得知对 `poll` 的调用可能要花一点时间，则应将工作卸载到线程池 (或类似的线程) 中，以确保 `poll` 可以快速返回。",
        "translate": ""
    },
    {
        "source": "Once a future has completed (returned `Ready` from `poll`), calling its `poll` method again may panic, block forever, or cause other kinds of problems;",
        "suggest": "future 完成后 (从 `poll` 返回 `Ready`)，再次调用其 `poll` 方法可能会导致 panic 永久阻塞或引起其他类型的问题。",
        "translate": ""
    },
    {
        "source": "the `Future` trait places no requirements on the effects of such a call.",
        "suggest": "`Future` trait 对这种调用的效果没有任何要求。",
        "translate": ""
    },
    {
        "source": "However, as the `poll` method is not marked `unsafe`, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of `unsafe` functions, or the like), regardless of the future's state.",
        "suggest": "但是，由于 `poll` 方法未标记为 `unsafe`，因此适用 Rust 的通常规则: 调用绝不能引起未定义的行为 (内存损坏，`unsafe` 函数的错误使用等)，而与 future 的状态无关。",
        "translate": ""
    },
    {
        "source": "Conversion into a `Future`.",
        "suggest": "转换为 `Future`。",
        "translate": ""
    },
    {
        "source": "The output that the future will produce on completion.",
        "suggest": "future 完成时将产生的输出。",
        "translate": ""
    },
    {
        "source": "Which kind of future are we turning this into?",
        "suggest": "我们要把它变成哪种 future?",
        "translate": ""
    },
    {
        "source": "Creates a future from a value.",
        "suggest": "根据一个值创建一个 future。",
        "translate": ""
    },
    {
        "source": "Asynchronous values.",
        "suggest": "异步值。",
        "translate": ""
    },
    {
        "source": "This type is needed because:",
        "suggest": "之所以需要这种类型，是因为:",
        "translate": ""
    },
    {
        "source": "a) Generators cannot implement `for<'a, 'b> Generator<&'a mut Context<'b>>`, so we need to pass a raw pointer (see <https://github.com/rust-lang/rust/issues/68923>).",
        "suggest": "a) 生成器无法实现 `for<'a, 'b> Generator<&'a mut Context<'b>>`，因此我们需要传递一个裸指针 (请参见 <https://github.com/rust-lang/rust/issues/68923>)。",
        "translate": ""
    },
    {
        "source": "b) Raw pointers and `NonNull` aren't `Send` or `Sync`, so that would make every single future non-Send/Sync as well, and we don't want that.",
        "suggest": "b) 裸指针和 `NonNull` 既不是 `Send` 也不是 `Sync`，所以这也会使每个 future non-Send/Sync 都一样，我们不希望这样。",
        "translate": ""
    },
    {
        "source": "It also simplifies the HIR lowering of `.await`.",
        "suggest": "它还简化了 `.await` 的 HIR 降低。",
        "translate": ""
    },
    {
        "source": "Wrap a generator in a future.",
        "suggest": "将生成器包装在 future 中。",
        "translate": ""
    },
    {
        "source": "This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).",
        "suggest": "此函数在下面返回 `GenFuture`，但将其隐藏在 `impl Trait` 中以提供更好的错误消息 (`impl Future` 而不是 `GenFuture<[closure.....]>`)。",
        "translate": ""
    },
    {
        "source": "This is `const` to avoid extra errors after we recover from `const async fn`",
        "suggest": "这是 `const`，以避免在我们从 `const async fn` 恢复后出现额外的错误",
        "translate": ""
    },
    {
        "source": "We rely on the fact that async/await futures are immovable in order to create self-referential borrows in the underlying generator.",
        "suggest": "我们依靠这样的事实，即 async/await futures 是不动的，以便在基础生成器中创建自指代借用。",
        "translate": ""
    },
    {
        "source": "Safe because we're !Unpin + !Drop, and this is just a field projection.",
        "suggest": "安全，因为我们是 `!Unpin + !Drop`，这只是一个字段推断。",
        "translate": ""
    },
    {
        "source": "Resume the generator, turning the `&mut Context` into a `NonNull` raw pointer.",
        "suggest": "恢复生成器，将 `&mut Context` 变成 `NonNull` 裸指针。",
        "translate": ""
    },
    {
        "source": "The `.await` lowering will safely cast that back to a `&mut Context`.",
        "suggest": "`.await` lowering 会安全地将其转换为 `&mut Context`。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `cx.0` is a valid pointer that fulfills all the requirements for a mutable reference.",
        "suggest": "调用者必须保证 `cx.0` 是满足可变引用所有要求的有效指针。",
        "translate": ""
    },
    {
        "source": "Creates a future which never resolves, representing a computation that never finishes.",
        "suggest": "创建一个永不解析的 future，表示永不结束的计算。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`pending()`].",
        "suggest": "该 `struct` 由 [`pending()`] 创建。",
        "translate": ""
    },
    {
        "source": "Creates a future that wraps a function returning [`Poll`].",
        "suggest": "创建一个 future，它包装返回 [`Poll`] 的函数。",
        "translate": ""
    },
    {
        "source": "Polling the future delegates to the wrapped function.",
        "suggest": "将 future 委托轮询到包装的函数。",
        "translate": ""
    },
    {
        "source": "A Future that wraps a function returning [`Poll`].",
        "suggest": "Future，它包装返回 [`Poll`] 的函数。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`poll_fn()`].",
        "suggest": "该 `struct` 由 [`poll_fn()`] 创建。",
        "translate": ""
    },
    {
        "source": "Creates a future that is immediately ready with a value.",
        "suggest": "创建一个立即准备好值的 future。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`ready()`].",
        "suggest": "该 `struct` 由 [`ready()`] 创建。",
        "translate": ""
    },
    {
        "source": "Futures created through this function are functionally similar to those created through `async {}`.",
        "suggest": "通过此函数创建的 Futures 在功能上类似于通过 `async {}` 创建的 Futures。",
        "translate": ""
    },
    {
        "source": "The main difference is that futures created through this function are named and implement `Unpin`.",
        "suggest": "主要区别在于，通过此函数创建的 futures 被命名并实现 `Unpin`。",
        "translate": ""
    },
    {
        "source": "Your hashing algorithm goes here!",
        "suggest": "您的哈希算法就在这里!",
        "translate": ""
    },
    {
        "source": "Generic hashing support.",
        "suggest": "通用哈希支持。",
        "translate": ""
    },
    {
        "source": "This module provides a generic way to compute the [hash] of a value.",
        "suggest": "该模块提供了一种计算值的 [hash] 的通用方法。",
        "translate": ""
    },
    {
        "source": "Hashes are most commonly used with [`HashMap`] and [`HashSet`].",
        "suggest": "哈希最常与 [`HashMap`] 和 [`HashSet`] 一起使用。",
        "translate": ""
    },
    {
        "source": "The simplest way to make a type hashable is to use `#[derive(Hash)]`:",
        "suggest": "使类型可哈希化的最简单方法是使用 `#[derive(Hash)]`:",
        "translate": ""
    },
    {
        "source": "If you need more control over how a value is hashed, you need to implement the [`Hash`] trait:",
        "suggest": "如果需要更多控制值散列的方式，则需要实现 [`Hash`] trait:",
        "translate": ""
    },
    {
        "source": "A hashable type.",
        "suggest": "可散列的类型。",
        "translate": ""
    },
    {
        "source": "Types implementing `Hash` are able to be [`hash`]ed with an instance of [`Hasher`].",
        "suggest": "实现 `Hash` 的类型可以通过 [`Hasher`] 的实例进行 [`hash`] 化。",
        "translate": ""
    },
    {
        "source": "Implementing `Hash`",
        "suggest": "实现 `Hash`",
        "translate": ""
    },
    {
        "source": "You can derive `Hash` with `#[derive(Hash)]` if all fields implement `Hash`.",
        "suggest": "如果所有字段都要实现 `Hash`，则可以用 `#[derive(Hash)]` 派生 `Hash`。",
        "translate": ""
    },
    {
        "source": "The resulting hash will be the combination of the values from calling [`hash`] on each field.",
        "suggest": "产生的哈希将是在每个字段上调用 [`hash`] 的值的组合。",
        "translate": ""
    },
    {
        "source": "If you need more control over how a value is hashed, you can of course implement the `Hash` trait yourself:",
        "suggest": "如果您需要对值的散列方式进行更多控制，则当然可以自己实现 `Hash` trait:",
        "translate": ""
    },
    {
        "source": "and `Eq`",
        "suggest": "和 `Eq`",
        "translate": ""
    },
    {
        "source": "When implementing both `Hash` and [`Eq`], it is important that the following property holds:",
        "suggest": "同时实现 `Hash` 和 [`Eq`] 时，保持以下属性很重要:",
        "translate": ""
    },
    {
        "source": "In other words, if two keys are equal, their hashes must also be equal.",
        "suggest": "换句话说，如果两个键相等，则它们的哈希也必须相等。",
        "translate": ""
    },
    {
        "source": "and [`HashSet`] both rely on this behavior.",
        "suggest": "和 [`HashSet`] 都依赖此行为。",
        "translate": ""
    },
    {
        "source": "Thankfully, you won't need to worry about upholding this property when deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`.",
        "suggest": "值得庆幸的是，在使用 `#[derive(PartialEq, Eq, Hash)]` 派生 [`Eq`] 和 `Hash` 时，您不必担心维护此属性。",
        "translate": ""
    },
    {
        "source": "Feeds this value into the given [`Hasher`].",
        "suggest": "将该值输入给定的 [`Hasher`]。",
        "translate": ""
    },
    {
        "source": "Feeds a slice of this type into the given [`Hasher`].",
        "suggest": "将这种类型的切片送入给定的 [`Hasher`] 中。",
        "translate": ""
    },
    {
        "source": "Separate module to reexport the macro `Hash` from prelude without the trait `Hash`.",
        "suggest": "单独的模块，用于从 prelude 重导出 `Hash` 宏，而无需 `Hash` trait。",
        "translate": ""
    },
    {
        "source": "Derive macro generating an impl of the trait `Hash`.",
        "suggest": "派生宏，生成 `Hash` trait 的实现。",
        "translate": ""
    },
    {
        "source": "A trait for hashing an arbitrary stream of bytes.",
        "suggest": "trait，用于散列任意字节流。",
        "translate": ""
    },
    {
        "source": "Instances of `Hasher` usually represent state that is changed while hashing data.",
        "suggest": "`Hasher` 的实例通常表示在对数据进行哈希处理时更改的状态。",
        "translate": ""
    },
    {
        "source": "provides a fairly basic interface for retrieving the generated hash (with [`finish`]), and writing integers as well as slices of bytes into an instance (with [`write`] and [`write_u8`] etc.).",
        "suggest": "提供了一个相当基本的接口，用于检索生成的哈希 (使用 [`finish`])，并将整数以及字节片写入实例 (使用 [`write`] 和 [`write_u8`] 等)。",
        "translate": ""
    },
    {
        "source": "Most of the time, `Hasher` instances are used in conjunction with the [`Hash`] trait.",
        "suggest": "大多数情况下，`Hasher` 实例与 [`Hash`] trait 结合使用。",
        "translate": ""
    },
    {
        "source": "Returns the hash value for the values written so far.",
        "suggest": "返回到目前为止写入的值的哈希值。",
        "translate": ""
    },
    {
        "source": "Despite its name, the method does not reset the hasher’s internal state.",
        "suggest": "尽管名称如此，该方法不会重置哈希器的内部状态。",
        "translate": ""
    },
    {
        "source": "Additional [`write`]s will continue from the current value.",
        "suggest": "额外的 [`write`] 将从当前值继续。",
        "translate": ""
    },
    {
        "source": "If you need to start a fresh hash value, you will have to create a new hasher.",
        "suggest": "如果需要开始一个新的哈希值，则必须创建一个新的哈希器。",
        "translate": ""
    },
    {
        "source": "Writes some data into this `Hasher`.",
        "suggest": "将一些数据写入此 `Hasher`。",
        "translate": ""
    },
    {
        "source": "Writes a single `u8` into this hasher.",
        "suggest": "将单个 `u8` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `u16` into this hasher.",
        "suggest": "将单个 `u16` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `u32` into this hasher.",
        "suggest": "将单个 `u32` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `u64` into this hasher.",
        "suggest": "将单个 `u64` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `u128` into this hasher.",
        "suggest": "将单个 `u128` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `usize` into this hasher.",
        "suggest": "将单个 `usize` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `i8` into this hasher.",
        "suggest": "将单个 `i8` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `i16` into this hasher.",
        "suggest": "将单个 `i16` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `i32` into this hasher.",
        "suggest": "将单个 `i32` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `i64` into this hasher.",
        "suggest": "将单个 `i64` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `i128` into this hasher.",
        "suggest": "将单个 `i128` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "Writes a single `isize` into this hasher.",
        "suggest": "将单个 `isize` 写入此哈希器。",
        "translate": ""
    },
    {
        "source": "A trait for creating instances of [`Hasher`].",
        "suggest": "用于创建 [`Hasher`] 实例的 trait。",
        "translate": ""
    },
    {
        "source": "A `BuildHasher` is typically used (e.g., by [`HashMap`]) to create [`Hasher`]s for each key such that they are hashed independently of one another, since [`Hasher`]s contain state.",
        "suggest": "`BuildHasher` 通常用于 (例如，由 [`HashMap`] 来) 为每个键创建 ['Hasher`]，使得它们彼此独立地进行哈希处理，因为 ['Hasher`] 包含状态。",
        "translate": ""
    },
    {
        "source": "For each instance of `BuildHasher`, the [`Hasher`]s created by [`build_hasher`] should be identical.",
        "suggest": "对于 `BuildHasher` 的每个实例，由 [`build_hasher`] 创建的 [`Hasher`] 应该相同。",
        "translate": ""
    },
    {
        "source": "That is, if the same stream of bytes is fed into each hasher, the same output will also be generated.",
        "suggest": "也就是说，如果将相同的字节流馈送到每个哈希器中，则还将生成相同的输出。",
        "translate": ""
    },
    {
        "source": "Type of the hasher that will be created.",
        "suggest": "将创建的哈希器的类型。",
        "translate": ""
    },
    {
        "source": "Creates a new hasher.",
        "suggest": "创建一个新的哈希器。",
        "translate": ""
    },
    {
        "source": "Each call to `build_hasher` on the same instance should produce identical [`Hasher`]s.",
        "suggest": "在同一实例上对 `build_hasher` 的每次调用都应产生相同的 ['Hasher`]。",
        "translate": ""
    },
    {
        "source": "Used to create a default [`BuildHasher`] instance for types that implement [`Hasher`] and [`Default`].",
        "suggest": "用于为实现 [`Hasher`] 和 [`Default`] 的类型创建默认的 [`BuildHasher`] 实例。",
        "translate": ""
    },
    {
        "source": "can be used when a type `H` implements [`Hasher`] and [`Default`], and you need a corresponding [`BuildHasher`] instance, but none is defined.",
        "suggest": "当类型 `H` 实现 [`Hasher`] 和 [`Default`]，并且需要相应的 [`BuildHasher`] 实例，但未定义任何实例时，可以使用。",
        "translate": ""
    },
    {
        "source": "Any `BuildHasherDefault` is [zero-sized].",
        "suggest": "任何 `BuildHasherDefault` 都是 [zero-sized]。",
        "translate": ""
    },
    {
        "source": "It can be created with [`default`][method.default].",
        "suggest": "可以用 [`default`][method.default] 创建。",
        "translate": ""
    },
    {
        "source": "When using `BuildHasherDefault` with [`HashMap`] or [`HashSet`], this doesn't need to be done, since they implement appropriate [`Default`] instances themselves.",
        "suggest": "当将 `BuildHasherDefault` 与 [`HashMap`] 或 [`HashSet`] 一起使用时，不需要这样做，因为它们自己实现了适当的 [`Default`] 实例。",
        "translate": ""
    },
    {
        "source": "Using `BuildHasherDefault` to specify a custom [`BuildHasher`] for",
        "suggest": "使用 `BuildHasherDefault` 指定用于的自定义 [`BuildHasher`]",
        "translate": ""
    },
    {
        "source": "`ptr` is valid and aligned, as this macro is only used for numeric primitives which have no padding.",
        "suggest": "`ptr` 有效且已对齐，因为此宏仅用于没有填充的数字基元。",
        "translate": ""
    },
    {
        "source": "The new slice only spans across `data` and is never mutated, and its total size is the same as the original `data` so it can't be over `isize::MAX`.",
        "suggest": "新切片仅跨越 `data`，并且不会发生可变的，并且其总大小与原始 `data` 相同，因此不能超过 `isize::MAX`。",
        "translate": ""
    },
    {
        "source": "Thin pointer",
        "suggest": "细指针",
        "translate": ""
    },
    {
        "source": "Fat pointer",
        "suggest": "胖指针",
        "translate": ""
    },
    {
        "source": "we are accessing the memory occupied by `self` which is guaranteed to be valid.",
        "suggest": "我们正在访问 `self` 占用的内存，该内存被保证是有效的。",
        "translate": ""
    },
    {
        "source": "This assumes a fat pointer can be represented by a `(usize, usize)`, which is safe to do in `std` because it is shipped and kept in sync with the implementation of fat pointers in `rustc`.",
        "suggest": "这假定胖指针可以用 `(usize, usize)` 表示，这在 `std` 中是安全的，因为它已交付并与 `rustc` 中胖指针的实现保持同步。",
        "translate": ""
    },
    {
        "source": "An implementation of SipHash.",
        "suggest": "SipHash 的实现。",
        "translate": ""
    },
    {
        "source": "the types in this module are deprecated",
        "suggest": "不建议使用此模块中的类型",
        "translate": ""
    },
    {
        "source": "An implementation of SipHash 1-3.",
        "suggest": "SipHash 1-3 的实现。",
        "translate": ""
    },
    {
        "source": "This is currently the default hashing function used by standard library (e.g., `collections::HashMap` uses it by default).",
        "suggest": "当前，这是标准库使用的默认哈希函数 (例如，`collections::HashMap` 默认使用它)。",
        "translate": ""
    },
    {
        "source": "An implementation of SipHash 2-4.",
        "suggest": "SipHash 2-4 的实现。",
        "translate": ""
    },
    {
        "source": "SipHash is a general-purpose hashing function: it runs at a good speed (competitive with Spooky and City) and permits strong _keyed_ hashing.",
        "suggest": "SipHash 是通用的哈希函数: 它以良好的速度运行 (与 Spooky 和 City 竞争)，并允许强大的 _keyed_ 哈希。",
        "translate": ""
    },
    {
        "source": "This lets you key your hash tables from a strong RNG, such as [`rand::os::OsRng`](https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html).",
        "suggest": "这使您可以从强大的 RNG (例如 [`rand::os::OsRng`](https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html)) 中键入哈希表。",
        "translate": ""
    },
    {
        "source": "Although the SipHash algorithm is considered to be generally strong, it is not intended for cryptographic purposes.",
        "suggest": "尽管 SipHash 算法通常被认为是强大的，但它并非旨在用于加密目的。",
        "translate": ""
    },
    {
        "source": "As such, all cryptographic uses of this implementation are _strongly discouraged_.",
        "suggest": "这样，此实现的所有加密用途都是 _strongly discouraged_。",
        "translate": ""
    },
    {
        "source": "how many bytes we've processed",
        "suggest": "我们处理了多少字节",
        "translate": ""
    },
    {
        "source": "hash State",
        "suggest": "哈希状态",
        "translate": ""
    },
    {
        "source": "unprocessed bytes le",
        "suggest": "未处理的字节",
        "translate": ""
    },
    {
        "source": "how many bytes in tail are valid",
        "suggest": "尾部有多少字节有效",
        "translate": ""
    },
    {
        "source": "v2 and v1, v3 show up in pairs in the algorithm, and simd implementations of SipHash will use vectors of v02 and v13.",
        "suggest": "v2 和 v1，v3 在算法中成对出现，SipHash 的 simd 实现将使用 v02 和 v13 的 vectors。",
        "translate": ""
    },
    {
        "source": "By placing them in this order in the struct, the compiler can pick up on just a few simd optimizations by itself.",
        "suggest": "通过将它们以这种顺序放置在结构体中，编译器本身可以进行一些 simd 优化。",
        "translate": ""
    },
    {
        "source": "Loads an integer of the desired type from a byte stream, in LE order.",
        "suggest": "以 LE 顺序从字节流中加载所需类型的整数。",
        "translate": ""
    },
    {
        "source": "Uses `copy_nonoverlapping` to let the compiler generate the most efficient way to load it from a possibly unaligned address.",
        "suggest": "使用 `copy_nonoverlapping` 使编译器生成最有效的方法来从可能未对齐的地址加载它。",
        "translate": ""
    },
    {
        "source": "Unsafe because: unchecked indexing at i..i+size_of(int_ty)",
        "suggest": "不安全，因为: 未经检查的索引在 i..i + size_of (int_ty)",
        "translate": ""
    },
    {
        "source": "Loads a u64 using up to 7 bytes of a byte slice.",
        "suggest": "最多使用一个字节切片的 7 个字节来加载 u64。",
        "translate": ""
    },
    {
        "source": "It looks clumsy but the `copy_nonoverlapping` calls that occur (via `load_int_le!`) all have fixed sizes and avoid calling `memcpy`, which is good for speed.",
        "suggest": "它看起来很笨拙，但是发生的 `copy_nonoverlapping` 调用 (通过 `load_int_le!`) 都具有固定的大小，并且避免调用 `memcpy`，这对于提高速度非常有用。",
        "translate": ""
    },
    {
        "source": "Unsafe because: unchecked indexing at start..start+len",
        "suggest": "不安全的原因是: 启动时未检查索引 start..start+len",
        "translate": ""
    },
    {
        "source": "current byte index (from LSB) in the output u64",
        "suggest": "输出 u64 中的当前字节索引 (来自 LSB)",
        "translate": ""
    },
    {
        "source": "`i` cannot be greater than `len`, and the caller must guarantee that the index start..start+len is in bounds.",
        "suggest": "`i` 不能大于 `len`，并且调用者必须保证索引 start..start + len 在范围之内。",
        "translate": ""
    },
    {
        "source": "Creates a new `SipHasher` with the two initial keys set to 0.",
        "suggest": "用两个初始键设置为 0 创建一个新的 `SipHasher`。",
        "translate": ""
    },
    {
        "source": "Creates a `SipHasher` that is keyed off the provided keys.",
        "suggest": "创建一个 `SipHasher`，该 `SipHasher` 从提供的键上退出。",
        "translate": ""
    },
    {
        "source": "Creates a new `SipHasher13` with the two initial keys set to 0.",
        "suggest": "用两个初始键设置为 0 创建一个新的 `SipHasher13`。",
        "translate": ""
    },
    {
        "source": "Creates a `SipHasher13` that is keyed off the provided keys.",
        "suggest": "创建一个 `SipHasher13`，该 `SipHasher13` 从提供的键上退出。",
        "translate": ""
    },
    {
        "source": "no integer hashing methods (`write_u*`, `write_i*`) are defined for this type.",
        "suggest": "没有为此类型定义整数哈希方法 (`write_u *`，`write_i*`)。",
        "translate": ""
    },
    {
        "source": "We could add them, copy the `short_write` implementation in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*` methods to `SipHasher`, `SipHasher13`, and `DefaultHasher`.",
        "suggest": "我们可以添加它们，在 librustc_data_structures/sip128.rs 中复制 `short_write` 实现，然后将 `write_u *`/`write_i*` 方法添加到 `SipHasher`，`SipHasher13` 和 `DefaultHasher`。",
        "translate": ""
    },
    {
        "source": "This would greatly speed up integer hashing by those hashers, at the cost of slightly slowing down compile speeds on some benchmarks.",
        "suggest": "这将大大加快这些散列的整数散列速度，但会以稍微降低某些基准的编译速度为代价。",
        "translate": ""
    },
    {
        "source": "See #69152 for details.",
        "suggest": "有关详细信息，请参见 #69152。",
        "translate": ""
    },
    {
        "source": "`cmp::min(length, needed)` is guaranteed to not be over `length`",
        "suggest": "`cmp::min(length, needed)` 保证不超过 `length`",
        "translate": ""
    },
    {
        "source": "Buffered tail is now flushed, process new input.",
        "suggest": "缓冲的尾巴现在被冲洗，处理新的输入。",
        "translate": ""
    },
    {
        "source": "because `len - left` is the biggest multiple of 8 under `len`, and because `i` starts at `needed` where `len` is `length - needed`, `i + 8` is guaranteed to be less than or equal to `length`.",
        "suggest": "因为 `len - left` 是 `len` 的 8 的最大倍数，并且因为 `i` 以 `len` 为 `length - needed` 的 `needed` 开头，所以保证 `i + 8` 小于或等于 `length`。",
        "translate": ""
    },
    {
        "source": "`i` is now `needed + len.div_euclid(8) * 8`, so `i + left` = `needed + len` = `length`, which is by definition equal to `msg.len()`.",
        "suggest": "`i` 现在是 `needed + len.div_euclid(8) * 8`，因此 `i + left` = `needed + len` = `length`，根据定义，它等于 `msg.len()`。",
        "translate": ""
    },
    {
        "source": "Creates a `Hasher<S>` with the two initial keys set to 0.",
        "suggest": "创建两个初始键设置为 0 的 `Hasher<S>`。",
        "translate": ""
    },
    {
        "source": "is always positive (not zero), hence `checked_div` will never return `None`.",
        "suggest": "始终为正 (不为零)，因此 `checked_div` 将永远不会返回 `None`。",
        "translate": ""
    },
    {
        "source": "Therefore, the else branch is unreachable.",
        "suggest": "因此，else 分支不可访问。",
        "translate": ""
    },
    {
        "source": "A shared atomic value that threads will use to coordinate",
        "suggest": "线程将用于协调的共享原子值",
        "translate": ""
    },
    {
        "source": "In a background thread we'll eventually set the value",
        "suggest": "在后台线程中，我们最终将设置该值",
        "translate": ""
    },
    {
        "source": "Do some work, then make the value live",
        "suggest": "做一些工作，然后创造值",
        "translate": ""
    },
    {
        "source": "Back on our current thread, we wait for the value to be set",
        "suggest": "回到我们当前的线程，我们等待该值被设置",
        "translate": ""
    },
    {
        "source": "The spin loop is a hint to the CPU that we're waiting, but probably not for very long",
        "suggest": "自旋循环是对我们正在等待的 CPU 的提示，但可能不会持续很长时间",
        "translate": ""
    },
    {
        "source": "The value is now set",
        "suggest": "现在设置该值",
        "translate": ""
    },
    {
        "source": "Hints to compiler that affects how code should be emitted or optimized.",
        "suggest": "对编译器的提示，该提示会影响应如何发出或优化代码。",
        "translate": ""
    },
    {
        "source": "Hints may be compile time or runtime.",
        "suggest": "提示可能是编译时或运行时。",
        "translate": ""
    },
    {
        "source": "Informs the compiler that this point in the code is not reachable, enabling further optimizations.",
        "suggest": "通知编译器代码中的这一点不可访问，从而可以进行进一步的优化。",
        "translate": ""
    },
    {
        "source": "Reaching this function is completely *undefined behavior* (UB).",
        "suggest": "达到此函数完全是 *未定义的行为* (UB)。",
        "translate": ""
    },
    {
        "source": "In particular, the compiler assumes that all UB must never happen, and therefore will eliminate all branches that reach to a call to `unreachable_unchecked()`.",
        "suggest": "特别是，编译器假定所有 UB 都绝不会发生，因此将消除到达 `unreachable_unchecked()` 调用的所有分支。",
        "translate": ""
    },
    {
        "source": "Like all instances of UB, if this assumption turns out to be wrong, i.e., the `unreachable_unchecked()` call is actually reachable among all possible control flow, the compiler will apply the wrong optimization strategy, and may sometimes even corrupt seemingly unrelated code, causing difficult-to-debug problems.",
        "suggest": "与 UB 的所有实例一样，如果这种假设被证明是错误的，即 `unreachable_unchecked()` 调用实际上在所有可能的控制流中都是可以到达的，则编译器将应用错误的优化策略，有时甚至可能破坏看似无关的代码，从而导致难以解决的问题 - 调试问题。",
        "translate": ""
    },
    {
        "source": "Use this function only when you can prove that the code will never call it.",
        "suggest": "仅当您可以证明该代码永远不会调用它时，才使用此函数。",
        "translate": ""
    },
    {
        "source": "Otherwise, consider using the [`unreachable!`] macro, which does not allow optimizations but will panic when executed.",
        "suggest": "否则，请考虑使用 [`unreachable!`] 宏，该宏不允许进行优化，但是在执行时将为 panic。",
        "translate": ""
    },
    {
        "source": "the safety contract for `intrinsics::unreachable` must be upheld by the caller.",
        "suggest": "调用者必须遵守 `intrinsics::unreachable` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Emits a machine instruction to signal the processor that it is running in a busy-wait spin-loop (\"spin lock\").",
        "suggest": "发出一条机器指令，以向处理器发送信号，指示其正在忙于等待的自旋循环 (自旋锁) 中运行。",
        "translate": ""
    },
    {
        "source": "Upon receiving the spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.",
        "suggest": "在接收到自旋环信号后，处理器可以通过例如节省功率或切换 hyper 线程来优化其行为。",
        "translate": ""
    },
    {
        "source": "This function is different from [`thread::yield_now`] which directly yields to the system's scheduler, whereas `spin_loop` does not interact with the operating system.",
        "suggest": "此函数不同于 [`thread::yield_now`]，后者直接产生系统的调度程序，而 `spin_loop` 不与操作系统交互。",
        "translate": ""
    },
    {
        "source": "A common use case for `spin_loop` is implementing bounded optimistic spinning in a CAS loop in synchronization primitives.",
        "suggest": "`spin_loop` 的一个常见用例是在同步原语的 CAS 循环中实现有界乐观旋转。",
        "translate": ""
    },
    {
        "source": "To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.",
        "suggest": "为避免优先级倒置之类的问题，强烈建议在有限次数的迭代后终止旋转循环，并进行适当的阻塞系统调用。",
        "translate": ""
    },
    {
        "source": "On platforms that do not support receiving spin-loop hints this function does not do anything at all.",
        "suggest": "在不支持接收自旋循环提示的平台上，此函数完全不执行任何操作。",
        "translate": ""
    },
    {
        "source": "the `cfg` attr ensures that we only execute this on x86 targets.",
        "suggest": "`cfg` 属性确保我们仅在 x86 目标上执行此操作。",
        "translate": ""
    },
    {
        "source": "the `cfg` attr ensures that we only execute this on x86_64 targets.",
        "suggest": "`cfg` 属性确保我们仅在 x86_64 目标上执行此操作。",
        "translate": ""
    },
    {
        "source": "the `cfg` attr ensures that we only execute this on aarch64 targets.",
        "suggest": "`cfg` 属性确保我们仅在 aarch64 目标上执行此操作。",
        "translate": ""
    },
    {
        "source": "the `cfg` attr ensures that we only execute this on arm targets with support for the v6 feature.",
        "suggest": "`cfg` 属性确保我们仅在支持 v6 功能的 arm 目标上执行此操作。",
        "translate": ""
    },
    {
        "source": "An identity function that *__hints__* to the compiler to be maximally pessimistic about what `black_box` could do.",
        "suggest": "*__提示 __* 到编译器的标识函数，对于 `black_box` 可以做什么最大程度地悲观。",
        "translate": ""
    },
    {
        "source": "Unlike [`std::convert::identity`], a Rust compiler is encouraged to assume that `black_box` can use `dummy` in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code.",
        "suggest": "与 [`std::convert::identity`] 不同，鼓励 Rust 编译器假定 `black_box` 可以以允许 Rust 代码使用的任何可能有效方式使用 `dummy`，而不会在调用代码中引入未定义的行为。",
        "translate": ""
    },
    {
        "source": "This property makes `black_box` useful for writing code in which certain optimizations are not desired, such as benchmarks.",
        "suggest": "此属性使 `black_box` 可用于编写不需要进行某些优化 (例如基准测试) 的代码。",
        "translate": ""
    },
    {
        "source": "Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis.",
        "suggest": "但是请注意，`black_box` 仅 (并且只能) 以 \"best-effort\" 为基础提供。",
        "translate": ""
    },
    {
        "source": "The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used.",
        "suggest": "它可以阻止优化的程度可能会有所不同，具体取决于所使用的平台和代码源后端。",
        "translate": ""
    },
    {
        "source": "Programs cannot rely on `black_box` for *correctness* in any way.",
        "suggest": "程序不能以任何方式依靠 `black_box` 的正确性。",
        "translate": ""
    },
    {
        "source": "We need to \"use\" the argument in some way LLVM can't introspect, and on targets that support it we can typically leverage inline assembly to do this.",
        "suggest": "我们需要以某种方式 \"use\" LLVM 无法自省该参数，并且在支持它的目标上，我们通常可以利用内联汇编来执行此操作。",
        "translate": ""
    },
    {
        "source": "LLVM's interpretation of inline assembly is that it's, well, a black box.",
        "suggest": "LLVM 对内联汇编的解释是，它是黑色的 box。",
        "translate": ""
    },
    {
        "source": "This isn't the greatest implementation since it probably deoptimizes more than we want, but it's so far good enough.",
        "suggest": "这不是最好的实现，因为它可能对优化进行的优化超出了我们的期望，但到目前为止已经足够好了。",
        "translate": ""
    },
    {
        "source": "This is just a hint, so it is fine to skip in Miri.",
        "suggest": "这只是一个提示，因此可以跳过 Miri。",
        "translate": ""
    },
    {
        "source": "the inline assembly is a no-op.",
        "suggest": "内联汇编是无操作的。",
        "translate": ""
    },
    {
        "source": "Cannot use `asm!` because it doesn't support MIPS and other architectures.",
        "suggest": "无法使用 `asm!`，因为它不支持 MIPS 和其他体系结构。",
        "translate": ""
    },
    {
        "source": "implements the unary operator \"op &T\" based on \"op T\" where T is expected to be `Copy`able",
        "suggest": "基于 \"op T\" 实现一元运算符 \"op &T\"，其中 T 应该是可复制的",
        "translate": ""
    },
    {
        "source": "implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\" based on \"T op U\" where T and U are expected to be `Copy`able",
        "suggest": "基于 \"T op U\" 实现二进制运算符 \"&T op U\"，\"T op &U\"，\"&T op &U\"，其中 T 和 U 应该是可复制的",
        "translate": ""
    },
    {
        "source": "implements \"T op= &U\", based on \"T op= U\" where U is expected to be `Copy`able",
        "suggest": "基于 \"T op= U\" 实现 \"T op= &U\"，其中 U 应该是可复制的",
        "translate": ""
    },
    {
        "source": "Create a zero-size type similar to a closure type, but named.",
        "suggest": "创建一个与闭包类型相似的零大小类型，但命名为。",
        "translate": ""
    },
    {
        "source": "use `u32::from_ne_bytes` instead",
        "suggest": "改用 `u32::from_ne_bytes`",
        "translate": ""
    },
    {
        "source": "or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness",
        "suggest": "或使用 `u32::from_le_bytes` 或 `u32::from_be_bytes` 指定字节顺序",
        "translate": ""
    },
    {
        "source": "Use an `as` cast instead",
        "suggest": "请改用 `as` 进行类型转换",
        "translate": ""
    },
    {
        "source": "Use a reborrow instead",
        "suggest": "改用借用",
        "translate": ""
    },
    {
        "source": "Now, put together `as` and reborrowing - note the chaining of `as` `as` is not transitive",
        "suggest": "现在，将 `as` 放在一起并重新借用 - 请注意，`as` `as` 的链接不是可传递的",
        "translate": ""
    },
    {
        "source": "this is not a good way to do this.",
        "suggest": "这不是执行此操作的好方法。",
        "translate": ""
    },
    {
        "source": "You could use `str::as_bytes`",
        "suggest": "您可以使用 `str::as_bytes`",
        "translate": ""
    },
    {
        "source": "Or, just use a byte string, if you have control over the string literal",
        "suggest": "或者，如果您可以控制字符串，则只需使用字节字符串即可。",
        "translate": ""
    },
    {
        "source": "clone the vector as we will reuse them later",
        "suggest": "克隆 vector，因为稍后我们将重用它们",
        "translate": ""
    },
    {
        "source": "Using transmute: this relies on the unspecified data layout of `Vec`, which is a bad idea and could cause Undefined Behavior.",
        "suggest": "使用 transmute: 这依赖于 `Vec` 的未指定数据布局，这是一个坏主意，并可能导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "However, it is no-copy.",
        "suggest": "但是，它是无副本的。",
        "translate": ""
    },
    {
        "source": "This is the suggested, safe way.",
        "suggest": "这是建议的安全方法。",
        "translate": ""
    },
    {
        "source": "It does copy the entire vector, though, into a new array.",
        "suggest": "但是，它确实将整个 vector 复制到一个新数组中。",
        "translate": ""
    },
    {
        "source": "This is the proper no-copy, unsafe way of \"transmuting\" a `Vec`, without relying on the data layout.",
        "suggest": "这是 \"transmuting\" 和 `Vec` 的正确无复制，不安全的方式，而无需依赖数据布局。",
        "translate": ""
    },
    {
        "source": "Instead of literally calling `transmute`, we perform a pointer cast, but in terms of converting the original inner type (`&i32`) to the new one (`Option<&i32>`), this has all the same caveats.",
        "suggest": "我们不执行字面上的调用 `transmute`，而是执行指针强制转换，但是就将原始内部类型 (`&i32`) 转换为新的 (`Option<&i32>`) 而言，这具有所有相同的警告。",
        "translate": ""
    },
    {
        "source": "Besides the information provided above, also consult the [`from_raw_parts`] documentation.",
        "suggest": "除了上面提供的信息之外，还请查阅 [`from_raw_parts`] 文档。",
        "translate": ""
    },
    {
        "source": "Ensure the original vector is not dropped.",
        "suggest": "确保原始 vector 没有被丢弃。",
        "translate": ""
    },
    {
        "source": "There are multiple ways to do this, and there are multiple problems with the following (transmute) way.",
        "suggest": "有多种方法可以执行此操作，并且以下 (transmute) 方法存在多个问题。",
        "translate": ""
    },
    {
        "source": "first: transmute is not type safe;",
        "suggest": "第一: 转换不是安全类型;",
        "translate": ""
    },
    {
        "source": "all it checks is that T and U are of the same size.",
        "suggest": "它所检查的只是 T 和 U 的大小相同。",
        "translate": ""
    },
    {
        "source": "Second, right here, you have two mutable references pointing to the same memory.",
        "suggest": "其次，在这里，您有两个指向同一内存的可变引用。",
        "translate": ""
    },
    {
        "source": "This gets rid of the type safety problems;",
        "suggest": "这消除了类型安全问题;",
        "translate": ""
    },
    {
        "source": "`&mut *` will *only* give you an `&mut T` from an `&mut T` or `*mut T`.",
        "suggest": "`&mut *`* 仅 *将为您提供 `&mut T` 或 `* mut T` 的 `&mut T`。",
        "translate": ""
    },
    {
        "source": "however, you still have two mutable references pointing to the same memory.",
        "suggest": "但是，您仍然有两个指向同一内存的可变引用。",
        "translate": ""
    },
    {
        "source": "This is how the standard library does it.",
        "suggest": "这就是标准库的工作方式。",
        "translate": ""
    },
    {
        "source": "This is the best method, if you need to do something like this",
        "suggest": "如果您需要执行以下操作，这是最好的方法",
        "translate": ""
    },
    {
        "source": "This now has three mutable references pointing at the same memory.",
        "suggest": "现在，它具有三个指向同一内存的可变引用。",
        "translate": ""
    },
    {
        "source": "`slice`, the rvalue ret.0, and the rvalue ret.1.",
        "suggest": "`slice`，右值 ret.0 和右值 ret.1。",
        "translate": ""
    },
    {
        "source": "is never used after `let ptr = ...`, and so one can treat it as \"dead\", and therefore, you only have two real mutable slices.",
        "suggest": "`let ptr = ...` 之后从未使用过，因此可以将其视为 \"dead\"，因此，您只有两个实际的可变切片。",
        "translate": ""
    },
    {
        "source": "Moves all the elements of `src` into `dst`, leaving `src` empty.",
        "suggest": "将 `src` 的所有元素移到 `dst`，将 `src` 留空。",
        "translate": ""
    },
    {
        "source": "Ensure that `dst` has enough capacity to hold all of `src`.",
        "suggest": "确保 `dst` 具有足够的容量来容纳所有 `src`。",
        "translate": ""
    },
    {
        "source": "The call to offset is always safe because `Vec` will never allocate more than `isize::MAX` bytes.",
        "suggest": "偏移的调用始终是安全的，因为 `Vec` 分配的字节数永远不会超过 `isize::MAX` 字节。",
        "translate": ""
    },
    {
        "source": "Truncate `src` without dropping its contents.",
        "suggest": "截断 `src` 而不丢弃其内容。",
        "translate": ""
    },
    {
        "source": "We do this first, to avoid problems in case something further down panics.",
        "suggest": "我们首先执行此操作，以避免在 panics 处出现问题时避免出现问题。",
        "translate": ""
    },
    {
        "source": "The two regions cannot overlap because mutable references do not alias, and two different vectors cannot own the same memory.",
        "suggest": "这两个区域不能重叠，因为可变引用没有别名，并且两个不同的 vectors 不能拥有相同的内存。",
        "translate": ""
    },
    {
        "source": "Notify `dst` that it now holds the contents of `src`.",
        "suggest": "通知 `dst` 现在包含 `src` 的内容。",
        "translate": ""
    },
    {
        "source": "must be correctly aligned for its type and non-zero.",
        "suggest": "必须正确对齐其类型且非零。",
        "translate": ""
    },
    {
        "source": "must be valid for reads of `elts` contiguous elements of type `T`.",
        "suggest": "必须对读取 `T` 类型的 `elts` 连续元素有效。",
        "translate": ""
    },
    {
        "source": "Those elements must not be used after calling this function unless `T: Copy`.",
        "suggest": "除非 `T: Copy`，否则在调用此函数后不得使用这些元素。",
        "translate": ""
    },
    {
        "source": "Our precondition ensures the source is aligned and valid, and `Vec::with_capacity` ensures that we have usable space to write them.",
        "suggest": "我们的前提条件是确保源文件对齐和有效，而 `Vec::with_capacity` 确保我们有可用的空间来编写它们。",
        "translate": ""
    },
    {
        "source": "We created it with this much capacity earlier, and the previous `copy` has initialized these elements.",
        "suggest": "我们之前已经用这么大的容量创建了它，而以前的 `copy` 已经初始化了这些元素。",
        "translate": ""
    },
    {
        "source": "Leaks the previously held value by overwriting the `Box<T>` with a null pointer.",
        "suggest": "通过使用空指针覆盖 `Box<T>`，泄漏先前保留的值。",
        "translate": ""
    },
    {
        "source": "At this point, using or dropping `v` results in undefined behavior.",
        "suggest": "此时，使用或丢弃 `v` 会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "Even leaking `v` \"uses\" it, and hence is undefined behavior.",
        "suggest": "即使 `v` \"uses\" 泄漏了它，因此也是未定义的行为。",
        "translate": ""
    },
    {
        "source": "mem::forget(v);",
        "suggest": "mem::forget (v) ;",
        "translate": ""
    },
    {
        "source": "// ERROR",
        "suggest": "// 错误",
        "translate": ""
    },
    {
        "source": "In fact, `v` is invalid according to basic type layout invariants, so *any* operation touching it is undefined behavior.",
        "suggest": "实际上，根据基本类型布局不变式，`v` 无效，因此触摸它的 *any* 操作是未定义的行为。",
        "translate": ""
    },
    {
        "source": "Let us instead put in a valid value",
        "suggest": "让我们输入一个有效值",
        "translate": ""
    },
    {
        "source": "Now the box is fine",
        "suggest": "现在 box 很好",
        "translate": ""
    },
    {
        "source": "Compiler intrinsics.",
        "suggest": "编译器内联函数。",
        "translate": ""
    },
    {
        "source": "The corresponding definitions are in `compiler/rustc_codegen_llvm/src/intrinsic.rs`.",
        "suggest": "相应的定义在 `compiler/rustc_codegen_llvm/src/intrinsic.rs` 中。",
        "translate": ""
    },
    {
        "source": "The corresponding const implementations are in `compiler/rustc_mir/src/interpret/intrinsics.rs`",
        "suggest": "相应的 const 实现在 `compiler/rustc_mir/src/interpret/intrinsics.rs` 中",
        "translate": ""
    },
    {
        "source": "Const intrinsics",
        "suggest": "常量内联函数",
        "translate": ""
    },
    {
        "source": "any changes to the constness of intrinsics should be discussed with the language team.",
        "suggest": "对内在常量的任何更改都应与语言团队讨论。",
        "translate": ""
    },
    {
        "source": "This includes changes in the stability of the constness.",
        "suggest": "这包括常量稳定性的变化。",
        "translate": ""
    },
    {
        "source": "In order to make an intrinsic usable at compile-time, one needs to copy the implementation from <https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs> to `compiler/rustc_mir/src/interpret/intrinsics.rs` and add a `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` to the intrinsic.",
        "suggest": "为了使内联函数在编译时可用，需要将实现从 <https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs> 复制到 `compiler/rustc_mir/src/interpret/intrinsics.rs` 并将 `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` 添加到内联函数。",
        "translate": ""
    },
    {
        "source": "If an intrinsic is supposed to be used from a `const fn` with a `rustc_const_stable` attribute, the intrinsic's attribute must be `rustc_const_stable`, too.",
        "suggest": "如果应该从具有 `rustc_const_stable` 属性的 `const fn` 使用内联函数，则内联函数的属性也必须为 `rustc_const_stable`。",
        "translate": ""
    },
    {
        "source": "Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.",
        "suggest": "如果没有 T-lang 咨询，则不应进行此类更改，因为它会将语言中的功能烘焙到没有编译器支持的情况下无法在用户代码中复制。",
        "translate": ""
    },
    {
        "source": "The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics.",
        "suggest": "易失性内联函数提供旨在作用于 I/O 内存的操作，并保证编译器不会在其他易失性内联函数之间对它们进行重新排序。",
        "translate": ""
    },
    {
        "source": "See the LLVM documentation on [[volatile]].",
        "suggest": "请参见 [[volatile]] 上的 LLVM 文档。",
        "translate": ""
    },
    {
        "source": "The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings.",
        "suggest": "原子内联函数对机器字提供常见的原子操作，并具有多种可能的存储顺序。",
        "translate": ""
    },
    {
        "source": "They obey the same semantics as C++11.",
        "suggest": "它们遵循与 C++ 11 相同的语义。",
        "translate": ""
    },
    {
        "source": "See the LLVM documentation on [[atomics]].",
        "suggest": "请参见 [[atomics]] 上的 LLVM 文档。",
        "translate": ""
    },
    {
        "source": "A quick refresher on memory ordering:",
        "suggest": "关于内存排序的快速回顾:",
        "translate": ""
    },
    {
        "source": "Acquire - a barrier for acquiring a lock.",
        "suggest": "获取 - 获取锁的障碍。",
        "translate": ""
    },
    {
        "source": "Subsequent reads and writes take place after the barrier.",
        "suggest": "屏障之后将进行后续的读取和写入。",
        "translate": ""
    },
    {
        "source": "Release - a barrier for releasing a lock.",
        "suggest": "释放 - 释放锁的障碍物。",
        "translate": ""
    },
    {
        "source": "Preceding reads and writes take place before the barrier.",
        "suggest": "之前的读取和写入发生在该屏障之前。",
        "translate": ""
    },
    {
        "source": "Sequentially consistent - sequentially consistent operations are guaranteed to happen in order.",
        "suggest": "顺序一致 - 顺序一致的操作可保证按顺序进行。",
        "translate": ""
    },
    {
        "source": "This is the standard mode for working with atomic types and is equivalent to Java's `volatile`.",
        "suggest": "这是处理原子类型的标准模式，等效于 Java 的 `volatile`。",
        "translate": ""
    },
    {
        "source": "These imports are used for simplifying intra-doc links",
        "suggest": "这些导入用于简化文档内链接",
        "translate": ""
    },
    {
        "source": "see `ptr::drop_in_place`",
        "suggest": "请参见 `ptr::drop_in_place`",
        "translate": ""
    },
    {
        "source": "N.B., these intrinsics take raw pointers because they mutate aliased memory, which is not valid for either `&` or `&mut`.",
        "suggest": "注意，这些内联函数采用裸指针，因为它们会使别名内存发生可变的，这对于 `&` 或 `&mut` 均无效。",
        "translate": ""
    },
    {
        "source": "Stores a value if the current value is the same as the `old` value.",
        "suggest": "如果当前值与 `old` 值相同，则存储一个值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::SeqCst`] as both the `success` and `failure` parameters.",
        "suggest": "通过将 [`Ordering::SeqCst`] 用作 `success` 和 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "For example,",
        "suggest": "例如，",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::Acquire`] as both the `success` and `failure` parameters.",
        "suggest": "通过将 [`Ordering::Acquire`] 用作 `success` 和 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `success` 和 [`Ordering::Acquire`] 作为 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::Relaxed`] as both the `success` and `failure` parameters.",
        "suggest": "通过将 [`Ordering::Relaxed`] 用作 `success` 和 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `success` 和 [`Ordering::Acquire`] 作为 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange` method by passing [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::SeqCst`] as both the `success` and `failure` parameters.",
        "suggest": "通过将 [`Ordering::SeqCst`] 用作 `success` 和 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::Acquire`] as both the `success` and `failure` parameters.",
        "suggest": "通过将 [`Ordering::Acquire`] 用作 `success` 和 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `success` 和 [`Ordering::Acquire`] 作为 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::Relaxed`] as both the `success` and `failure` parameters.",
        "suggest": "通过将 [`Ordering::Relaxed`] 用作 `success` 和 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `success` 和 [`Ordering::Acquire`] 作为 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `compare_exchange_weak` method by passing [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the `failure` parameters.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `success` 和 [`Ordering::Relaxed`] 作为 `failure` 参数，可以通过 `compare_exchange_weak` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Loads the current value of the pointer.",
        "suggest": "加载指针的当前值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `load` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `load` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `load` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `load` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `load` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `load` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Stores the value at the specified memory location.",
        "suggest": "将值存储在指定的存储位置。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `store` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `store` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `store` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `store` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `store` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `store` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Stores the value at the specified memory location, returning the old value.",
        "suggest": "将值存储在指定的内存位置，并返回旧值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `swap` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `swap` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `swap` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `swap` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `swap` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `swap` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `swap` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `order` 传递，可以通过 `swap` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `swap` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `swap` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Adds to the current value, returning the previous value.",
        "suggest": "加到当前值，返回前一个值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_add` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `fetch_add` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_add` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `fetch_add` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_add` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `fetch_add` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_add` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `order` 传递，可以通过 `fetch_add` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_add` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `fetch_add` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Subtract from the current value, returning the previous value.",
        "suggest": "从当前值减去，返回前一个值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_sub` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `fetch_sub` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_sub` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `fetch_sub` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_sub` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `fetch_sub` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_sub` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `order` 传递，可以通过 `fetch_sub` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_sub` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `fetch_sub` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Bitwise and with the current value, returning the previous value.",
        "suggest": "对当前值按位与，返回前一个值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_and` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `fetch_and` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_and` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `fetch_and` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_and` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `fetch_and` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_and` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `order` 传递，可以通过 `fetch_and` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_and` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `fetch_and` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Bitwise nand with the current value, returning the previous value.",
        "suggest": "对当前值按位与，返回前一个值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`AtomicBool`] type via the `fetch_nand` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `fetch_nand` 方法在 [`AtomicBool`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`AtomicBool`] type via the `fetch_nand` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `fetch_nand` 方法在 [`AtomicBool`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`AtomicBool`] type via the `fetch_nand` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `fetch_nand` 方法在 [`AtomicBool`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`AtomicBool`] type via the `fetch_nand` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `order` 传递，可以通过 `fetch_nand` 方法在 [`AtomicBool`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`AtomicBool`] type via the `fetch_nand` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `fetch_nand` 方法在 [`AtomicBool`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Bitwise or with the current value, returning the previous value.",
        "suggest": "按位或具有当前值，返回前一个值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_or` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `fetch_or` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_or` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `fetch_or` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_or` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `fetch_or` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_or` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `order` 传递，可以通过 `fetch_or` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_or` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `fetch_or` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Bitwise xor with the current value, returning the previous value.",
        "suggest": "与当前值按位异或，返回前一个值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_xor` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 作为 `order` 传递，可以通过 `fetch_xor` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_xor` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 作为 `order` 传递，可以通过 `fetch_xor` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_xor` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 作为 `order` 传递，可以通过 `fetch_xor` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_xor` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 作为 `order` 传递，可以通过 `fetch_xor` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] types via the `fetch_xor` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 作为 `order` 传递，可以通过 `fetch_xor` 方法在 [`atomic`] 类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Maximum with the current value using a signed comparison.",
        "suggest": "使用带符号的比较将当前值设为最大值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_max` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_max` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_max` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_max` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Maximum with the current value.",
        "suggest": "当前值的最大值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_max` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Minimum with the current value using a signed comparison.",
        "suggest": "使用带符号的比较将当前值设为最小值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_min` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_min` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_min` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_min` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] signed integer types via the `fetch_min` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 有符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Minimum with the current value using an unsigned comparison.",
        "suggest": "使用无符号比较，使用当前值的最小值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_min` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_min` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_min` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_min` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_min` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 传递为 `order`，可以通过 `fetch_min` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Maximum with the current value using an unsigned comparison.",
        "suggest": "使用无符号比较将当前值设为最大值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_max` method by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_max` method by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_max` method by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_max` method by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available on the [`atomic`] unsigned integer types via the `fetch_max` method by passing [`Ordering::Relaxed`] as the `order`.",
        "suggest": "通过将 [`Ordering::Relaxed`] 传递为 `order`，可以通过 `fetch_max` 方法在 [`atomic`] 无符号整数类型上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported;",
        "suggest": "`prefetch` 内联函数是对代码生成器的提示，如果支持的话，它会插入一个预取指令。",
        "translate": ""
    },
    {
        "source": "otherwise, it is a no-op.",
        "suggest": "否则，它是无操作的。",
        "translate": ""
    },
    {
        "source": "Prefetches have no effect on the behavior of the program but can change its performance characteristics.",
        "suggest": "预取对程序的行为没有影响，但可以更改其性能特征。",
        "translate": ""
    },
    {
        "source": "The `locality` argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.",
        "suggest": "`locality` 参数必须是一个常量整数，并且是时间局部性说明符，范围从 (0) (无局部性) 到 (3) (在缓存中极其局部化)。",
        "translate": ""
    },
    {
        "source": "This intrinsic does not have a stable counterpart.",
        "suggest": "此内联函数没有稳定的对应对象。",
        "translate": ""
    },
    {
        "source": "An atomic fence.",
        "suggest": "原子 fence。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::fence`] by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 传递为 `order`，可以在 [`atomic::fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::fence`] by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 传递为 `order`，可以在 [`atomic::fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::fence`] by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 传递为 `order`，可以在 [`atomic::fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::fence`] by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 传递为 `order`，可以在 [`atomic::fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "A compiler-only memory barrier.",
        "suggest": "仅编译器的内存屏障。",
        "translate": ""
    },
    {
        "source": "Memory accesses will never be reordered across this barrier by the compiler, but no instructions will be emitted for it.",
        "suggest": "编译器绝不会在此障碍上对内存访问进行重新排序，但不会为此发出任何指令。",
        "translate": ""
    },
    {
        "source": "This is appropriate for operations on the same thread that may be preempted, such as when interacting with signal handlers.",
        "suggest": "这适用于可能被抢占的同一线程上的操作，例如与信号处理程序进行交互时。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`] as the `order`.",
        "suggest": "通过将 [`Ordering::SeqCst`] 传递为 `order`，可以在 [`atomic::compiler_fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::compiler_fence`] by passing [`Ordering::Acquire`] as the `order`.",
        "suggest": "通过将 [`Ordering::Acquire`] 传递为 `order`，可以在 [`atomic::compiler_fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::compiler_fence`] by passing [`Ordering::Release`] as the `order`.",
        "suggest": "通过将 [`Ordering::Release`] 传递为 `order`，可以在 [`atomic::compiler_fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is available in [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`] as the `order`.",
        "suggest": "通过将 [`Ordering::AcqRel`] 传递为 `order`，可以在 [`atomic::compiler_fence`] 中获得此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Magic intrinsic that derives its meaning from attributes attached to the function.",
        "suggest": "从函数附带的属性中获取其含义的魔术内联函数。",
        "translate": ""
    },
    {
        "source": "For example, dataflow uses this to inject static assertions so that `rustc_peek(potentially_uninitialized)` would actually double-check that dataflow did indeed compute that it is uninitialized at that point in the control flow.",
        "suggest": "例如，数据流使用它来注入静态断言，以便 `rustc_peek(potentially_uninitialized)` 实际上会再次检查数据流确实确实计算出该数据流在控制流中未初始化。",
        "translate": ""
    },
    {
        "source": "This intrinsic should not be used outside of the compiler.",
        "suggest": "不应在编译器外部使用此内联函数。",
        "translate": ""
    },
    {
        "source": "Aborts the execution of the process.",
        "suggest": "中止进程的执行。",
        "translate": ""
    },
    {
        "source": "A more user-friendly and stable version of this operation is [`std::process::abort`](../../std/process/fn.abort.html).",
        "suggest": "[`std::process::abort`](../../std/process/fn.abort.html) 是此操作的更用户友好和稳定的版本。",
        "translate": ""
    },
    {
        "source": "Informs the optimizer that this point in the code is not reachable, enabling further optimizations.",
        "suggest": "通知优化器代码中的这一点不可访问，从而可以进行进一步的优化。",
        "translate": ""
    },
    {
        "source": "N.B., this is very different from the `unreachable!()` macro: Unlike the macro, which panics when it is executed, it is *undefined behavior* to reach code marked with this function.",
        "suggest": "注意，这与 `unreachable!()` 宏非常不同: 与执行 panics 的宏不同，到达带有此函数标记的代码是 *undefined 行为*。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`](crate::hint::unreachable_unchecked).",
        "suggest": "此内联函数的稳定版本为 [`core::hint::unreachable_unchecked`](crate::hint::unreachable_unchecked)。",
        "translate": ""
    },
    {
        "source": "Informs the optimizer that a condition is always true.",
        "suggest": "通知优化器条件始终为真。",
        "translate": ""
    },
    {
        "source": "If the condition is false, the behavior is undefined.",
        "suggest": "如果条件为假，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "No code is generated for this intrinsic, but the optimizer will try to preserve it (and its condition) between passes, which may interfere with optimization of surrounding code and reduce performance.",
        "suggest": "没有为该内联函数生成任何代码，但是优化器将尝试在通过之间保留它 (及其条件)，这可能会干扰周围代码的优化并降低性能。",
        "translate": ""
    },
    {
        "source": "It should not be used if the invariant can be discovered by the optimizer on its own, or if it does not enable any significant optimizations.",
        "suggest": "如果优化器可以自己发现不可变变量，或者不启用任何重要的优化，则不应使用该变量。",
        "translate": ""
    },
    {
        "source": "Hints to the compiler that branch condition is likely to be true.",
        "suggest": "提示编译器分支条件很可能是正确的。",
        "translate": ""
    },
    {
        "source": "Returns the value passed to it.",
        "suggest": "返回传递给它的值。",
        "translate": ""
    },
    {
        "source": "Any use other than with `if` statements will probably not have an effect.",
        "suggest": "除与 `if` 语句一起使用外，其他任何使用都可能无效。",
        "translate": ""
    },
    {
        "source": "Hints to the compiler that branch condition is likely to be false.",
        "suggest": "提示编译器分支条件可能为 false。",
        "translate": ""
    },
    {
        "source": "Executes a breakpoint trap, for inspection by a debugger.",
        "suggest": "执行一个断点陷阱，以供调试器检查。",
        "translate": ""
    },
    {
        "source": "The size of a type in bytes.",
        "suggest": "类型的大小 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "More specifically, this is the offset in bytes between successive items of the same type, including alignment padding.",
        "suggest": "更具体地说，这是相同类型的连续项之间的字节偏移量，包括对齐填充。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::size_of`](crate::mem::size_of).",
        "suggest": "此内联函数的稳定版本为 [`core::mem::size_of`](crate::mem::size_of)。",
        "translate": ""
    },
    {
        "source": "The minimum alignment of a type.",
        "suggest": "类型的最小对齐方式。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::align_of`](crate::mem::align_of).",
        "suggest": "此内联函数的稳定版本为 [`core::mem::align_of`](crate::mem::align_of)。",
        "translate": ""
    },
    {
        "source": "The preferred alignment of a type.",
        "suggest": "类型的首选对齐方式。",
        "translate": ""
    },
    {
        "source": "The size of the referenced value in bytes.",
        "suggest": "引用值的大小 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`mem::size_of_val`].",
        "suggest": "此内联函数的稳定版本为 [`mem::size_of_val`]。",
        "translate": ""
    },
    {
        "source": "The required alignment of the referenced value.",
        "suggest": "参考值的所需对齐方式。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::align_of_val`](crate::mem::align_of_val).",
        "suggest": "此内联函数的稳定版本为 [`core::mem::align_of_val`](crate::mem::align_of_val)。",
        "translate": ""
    },
    {
        "source": "Gets a static string slice containing the name of a type.",
        "suggest": "获取包含类型名称的静态字符串切片。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::any::type_name`](crate::any::type_name).",
        "suggest": "此内联函数的稳定版本为 [`core::any::type_name`](crate::any::type_name)。",
        "translate": ""
    },
    {
        "source": "Gets an identifier which is globally unique to the specified type.",
        "suggest": "获取一个标识符，该标识符对于指定的类型是全局唯一的。",
        "translate": ""
    },
    {
        "source": "This function will return the same value for a type regardless of whichever crate it is invoked in.",
        "suggest": "无论调用哪个 crate，此函数都将为类型返回相同的值。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::any::TypeId::of`](crate::any::TypeId::of).",
        "suggest": "此内联函数的稳定版本为 [`core::any::TypeId::of`](crate::any::TypeId::of)。",
        "translate": ""
    },
    {
        "source": "A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:",
        "suggest": "如果 `T` 未定义，则无法执行的不安全函数的守卫:",
        "translate": ""
    },
    {
        "source": "This will statically either panic, or do nothing.",
        "suggest": "这将静态地为 panic，或者什么也不做。",
        "translate": ""
    },
    {
        "source": "A guard for unsafe functions that cannot ever be executed if `T` does not permit zero-initialization: This will statically either panic, or do nothing.",
        "suggest": "如果 `T` 不允许零初始化，则永远不能执行的不安全函数的守卫: 这将静态 panic，或者什么也不做。",
        "translate": ""
    },
    {
        "source": "A guard for unsafe functions that cannot ever be executed if `T` has invalid bit patterns: This will statically either panic, or do nothing.",
        "suggest": "如果 `T` 具有无效的位模式，则永远不能执行的不安全函数的守卫: 这将静态地 panic，或者什么也不做。",
        "translate": ""
    },
    {
        "source": "Gets a reference to a static `Location` indicating where it was called.",
        "suggest": "获取对静态 `Location` 的引用，以指示在何处调用了它。",
        "translate": ""
    },
    {
        "source": "Consider using [`core::panic::Location::caller`](crate::panic::Location::caller) instead.",
        "suggest": "考虑改用 [`core::panic::Location::caller`](crate::panic::Location::caller)。",
        "translate": ""
    },
    {
        "source": "Moves a value out of scope without running drop glue.",
        "suggest": "将值移出作用域。 而无需运行丢弃守卫。",
        "translate": ""
    },
    {
        "source": "This exists solely for [`mem::forget_unsized`];",
        "suggest": "这仅适用于 [`mem::forget_unsized`]。",
        "translate": ""
    },
    {
        "source": "normal `forget` uses `ManuallyDrop` instead.",
        "suggest": "正常情况下，请改用 `forget` 为 `ManuallyDrop`。",
        "translate": ""
    },
    {
        "source": "Reinterprets the bits of a value of one type as another type.",
        "suggest": "将一种类型的值的位重新解释为另一种类型。",
        "translate": ""
    },
    {
        "source": "Both types must have the same size.",
        "suggest": "两种类型都必须具有相同的大小。",
        "translate": ""
    },
    {
        "source": "Neither the original, nor the result, may be an [invalid value](../../nomicon/what-unsafe-does.html).",
        "suggest": "[invalid value](../../nomicon/what-unsafe-does.html) 既不是原始版本，也不是结果。",
        "translate": ""
    },
    {
        "source": "is semantically equivalent to a bitwise move of one type into another.",
        "suggest": "在语义上等效于从一种类型到另一种类型的按位移动。",
        "translate": ""
    },
    {
        "source": "It copies the bits from the source value into the destination value, then forgets the original.",
        "suggest": "它将位从源值复制到目标值，然后忘记原始值。",
        "translate": ""
    },
    {
        "source": "It's equivalent to C's `memcpy` under the hood, just like `transmute_copy`.",
        "suggest": "就像 `transmute_copy` 一样，它等同于 C 的引擎盖下的 `memcpy`。",
        "translate": ""
    },
    {
        "source": "Because `transmute` is a by-value operation, alignment of the *transmuted values themselves* is not a concern.",
        "suggest": "由于 `transmute` 是按值运算，因此不必担心 *transmuted values 本身的对齐*。",
        "translate": ""
    },
    {
        "source": "As with any other function, the compiler already ensures both `T` and `U` are properly aligned.",
        "suggest": "与任何其他函数一样，编译器已经确保 `T` 和 `U` 都正确对齐。",
        "translate": ""
    },
    {
        "source": "However, when transmuting values that *point elsewhere* (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values.",
        "suggest": "但是，当将 *point 的值转换为其他位置*(例如指针，引用，boxes…) 时，调用者必须确保所指向的值正确对齐。",
        "translate": ""
    },
    {
        "source": "is **incredibly** unsafe.",
        "suggest": "是非常不安全的。",
        "translate": ""
    },
    {
        "source": "There are a vast number of ways to cause [undefined behavior][ub] with this function.",
        "suggest": "有很多方法可以使用此函数来导致 [未定义的行为][ub]。",
        "translate": ""
    },
    {
        "source": "`transmute` should be the absolute last resort.",
        "suggest": "`transmute` 应该是绝对不得已的方法。",
        "translate": ""
    },
    {
        "source": "The [nomicon](../../nomicon/transmutes.html) has additional documentation.",
        "suggest": "[nomicon](../../nomicon/transmutes.html) 具有其他文档。",
        "translate": ""
    },
    {
        "source": "There are a few things that `transmute` is really useful for.",
        "suggest": "`transmute` 确实有一些用途。",
        "translate": ""
    },
    {
        "source": "Turning a pointer into a function pointer.",
        "suggest": "将指针转换为函数指针。",
        "translate": ""
    },
    {
        "source": "This is *not* portable to machines where function pointers and data pointers have different sizes.",
        "suggest": "对于函数指针和数据指针具有不同大小的机器，这不是可移植的。",
        "translate": ""
    },
    {
        "source": "Extending a lifetime, or shortening an invariant lifetime.",
        "suggest": "延长生命周期或缩短不变的生命周期。",
        "translate": ""
    },
    {
        "source": "This is advanced, very unsafe Rust!",
        "suggest": "这是高级的，非常不安全的 Rust!",
        "translate": ""
    },
    {
        "source": "Don't despair: many uses of `transmute` can be achieved through other means.",
        "suggest": "不要失望: `transmute` 的许多用途可以通过其他方式实现。",
        "translate": ""
    },
    {
        "source": "Below are common applications of `transmute` which can be replaced with safer constructs.",
        "suggest": "以下是 `transmute` 的常见应用程序，可以用更安全的结构替换它。",
        "translate": ""
    },
    {
        "source": "Turning raw bytes(`&[u8]`) to `u32`, `f64`, etc.:",
        "suggest": "将原始 bytes(`&[u8]`) 转换为 `u32`，`f64` 等:",
        "translate": ""
    },
    {
        "source": "Turning a pointer into a `usize`:",
        "suggest": "将指针变成 `usize`:",
        "translate": ""
    },
    {
        "source": "Turning a `*mut T` into an `&mut T`:",
        "suggest": "将 `*mut T` 变成 `&mut T`:",
        "translate": ""
    },
    {
        "source": "Turning an `&mut T` into an `&mut U`:",
        "suggest": "将 `&mut T` 变成 `&mut U`:",
        "translate": ""
    },
    {
        "source": "Turning an `&str` into an `&[u8]`:",
        "suggest": "将 `&str` 变成 `&[u8]`:",
        "translate": ""
    },
    {
        "source": "Turning a `Vec<&T>` into a `Vec<Option<&T>>`.",
        "suggest": "将 `Vec<&T>` 变成 `Vec<Option<&T>>`。",
        "translate": ""
    },
    {
        "source": "To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants.",
        "suggest": "要转换容器内容的内部类型，必须确保不违反容器的任何不变式。",
        "translate": ""
    },
    {
        "source": "For `Vec`, this means that both the size *and alignment* of the inner types have to match.",
        "suggest": "对于 `Vec`，这意味着内部类型的大小和对齐方式都必须匹配。",
        "translate": ""
    },
    {
        "source": "Other containers might rely on the size of the type, alignment, or even the `TypeId`, in which case transmuting wouldn't be possible at all without violating the container invariants.",
        "suggest": "其他容器可能依赖于类型，对齐方式甚至 `TypeId` 的大小，在这种情况下，在不违反容器不变式的情况下根本不可能进行转换。",
        "translate": ""
    },
    {
        "source": "Implementing `split_at_mut`:",
        "suggest": "实现 `split_at_mut`:",
        "translate": ""
    },
    {
        "source": "While this makes the intrinsic const stable, we have some custom code in const fn checks that prevent its use within `const fn`.",
        "suggest": "尽管这使内部 const 保持稳定，但我们在 const fn 检查中有一些自定义代码，以防止在 `const fn` 中使用它。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the actual type given as `T` requires drop glue;",
        "suggest": "如果 `T` 给出的实际类型需要丢弃 glue，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "returns `false` if the actual type provided for `T` implements `Copy`.",
        "suggest": "如果为 `T` 提供的实际类型实现 `Copy`，则返回 `false`。",
        "translate": ""
    },
    {
        "source": "If the actual type neither requires drop glue nor implements `Copy`, then the return value of this function is unspecified.",
        "suggest": "如果实际类型既不需要丢弃 glue 也不需要实现 `Copy`，则该函数的返回值不确定。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).",
        "suggest": "此内联函数的稳定版本为 [`mem::needs_drop`](crate::mem::needs_drop)。",
        "translate": ""
    },
    {
        "source": "Calculates the offset from a pointer.",
        "suggest": "计算与指针的偏移量。",
        "translate": ""
    },
    {
        "source": "This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.",
        "suggest": "这被实现为内联函数，以避免与整数进行转换，因为转换会丢弃别名信息。",
        "translate": ""
    },
    {
        "source": "Both the starting and resulting pointer must be either in bounds or one byte past the end of an allocated object.",
        "suggest": "起始指针和结果指针都必须在已分配对象末尾的范围之内或一个字节内。",
        "translate": ""
    },
    {
        "source": "If either pointer is out of bounds or arithmetic overflow occurs then any further use of the returned value will result in undefined behavior.",
        "suggest": "如果指针越界或发生算术溢出，则进一步使用返回值将导致不确定的行为。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`pointer::offset`].",
        "suggest": "此内联函数的稳定版本为 [`pointer::offset`]。",
        "translate": ""
    },
    {
        "source": "Calculates the offset from a pointer, potentially wrapping.",
        "suggest": "计算与指针的偏移量 (可能会自动换行)。",
        "translate": ""
    },
    {
        "source": "This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.",
        "suggest": "这被实现为内联函数，以避免与整数进行相互转换，因为该转换会禁止某些优化。",
        "translate": ""
    },
    {
        "source": "Unlike the `offset` intrinsic, this intrinsic does not restrict the resulting pointer to point into or one byte past the end of an allocated object, and it wraps with two's complement arithmetic.",
        "suggest": "与 `offset` 内联函数不同，此内联函数不会限制结果指针指向已分配对象的末尾或指向该对象末尾一个字节，并且使用二进制补码算法进行换行。",
        "translate": ""
    },
    {
        "source": "The resulting value is not necessarily valid to be used to actually access memory.",
        "suggest": "结果值不一定有效地用于实际访问内存。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`pointer::wrapping_offset`].",
        "suggest": "此内联函数的稳定版本为 [`pointer::wrapping_offset`]。",
        "translate": ""
    },
    {
        "source": "Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of",
        "suggest": "等效于适当的 `llvm.memcpy.p0i8.0i8.*` 本征，大小为 `count`*`size_of::<T>()`，对齐方式为",
        "translate": ""
    },
    {
        "source": "The volatile parameter is set to `true`, so it will not be optimized out unless size is equal to zero.",
        "suggest": "volatile 参数设置为 `true`，因此除非大小等于零，否则不会对其进行优化。",
        "translate": ""
    },
    {
        "source": "Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with a size of `count * size_of::<T>()` and an alignment of",
        "suggest": "等效于适当的 `llvm.memmove.p0i8.0i8.*` 本征，大小为 `count* size_of::<T>()`，对齐方式为",
        "translate": ""
    },
    {
        "source": "Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a size of `count * size_of::<T>()` and an alignment of `min_align_of::<T>()`.",
        "suggest": "等效于适当的 `llvm.memset.p0i8.*` 内联函数，其大小为 `count* size_of::<T>()`，并且对齐方式为 `min_align_of::<T>()`。",
        "translate": ""
    },
    {
        "source": "Performs a volatile load from the `src` pointer.",
        "suggest": "从 `src` 指针执行易失性加载。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::ptr::read_volatile`](crate::ptr::read_volatile).",
        "suggest": "此内联函数的稳定版本为 [`core::ptr::read_volatile`](crate::ptr::read_volatile)。",
        "translate": ""
    },
    {
        "source": "Performs a volatile store to the `dst` pointer.",
        "suggest": "对 `dst` 指针执行易失性存储。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::ptr::write_volatile`](crate::ptr::write_volatile).",
        "suggest": "此内联函数的稳定版本为 [`core::ptr::write_volatile`](crate::ptr::write_volatile)。",
        "translate": ""
    },
    {
        "source": "Performs a volatile load from the `src` pointer The pointer is not required to be aligned.",
        "suggest": "从 `src` 指针执行易失性加载不需要将指针对齐。",
        "translate": ""
    },
    {
        "source": "The pointer is not required to be aligned.",
        "suggest": "指针不需要对齐。",
        "translate": ""
    },
    {
        "source": "Returns the square root of an `f32`",
        "suggest": "返回 `f32` 的平方根",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is",
        "suggest": "此内联函数的稳定版本是",
        "translate": ""
    },
    {
        "source": "Returns the square root of an `f64`",
        "suggest": "返回 `f64` 的平方根",
        "translate": ""
    },
    {
        "source": "Raises an `f32` to an integer power.",
        "suggest": "将 `f32` 提升为整数幂。",
        "translate": ""
    },
    {
        "source": "Raises an `f64` to an integer power.",
        "suggest": "将 `f64` 提升为整数幂。",
        "translate": ""
    },
    {
        "source": "Returns the sine of an `f32`.",
        "suggest": "返回 `f32` 的正弦值。",
        "translate": ""
    },
    {
        "source": "Returns the sine of an `f64`.",
        "suggest": "返回 `f64` 的正弦值。",
        "translate": ""
    },
    {
        "source": "Returns the cosine of an `f32`.",
        "suggest": "返回 `f32` 的余弦值。",
        "translate": ""
    },
    {
        "source": "Returns the cosine of an `f64`.",
        "suggest": "返回 `f64` 的余弦值。",
        "translate": ""
    },
    {
        "source": "Raises an `f32` to an `f32` power.",
        "suggest": "将 `f32` 提升到 `f32` 的幂。",
        "translate": ""
    },
    {
        "source": "Raises an `f64` to an `f64` power.",
        "suggest": "将 `f64` 提升到 `f64` 的幂。",
        "translate": ""
    },
    {
        "source": "Returns the exponential of an `f32`.",
        "suggest": "返回 `f32` 的指数。",
        "translate": ""
    },
    {
        "source": "Returns the exponential of an `f64`.",
        "suggest": "返回 `f64` 的指数。",
        "translate": ""
    },
    {
        "source": "Returns 2 raised to the power of an `f32`.",
        "suggest": "返回 2 乘以 `f32` 的幂。",
        "translate": ""
    },
    {
        "source": "Returns 2 raised to the power of an `f64`.",
        "suggest": "返回 2 乘以 `f64` 的幂。",
        "translate": ""
    },
    {
        "source": "Returns the natural logarithm of an `f32`.",
        "suggest": "返回 `f32` 的自然对数。",
        "translate": ""
    },
    {
        "source": "Returns the natural logarithm of an `f64`.",
        "suggest": "返回 `f64` 的自然对数。",
        "translate": ""
    },
    {
        "source": "Returns the base 10 logarithm of an `f32`.",
        "suggest": "返回 `f32` 的以 10 为底的对数。",
        "translate": ""
    },
    {
        "source": "Returns the base 10 logarithm of an `f64`.",
        "suggest": "返回 `f64` 的以 10 为底的对数。",
        "translate": ""
    },
    {
        "source": "Returns the base 2 logarithm of an `f32`.",
        "suggest": "返回 `f32` 的以 2 为底的对数。",
        "translate": ""
    },
    {
        "source": "Returns the base 2 logarithm of an `f64`.",
        "suggest": "返回 `f64` 的以 2 为底的对数。",
        "translate": ""
    },
    {
        "source": "Returns `a * b + c` for `f32` values.",
        "suggest": "为 `f32` 值返回 `a * b + c`。",
        "translate": ""
    },
    {
        "source": "Returns `a * b + c` for `f64` values.",
        "suggest": "为 `f64` 值返回 `a * b + c`。",
        "translate": ""
    },
    {
        "source": "Returns the absolute value of an `f32`.",
        "suggest": "返回 `f32` 的绝对值。",
        "translate": ""
    },
    {
        "source": "Returns the absolute value of an `f64`.",
        "suggest": "返回 `f64` 的绝对值。",
        "translate": ""
    },
    {
        "source": "Returns the minimum of two `f32` values.",
        "suggest": "返回两个 `f32` 值中的最小值。",
        "translate": ""
    },
    {
        "source": "Returns the minimum of two `f64` values.",
        "suggest": "返回两个 `f64` 值中的最小值。",
        "translate": ""
    },
    {
        "source": "Returns the maximum of two `f32` values.",
        "suggest": "返回两个 `f32` 值的最大值。",
        "translate": ""
    },
    {
        "source": "Returns the maximum of two `f64` values.",
        "suggest": "返回两个 `f64` 值的最大值。",
        "translate": ""
    },
    {
        "source": "Copies the sign from `y` to `x` for `f32` values.",
        "suggest": "将 `f32` 值的符号从 `y` 复制到 `x`。",
        "translate": ""
    },
    {
        "source": "Copies the sign from `y` to `x` for `f64` values.",
        "suggest": "将 `f64` 值的符号从 `y` 复制到 `x`。",
        "translate": ""
    },
    {
        "source": "Returns the largest integer less than or equal to an `f32`.",
        "suggest": "返回小于或等于 `f32` 的最大整数。",
        "translate": ""
    },
    {
        "source": "Returns the largest integer less than or equal to an `f64`.",
        "suggest": "返回小于或等于 `f64` 的最大整数。",
        "translate": ""
    },
    {
        "source": "Returns the smallest integer greater than or equal to an `f32`.",
        "suggest": "返回大于或等于 `f32` 的最小整数。",
        "translate": ""
    },
    {
        "source": "Returns the smallest integer greater than or equal to an `f64`.",
        "suggest": "返回大于或等于 `f64` 的最小整数。",
        "translate": ""
    },
    {
        "source": "Returns the integer part of an `f32`.",
        "suggest": "返回 `f32` 的整数部分。",
        "translate": ""
    },
    {
        "source": "Returns the integer part of an `f64`.",
        "suggest": "返回 `f64` 的整数部分。",
        "translate": ""
    },
    {
        "source": "Returns the nearest integer to an `f32`.",
        "suggest": "返回最接近 `f32` 的整数。",
        "translate": ""
    },
    {
        "source": "May raise an inexact floating-point exception if the argument is not an integer.",
        "suggest": "如果参数不是整数，则可能会引发不精确的浮点异常。",
        "translate": ""
    },
    {
        "source": "Returns the nearest integer to an `f64`.",
        "suggest": "返回最接近 `f64` 的整数。",
        "translate": ""
    },
    {
        "source": "Float addition that allows optimizations based on algebraic rules.",
        "suggest": "浮点数加法允许基于代数规则进行优化。",
        "translate": ""
    },
    {
        "source": "May assume inputs are finite.",
        "suggest": "可以假设输入是有限的。",
        "translate": ""
    },
    {
        "source": "Float subtraction that allows optimizations based on algebraic rules.",
        "suggest": "浮点减法允许基于代数规则进行优化。",
        "translate": ""
    },
    {
        "source": "Float multiplication that allows optimizations based on algebraic rules.",
        "suggest": "浮点乘法允许基于代数规则进行优化。",
        "translate": ""
    },
    {
        "source": "Float division that allows optimizations based on algebraic rules.",
        "suggest": "浮点除法允许基于代数规则进行优化。",
        "translate": ""
    },
    {
        "source": "Float remainder that allows optimizations based on algebraic rules.",
        "suggest": "浮余数允许基于代数规则进行优化。",
        "translate": ""
    },
    {
        "source": "Convert with LLVM’s fptoui/fptosi, which may return undef for values out of range",
        "suggest": "使用 LLVM 的 fptoui/fptosi 进行转换，对于越界的值可能会返回 undef",
        "translate": ""
    },
    {
        "source": "Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].",
        "suggest": "稳定为 [`f32::to_int_unchecked`] 和 [`f64::to_int_unchecked`]。",
        "translate": ""
    },
    {
        "source": "Returns the number of bits set in an integer type `T`",
        "suggest": "返回整数类型 `T` 中设置的位数",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `count_ones` method.",
        "suggest": "可通过 `count_ones` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Returns the number of leading unset bits (zeroes) in an integer type `T`.",
        "suggest": "返回整数类型 `T` 的前导未设置位 (zeroes) 的数量。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `leading_zeros` method.",
        "suggest": "可通过 `leading_zeros` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "An `x` with value `0` will return the bit width of `T`.",
        "suggest": "值为 `0` 的 `x` 将返回 `T` 的位宽。",
        "translate": ""
    },
    {
        "source": "Like `ctlz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`.",
        "suggest": "类似于 `ctlz`，但是非常不安全，因为当给定值 `0` 的 `x` 时，它返回 `undef`。",
        "translate": ""
    },
    {
        "source": "Returns the number of trailing unset bits (zeroes) in an integer type `T`.",
        "suggest": "返回整数类型 `T` 的尾随未设置位 (zeroes) 的数量。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `trailing_zeros` method.",
        "suggest": "可通过 `trailing_zeros` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "An `x` with value `0` will return the bit width of `T`:",
        "suggest": "值为 `0` 的 `x` 将返回 `T` 的位宽:",
        "translate": ""
    },
    {
        "source": "Like `cttz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`.",
        "suggest": "类似于 `cttz`，但是非常不安全，因为当给定值 `0` 的 `x` 时，它返回 `undef`。",
        "translate": ""
    },
    {
        "source": "Reverses the bytes in an integer type `T`.",
        "suggest": "反转整数类型 `T` 中的字节。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `swap_bytes` method.",
        "suggest": "可通过 `swap_bytes` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Reverses the bits in an integer type `T`.",
        "suggest": "反转整数类型 `T` 中的位。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `reverse_bits` method.",
        "suggest": "可通过 `reverse_bits` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Performs checked integer addition.",
        "suggest": "执行检查的整数加法。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `overflowing_add` method.",
        "suggest": "可通过 `overflowing_add` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Performs checked integer subtraction",
        "suggest": "执行检查的整数减法",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `overflowing_sub` method.",
        "suggest": "可通过 `overflowing_sub` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Performs checked integer multiplication",
        "suggest": "执行检查的整数乘法",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `overflowing_mul` method.",
        "suggest": "可通过 `overflowing_mul` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Performs an exact division, resulting in undefined behavior where `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`",
        "suggest": "执行精确除法，从而导致 `x % y != 0` 或 `y == 0` 或 `x == T::MIN && y == -1` 出现不确定的行为",
        "translate": ""
    },
    {
        "source": "Performs an unchecked division, resulting in undefined behavior where `y == 0` or `x == T::MIN && y == -1`",
        "suggest": "执行未经检查的除法，从而导致 `y == 0` 或 `x == T::MIN && y == -1` 出现不确定的行为",
        "translate": ""
    },
    {
        "source": "Safe wrappers for this intrinsic are available on the integer primitives via the `checked_div` method.",
        "suggest": "可通过 `checked_div` 方法在整数基元上使用此内联函数的安全包装。",
        "translate": ""
    },
    {
        "source": "Returns the remainder of an unchecked division, resulting in undefined behavior when `y == 0` or `x == T::MIN && y == -1`",
        "suggest": "返回未经检查的除法的其余部分，从而在 `y == 0` 或 `x == T::MIN && y == -1` 时导致未定义的行为",
        "translate": ""
    },
    {
        "source": "Safe wrappers for this intrinsic are available on the integer primitives via the `checked_rem` method.",
        "suggest": "可通过 `checked_rem` 方法在整数基元上使用此内联函数的安全包装。",
        "translate": ""
    },
    {
        "source": "Performs an unchecked left shift, resulting in undefined behavior when `y < 0` or `y >= N`, where N is the width of T in bits.",
        "suggest": "执行未经检查的左移，导致 `y < 0` 或 `y >= N` 出现不确定的行为，其中 N 是 T 的宽度 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "Safe wrappers for this intrinsic are available on the integer primitives via the `checked_shl` method.",
        "suggest": "可通过 `checked_shl` 方法在整数基元上使用此内联函数的安全包装。",
        "translate": ""
    },
    {
        "source": "Performs an unchecked right shift, resulting in undefined behavior when `y < 0` or `y >= N`, where N is the width of T in bits.",
        "suggest": "执行未经检查的右移，导致 `y < 0` 或 `y >= N` 出现不确定的行为，其中 N 是 T 的宽度 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "Safe wrappers for this intrinsic are available on the integer primitives via the `checked_shr` method.",
        "suggest": "可通过 `checked_shr` 方法在整数基元上使用此内联函数的安全包装。",
        "translate": ""
    },
    {
        "source": "Returns the result of an unchecked addition, resulting in undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.",
        "suggest": "返回未经检查的加法运算的结果，导致 `x + y > T::MAX` 或 `x + y < T::MIN` 出现不确定的行为。",
        "translate": ""
    },
    {
        "source": "Returns the result of an unchecked subtraction, resulting in undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.",
        "suggest": "返回未经检查的减法的结果，当 `x - y > T::MAX` 或 `x - y < T::MIN` 时导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "Returns the result of an unchecked multiplication, resulting in undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.",
        "suggest": "返回未经检查的乘法的结果，当 `x *y > T::MAX` 或 `x* y < T::MIN` 时导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "Performs rotate left.",
        "suggest": "向左旋转。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `rotate_left` method.",
        "suggest": "可通过 `rotate_left` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Performs rotate right.",
        "suggest": "向右旋转。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `rotate_right` method.",
        "suggest": "可通过 `rotate_right` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.",
        "suggest": "返回 (a + b) mod 2 <sup>N</sup>，其中 N 是 T 的宽度 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `wrapping_add` method.",
        "suggest": "可通过 `wrapping_add` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.",
        "suggest": "返回 (a-b) mod 2 <sup>N</sup>，其中 N 是 T 的宽度 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `wrapping_sub` method.",
        "suggest": "可通过 `wrapping_sub` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.",
        "suggest": "返回 (a * b) mod 2 <sup>N</sup>，其中 N 是 T 的宽度 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `wrapping_mul` method.",
        "suggest": "可通过 `wrapping_mul` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Computes `a + b`, saturating at numeric bounds.",
        "suggest": "计算 `a + b`，在数字范围内达到饱和。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `saturating_add` method.",
        "suggest": "可通过 `saturating_add` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Computes `a - b`, saturating at numeric bounds.",
        "suggest": "计算 `a - b`，在数字范围内达到饱和。",
        "translate": ""
    },
    {
        "source": "The stabilized versions of this intrinsic are available on the integer primitives via the `saturating_sub` method.",
        "suggest": "可通过 `saturating_sub` 方法在整数基元上使用此内联函数的稳定版本。",
        "translate": ""
    },
    {
        "source": "Returns the value of the discriminant for the variant in 'v';",
        "suggest": "返回 'v' 中成员的判别式的值;",
        "translate": ""
    },
    {
        "source": "if `T` has no discriminant, returns `0`.",
        "suggest": "如果 `T` 没有判别，则返回 `0`。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::discriminant`](crate::mem::discriminant).",
        "suggest": "此内联函数的稳定版本为 [`core::mem::discriminant`](crate::mem::discriminant)。",
        "translate": ""
    },
    {
        "source": "Returns the number of variants of the type `T` cast to a `usize`;",
        "suggest": "返回强制转换为 `usize` 的 `T` 类型的成员的数量;",
        "translate": ""
    },
    {
        "source": "if `T` has no variants, returns `0`.",
        "suggest": "如果 `T` 没有成员，则返回 `0`。",
        "translate": ""
    },
    {
        "source": "Uninhabited variants will be counted.",
        "suggest": "无人居住的成员将被计算在内。",
        "translate": ""
    },
    {
        "source": "The to-be-stabilized version of this intrinsic is [`mem::variant_count`].",
        "suggest": "此内联函数的稳定版本为 [`mem::variant_count`]。",
        "translate": ""
    },
    {
        "source": "Rust's \"try catch\" construct which invokes the function pointer `try_fn` with the data pointer `data`.",
        "suggest": "Rust 的 \"try catch\" 构造使用数据指针 `data` 调用函数指针 `try_fn`。",
        "translate": ""
    },
    {
        "source": "The third argument is a function called if a panic occurs.",
        "suggest": "第三个参数是如果发生 panic 则调用的函数。",
        "translate": ""
    },
    {
        "source": "This function takes the data pointer and a pointer to the target-specific exception object that was caught.",
        "suggest": "此函数采用数据指针和指向所捕获的特定于目标的异常对象的指针。",
        "translate": ""
    },
    {
        "source": "For more information see the compiler's source as well as std's catch implementation.",
        "suggest": "有关更多信息，请参见编译器的源代码以及 std 的 catch 实现。",
        "translate": ""
    },
    {
        "source": "Emits a `!nontemporal` store according to LLVM (see their docs).",
        "suggest": "根据 LLVM 发出 `!nontemporal` 存储 (请参见其文档)。",
        "translate": ""
    },
    {
        "source": "Probably will never become stable.",
        "suggest": "可能永远都不会变得稳定。",
        "translate": ""
    },
    {
        "source": "See documentation of `<*const T>::offset_from` for details.",
        "suggest": "有关详细信息，请参见 `<*const T>::offset_from` 的文档。",
        "translate": ""
    },
    {
        "source": "See documentation of `<*const T>::guaranteed_eq` for details.",
        "suggest": "有关详细信息，请参见 `<*const T>::guaranteed_eq` 的文档。",
        "translate": ""
    },
    {
        "source": "See documentation of `<*const T>::guaranteed_ne` for details.",
        "suggest": "有关详细信息，请参见 `<*const T>::guaranteed_ne` 的文档。",
        "translate": ""
    },
    {
        "source": "Allocate at compile time.",
        "suggest": "在编译时分配。",
        "translate": ""
    },
    {
        "source": "Should not be called at runtime.",
        "suggest": "不应在运行时调用。",
        "translate": ""
    },
    {
        "source": "Some functions are defined here because they accidentally got made available in this module on stable.",
        "suggest": "之所以在这里定义一些函数，是因为它们意外地在稳定模块中可用。",
        "translate": ""
    },
    {
        "source": "See <https://github.com/rust-lang/rust/issues/15702>.",
        "suggest": "请参见 <https://github.com/rust-lang/rust/issues/15702>。",
        "translate": ""
    },
    {
        "source": "(`transmute` also falls into this category, but it cannot be wrapped due to the check that `T` and `U` have the same size.)",
        "suggest": "(`transmute` 也属于此类别，但是由于检查 `T` 和 `U` 具有相同的大小，因此无法将其包装。)",
        "translate": ""
    },
    {
        "source": "Checks whether `ptr` is properly aligned with respect to `align_of::<T>()`.",
        "suggest": "检查 `ptr` 是否相对于 `align_of::<T>()` 正确对齐。",
        "translate": ""
    },
    {
        "source": "Copies `count * size_of::<T>()` bytes from `src` to `dst`.",
        "suggest": "将 `count * size_of::<T>()` 字节从 `src` 复制到 `dst`。",
        "translate": ""
    },
    {
        "source": "The source and destination must *not* overlap.",
        "suggest": "源和目标必须不重叠。",
        "translate": ""
    },
    {
        "source": "For regions of memory which might overlap, use [`copy`] instead.",
        "suggest": "对于可能重叠的内存区域，请改用 [`copy`]。",
        "translate": ""
    },
    {
        "source": "is semantically equivalent to C's [`memcpy`], but with the argument order swapped.",
        "suggest": "在语义上等效于 C 的 [`memcpy`]，但是交换了参数顺序。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if any of the following conditions are violated:",
        "suggest": "如果违反以下任一条件，则行为是未定义的:",
        "translate": ""
    },
    {
        "source": "must be [valid] for reads of `count * size_of::<T>()` bytes.",
        "suggest": "必须为 [valid] 才能读取 `count * size_of::<T>()` 字节。",
        "translate": ""
    },
    {
        "source": "must be [valid] for writes of `count * size_of::<T>()` bytes.",
        "suggest": "对于写入 `count * size_of::<T>()` 字节，必须为 [valid]。",
        "translate": ""
    },
    {
        "source": "Both `src` and `dst` must be properly aligned.",
        "suggest": "`src` 和 `dst` 必须正确对齐。",
        "translate": ""
    },
    {
        "source": "The region of memory beginning at `src` with a size of `count",
        "suggest": "从 `src` 开始的内存区域，大小为 `count",
        "translate": ""
    },
    {
        "source": "size_of::<T>()` bytes must *not* overlap with the region of memory beginning at `dst` with the same size.",
        "suggest": "size_of::<T> () ` 字节不得与以 `dst` 开始且大小相同的内存区域重叠。",
        "translate": ""
    },
    {
        "source": "Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].",
        "suggest": "与 [`read`] 一样，无论 `T` 是否为 [`Copy`]，`copy_nonoverlapping` 都会创建 `T` 的按位副本。",
        "translate": ""
    },
    {
        "source": "If `T` is not [`Copy`], using *both* the values in the region beginning at `*src` and the region beginning at `*dst` can [violate memory safety][read-ownership].",
        "suggest": "如果 `T` 不是 [`Copy`]，则同时使用 *both* 和 [violate memory safety][read-ownership] 开头的区域中的值都可以 [violate memory safety][read-ownership]。",
        "translate": ""
    },
    {
        "source": "Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`, the pointers must be non-NULL and properly aligned.",
        "suggest": "请注意，即使有效复制的大小 (`count * size_of::<T>()`) 为 `0`，指针也必须为非 NULL 并正确对齐。",
        "translate": ""
    },
    {
        "source": "Manually implement [`Vec::append`]:",
        "suggest": "手动实现 [`Vec::append`]:",
        "translate": ""
    },
    {
        "source": "Perform these checks only at run time",
        "suggest": "仅在运行时执行这些检查",
        "translate": ""
    },
    {
        "source": "Not panicking to keep codegen impact smaller.",
        "suggest": "不要 panic，以保持代码生成的影响较小。",
        "translate": ""
    },
    {
        "source": "the safety contract for `copy_nonoverlapping` must be upheld by the caller.",
        "suggest": "调用者必须遵守 `copy_nonoverlapping` 的安全保证。",
        "translate": ""
    },
    {
        "source": "If the source and destination will *never* overlap, [`copy_nonoverlapping`] can be used instead.",
        "suggest": "如果源和目标永远不会重叠，则可以改用 [`copy_nonoverlapping`]。",
        "translate": ""
    },
    {
        "source": "is semantically equivalent to C's [`memmove`], but with the argument order swapped.",
        "suggest": "在语义上等效于 C 的 [`memmove`]，但是交换了参数顺序。",
        "translate": ""
    },
    {
        "source": "Copying takes place as if the bytes were copied from `src` to a temporary array and then copied from the array to `dst`.",
        "suggest": "就像将字节从 `src` 复制到临时数组，然后从数组复制到 `dst` 一样进行复制。",
        "translate": ""
    },
    {
        "source": "Like [`read`], `copy` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].",
        "suggest": "与 [`read`] 一样，无论 `T` 是否为 [`Copy`]，`copy` 都会创建 `T` 的按位副本。",
        "translate": ""
    },
    {
        "source": "If `T` is not [`Copy`], using both the values in the region beginning at `*src` and the region beginning at `*dst` can [violate memory safety][read-ownership].",
        "suggest": "如果 `T` 不是 [`Copy`]，则可以同时使用以 `*src` 开头的区域和以 `* dst` 开头的区域中的值。",
        "translate": ""
    },
    {
        "source": "Efficiently create a Rust vector from an unsafe buffer:",
        "suggest": "从不安全的缓冲区有效地创建 Rust vector:",
        "translate": ""
    },
    {
        "source": "the safety contract for `copy` must be upheld by the caller.",
        "suggest": "调用者必须遵守 `copy` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Sets `count * size_of::<T>()` bytes of memory starting at `dst` to `val`.",
        "suggest": "将从 `dst` 开始的 `count * size_of::<T>()` 内存字节设置为 `val`。",
        "translate": ""
    },
    {
        "source": "is similar to C's [`memset`], but sets `count * size_of::<T>()` bytes to `val`.",
        "suggest": "与 C 的 [`memset`] 类似，但是将 `count * size_of::<T>()` 字节设置为 `val`。",
        "translate": ""
    },
    {
        "source": "must be properly aligned.",
        "suggest": "必须正确对齐。",
        "translate": ""
    },
    {
        "source": "Additionally, the caller must ensure that writing `count * size_of::<T>()` bytes to the given region of memory results in a valid value of `T`.",
        "suggest": "此外，调用者必须确保将 `count * size_of::<T>()` 字节写入给定的内存区域会导致 `T` 的有效值。",
        "translate": ""
    },
    {
        "source": "Using a region of memory typed as a `T` that contains an invalid value of `T` is undefined behavior.",
        "suggest": "使用类型为 `T` 的内存区域包含无效的 `T` 值是未定义的行为。",
        "translate": ""
    },
    {
        "source": "Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`, the pointer must be non-NULL and properly aligned.",
        "suggest": "请注意，即使有效复制的大小 (`count * size_of::<T>()`) 为 `0`，指针也必须为非 NULL 并正确对齐。",
        "translate": ""
    },
    {
        "source": "Creating an invalid value:",
        "suggest": "创建一个无效值:",
        "translate": ""
    },
    {
        "source": "the safety contract for `write_bytes` must be upheld by the caller.",
        "suggest": "调用者必须遵守 `write_bytes` 的安全保证。",
        "translate": ""
    },
    {
        "source": "An iterator that links two iterators together, in a chain.",
        "suggest": "链中将两个迭代器链接在一起的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`Iterator::chain`].",
        "suggest": "该 `struct` 由 [`Iterator::chain`] 创建。",
        "translate": ""
    },
    {
        "source": "These are \"fused\" with `Option` so we don't need separate state to track which part is already exhausted, and we may also get niche layout for `None`.",
        "suggest": "它们是带有 `Option` 的 \"fused\"，因此我们不需要单独的状态来跟踪已经用尽的部分，并且我们还可以获得 `None` 的细分布局。",
        "translate": ""
    },
    {
        "source": "We don't use the real `Fuse` adapter because its specialization for `FusedIterator` unconditionally descends into the iterator, and that could be expensive to keep revisiting stuff like nested chains.",
        "suggest": "我们不使用真正的 `Fuse` 适配器，因为它对 `FusedIterator` 的专门化无条件地属于迭代器，而要继续访问嵌套链之类的东西可能会很昂贵。",
        "translate": ""
    },
    {
        "source": "It also hurts compiler performance to add more iterator layers to `Chain`.",
        "suggest": "向 `Chain` 添加更多的迭代器层也损害了编译器的性能。",
        "translate": ""
    },
    {
        "source": "Only the \"first\" iterator is actually set `None` when exhausted, depending on whether you iterate forward or backward.",
        "suggest": "实际用完时，只有 \"first\" 迭代器才实际设置为 `None`，具体取决于您是向前还是向后迭代。",
        "translate": ""
    },
    {
        "source": "If you mix directions, then both sides may be `None`.",
        "suggest": "如果混合方向，则两边都可能是 `None`。",
        "translate": ""
    },
    {
        "source": "Fuse the iterator if the expression is `None`.",
        "suggest": "如果表达式为 `None`，则对迭代器进行融合。",
        "translate": ""
    },
    {
        "source": "Try an iterator method without fusing, like an inline `.as_mut().and_then(...)`",
        "suggest": "尝试使用不带融合功能的迭代器方法，例如内联 `.as_mut().and_then(...)`",
        "translate": ""
    },
    {
        "source": "we don't fuse the second iterator",
        "suggest": "我们不融合第二个迭代器",
        "translate": ""
    },
    {
        "source": "Must exhaust a before b.",
        "suggest": "必须在 b 之前用尽 a。",
        "translate": ""
    },
    {
        "source": "*both* must be fused to handle double-ended iterators.",
        "suggest": "*两个* 都必须融合以处理双端迭代器。",
        "translate": ""
    },
    {
        "source": "An iterator that clones the elements of an underlying iterator.",
        "suggest": "一个迭代器，可克隆基础迭代器的元素。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`cloned`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`cloned`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the contract for `Iterator::__iterator_get_unchecked`.",
        "suggest": "调用者必须遵守 `Iterator::__iterator_get_unchecked` 的契约。",
        "translate": ""
    },
    {
        "source": "An iterator that copies the elements of an underlying iterator.",
        "suggest": "复制基础迭代器元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`copied`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`copied`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator that repeats endlessly.",
        "suggest": "无限重复的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`cycle`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`cycle`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "the cycle iterator is either empty or infinite",
        "suggest": "循环迭代器为空或无限",
        "translate": ""
    },
    {
        "source": "fully iterate the current iterator.",
        "suggest": "完全迭代当前的迭代器。",
        "translate": ""
    },
    {
        "source": "this is necessary because `self.iter` may be empty even when `self.orig` isn't",
        "suggest": "这是必要的，因为即使 `self.orig` 不是，`self.iter` 可能还是为空",
        "translate": ""
    },
    {
        "source": "complete a full cycle, keeping track of whether the cycled iterator is empty or not.",
        "suggest": "完成一个完整的周期，跟踪循环的迭代器是否为空。",
        "translate": ""
    },
    {
        "source": "we need to return early in case of an empty iterator to prevent an infinite loop",
        "suggest": "我们需要在迭代器为空的情况下尽早返回，以防止无限循环",
        "translate": ""
    },
    {
        "source": "No `fold` override, because `fold` doesn't make much sense for `Cycle`, and we can't do anything better than the default.",
        "suggest": "没有 `fold` 替代，因为 `fold` 对 `Cycle` 没有多大意义，我们无法做得比默认更好。",
        "translate": ""
    },
    {
        "source": "An iterator that yields the current count and the element during iteration.",
        "suggest": "一个在迭代过程中产生当前计数和元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`enumerate`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`enumerate`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Overflow Behavior",
        "suggest": "溢出行为",
        "translate": ""
    },
    {
        "source": "The method does no guarding against overflows, so enumerating more than `usize::MAX` elements either produces the wrong result or panics.",
        "suggest": "该方法无法防止溢出，因此枚举多个 `usize::MAX` 元素会产生错误的结果或 panics。",
        "translate": ""
    },
    {
        "source": "If debug assertions are enabled, a panic is guaranteed.",
        "suggest": "如果启用了调试断言，则将保证 panic。",
        "translate": ""
    },
    {
        "source": "Might panic if the index of the element overflows a `usize`.",
        "suggest": "如果元素的索引溢出 `usize`，则可能为 panic。",
        "translate": ""
    },
    {
        "source": "Can safely add, `ExactSizeIterator` promises that the number of elements fits into a `usize`.",
        "suggest": "可以安全地将 `ExactSizeIterator` promises 添加到一个 `usize` 中。",
        "translate": ""
    },
    {
        "source": "Can safely add and subtract the count, as `ExactSizeIterator` promises that the number of elements fits into a `usize`.",
        "suggest": "可以安全地加减计数，如 `ExactSizeIterator` promises 元素数量适合 `usize`。",
        "translate": ""
    },
    {
        "source": "unsafe function forwarding to unsafe function with the same requirements",
        "suggest": "将不安全的函数转发到具有相同要求的不安全的函数",
        "translate": ""
    },
    {
        "source": "An iterator that filters the elements of `iter` with `predicate`.",
        "suggest": "一个用 `predicate` 过滤 `iter` 元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`filter`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`filter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods",
        "suggest": "用于 `SplitWhitespace` 和 `SplitAsciiWhitespace` `as_str` 方法",
        "translate": ""
    },
    {
        "source": "can't know a lower bound, due to the predicate",
        "suggest": "由于谓词，无法知道下界",
        "translate": ""
    },
    {
        "source": "this special case allows the compiler to make `.filter(_).count()` branchless.",
        "suggest": "这种特殊情况允许编译器使 `.filter(_).count()` 无分支。",
        "translate": ""
    },
    {
        "source": "Barring perfect branch prediction (which is unattainable in the general case), this will be much faster in >90% of cases (containing virtually all real workloads) and only a tiny bit slower in the rest.",
        "suggest": "除非有完美的分支预测 (这在一般情况下是无法实现的)，否则在超过 90% 的情况下 (几乎包含所有实际工作量)，这将更快，而在其余情况下，速度则稍慢。",
        "translate": ""
    },
    {
        "source": "Having this specialization thus allows us to write `.filter(p).count()` where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is less readable and also less backwards-compatible to Rust before 1.10.",
        "suggest": "因此，拥有这种专业化知识使我们可以编写 `.filter(p).count()`，而在其他情况下则可以编写 `.map(|x| p(x) as usize).sum()`，因为它不那么可读，而且与 1.10 之前的 Rust 的向后兼容性也较低。",
        "translate": ""
    },
    {
        "source": "Using the branchless version will also simplify the LLVM byte code, thus leaving more budget for LLVM optimizations.",
        "suggest": "使用无分支版本还将简化 LLVM 字节码，从而为 LLVM 优化留出更多预算。",
        "translate": ""
    },
    {
        "source": "An iterator that uses `f` to both filter and map elements from `iter`.",
        "suggest": "一个使用 `f` 来过滤 `iter` 中的元素和 map 元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`filter_map`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`filter_map`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator that maps each element to an iterator, and yields the elements of the produced iterators.",
        "suggest": "Z0 将每个元素映射到一个迭代器，并产生所生成的迭代器的元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`Iterator::flat_map`].",
        "suggest": "该 `struct` 由 [`Iterator::flat_map`] 创建。",
        "translate": ""
    },
    {
        "source": "An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.",
        "suggest": "一个迭代器，它使可迭代化的事物的迭代器中的嵌套层次变得平坦。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`flatten`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`flatten`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Real logic of both `Flatten` and `FlatMap` which simply delegate to this type.",
        "suggest": "`Flatten` 和 `FlatMap` 的真实逻辑都简单地委派给了这种类型。",
        "translate": ""
    },
    {
        "source": "Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.",
        "suggest": "通过展平调整迭代器，以用于 `flatten()` 和 `flat_map()`。",
        "translate": ""
    },
    {
        "source": "An iterator that yields `None` forever after the underlying iterator yields `None` once.",
        "suggest": "在基础迭代器一次生成 `None` 之后，将永远生成 `None` 的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`Iterator::fuse`].",
        "suggest": "该 `struct` 由 [`Iterator::fuse`] 创建。",
        "translate": ""
    },
    {
        "source": "for `I: FusedIterator`, this is always assumed `Some`!",
        "suggest": "对于 `I: FusedIterator`，始终假定为 `Some`!",
        "translate": ""
    },
    {
        "source": "for `I: FusedIterator`, we assume that the iterator is always `Some`.",
        "suggest": "对于 `I: FusedIterator`，我们假定迭代器始终为 `Some`。",
        "translate": ""
    },
    {
        "source": "Implementing this as a directly-expanded macro helps codegen performance.",
        "suggest": "将其实现为直接扩展的宏有助于提高代码生成性能。",
        "translate": ""
    },
    {
        "source": "the specialized iterator never sets `None`",
        "suggest": "专业迭代器从不设置 `None`",
        "translate": ""
    },
    {
        "source": "Any implementation here is made internal to avoid exposing default fns outside this trait",
        "suggest": "此处的任何实现都是内部的，以避免在此 trait 之外公开默认的 fns",
        "translate": ""
    },
    {
        "source": "the caller asserts there is an item at `i`, so we're not exhausted.",
        "suggest": "调用者断言 `i` 处有一个项目，因此我们不疲倦。",
        "translate": ""
    },
    {
        "source": "`TrustedLen` requires that an accurate length is reported via `size_hint()`.",
        "suggest": "`TrustedLen` 要求通过 `size_hint()` 报告准确的长度。",
        "translate": ""
    },
    {
        "source": "As `Fuse` is just forwarding this to the wrapped iterator `I` this property is preserved and it is safe to implement `TrustedLen` here.",
        "suggest": "由于 `Fuse` 只是将其转发给包装的迭代器 `I`，因此保留了此属性，可以在此处安全地实现 `TrustedLen`。",
        "translate": ""
    },
    {
        "source": "`TrustedRandomAccess` requires that `size_hint()` must be exact and cheap to call, and `Iterator::__iterator_get_unchecked()` must be implemented accordingly.",
        "suggest": "`TrustedRandomAccess` 要求 `size_hint()` 必须精确且便宜，并且 `Iterator::__iterator_get_unchecked()` 必须相应地实现。",
        "translate": ""
    },
    {
        "source": "This is safe to implement as `Fuse` is just forwarding these to the wrapped iterator `I`, which preserves these properties.",
        "suggest": "这是安全的，因为 `Fuse` 只是将它们转发给包装的迭代器 `I`，后者保留了这些属性。",
        "translate": ""
    },
    {
        "source": "Fuse specialization trait",
        "suggest": "Fuse 专用 trait",
        "translate": ""
    },
    {
        "source": "Functions specific to any normal Iterators",
        "suggest": "特定于任何普通迭代器的函数",
        "translate": ""
    },
    {
        "source": "Functions specific to DoubleEndedIterators",
        "suggest": "特定于 DoubleEndedIterators 的函数",
        "translate": ""
    },
    {
        "source": "Functions specific to ExactSizeIterator",
        "suggest": "特定于 ExactSizeIterator 的函数",
        "translate": ""
    },
    {
        "source": "General Fuse impl",
        "suggest": "通用 Fuse",
        "translate": ""
    },
    {
        "source": "An iterator that calls a function with a reference to each element before yielding it.",
        "suggest": "一个迭代器，在产生该迭代器之前，会对每个元素调用带有引用的函数。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`inspect`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`inspect`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator adapter that places a separator between all elements.",
        "suggest": "在所有元素之间放置分隔符的迭代器适配器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`Iterator::intersperse`].",
        "suggest": "该 `struct` 由 [`Iterator::intersperse`] 创建。",
        "translate": ""
    },
    {
        "source": "See its documentation for more information.",
        "suggest": "有关更多信息，请参见其文档。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`Iterator::intersperse_with`].",
        "suggest": "该 `struct` 由 [`Iterator::intersperse_with`] 创建。",
        "translate": ""
    },
    {
        "source": "An iterator that maps the values of `iter` with `f`.",
        "suggest": "将 `iter` 的值与 `f` 映射的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`map`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`map`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Notes about side effects",
        "suggest": "有关副作用的注意事项",
        "translate": ""
    },
    {
        "source": "The [`map`] iterator implements [`DoubleEndedIterator`], meaning that you can also [`map`] backwards:",
        "suggest": "[`map`] 迭代器实现 [`DoubleEndedIterator`]，这意味着您还可以向后 [`map`]:",
        "translate": ""
    },
    {
        "source": "But if your closure has state, iterating backwards may act in a way you do not expect.",
        "suggest": "但是，如果您的闭包具有状态，则向后迭代可能会以您所不期望的方式起作用。",
        "translate": ""
    },
    {
        "source": "Let's go through an example.",
        "suggest": "让我们来看一个例子。",
        "translate": ""
    },
    {
        "source": "First, in the forward direction:",
        "suggest": "首先，在前进方向上:",
        "translate": ""
    },
    {
        "source": "This will print \"('a', 1), ('b', 2), ('c', 3)\".",
        "suggest": "这将打印 \"('a', 1), ('b', 2), ('c', 3)\"。",
        "translate": ""
    },
    {
        "source": "Now consider this twist where we add a call to `rev`.",
        "suggest": "现在考虑这种转折，我们在 `rev` 上添加了一个调用。",
        "translate": ""
    },
    {
        "source": "This version will print `('c', 1), ('b', 2), ('a', 3)`.",
        "suggest": "此版本将打印 `('c', 1), ('b', 2), ('a', 3)`。",
        "translate": ""
    },
    {
        "source": "Note that the letters are reversed, but the values of the counter still go in order.",
        "suggest": "请注意，字母是相反的，但计数器的值仍然按顺序排列。",
        "translate": ""
    },
    {
        "source": "This is because `map()` is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.",
        "suggest": "这是因为 `map()` 仍在每个项上被延迟调用，但是现在我们将项从 vector 的背面弹出，而不是从正面移出它们。",
        "translate": ""
    },
    {
        "source": "An iterator that only accepts elements while `predicate` returns `Some(_)`.",
        "suggest": "一个仅在 `predicate` 返回 `Some(_)` 时才接受元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`map_while`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`map_while`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "This trait provides transitive access to source-stage in an interator-adapter pipeline under the conditions that",
        "suggest": "trait 在以下情况下提供对 Interator-adapter 管道中源阶段的传递访问:",
        "translate": ""
    },
    {
        "source": "the iterator source `S` itself implements `SourceIter<Source = S>`",
        "suggest": "迭代器源 `S` 本身实现 `SourceIter<Source = S>`",
        "translate": ""
    },
    {
        "source": "there is a delegating implementation of this trait for each adapter in the pipeline between the source and the pipeline consumer.",
        "suggest": "在源和管道使用者之间的管道中，每个适配器都有 trait 的委派实现。",
        "translate": ""
    },
    {
        "source": "When the source is an owning iterator struct (commonly called `IntoIter`) then this can be useful for specializing [`FromIterator`] implementations or recovering the remaining elements after an iterator has been partially exhausted.",
        "suggest": "当源是拥有的迭代器结构体 (通常称为 `IntoIter`) 时，这对于专门化 [`FromIterator`] 实现或在迭代器部分用尽之后恢复其余元素很有用。",
        "translate": ""
    },
    {
        "source": "Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline.",
        "suggest": "注意，实现不一定必须提供对管道最内层源的访问。",
        "translate": ""
    },
    {
        "source": "A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.",
        "suggest": "有状态的中间适配器可能会急切地评估管道的一部分，并将其内部存储公开为源。",
        "translate": ""
    },
    {
        "source": "The trait is unsafe because implementers must uphold additional safety properties.",
        "suggest": "trait 是不安全的，因为实现者必须维护其他安全属性。",
        "translate": ""
    },
    {
        "source": "See [`as_inner`] for details.",
        "suggest": "有关详细信息，请参见 [`as_inner`]。",
        "translate": ""
    },
    {
        "source": "Retrieving a partially consumed source:",
        "suggest": "检索部分消耗的源:",
        "translate": ""
    },
    {
        "source": "A source stage in an iterator pipeline.",
        "suggest": "迭代器管道中的源阶段。",
        "translate": ""
    },
    {
        "source": "Retrieve the source of an iterator pipeline.",
        "suggest": "检索迭代器管道的源。",
        "translate": ""
    },
    {
        "source": "Implementations of must return the same mutable reference for their lifetime, unless replaced by a caller.",
        "suggest": "的实现必须为其生命周期返回相同的可变引用，除非被调用者替换。",
        "translate": ""
    },
    {
        "source": "Callers may only replace the reference when they stopped iteration and drop the iterator pipeline after extracting the source.",
        "suggest": "调用者只有在停止迭代并在提取源之后丢弃迭代器管道时才可以替换引用。",
        "translate": ""
    },
    {
        "source": "This means iterator adapters can rely on the source not changing during iteration but they cannot rely on it in their Drop implementations.",
        "suggest": "这意味着迭代器适配器可以依赖在迭代过程中未更改的源，但不能在其 Drop 实现中依赖它。",
        "translate": ""
    },
    {
        "source": "Implementing this method means adapters relinquish private-only access to their source and can only rely on guarantees made based on method receiver types.",
        "suggest": "实现此方法意味着适配器放弃对其源的仅私有访问，并且只能依赖基于方法接收者类型的保证。",
        "translate": ""
    },
    {
        "source": "The lack of restricted access also requires that adapters must uphold the source's public API even when they have access to its internals.",
        "suggest": "缺少受限制的访问还要求适配器即使在访问其内部时也必须维护源的公共 API。",
        "translate": ""
    },
    {
        "source": "Callers in turn must expect the source to be in any state that is consistent with its public API since adapters sitting between it and the source have the same access.",
        "suggest": "依次，调用者必须期望源处于与其公共 API 一致的任何状态，因为位于源和源之间的适配器具有相同的访问权限。",
        "translate": ""
    },
    {
        "source": "In particular an adapter may have consumed more elements than strictly necessary.",
        "suggest": "特别是适配器可能消耗了比严格需要更多的元素。",
        "translate": ""
    },
    {
        "source": "The overall goal of these requirements is to let the consumer of a pipeline use",
        "suggest": "这些要求的总体目标是让管道的使用者使用",
        "translate": ""
    },
    {
        "source": "whatever remains in the source after iteration has stopped",
        "suggest": "迭代停止后保留在源中的所有内容",
        "translate": ""
    },
    {
        "source": "the memory that has become unused by advancing a consuming iterator",
        "suggest": "推进消费迭代器而变得未使用的内存",
        "translate": ""
    },
    {
        "source": "An iterator adapter that produces output as long as the underlying iterator produces `Result::Ok` values.",
        "suggest": "只要基础迭代器产生 `Result::Ok` 值，迭代器适配器就产生输出。",
        "translate": ""
    },
    {
        "source": "If an error is encountered, the iterator stops and the error is stored.",
        "suggest": "如果遇到错误，则迭代器将停止并存储错误。",
        "translate": ""
    },
    {
        "source": "Process the given iterator as if it yielded a `T` instead of a `Result<T, _>`.",
        "suggest": "处理给定的迭代器，就像产生 `T` 而不是 `Result<T, _>` 一样。",
        "translate": ""
    },
    {
        "source": "Any errors will stop the inner iterator and the overall result will be an error.",
        "suggest": "任何错误都将停止内部迭代器，并且总体结果将是一个错误。",
        "translate": ""
    },
    {
        "source": "lets us see into the future",
        "suggest": "让我们看看 future",
        "translate": ""
    },
    {
        "source": "The iterator does not advance even if we `peek` multiple times",
        "suggest": "即使我们多次 `peek`，迭代器也不会前进",
        "translate": ""
    },
    {
        "source": "After the iterator is finished, so is `peek()`",
        "suggest": "迭代器完成后，`peek()` 也是如此",
        "translate": ""
    },
    {
        "source": "Like with `peek()`, we can see into the future without advancing the iterator.",
        "suggest": "像 `peek()` 一样，我们可以在不推进迭代器的情况下查看 future。",
        "translate": ""
    },
    {
        "source": "Peek into the iterator and set the value behind the mutable reference.",
        "suggest": "查看迭代器并设置可变引用背后的值。",
        "translate": ""
    },
    {
        "source": "The value we put in reappears as the iterator continues.",
        "suggest": "随着迭代器的继续，我们输入的值会重新出现。",
        "translate": ""
    },
    {
        "source": "The first item of the iterator is 0;",
        "suggest": "迭代器的第一个项是 0;",
        "translate": ""
    },
    {
        "source": "consume it.",
        "suggest": "消耗它。",
        "translate": ""
    },
    {
        "source": "The next item returned is now 1, so `consume` will return `false`.",
        "suggest": "现在返回的下一个项为 1，因此 `consume` 将返回 `false`。",
        "translate": ""
    },
    {
        "source": "saves the value of the next item if it was not equal to `expected`.",
        "suggest": "如果下一个项目的值不等于 `expected`，则保存该值。",
        "translate": ""
    },
    {
        "source": "Consume all numbers less than 10",
        "suggest": "消耗所有小于 10 的数字",
        "translate": ""
    },
    {
        "source": "The next value returned will be 10",
        "suggest": "返回的下一个值将是 10",
        "translate": ""
    },
    {
        "source": "An iterator with a `peek()` that returns an optional reference to the next element.",
        "suggest": "带有 `peek()` 的迭代器，该迭代器将可选的引用返回到下一个元素。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`peekable`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`peekable`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Remember a peeked value, even if it was None.",
        "suggest": "记住一个 peeked 的值，即使它是 `None`。",
        "translate": ""
    },
    {
        "source": "Peekable must remember if a None has been seen in the `.peek()` method.",
        "suggest": "Peekable 必须记住是否在 `.peek()` 方法中看到 `None`。",
        "translate": ""
    },
    {
        "source": "It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the underlying iterator at most once.",
        "suggest": "它确保 `.peek(); .peek();` 或 `.peek(); .next();` 最多只推进基础迭代器一次。",
        "translate": ""
    },
    {
        "source": "This does not by itself make the iterator fused.",
        "suggest": "这本身不会使迭代器融合。",
        "translate": ""
    },
    {
        "source": "Returns a reference to the next() value without advancing the iterator.",
        "suggest": "在不推进迭代器的情况下，返回 next() 值的引用。",
        "translate": ""
    },
    {
        "source": "Like [`next`], if there is a value, it is wrapped in a `Some(T)`.",
        "suggest": "与 [`next`] 一样，如果有值，则将其包装在 `Some(T)` 中。",
        "translate": ""
    },
    {
        "source": "But if the iteration is over, `None` is returned.",
        "suggest": "但是，如果迭代结束，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Because `peek()` returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference.",
        "suggest": "因为 `peek()` 返回一个引用，并且许多迭代器迭代引用，所以返回值是双引用的情况可能会令人困惑。",
        "translate": ""
    },
    {
        "source": "You can see this effect in the examples below.",
        "suggest": "您可以在下面的示例中看到这种效果。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to the next() value without advancing the iterator.",
        "suggest": "返回 next() 值的变量引用，而无需前进迭代器。",
        "translate": ""
    },
    {
        "source": "Because `peek_mut()` returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference.",
        "suggest": "因为 `peek_mut()` 返回一个，并且许多迭代器迭代引用，所以返回值是双引用的情况可能会令人困惑。",
        "translate": ""
    },
    {
        "source": "Consume and return the next value of this iterator if a condition is true.",
        "suggest": "如果条件为真，则使用并返回此迭代器的下一个值。",
        "translate": ""
    },
    {
        "source": "If `func` returns `true` for the next value of this iterator, consume and return it.",
        "suggest": "如果 `func` 返回 `true` 作为此迭代器的下一个值，请消耗并返回它。",
        "translate": ""
    },
    {
        "source": "Otherwise, return `None`.",
        "suggest": "否则，返回 `None`。",
        "translate": ""
    },
    {
        "source": "Consume a number if it's equal to 0.",
        "suggest": "如果它等于 0，则使用一个数字。",
        "translate": ""
    },
    {
        "source": "Consume any number less than 10.",
        "suggest": "消费小于 10 的任何数字。",
        "translate": ""
    },
    {
        "source": "Since we called `self.next()`, we consumed `self.peeked`.",
        "suggest": "因为我们叫 `self.next()`，所以我们消耗了 `self.peeked`。",
        "translate": ""
    },
    {
        "source": "Consume and return the next item if it is equal to `expected`.",
        "suggest": "消费并返回下一个等于 `expected` 的项。",
        "translate": ""
    },
    {
        "source": "A double-ended iterator with the direction inverted.",
        "suggest": "方向相反的双端迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`rev`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`rev`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator to maintain state while iterating another iterator.",
        "suggest": "一个迭代器，用于在迭代另一个迭代器时维持状态。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`scan`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`scan`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "can't know a lower bound, due to the scan function",
        "suggest": "由于扫描函数，无法知道下限",
        "translate": ""
    },
    {
        "source": "An iterator that skips over `n` elements of `iter`.",
        "suggest": "一个跳过 `iter` 的 `n` 元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`skip`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`skip`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Can't just add n + self.n due to overflow.",
        "suggest": "由于溢出而不能仅添加 n + self.n。",
        "translate": ""
    },
    {
        "source": "skips n+1",
        "suggest": "跳过 n+1",
        "translate": ""
    },
    {
        "source": "consume the original iterator",
        "suggest": "消耗原始的迭代器",
        "translate": ""
    },
    {
        "source": "An iterator that rejects elements while `predicate` returns `true`.",
        "suggest": "`predicate` 返回 `true` 时拒绝元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`skip_while`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`skip_while`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator for stepping iterators by a custom amount.",
        "suggest": "一个用于按自定义数量步进迭代器的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`step_by`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`step_by`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "n and self.step are indices, we need to add 1 to get the amount of elements When calling `.nth`, we need to subtract 1 again to convert back to an index step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`",
        "suggest": "n 和 self.step 是索引，我们需要加 1 以获得元素数量调用 `.nth` 时，我们需要再次减去 1 以转换回索引步 + 1 不会溢出，因为 `.step_by` 将 `self.step` 设置为 `step - 1`",
        "translate": ""
    },
    {
        "source": "n + 1 could overflow thus, if n is usize::MAX, instead of adding one, we call .nth(step)",
        "suggest": "n + 1 可能溢出，因此，如果 n 为 usize::MAX，我们不加 1，而是调用 .nth(step)",
        "translate": ""
    },
    {
        "source": "overflow handling",
        "suggest": "溢出处理",
        "translate": ""
    },
    {
        "source": "The zero-based index starting from the end of the iterator of the last element.",
        "suggest": "从最后一个元素的迭代器的末尾开始的从零开始的索引。",
        "translate": ""
    },
    {
        "source": "Used in the `DoubleEndedIterator` implementation.",
        "suggest": "在 `DoubleEndedIterator` 实现中使用。",
        "translate": ""
    },
    {
        "source": "does the right thing here when `n` is out of bounds because the length of `self.iter` does not exceed `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is zero-indexed",
        "suggest": "当 `n` 越界时，此处将执行正确的操作，因为 `self.iter` 的长度不超过 `usize::MAX` (因为 `I: ExactSizeIterator`) 并且 `nth_back` 的索引为零",
        "translate": ""
    },
    {
        "source": "StepBy can only make the iterator shorter, so the len will still fit.",
        "suggest": "StepBy 只能使迭代器更短，因此 len 仍然合适。",
        "translate": ""
    },
    {
        "source": "An iterator that only iterates over the first `n` iterations of `iter`.",
        "suggest": "一个仅迭代 `iter` 的前 `n` 迭代的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`take`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`take`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator that only accepts elements while `predicate` returns `true`.",
        "suggest": "一个仅在 `predicate` 返回 `true` 时才接受元素的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`take_while`] method on [`Iterator`].",
        "suggest": "该 `struct` 是通过 [`Iterator`] 上的 [`take_while`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator that iterates two other iterators simultaneously.",
        "suggest": "同时迭代其他两个迭代器的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`Iterator::zip`].",
        "suggest": "该 `struct` 由 [`Iterator::zip`] 创建。",
        "translate": ""
    },
    {
        "source": "index, len and a_len are only used by the specialized version of zip",
        "suggest": "index，len 和 a_len 仅由 zip 的专用版本使用",
        "translate": ""
    },
    {
        "source": "`ZipImpl::__iterator_get_unchecked` has same safety requirements as `Iterator::__iterator_get_unchecked`.",
        "suggest": "`ZipImpl::__iterator_get_unchecked` 与 `Iterator::__iterator_get_unchecked` 具有相同的安全要求。",
        "translate": ""
    },
    {
        "source": "Zip specialization trait",
        "suggest": "Zip 专用 trait",
        "translate": ""
    },
    {
        "source": "This has the same safety requirements as `Iterator::__iterator_get_unchecked`",
        "suggest": "与 `Iterator::__iterator_get_unchecked` 具有相同的安全要求",
        "translate": ""
    },
    {
        "source": "General Zip impl",
        "suggest": "通用 Zip 实现",
        "translate": ""
    },
    {
        "source": "Adjust a, b to equal length",
        "suggest": "将 a，b 调整为相等的长度",
        "translate": ""
    },
    {
        "source": "`i` is smaller than `self.len`, thus smaller than `self.a.len()` and `self.b.len()`",
        "suggest": "`i` 小于 `self.len`，因此小于 `self.a.len()` 和 `self.b.len()`",
        "translate": ""
    },
    {
        "source": "match the base implementation's potential side effects",
        "suggest": "匹配基本实现的潜在副作用",
        "translate": ""
    },
    {
        "source": "we just checked that `i` < `self.a.len()`",
        "suggest": "我们只是检查 `i` <`self.a.len()`",
        "translate": ""
    },
    {
        "source": "the usage of `cmp::min` to calculate `delta` ensures that `end` is smaller than or equal to `self.len`, so `i` is also smaller than `self.len`.",
        "suggest": "使用 `cmp::min` 计算 `delta` 可确保 `end` 小于或等于 `self.len`，因此 `i` 也小于 `self.len`。",
        "translate": ""
    },
    {
        "source": "Adjust a, b to equal length, make sure that only the first call of `next_back` does this, otherwise we will break the restriction on calls to `self.next_back()` after calling `get_unchecked()`.",
        "suggest": "将 a，b 调整为相等的长度，确保只有 `next_back` 的第一个调用能够做到这一点，否则在调用 `get_unchecked()` 之后，我们将打破对 `self.next_back()` 的调用限制。",
        "translate": ""
    },
    {
        "source": "`i` is smaller than the previous value of `self.len`, which is also smaller than or equal to `self.a.len()` and `self.b.len()`",
        "suggest": "`i` 小于 `self.len` 的前一个值，该值也小于或等于 `self.a.len()` 和 `self.b.len()`",
        "translate": ""
    },
    {
        "source": "Arbitrarily selects the left side of the zip iteration as extractable \"source\" it would require negative trait bounds to be able to try both",
        "suggest": "任意选择 zip 迭代的左侧作为可提取的 \"source\"，这将需要负 trait bounds 才能尝试",
        "translate": ""
    },
    {
        "source": "Limited to Item: Copy since interaction between Zip's use of TrustedRandomAccess and Drop implementation of the source is unclear.",
        "suggest": "限制于以下项: 复制，因为不清楚 Zip 对 TrustedRandomAccess 的使用与源的 Drop 实现之间的交互。",
        "translate": ""
    },
    {
        "source": "An additional method returning the number of times the source has been logically advanced (without calling next()) would be needed to properly drop the remainder of the source.",
        "suggest": "另一种方法返回源已被逻辑高级化的次数 (需要调用 next()) 才能正确丢弃源的其余部分。",
        "translate": ""
    },
    {
        "source": "It's *not safe* to call fmt on the contained iterators, since once we start iterating they're in strange, potentially unsafe, states.",
        "suggest": "在包含的迭代器上调用 fmt 是 *not 安全的*，因为一旦我们开始迭代，它们就处于奇怪的，可能不安全的状态。",
        "translate": ""
    },
    {
        "source": "An iterator whose items are random-accessible efficiently",
        "suggest": "一个迭代器，其项可以有效随机访问",
        "translate": ""
    },
    {
        "source": "The iterator's `size_hint` must be exact and cheap to call.",
        "suggest": "迭代器的 `size_hint` 必须精确且调用便宜。",
        "translate": ""
    },
    {
        "source": "may not be overridden.",
        "suggest": "可能不会被覆盖。",
        "translate": ""
    },
    {
        "source": "must be safe to call provided the following conditions are met.",
        "suggest": "在满足以下条件的情况下必须安全。",
        "translate": ""
    },
    {
        "source": "and `idx < self.size()`.",
        "suggest": "和 `idx < self.size()`。",
        "translate": ""
    },
    {
        "source": "If `self: !Clone`, then `get_unchecked` is never called with the same index on `self` more than once.",
        "suggest": "如果是 `self: !Clone`，则永远不会在 `self` 上使用相同的索引多次调用 `get_unchecked`。",
        "translate": ""
    },
    {
        "source": "After `self.get_unchecked(idx)` has been called then `next_back` will only be called at most `self.size() - idx - 1` times.",
        "suggest": "调用 `self.get_unchecked(idx)` 之后，最多只会调用 `self.size() - idx - 1` 次 `next_back`。",
        "translate": ""
    },
    {
        "source": "After `get_unchecked` is called, then only the following methods will be called on `self`:",
        "suggest": "调用 `get_unchecked` 之后，将仅在 `self` 上调用以下方法:",
        "translate": ""
    },
    {
        "source": "Further, given that these conditions are met, it must guarantee that:",
        "suggest": "此外，考虑到这些条件，它必须保证:",
        "translate": ""
    },
    {
        "source": "It does not change the value returned from `size_hint`",
        "suggest": "它不会更改从 `size_hint` 返回的值",
        "translate": ""
    },
    {
        "source": "It must be safe to call the methods listed above on `self` after calling `get_unchecked`, assuming that the required traits are implemented.",
        "suggest": "假设已实现所需的 traits，则在调用 `get_unchecked` 之后在 `self` 上调用上面列出的方法必须是安全的。",
        "translate": ""
    },
    {
        "source": "It must also be safe to drop `self` after calling `get_unchecked`.",
        "suggest": "调用 `get_unchecked` 后丢弃 `self` 也必须是安全的。",
        "translate": ""
    },
    {
        "source": "Convenience method.",
        "suggest": "方便的方法。",
        "translate": ""
    },
    {
        "source": "if getting an iterator element may have side effects.",
        "suggest": "如果获取迭代器元素可能会有副作用。",
        "translate": ""
    },
    {
        "source": "Remember to take inner iterators into account.",
        "suggest": "记住要考虑内部迭代器。",
        "translate": ""
    },
    {
        "source": "Like `Iterator::__iterator_get_unchecked`, but doesn't require the compiler to know that `U: TrustedRandomAccess`.",
        "suggest": "类似于 `Iterator::__iterator_get_unchecked`，但不需要编译器知道 `U: TrustedRandomAccess`。",
        "translate": ""
    },
    {
        "source": "Same requirements calling `get_unchecked` directly.",
        "suggest": "相同的要求直接调用 `get_unchecked`。",
        "translate": ""
    },
    {
        "source": "If `Self: TrustedRandomAccess`, it must be safe to call a `Iterator::__iterator_get_unchecked(self, index)`.",
        "suggest": "如果是 `Self: TrustedRandomAccess`，则调用 `Iterator::__iterator_get_unchecked(self, index)` 必须安全。",
        "translate": ""
    },
    {
        "source": "First, the struct:",
        "suggest": "首先，结构体:",
        "translate": ""
    },
    {
        "source": "An iterator which counts from one to five",
        "suggest": "从 1 到 5 计数的迭代器",
        "translate": ""
    },
    {
        "source": "we want our count to start at one, so let's add a new() method to help.",
        "suggest": "我们希望计数从一开始，所以让我们添加一个 new() 方法来提供帮助。",
        "translate": ""
    },
    {
        "source": "This isn't strictly necessary, but is convenient.",
        "suggest": "这不是严格必要的，但很方便。",
        "translate": ""
    },
    {
        "source": "Note that we start `count` at zero, we'll see why in `next()`'s implementation below.",
        "suggest": "请注意，我们将 `count` 从零开始，我们将在下面的 `next () ` 实现中看到其原因。",
        "translate": ""
    },
    {
        "source": "Then, we implement `Iterator` for our `Counter`:",
        "suggest": "然后，我们为 `Counter` 实现 `Iterator`:",
        "translate": ""
    },
    {
        "source": "we will be counting with usize",
        "suggest": "我们将使用 usize 进行计数",
        "translate": ""
    },
    {
        "source": "is the only required method",
        "suggest": "是唯一需要的方法",
        "translate": ""
    },
    {
        "source": "Increment our count.",
        "suggest": "增加我们的数量。",
        "translate": ""
    },
    {
        "source": "This is why we started at zero.",
        "suggest": "这就是为什么我们从零开始。",
        "translate": ""
    }
]
