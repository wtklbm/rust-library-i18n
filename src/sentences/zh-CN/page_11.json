[
    {
        "source": "A temporary unaligned reference is created here which results in undefined behavior regardless of whether the reference is used or not.",
        "suggest": "此处将创建一个临时的未对齐引用，无论是否使用引用，都会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "Casting to a raw pointer doesn't help;",
        "suggest": "强制转换为裸指针无济于事;",
        "translate": ""
    },
    {
        "source": "the mistake already happened.",
        "suggest": "错误已经发生。",
        "translate": ""
    },
    {
        "source": "Pointers have equal addresses.",
        "suggest": "指针具有相等的地址。",
        "translate": ""
    },
    {
        "source": "Objects have equal addresses, but `Trait` has different implementations.",
        "suggest": "对象具有相等的地址，但是 `Trait` 具有不同的实现。",
        "translate": ""
    },
    {
        "source": "Converting the reference to a `*const u8` compares by address.",
        "suggest": "将引用转换为 `*const u8` 时，将按地址进行比较。",
        "translate": ""
    },
    {
        "source": "would create an unaligned reference, and thus be Undefined Behavior!",
        "suggest": "会导致未对齐的引用，从而成为未定义的行为!",
        "translate": ""
    },
    {
        "source": "forces copying the field instead of creating a reference.",
        "suggest": "强制复制字段，而不创建引用。",
        "translate": ""
    },
    {
        "source": "Manually manage memory through raw pointers.",
        "suggest": "通过裸指针手动管理内存。",
        "translate": ""
    },
    {
        "source": "Many functions in this module take raw pointers as arguments and read from or write to them.",
        "suggest": "该模块中的许多函数都将裸指针作为参数，并对其进行读取或写入。",
        "translate": ""
    },
    {
        "source": "For this to be safe, these pointers must be *valid*.",
        "suggest": "为了安全起见，这些指针必须是 *valid*。",
        "translate": ""
    },
    {
        "source": "Whether a pointer is valid depends on the operation it is used for (read or write), and the extent of the memory that is accessed (i.e., how many bytes are read/written).",
        "suggest": "指针是否有效取决于指针用于 (读或写) 的操作以及所访问的内存范围 (即 read/written 多少个字节)。",
        "translate": ""
    },
    {
        "source": "Most functions use `*mut T` and `*const T` to access only a single value, in which case the documentation omits the size and implicitly assumes it to be `size_of::<T>()` bytes.",
        "suggest": "大多数函数使用 `*mut T` 和 `* const T` 来访问单个值，在这种情况下，文档将忽略该大小，并隐式地假定其为 `size_of::<T>()` 字节。",
        "translate": ""
    },
    {
        "source": "The precise rules for validity are not determined yet.",
        "suggest": "有效性的确切规则尚未确定。",
        "translate": ""
    },
    {
        "source": "The guarantees that are provided at this point are very minimal:",
        "suggest": "此时提供的保证非常小:",
        "translate": ""
    },
    {
        "source": "A [null] pointer is *never* valid, not even for accesses of [size zero][zst].",
        "suggest": "[null] 指针从来都是无效的，甚至对于 [大小为零][zst] 的访问也是无效的。",
        "translate": ""
    },
    {
        "source": "For a pointer to be valid, it is necessary, but not always sufficient, that the pointer be *dereferenceable*: the memory range of the given size starting at the pointer must all be within the bounds of a single allocated object.",
        "suggest": "为了使指针有效，有必要 (但并不总是足够) 使指针 *可引用*: 从指针开始的给定大小的内存范围必须全部在单个已分配对象的范围内。",
        "translate": ""
    },
    {
        "source": "Even for operations of [size zero][zst], the pointer must not be pointing to deallocated memory, i.e., deallocation makes pointers invalid even for zero-sized operations.",
        "suggest": "即使对于 [size zero][zst] 的操作，指针也不得指向已释放的内存，即，即使对于大小为零的操作，释放也会使指针无效。",
        "translate": ""
    },
    {
        "source": "However, casting any non-zero integer *literal* to a pointer is valid for zero-sized accesses, even if some memory happens to exist at that address and gets deallocated.",
        "suggest": "但是，将任何非零整数 *字面量* 强制转换为指针对于零大小的访问都是有效的，即使该地址恰好存在一些内存并被释放了。",
        "translate": ""
    },
    {
        "source": "This corresponds to writing your own allocator: allocating zero-sized objects is not very hard.",
        "suggest": "这相当于编写自己的分配器: 分配零大小的对象不是很困难。",
        "translate": ""
    },
    {
        "source": "The canonical way to obtain a pointer that is valid for zero-sized accesses is [`NonNull::dangling`].",
        "suggest": "获得对零大小访问有效的指针的规范方法是 [`NonNull::dangling`]。",
        "translate": ""
    },
    {
        "source": "All accesses performed by functions in this module are *non-atomic* in the sense of [atomic operations] used to synchronize between threads.",
        "suggest": " 在用于在线程之间同步的 [atomic operations] 的意义上，此模块中的函数执行的所有访问都是非原子的。",
        "translate": ""
    },
    {
        "source": "This means it is undefined behavior to perform two concurrent accesses to the same location from different threads unless both accesses only read from memory.",
        "suggest": "这意味着从两个不同的线程对同一位置执行两次并发访问是一种未定义的行为，除非两个访问均仅从内存中读取。",
        "translate": ""
    },
    {
        "source": "Notice that this explicitly includes [`read_volatile`] and [`write_volatile`]: Volatile accesses cannot be used for inter-thread synchronization.",
        "suggest": "请注意，这明确包含 [`read_volatile`] 和 [`write_volatile`]: 易失性访问不能用于线程间同步。",
        "translate": ""
    },
    {
        "source": "The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.",
        "suggest": "只要基础对象处于活动状态，并且不使用引用 (仅裸指针) 来访问同一内存，则对指针进行强制引用的结果是有效的。",
        "translate": ""
    },
    {
        "source": "These axioms, along with careful use of [`offset`] for pointer arithmetic, are enough to correctly implement many useful things in unsafe code.",
        "suggest": "这些公理，以及仔细地使用 [`offset`] 进行指针算术，足以在不安全的代码中正确实现许多有用的东西。",
        "translate": ""
    },
    {
        "source": "Stronger guarantees will be provided eventually, as the [aliasing] rules are being determined.",
        "suggest": "随着 [aliasing] 规则的确定，最终将提供更强有力的保证。",
        "translate": ""
    },
    {
        "source": "For more information, see the [book] as well as the section in the reference devoted to [undefined behavior][ub].",
        "suggest": "有关更多信息，请参见 [book] 以及专门针对 [undefined behavior][ub] 的引用中的部分。",
        "translate": ""
    },
    {
        "source": "Valid raw pointers as defined above are not necessarily properly aligned (where \"proper\" alignment is defined by the pointee type, i.e., `*const T` must be aligned to `mem::align_of::<T>()`).",
        "suggest": "上面定义的有效裸指针不一定正确对齐 (其中 \"proper\" 对齐由 pointee 类型定义，即 `*const T` 必须与 `mem::align_of::<T>()` 对齐)。",
        "translate": ""
    },
    {
        "source": "However, most functions require their arguments to be properly aligned, and will explicitly state this requirement in their documentation.",
        "suggest": "但是，大多数函数要求其参数正确对齐，并将在其文档中明确说明此要求。",
        "translate": ""
    },
    {
        "source": "Notable exceptions to this are [`read_unaligned`] and [`write_unaligned`].",
        "suggest": "[`read_unaligned`] 和 [`write_unaligned`] 除外。",
        "translate": ""
    },
    {
        "source": "When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched.",
        "suggest": "当一个函数需要适当的对齐时，即使访问的大小为 0，即实际上没有触摸到内存，它也需要进行适当的对齐。",
        "translate": ""
    },
    {
        "source": "Consider using [`NonNull::dangling`] in such cases.",
        "suggest": "在这种情况下，请考虑使用 [`NonNull::dangling`]。",
        "translate": ""
    },
    {
        "source": "Executes the destructor (if any) of the pointed-to value.",
        "suggest": "执行指向值的析构函数 (如果有)。",
        "translate": ""
    },
    {
        "source": "This is semantically equivalent to calling [`ptr::read`] and discarding the result, but has the following advantages:",
        "suggest": "从语义上讲，这等效于调用 [`ptr::read`] 并丢弃结果，但是具有以下优点:",
        "translate": ""
    },
    {
        "source": "It is *required* to use `drop_in_place` to drop unsized types like trait objects, because they can't be read out onto the stack and dropped normally.",
        "suggest": "强制要求使用 `drop_in_place` 丢弃未定义大小的类型 (例如 trait 对象)，因为它们无法被读取到栈上并且无法正常丢弃。",
        "translate": ""
    },
    {
        "source": "It is friendlier to the optimizer to do this over [`ptr::read`] when dropping manually allocated memory (e.g., in the implementations of `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's sound to elide the copy.",
        "suggest": "当丢弃手动分配的内存时 (例如，在 `Box`/`Rc`/`Vec` 的实现中)，通过 [`ptr::read`] 进行此操作对优化器来说更友好，因为编译器不需要证明丢弃副本是合理的。",
        "translate": ""
    },
    {
        "source": "It can be used to drop [pinned] data when `T` is not `repr(packed)` (pinned data must not be moved before it is dropped).",
        "suggest": "当 `T` 不是 `repr(packed)` 时，可用于丢弃 [pinned] 数据 (在丢弃固定的数据之前，不得移动固定的数据)。",
        "translate": ""
    },
    {
        "source": "Unaligned values cannot be dropped in place, they must be copied to an aligned location first using [`ptr::read_unaligned`].",
        "suggest": "未对齐的值不能被直接丢弃，必须先使用 [`ptr::read_unaligned`] 将它们复制到对齐的位置。",
        "translate": ""
    },
    {
        "source": "For packed structs, this move is done automatically by the compiler.",
        "suggest": "对于包装的结构体，此移动由编译器自动完成。",
        "translate": ""
    },
    {
        "source": "This means the fields of packed structs are not dropped in-place.",
        "suggest": "这意味着已打包结构的字段不会被原地丢弃。",
        "translate": ""
    },
    {
        "source": "must be [valid] for both reads and writes.",
        "suggest": "对于读写，必须为 [valid]。",
        "translate": ""
    },
    {
        "source": "The value `to_drop` points to must be valid for dropping, which may mean it must uphold additional invariants - this is type-dependent.",
        "suggest": "`to_drop` 指向的值必须对丢弃有效，这可能意味着它必须支持其他不变式 - 这与类型有关。",
        "translate": ""
    },
    {
        "source": "Additionally, if `T` is not [`Copy`], using the pointed-to value after calling `drop_in_place` can cause undefined behavior.",
        "suggest": "此外，如果 `T` 不是 [`Copy`]，则在调用 `drop_in_place` 之后使用指向的值可能会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "Note that `*to_drop = foo` counts as a use because it will cause the value to be dropped again.",
        "suggest": "请注意，`*to_drop = foo` 被视为使用，因为它将导致该值再次被丢弃。",
        "translate": ""
    },
    {
        "source": "can be used to overwrite data without causing it to be dropped.",
        "suggest": "可用于覆盖数据而不会导致数据被丢弃。",
        "translate": ""
    },
    {
        "source": "Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.",
        "suggest": "请注意，即使 `T` 的大小为 `0`，指针也必须为非 NULL 并正确对齐。",
        "translate": ""
    },
    {
        "source": "Manually remove the last item from a vector:",
        "suggest": "从 vector 手动删除最后一个项:",
        "translate": ""
    },
    {
        "source": "Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call `drop_in_place` manually.",
        "suggest": "注意，编译器在丢弃包装好的结构时会自动执行这种复制，即，除非您手动调用 `drop_in_place`，否则通常不必担心此类问题。",
        "translate": ""
    },
    {
        "source": "Code here does not matter - this is replaced by the real drop glue by the compiler.",
        "suggest": "编译器会将其替换为真正的 drop glue。",
        "translate": ""
    },
    {
        "source": "see comment above",
        "suggest": "见上面的评论",
        "translate": ""
    },
    {
        "source": "Creates a null raw pointer.",
        "suggest": "创建一个空的裸指针。",
        "translate": ""
    },
    {
        "source": "Creates a null mutable raw pointer.",
        "suggest": "创建一个空的可变裸露指针。",
        "translate": ""
    },
    {
        "source": "Forms a raw slice from a pointer and a length.",
        "suggest": "根据指针和长度形成原始切片。",
        "translate": ""
    },
    {
        "source": "The `len` argument is the number of **elements**, not the number of bytes.",
        "suggest": "`len` 参数是 **元素** 的数量，而不是字节数。",
        "translate": ""
    },
    {
        "source": "This function is safe, but actually using the return value is unsafe.",
        "suggest": "此函数是安全的，但实际上使用返回值是不安全的。",
        "translate": ""
    },
    {
        "source": "See the documentation of [`slice::from_raw_parts`] for slice safety requirements.",
        "suggest": "有关切片的安全要求，请参见 [`slice::from_raw_parts`] 的文档。",
        "translate": ""
    },
    {
        "source": "Accessing the value from the `Repr` union is safe since *const [T] and FatPtr have the same memory layouts.",
        "suggest": "因为 *const [T] 和 FatPtr 具有相同的内存布局，所以从 `Repr` union 访问值是安全的。",
        "translate": ""
    },
    {
        "source": "Performs the same functionality as [`slice_from_raw_parts`], except that a raw mutable slice is returned, as opposed to a raw immutable slice.",
        "suggest": "执行与 [`slice_from_raw_parts`] 相同的功能，但返回的是原始可变切片，而不是原始的不可变切片。",
        "translate": ""
    },
    {
        "source": "See the documentation of [`slice_from_raw_parts`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`slice_from_raw_parts`] 的文档。",
        "translate": ""
    },
    {
        "source": "See the documentation of [`slice::from_raw_parts_mut`] for slice safety requirements.",
        "suggest": "有关切片的安全要求，请参见 [`slice::from_raw_parts_mut`] 的文档。",
        "translate": ""
    },
    {
        "source": "Accessing the value from the `Repr` union is safe since *mut [T] and FatPtr have the same memory layouts",
        "suggest": "因为 *mut [T] 和 FatPtr 具有相同的内存布局，所以从 `Repr` union 访问值是安全的，",
        "translate": ""
    },
    {
        "source": "Swaps the values at two mutable locations of the same type, without deinitializing either.",
        "suggest": "在相同类型的两个可变位置交换值，而无需取消初始化任何一个。",
        "translate": ""
    },
    {
        "source": "But for the following two exceptions, this function is semantically equivalent to [`mem::swap`]:",
        "suggest": "但是对于以下两个例外，此函数在语义上等效于 [`mem::swap`]:",
        "translate": ""
    },
    {
        "source": "It operates on raw pointers instead of references.",
        "suggest": "它对裸指针而不是引用进行操作。",
        "translate": ""
    },
    {
        "source": "When references are available, [`mem::swap`] should be preferred.",
        "suggest": "如果引用可用，则应首选 [`mem::swap`]。",
        "translate": ""
    },
    {
        "source": "The two pointed-to values may overlap.",
        "suggest": "两个指向的值可能会重叠。",
        "translate": ""
    },
    {
        "source": "If the values do overlap, then the overlapping region of memory from `x` will be used.",
        "suggest": "如果值确实重叠，则将使用 `x` 的内存重叠区域。",
        "translate": ""
    },
    {
        "source": "This is demonstrated in the second example below.",
        "suggest": "在下面的第二个示例中对此进行了演示。",
        "translate": ""
    },
    {
        "source": "Both `x` and `y` must be [valid] for both reads and writes.",
        "suggest": "对于读取和写入，`x` 和 `y` 都必须为 [valid]。",
        "translate": ""
    },
    {
        "source": "Both `x` and `y` must be properly aligned.",
        "suggest": "`x` 和 `y` 必须正确对齐。",
        "translate": ""
    },
    {
        "source": "Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.",
        "suggest": "请注意，即使 `T` 的大小为 `0`，指针也必须为非 NULL 并正确对齐。",
        "translate": ""
    },
    {
        "source": "Swapping two non-overlapping regions:",
        "suggest": "交换两个不重叠的区域:",
        "translate": ""
    },
    {
        "source": "Swapping two overlapping regions:",
        "suggest": "交换两个重叠的区域:",
        "translate": ""
    },
    {
        "source": "Give ourselves some scratch space to work with.",
        "suggest": "给自己一些工作的空间。",
        "translate": ""
    },
    {
        "source": "We do not have to worry about drops: `MaybeUninit` does nothing when dropped.",
        "suggest": "我们不必担心丢弃: `MaybeUninit` 在丢弃时什么也不做。",
        "translate": ""
    },
    {
        "source": "Perform the swap",
        "suggest": "执行交换",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `x` and `y` are valid for writes and properly aligned.",
        "suggest": "调用者必须保证 `x` 和 `y` 对写入有效并且正确对齐。",
        "translate": ""
    },
    {
        "source": "cannot be overlapping either `x` or `y` because `tmp` was just allocated on the stack as a separate allocated object.",
        "suggest": "不能与 `x` 或 `y` 重叠，因为 `tmp` 只是作为单独的已分配对象在栈上分配的。",
        "translate": ""
    },
    {
        "source": "and `y` may overlap",
        "suggest": "和 `y` 可能重叠",
        "translate": ""
    },
    {
        "source": "Swaps `count * size_of::<T>()` bytes between the two regions of memory beginning at `x` and `y`.",
        "suggest": "从 `x` 和 `y` 开始在两个内存区域之间交换 `count * size_of::<T>()` 字节。",
        "translate": ""
    },
    {
        "source": "The two regions must *not* overlap.",
        "suggest": "这两个区域必须 *不能* 重叠。",
        "translate": ""
    },
    {
        "source": "Both `x` and `y` must be [valid] for both reads and writes of `count",
        "suggest": "`x` 和 `y` 都必须为 [valid] 才能读取和写入 `count",
        "translate": ""
    },
    {
        "source": "size_of::<T>()` bytes.",
        "suggest": "size_of::<T>()` 个字节。",
        "translate": ""
    },
    {
        "source": "The region of memory beginning at `x` with a size of `count",
        "suggest": "从 `x` 开始的内存区域，大小为 `count",
        "translate": ""
    },
    {
        "source": "size_of::<T>()` bytes must *not* overlap with the region of memory beginning at `y` with the same size.",
        "suggest": "size_of::<T>()` 字节不得与以 `y` 开始且大小相同的内存区域重叠。",
        "translate": ""
    },
    {
        "source": "For types smaller than the block optimization below, just swap directly to avoid pessimizing codegen.",
        "suggest": "对于小于下面的块优化的类型，只需直接交换就可以避免对代码源造成不必要的影响。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `x` and `y` are valid for writes, properly aligned, and non-overlapping.",
        "suggest": "调用者必须保证 `x` 和 `y` 对于写入有效，正确对齐且不重叠。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `swap_nonoverlapping`.",
        "suggest": "调用者必须坚持 `swap_nonoverlapping` 的安全保证。",
        "translate": ""
    },
    {
        "source": "The approach here is to utilize simd to swap x & y efficiently.",
        "suggest": "这里的方法是利用 simd 有效地交换 x 和 y。",
        "translate": ""
    },
    {
        "source": "Testing reveals that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel Haswell E processors.",
        "suggest": "测试表明，一次交换 32 字节或 64 字节对于 Intel Haswell E 处理器是最有效的。",
        "translate": ""
    },
    {
        "source": "LLVM is more able to optimize if we give a struct a #[repr(simd)], even if we don't actually use this struct directly.",
        "suggest": "如果我们实际上不直接使用该结构体，则 LLVM 更能够优化 #[repr(simd)]。",
        "translate": ""
    },
    {
        "source": "FIXME repr(simd) broken on emscripten and redox",
        "suggest": "FIXME repr(simd) 在脚本和 redox 上损坏",
        "translate": ""
    },
    {
        "source": "Loop through x & y, copying them `Block` at a time The optimizer should unroll the loop fully for most types N.B.",
        "suggest": "遍历 x 和 y，一次复制 `Block` 优化器应针对大多数类型的 NB 完全展开循环",
        "translate": ""
    },
    {
        "source": "We can't use a for loop as the `range` impl calls `mem::swap` recursively",
        "suggest": "我们不能使用 for 循环，因为 `range` impl 递归调用 `mem::swap`",
        "translate": ""
    },
    {
        "source": "Create some uninitialized memory as scratch space Declaring `t` here avoids aligning the stack when this loop is unused",
        "suggest": "创建一些未初始化的内存作为暂存空间在此声明 `t` 可以避免在未使用此循环时对齐栈",
        "translate": ""
    },
    {
        "source": "As `i < len`, and as the caller must guarantee that `x` and `y` are valid for `len` bytes, `x + i` and `y + i` must be valid addresses, which fulfills the safety contract for `add`.",
        "suggest": "作为 `i < len`，并且由于调用方必须保证 `x` 和 `y` 对于 `len` 字节有效，因此 `x + i` 和 `y + i` 必须是有效地址，这满足了 `add` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Also, the caller must guarantee that `x` and `y` are valid for writes, properly aligned, and non-overlapping, which fulfills the safety contract for `copy_nonoverlapping`.",
        "suggest": "同样，调用者必须保证 `x` 和 `y` 对于写入有效，正确对齐且不重叠，从而满足 `copy_nonoverlapping` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Swap a block of bytes of x & y, using t as a temporary buffer This should be optimized into efficient SIMD operations where available",
        "suggest": "将 t 用作临时缓冲区交换 x&y 字节的字节块。应将其优化为有效的 SIMD 操作 (如果可用)",
        "translate": ""
    },
    {
        "source": "Swap any remaining bytes",
        "suggest": "交换所有剩余字节",
        "translate": ""
    },
    {
        "source": "see previous safety comment.",
        "suggest": "请参见之前的安全注释。",
        "translate": ""
    },
    {
        "source": "Moves `src` into the pointed `dst`, returning the previous `dst` value.",
        "suggest": "将 `src` 移至指定的 `dst`，返回先前的 `dst` 值。",
        "translate": ""
    },
    {
        "source": "This function is semantically equivalent to [`mem::replace`] except that it operates on raw pointers instead of references.",
        "suggest": "该函数在语义上等效于 [`mem::replace`]，除了它在裸指针上而不是在引用上运行。",
        "translate": ""
    },
    {
        "source": "When references are available, [`mem::replace`] should be preferred.",
        "suggest": "如果引用可用，则应首选 [`mem::replace`]。",
        "translate": ""
    },
    {
        "source": "must point to a properly initialized value of type `T`.",
        "suggest": "必须指向类型为 `T` 的正确初始化的值。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `dst` is valid to be cast to a mutable reference (valid for writes, aligned, initialized), and cannot overlap `src` since `dst` must point to a distinct allocated object.",
        "suggest": "调用者必须保证 `dst` 有效，可以强制转换为变量引用 (对写入，对齐，初始化有效)，并且不能与 `src` 重叠，因为 `dst` 必须指向不同的分配对象。",
        "translate": ""
    },
    {
        "source": "cannot overlap",
        "suggest": "不能重叠",
        "translate": ""
    },
    {
        "source": "Reads the value from `src` without moving it.",
        "suggest": "从 `src` 读取值而不移动它。",
        "translate": ""
    },
    {
        "source": "This leaves the memory in `src` unchanged.",
        "suggest": "这将使 `src` 中的内存保持不变。",
        "translate": ""
    },
    {
        "source": "must be [valid] for reads.",
        "suggest": "必须为 [valid] 才能读取。",
        "translate": ""
    },
    {
        "source": "Manually implement [`mem::swap`]:",
        "suggest": "手动实现 [`mem::swap`]:",
        "translate": ""
    },
    {
        "source": "Ownership of the Returned Value",
        "suggest": "归还值的所有权",
        "translate": ""
    },
    {
        "source": "creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].",
        "suggest": "不管 `T` 是否为 [`Copy`]，都会创建 `T` 的按位副本。",
        "translate": ""
    },
    {
        "source": "If `T` is not [`Copy`], using both the returned value and the value at `*src` can violate memory safety.",
        "suggest": "如果 `T` 不是 [`Copy`]，则同时使用返回的值和 `*src` 的值可能会违反内存安全性。",
        "translate": ""
    },
    {
        "source": "Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`.",
        "suggest": "请注意，将分配给 `*src` 视为一种用途，因为它将尝试丢弃 `*src` 处的值。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `src` is valid for reads.",
        "suggest": "调用者必须保证 `src` 对于读取有效。",
        "translate": ""
    },
    {
        "source": "cannot overlap `tmp` because `tmp` was just allocated on the stack as a separate allocated object.",
        "suggest": "不能与 `tmp` 重叠，因为 `tmp` 只是作为单独的已分配对象在栈上分配的。",
        "translate": ""
    },
    {
        "source": "Also, since we just wrote a valid value into `tmp`, it is guaranteed to be properly initialized.",
        "suggest": "另外，由于我们只是将有效值写入 `tmp`，因此可以确保正确初始化它。",
        "translate": ""
    },
    {
        "source": "Unlike [`read`], `read_unaligned` works with unaligned pointers.",
        "suggest": "与 [`read`] 不同，`read_unaligned` 使用未对齐的指针。",
        "translate": ""
    },
    {
        "source": "Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].",
        "suggest": "与 [`read`] 一样，无论 `T` 是否为 [`Copy`]，`read_unaligned` 都会创建 `T` 的按位副本。",
        "translate": ""
    },
    {
        "source": "If `T` is not [`Copy`], using both the returned value and the value at `*src` can [violate memory safety][read-ownership].",
        "suggest": "如果 `T` 不是 [`Copy`]，则同时使用返回值和 `*src` 处的值都可以 [violate memory safety][read-ownership]。",
        "translate": ""
    },
    {
        "source": "Note that even if `T` has size `0`, the pointer must be non-NULL.",
        "suggest": "请注意，即使 `T` 的大小为 `0`，指针也必须为非 NULL。",
        "translate": ""
    },
    {
        "source": "On `packed` structs",
        "suggest": "在 `packed` 结构体上",
        "translate": ""
    },
    {
        "source": "It is currently impossible to create raw pointers to unaligned fields of a packed struct.",
        "suggest": "当前无法为包装结构体的未对齐字段创建裸指针。",
        "translate": ""
    },
    {
        "source": "Attempting to create a raw pointer to an `unaligned` struct field with an expression such as `&packed.unaligned as *const FieldType` creates an intermediate unaligned reference before converting that to a raw pointer.",
        "suggest": "尝试使用诸如 `&packed.unaligned as *const FieldType` 的表达式创建指向 `unaligned` 结构体字段的裸指针，然后再将其转换为裸指针，这会产生一个中间未对齐的引用。",
        "translate": ""
    },
    {
        "source": "That this reference is temporary and immediately cast is inconsequential as the compiler always expects references to be properly aligned.",
        "suggest": "引用是临时的并且立即强制转换是无关紧要的，因为编译器始终希望引用正确对齐。",
        "translate": ""
    },
    {
        "source": "As a result, using `&packed.unaligned as *const FieldType` causes immediate *undefined behavior* in your program.",
        "suggest": "结果，使用 `&packed.unaligned as *const FieldType` 会在程序中立即导致* undefined 行为 *。",
        "translate": ""
    },
    {
        "source": "An example of what not to do and how this relates to `read_unaligned` is:",
        "suggest": "一个不执行的操作以及它与 `read_unaligned` 的关系的示例是:",
        "translate": ""
    },
    {
        "source": "Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.",
        "suggest": "但是，例如使用 `packed.unaligned` 直接访问未对齐的字段是安全的。",
        "translate": ""
    },
    {
        "source": "Update docs based on outcome of RFC #2582 and friends.",
        "suggest": "根据 RFC #2582 和朋友的结果更新文档。",
        "translate": ""
    },
    {
        "source": "Read an usize value from a byte buffer:",
        "suggest": "从字节缓冲区读取 usize 值:",
        "translate": ""
    },
    {
        "source": "Overwrites a memory location with the given value without reading or dropping the old value.",
        "suggest": "用给定值覆盖存储位置，而无需读取或丢弃旧值。",
        "translate": ""
    },
    {
        "source": "does not drop the contents of `dst`.",
        "suggest": "不会丢弃 `dst` 的内容。",
        "translate": ""
    },
    {
        "source": "This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped.",
        "suggest": "这是安全的，但可能会泄漏分配或资源，因此应注意不要覆盖应丢弃的对象。",
        "translate": ""
    },
    {
        "source": "Additionally, it does not drop `src`.",
        "suggest": "此外，它不会丢弃 `src`。",
        "translate": ""
    },
    {
        "source": "Semantically, `src` is moved into the location pointed to by `dst`.",
        "suggest": "在语义上，`src` 被移到 `dst` 指向的位置。",
        "translate": ""
    },
    {
        "source": "This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been [`read`] from.",
        "suggest": "这适用于初始化未初始化的内存，或覆盖以前是 [`read`] 的内存。",
        "translate": ""
    },
    {
        "source": "must be [valid] for writes.",
        "suggest": "必须为 [valid] 进行写入。",
        "translate": ""
    },
    {
        "source": "We are calling the intrinsics directly to avoid function calls in the generated code as `intrinsics::copy_nonoverlapping` is a wrapper function.",
        "suggest": "我们直接调用内联函数是为了避免在生成的代码中调用函数，因为 `intrinsics::copy_nonoverlapping` 是包装函数。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `dst` is valid for writes.",
        "suggest": "调用者必须保证 `dst` 对写入有效。",
        "translate": ""
    },
    {
        "source": "cannot overlap `src` because the caller has mutable access to `dst` while `src` is owned by this function.",
        "suggest": "`src` 不能与 `src` 重叠，因为当 `src` 属于此函数时，调用方可以对其进行灵活访问。",
        "translate": ""
    },
    {
        "source": "Unlike [`write()`], the pointer may be unaligned.",
        "suggest": "与 [`write()`] 不同，指针可能未对齐。",
        "translate": ""
    },
    {
        "source": "This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with [`read_unaligned`].",
        "suggest": "这适用于初始化未初始化的内存，或覆盖以前用 [`read_unaligned`] 读取的内存。",
        "translate": ""
    },
    {
        "source": "An example of what not to do and how this relates to `write_unaligned` is:",
        "suggest": "一个不执行的操作以及它与 `write_unaligned` 的关系的示例是:",
        "translate": ""
    },
    {
        "source": "Write an usize value to a byte buffer:",
        "suggest": "将 usize 值写入字节缓冲区:",
        "translate": ""
    },
    {
        "source": "We are calling the intrinsic directly to avoid function calls in the generated code.",
        "suggest": "我们直接调用内联函数以避免在生成的代码中进行函数调用。",
        "translate": ""
    },
    {
        "source": "Performs a volatile read of the value from `src` without moving it.",
        "suggest": "对 `src` 的值进行易失性读取，而无需移动它。",
        "translate": ""
    },
    {
        "source": "Rust does not currently have a rigorously and formally defined memory model, so the precise semantics of what \"volatile\" means here is subject to change over time.",
        "suggest": "Rust 当前没有严格和正式定义的内存模型，因此 \"volatile\" 此处所指的确切语义会随时间而变化。",
        "translate": ""
    },
    {
        "source": "That being said, the semantics will almost always end up pretty similar to [C11's definition of volatile][c11].",
        "suggest": "话虽如此，其语义几乎总是以与 [C11 对 volatile 的定义][c11] 相似的方式结束。",
        "translate": ""
    },
    {
        "source": "The compiler shouldn't change the relative order or number of volatile memory operations.",
        "suggest": "编译器不应更改易失性存储器操作的相对顺序或数量。",
        "translate": ""
    },
    {
        "source": "However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to `read_volatile`) are noops and may be ignored.",
        "suggest": "但是，零大小类型 (例如，如果将零大小类型传递给 `read_volatile`) 上的易失性存储器操作为无操作，可以忽略。",
        "translate": ""
    },
    {
        "source": "Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].",
        "suggest": "与 [`read`] 一样，无论 `T` 是否为 [`Copy`]，`read_volatile` 都会创建 `T` 的按位副本。",
        "translate": ""
    },
    {
        "source": "However, storing non-[`Copy`] types in volatile memory is almost certainly incorrect.",
        "suggest": "但是，几乎可以肯定地将非 [`Copy`] 类型存储在易失性存储器中。",
        "translate": ""
    },
    {
        "source": "Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads.",
        "suggest": "就像在 C 语言中一样，操作是否易失性与涉及从多个线程进行并发访问的问题无关。",
        "translate": ""
    },
    {
        "source": "Volatile accesses behave exactly like non-atomic accesses in that regard.",
        "suggest": "在这方面，易失性访问的行为与非原子访问完全相同。",
        "translate": ""
    },
    {
        "source": "In particular, a race between a `read_volatile` and any write operation to the same location is undefined behavior.",
        "suggest": "特别是，`read_volatile` 与任何对同一位置的写操作之间的争夺是未定义的行为。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `volatile_load`.",
        "suggest": "调用者必须坚持 `volatile_load` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Performs a volatile write of a memory location with the given value without reading or dropping the old value.",
        "suggest": "使用给定值对存储单元执行易失性写操作，而无需读取或丢弃旧值。",
        "translate": ""
    },
    {
        "source": "However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to `write_volatile`) are noops and may be ignored.",
        "suggest": "但是，零大小类型 (例如，如果将零大小类型传递给 `write_volatile`) 上的易失性存储器操作为无操作，可以忽略。",
        "translate": ""
    },
    {
        "source": "In particular, a race between a `write_volatile` and any other operation (reading or writing) on the same location is undefined behavior.",
        "suggest": "特别是，`write_volatile` 与同一位置上的任何其他操作 (读取或写入) 之间的争夺是未定义的行为。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `volatile_store`.",
        "suggest": "调用者必须坚持 `volatile_store` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Align pointer `p`.",
        "suggest": "对齐指针 `p`。",
        "translate": ""
    },
    {
        "source": "Calculate offset (in terms of elements of `stride` stride) that has to be applied to pointer `p` so that pointer `p` would get aligned to `a`.",
        "suggest": "计算必须应用于指针 `p` 的偏移量 (根据 `stride` 步幅)，以便指针 `p` 与 `a` 对齐。",
        "translate": ""
    },
    {
        "source": "This implementation has been carefully tailored to not panic.",
        "suggest": "此实现已针对非 panic 进行了精心设计。",
        "translate": ""
    },
    {
        "source": "It is UB for this to panic.",
        "suggest": "到 panic 是 UB。",
        "translate": ""
    },
    {
        "source": "The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated constants.",
        "suggest": "此处唯一可以进行的更改是 `INV_TABLE_MOD_16` 及其关联常量的更改。",
        "translate": ""
    },
    {
        "source": "If we ever decide to make it possible to call the intrinsic with `a` that is not a power-of-two, it will probably be more prudent to just change to a naive implementation rather than trying to adapt this to accommodate that change.",
        "suggest": "如果我们决定允许使用非 2 的幂的 `a` 调用内联函数，那么仅更改为幼稚的实现而不是尝试使其适应这种变化可能会更明智。",
        "translate": ""
    },
    {
        "source": "Any questions go to @nagisa.",
        "suggest": "如有任何疑问，请发送至 @nagisa。",
        "translate": ""
    },
    {
        "source": "Direct use of these intrinsics improves codegen significantly at opt-level <=",
        "suggest": "在 opt 级别 <= 上，直接使用这些内联函数可显着改善代码生成",
        "translate": ""
    },
    {
        "source": "1, where the method versions of these operations are not inlined.",
        "suggest": "1，其中未内联这些操作的方法版本。",
        "translate": ""
    },
    {
        "source": "Calculate multiplicative modular inverse of `x` modulo `m`.",
        "suggest": "计算 `x` 模 `m` 的乘法模逆。",
        "translate": ""
    },
    {
        "source": "This implementation is tailored for `align_offset` and has following preconditions:",
        "suggest": "此实现是针对 `align_offset` 量身定制的，并具有以下先决条件:",
        "translate": ""
    },
    {
        "source": "is a power-of-two;",
        "suggest": "是二的幂;",
        "translate": ""
    },
    {
        "source": "(if `x ≥ m`, pass in `x % m` instead)",
        "suggest": "(如果使用 `x ≥ m`，请改为传入 `x % m`)",
        "translate": ""
    },
    {
        "source": "Implementation of this function shall not panic.",
        "suggest": "此函数的实现不得为 panic。",
        "translate": ""
    },
    {
        "source": "Ever.",
        "suggest": "曾经。",
        "translate": ""
    },
    {
        "source": "Multiplicative modular inverse table modulo 2⁴ = 16.",
        "suggest": "乘模逆矩阵模 2⁴=16。",
        "translate": ""
    },
    {
        "source": "Note, that this table does not contain values where inverse does not exist (i.e., for `0⁻¹ mod 16`, `2⁻¹ mod 16`, etc.)",
        "suggest": "注意，该表不包含不存在反值的值 (例如，对于 `0⁻¹ mod 16`，`2⁻¹ mod 16` 等)。",
        "translate": ""
    },
    {
        "source": "Modulo for which the `INV_TABLE_MOD_16` is intended.",
        "suggest": "`INV_TABLE_MOD_16` 的模数。",
        "translate": ""
    },
    {
        "source": "`m` is required to be a power-of-two, hence non-zero.",
        "suggest": "`m` 必须为 2 的幂，因此不能为零。",
        "translate": ""
    },
    {
        "source": "We iterate \"up\" using the following formula:",
        "suggest": "我们使用以下公式迭代 \"up\":",
        "translate": ""
    },
    {
        "source": "until 2²ⁿ ≥ m.",
        "suggest": "直到 2²ⁿ ≥ m。",
        "translate": ""
    },
    {
        "source": "Then we can reduce to our desired `m` by taking the result `mod m`.",
        "suggest": "然后，我们可以通过取结果 `mod m` 减少到所需的 `m`。",
        "translate": ""
    },
    {
        "source": "Note, that we use wrapping operations here intentionally – the original formula uses e.g., subtraction `mod n`.",
        "suggest": "注意，这里我们有意使用包装操作-原始公式使用减法 `mod n`。",
        "translate": ""
    },
    {
        "source": "It is entirely fine to do them `mod usize::MAX` instead, because we take the result `mod n` at the end anyway.",
        "suggest": "改用 `mod usize::MAX` 完全可以，因为无论如何我们将结果 `mod n` 放在最后。",
        "translate": ""
    },
    {
        "source": "`a` is a power-of-two, therefore non-zero.",
        "suggest": "`a` 为 2 的幂，因此非零。",
        "translate": ""
    },
    {
        "source": "case can be computed more simply through `-p (mod a)`, but doing so inhibits LLVM's ability to select instructions like `lea`.",
        "suggest": "通过 `-p (mod a)` 可以更简单地计算大小写，但是这样做会限制 LLVM 选择 `lea` 之类的指令的能力。",
        "translate": ""
    },
    {
        "source": "Instead we compute",
        "suggest": "相反，我们计算",
        "translate": ""
    },
    {
        "source": "which distributes operations around the load-bearing, but pessimizing `and` sufficiently for LLVM to be able to utilize the various optimizations it knows about.",
        "suggest": "它围绕承重来分配操作，但是对 `and` 进行了充分的模拟，以使 LLVM 能够利用它所了解的各种优化。",
        "translate": ""
    },
    {
        "source": "Already aligned.",
        "suggest": "已经对齐。",
        "translate": ""
    },
    {
        "source": "Yay!",
        "suggest": "耶!",
        "translate": ""
    },
    {
        "source": "If the pointer is not aligned, and the element is zero-sized, then no amount of elements will ever align the pointer.",
        "suggest": "如果指针未对齐，并且元素大小为零，则将没有任何元素可以对齐指针。",
        "translate": ""
    },
    {
        "source": "a is power-of-two hence non-zero.",
        "suggest": "a 是 2 的幂，因此非零。",
        "translate": ""
    },
    {
        "source": "stride == 0 case is handled above.",
        "suggest": "stride == 0 情况已在上面处理。",
        "translate": ""
    },
    {
        "source": "gcdpow has an upper-bound that’s at most the number of bits in an usize.",
        "suggest": "gcdpow 的上限上限是 usize 中的位数。",
        "translate": ""
    },
    {
        "source": "gcd is always greater or equal to 1.",
        "suggest": "gcd 始终大于或等于 1。",
        "translate": ""
    },
    {
        "source": "This branch solves for the following linear congruence equation:",
        "suggest": "该分支求解以下线性同余方程:",
        "translate": ""
    },
    {
        "source": "here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the requested alignment.",
        "suggest": "这是指针值，`s`-`T` 的步幅，`o` 在 `T` 中的偏移量，`a` - 所请求的对齐方式。",
        "translate": ""
    },
    {
        "source": "With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:",
        "suggest": "使用 `g = gcd(a, s)`，并且上面的条件断言 `p` 也可以被 `g` 整除，我们可以表示 `a' = a/g`，`s' = s/g`，`p' = p/g`，那么它等效于:",
        "translate": ""
    },
    {
        "source": "The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the second term is \"how does incrementing `p` by `s` bytes change the relative alignment of `p`\" (again divided by `g`).",
        "suggest": "第一项是 \"the relative alignment of `p` to `a`\" (除以 `g`)，第二项是 \"how does incrementing `p` by `s` bytes change the relative alignment of `p`\" (再次除以 `g`)。",
        "translate": ""
    },
    {
        "source": "Division by `g` is necessary to make the inverse well formed if `a` and `s` are not co-prime.",
        "suggest": "如果 `a` 和 `s` 不是互质的，则 `g` 的除法对于使逆结构良好是必要的。",
        "translate": ""
    },
    {
        "source": "Furthermore, the result produced by this solution is not \"minimal\", so it is necessary to take the result `o mod lcm(s, a)`.",
        "suggest": "此外，此解决方案产生的结果不是 \"minimal\"，因此必须获得结果 `o mod lcm(s, a)`。",
        "translate": ""
    },
    {
        "source": "We can replace `lcm(s, a)` with just a `a'`.",
        "suggest": "我们可以只用 `a'` 代替 `lcm(s, a)`。",
        "translate": ""
    },
    {
        "source": "`gcdpow` has an upper-bound not greater than the number of trailing 0-bits in `a`.",
        "suggest": "`gcdpow` 的上限不大于 `a` 的尾随 0 位的数量。",
        "translate": ""
    },
    {
        "source": "`a2` is non-zero.",
        "suggest": "`a2` 不为零。",
        "translate": ""
    },
    {
        "source": "Shifting `a` by `gcdpow` cannot shift out any of the set bits in `a` (of which it has exactly one).",
        "suggest": "将 `a` 移位 `gcdpow` 不能移出 `a` 中的任何设置位 (其中只有一位)。",
        "translate": ""
    },
    {
        "source": "Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will always be strictly greater than `(p % a) >> gcdpow`.",
        "suggest": "此外，减法不会溢出，因为 `a2 = a >> gcdpow` 将始终严格大于 `(p % a) >> gcdpow`。",
        "translate": ""
    },
    {
        "source": "`a2` is a power-of-two, as proven above.",
        "suggest": "如上所述，`a2` 是 2 的幂。",
        "translate": ""
    },
    {
        "source": "is strictly less than `a2` because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.",
        "suggest": "严格小于 `a2`，因为 `(s % a) >> gcdpow` 严格小于 `a >> gcdpow`。",
        "translate": ""
    },
    {
        "source": "Cannot be aligned at all.",
        "suggest": "根本无法对齐。",
        "translate": ""
    },
    {
        "source": "Compares raw pointers for equality.",
        "suggest": "比较裸指针是否相等。",
        "translate": ""
    },
    {
        "source": "This is the same as using the `==` operator, but less generic:",
        "suggest": "这与使用 `==` 运算符相同，但泛型较少:",
        "translate": ""
    },
    {
        "source": "the arguments have to be `*const T` raw pointers, not anything that implements `PartialEq`.",
        "suggest": "参数必须是 `*const T` 裸指针，而不是任何实现 `PartialEq` 的东西。",
        "translate": ""
    },
    {
        "source": "This can be used to compare `&T` references (which coerce to `*const T` implicitly) by their address rather than comparing the values they point to (which is what the `PartialEq for &T` implementation does).",
        "suggest": "这可用于按地址比较 `&T` 引用 (隐式强制为 `*const T`)，而不是比较它们指向的值 (`PartialEq for &T` 实现的作用)。",
        "translate": ""
    },
    {
        "source": "Slices are also compared by their length (fat pointers):",
        "suggest": "切片还通过其长度 (胖指针) 进行比较:",
        "translate": ""
    },
    {
        "source": "Traits are also compared by their implementation:",
        "suggest": "Traits 的实现方式也进行了比较:",
        "translate": ""
    },
    {
        "source": "Hash a raw pointer.",
        "suggest": "散列一个裸指针。",
        "translate": ""
    },
    {
        "source": "This can be used to hash a `&T` reference (which coerces to `*const T` implicitly) by its address rather than the value it points to (which is what the `Hash for &T` implementation does).",
        "suggest": "这可用于通过其地址而不是其指向的值 (`Hash for &T` 实现的作用) 对 `&T` 引用 (隐式强制为 `*const T`) 进行哈希处理。",
        "translate": ""
    },
    {
        "source": "Impls for function pointers",
        "suggest": "函数指针的 Impls",
        "translate": ""
    },
    {
        "source": "The intermediate cast as usize is required for AVR so that the address space of the source function pointer is preserved in the final function pointer.",
        "suggest": "AVR 需要使用 asize 中间转换，以便将源函数指针的地址空间保留在最终函数指针中。",
        "translate": ""
    },
    {
        "source": "No variadic functions with 0 parameters",
        "suggest": "没有参数为 0 的可变参数函数",
        "translate": ""
    },
    {
        "source": "Create a `const` raw pointer to a place, without creating an intermediate reference.",
        "suggest": "创建一个 `const` 裸指针到一个位置，而无需创建中间引用。",
        "translate": ""
    },
    {
        "source": "Creating a reference with `&`/`&mut` is only allowed if the pointer is properly aligned and points to initialized data.",
        "suggest": "仅当指针正确对齐并指向初始化数据时，才允许使用 `&`/`&mut` 创建引用。",
        "translate": ""
    },
    {
        "source": "For cases where those requirements do not hold, raw pointers should be used instead.",
        "suggest": "对于那些不满足要求的情况，应改用裸指针。",
        "translate": ""
    },
    {
        "source": "However, `&expr as *const _` creates a reference before casting it to a raw pointer, and that reference is subject to the same rules as all other references.",
        "suggest": "但是，`&expr as *const _` 在将其强制转换为裸指针之前会创建一个引用，并且该引用与所有其他引用都遵循相同的规则。",
        "translate": ""
    },
    {
        "source": "This macro can create a raw pointer *without* creating a reference first.",
        "suggest": "该宏可以创建一个裸指针，而无需先创建一个引用。",
        "translate": ""
    },
    {
        "source": "Create a `mut` raw pointer to a place, without creating an intermediate reference.",
        "suggest": "创建一个 `mut` 裸指针到一个位置，而无需创建中间引用。",
        "translate": ""
    },
    {
        "source": "However, `&mut expr as *mut _` creates a reference before casting it to a raw pointer, and that reference is subject to the same rules as all other references.",
        "suggest": "但是，`&mut expr as *mut _` 在将其强制转换为裸指针之前会创建一个引用，并且该引用与所有其他引用都遵循相同的规则。",
        "translate": ""
    },
    {
        "source": "It'll print:",
        "suggest": "它会打印:",
        "translate": ""
    },
    {
        "source": "The pointer can be later reconstructed with [`from_raw_parts_mut`].",
        "suggest": "以后可以使用 [`from_raw_parts_mut`] 重建指针。",
        "translate": ""
    },
    {
        "source": "For the mutable counterpart see [`as_mut`].",
        "suggest": "对于可变的对应物，请参见 [`as_mut`]。",
        "translate": ""
    },
    {
        "source": "For the mutable counterpart see [`as_uninit_mut`].",
        "suggest": "对于可变的对应物，请参见 [`as_uninit_mut`]。",
        "translate": ""
    },
    {
        "source": "The obtained pointer is valid for writes since the caller must guarantee that it points to the same allocated object as `self`.",
        "suggest": "获得的指针对于写入有效，因为调用者必须保证它指向的对象与 `self` 相同。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the pointer is null, or else returns a unique reference to the value wrapped in `Some`.",
        "suggest": "如果指针为 null，则返回 `None`，否则返回 `Some` 中包装的值的唯一引用。",
        "translate": ""
    },
    {
        "source": "If the value may be uninitialized, [`as_uninit_mut`] must be used instead.",
        "suggest": "如果该值可能未初始化，则必须改用 [`as_uninit_mut`]。",
        "translate": ""
    },
    {
        "source": "For the shared counterpart see [`as_ref`].",
        "suggest": "有关共享副本，请参见 [`as_ref`]。",
        "translate": ""
    },
    {
        "source": "In particular, for the duration of this lifetime, the memory the pointer points to must not get accessed (read or written) through any other pointer.",
        "suggest": "特别是，在此生命周期的持续时间内，指针所指向的内存一定不能通过任何其他指针进行访问 (读取或写入)。",
        "translate": ""
    },
    {
        "source": "If you are sure the pointer can never be null and are looking for some kind of `as_mut_unchecked` that returns the `&mut T` instead of `Option<&mut T>`, know that you can dereference the pointer directly.",
        "suggest": "如果确定指针永远不会为空，并且正在寻找某种返回 `&mut T` 而不是 `Option<&mut T>` 的 `as_mut_unchecked`，请知道您可以直接引用该指针。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` is be valid for a mutable reference if it isn't null.",
        "suggest": "如果 `self` 不为 null，则调用者必须保证 `self` 对变量引用有效。",
        "translate": ""
    },
    {
        "source": "In contrast to [`as_mut`], this does not require that the value has to be initialized.",
        "suggest": "与 [`as_mut`] 相比，这不需要将该值初始化。",
        "translate": ""
    },
    {
        "source": "For the shared counterpart see [`as_uninit_ref`].",
        "suggest": "有关共享副本，请参见 [`as_uninit_ref`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `offset_from`.",
        "suggest": "调用者必须坚持 `offset_from` 的安全保证。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for ``.",
        "suggest": "调用者必须坚持 `` 的安全保证 ''。",
        "translate": ""
    },
    {
        "source": "Copies `count * size_of<T>` bytes from `src` to `self`.",
        "suggest": "将 `count * size_of<T>` 字节从 `src` 复制到 `self`。",
        "translate": ""
    },
    {
        "source": "this has the *opposite* argument order of [`ptr::copy`].",
        "suggest": "这具有 [`ptr::copy`] 的 *相反* 参数顺序。",
        "translate": ""
    },
    {
        "source": "this has the *opposite* argument order of [`ptr::copy_nonoverlapping`].",
        "suggest": "这具有 [`ptr::copy_nonoverlapping`] 的 *相反* 参数顺序。",
        "translate": ""
    },
    {
        "source": "See [`ptr::drop_in_place`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::drop_in_place`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `drop_in_place`.",
        "suggest": "调用者必须坚持 `drop_in_place` 的安全保证。",
        "translate": ""
    },
    {
        "source": "See [`ptr::write`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::write`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `write`.",
        "suggest": "调用者必须坚持 `write` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Invokes memset on the specified pointer, setting `count * size_of::<T>()` bytes of memory starting at `self` to `val`.",
        "suggest": "在指定的指针上调用 memset，将 `self` 开始的 `count * size_of::<T>()` 内存字节设置为 `val`。",
        "translate": ""
    },
    {
        "source": "See [`ptr::write_bytes`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::write_bytes`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `write_bytes`.",
        "suggest": "调用者必须坚持 `write_bytes` 的安全保证。",
        "translate": ""
    },
    {
        "source": "See [`ptr::write_volatile`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::write_volatile`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `write_volatile`.",
        "suggest": "调用者必须坚持 `write_volatile` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Unlike `write`, the pointer may be unaligned.",
        "suggest": "与 `write` 不同，指针可能未对齐。",
        "translate": ""
    },
    {
        "source": "See [`ptr::write_unaligned`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::write_unaligned`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `write_unaligned`.",
        "suggest": "调用者必须坚持 `write_unaligned` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Replaces the value at `self` with `src`, returning the old value, without dropping either.",
        "suggest": "用 `src` 替换 `self` 处的值，返回旧值，但不丢弃任何一个。",
        "translate": ""
    },
    {
        "source": "See [`ptr::replace`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::replace`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `replace`.",
        "suggest": "调用者必须坚持 `replace` 的安全保证。",
        "translate": ""
    },
    {
        "source": "They may overlap, unlike `mem::swap` which is otherwise equivalent.",
        "suggest": "它们可能重叠，这与 `mem::swap` 不同，后者在其他方面是等效的。",
        "translate": ""
    },
    {
        "source": "See [`ptr::swap`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::swap`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `swap`.",
        "suggest": "调用者必须坚持 `swap` 的安全保证。",
        "translate": ""
    },
    {
        "source": "This is equivalent to casting `self` to `*mut T`, but more type-safe.",
        "suggest": "这等效于将 `self` 强制转换为 `*mut T`，但类型安全性更高。",
        "translate": ""
    },
    {
        "source": "For the mutable counterpart see [`as_uninit_slice_mut`].",
        "suggest": "对于可变的对应物，请参见 [`as_uninit_slice_mut`]。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the pointer is null, or else returns a unique slice to the value wrapped in `Some`.",
        "suggest": "如果指针为空，则返回 `None`，否则返回一个唯一的切片到 `Some` 中包装的值。",
        "translate": ""
    },
    {
        "source": "For the shared counterpart see [`as_uninit_slice`].",
        "suggest": "有关共享副本，请参见 [`as_uninit_slice`]。",
        "translate": ""
    },
    {
        "source": "The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()` many bytes, and it must be properly aligned.",
        "suggest": "指针必须为 [valid] 才能进行 `ptr.len() * mem::size_of::<T>()` 多个字节的读取和写入，并且必须正确对齐。",
        "translate": ""
    },
    {
        "source": "See also [`slice::from_raw_parts_mut`][].",
        "suggest": "另请参见 [`slice::from_raw_parts_mut`][]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `as_uninit_slice_mut`.",
        "suggest": "调用者必须坚持 `as_uninit_slice_mut` 的安全保证。",
        "translate": ""
    },
    {
        "source": "This is safe as `memory` is valid for reads and writes for `memory.len()` many bytes.",
        "suggest": "这是安全的，因为 `memory` 对于许多字节的 `memory.len()` 读和写有效。",
        "translate": ""
    },
    {
        "source": "Note that calling `memory.as_mut()` is not allowed here as the content may be uninitialized.",
        "suggest": "请注意，此处不允许调用 `memory.as_mut()`，因为内容可能未初始化。",
        "translate": ""
    },
    {
        "source": "but non-zero and covariant.",
        "suggest": "但非零且协变。",
        "translate": ""
    },
    {
        "source": "This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties.",
        "suggest": "在使用裸指针构建数据结构时，这通常是正确的选择，但由于其额外的属性，最终使用起来更加危险。",
        "translate": ""
    },
    {
        "source": "If you're not sure if you should use `NonNull<T>`, just use `*mut T`!",
        "suggest": "如果不确定是否应使用 `NonNull<T>`，请使用 `*mut T`!",
        "translate": ""
    },
    {
        "source": "Unlike `*mut T`, the pointer must always be non-null, even if the pointer is never dereferenced.",
        "suggest": "与 `*mut T` 不同，即使从未解引用指针，指针也必须始终为非 null。",
        "translate": ""
    },
    {
        "source": "This is so that enums may use this forbidden value as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.",
        "suggest": "这样一来，枚举就可以将此禁止值用作判别式 - `Option<NonNull<T>>` 与 `*mut T` 具有相同的大小。",
        "translate": ""
    },
    {
        "source": "However the pointer may still dangle if it isn't dereferenced.",
        "suggest": "但是，如果指针未解引用，它可能仍会悬垂。",
        "translate": ""
    },
    {
        "source": "Unlike `*mut T`, `NonNull<T>` was chosen to be covariant over `T`.",
        "suggest": "与 `*mut T` 不同，选择 `NonNull<T>` 作为 `T` 的协变。",
        "translate": ""
    },
    {
        "source": "This makes it possible to use `NonNull<T>` when building covariant types, but introduces the risk of unsoundness if used in a type that shouldn't actually be covariant.",
        "suggest": "这样就可以在构建协变类型时使用 `NonNull<T>`，但是如果在实际上不应该协变的类型中使用，则会带来不健全的风险。",
        "translate": ""
    },
    {
        "source": "(The opposite choice was made for `*mut T` even though technically the unsoundness could only be caused by calling unsafe functions.)",
        "suggest": "(尽管从技术上讲，不健全只能由调用不安全的函数引起，但对于 `*mut T` 却做出了相反的选择。)",
        "translate": ""
    },
    {
        "source": "Covariance is correct for most safe abstractions, such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`.",
        "suggest": "对于大多数安全抽象，例如 `Box`，`Rc`，`Arc`，`Vec` 和 `LinkedList`，协方差是正确的。",
        "translate": ""
    },
    {
        "source": "This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust.",
        "suggest": "之所以如此，是因为它们提供了遵循 Rust 的常规共享 XOR 可变规则的公共 API。",
        "translate": ""
    },
    {
        "source": "If your type cannot safely be covariant, you must ensure it contains some additional field to provide invariance.",
        "suggest": "如果您的类型不能安全地协变，则必须确保它包含一些附加字段以提供不变性。",
        "translate": ""
    },
    {
        "source": "Often this field will be a [`PhantomData`] type like `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.",
        "suggest": "通常，此字段是 [`PhantomData`] 类型，例如 `PhantomData<Cell<T>>` 或 `PhantomData<&'a mut T>`。",
        "translate": ""
    },
    {
        "source": "Notice that `NonNull<T>` has a `From` instance for `&T`.",
        "suggest": "请注意，`NonNull<T>` 具有 `&T` 的 `From` 实例。",
        "translate": ""
    },
    {
        "source": "However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an [`UnsafeCell<T>`].",
        "suggest": "但是，这不会改变以下事实: 除非通过 [`UnsafeCell<T>`] 内部发生可变的，否则通过 (从 a 派生的指针) 进行共享引用的可变的是未定义的行为。",
        "translate": ""
    },
    {
        "source": "The same goes for creating a mutable reference from a shared reference.",
        "suggest": "从共享引用创建变量引用也是如此。",
        "translate": ""
    },
    {
        "source": "When using this `From` instance without an `UnsafeCell<T>`, it is your responsibility to ensure that `as_mut` is never called, and `as_ptr` is never used for mutation.",
        "suggest": "当使用不带 `UnsafeCell<T>` 的 `From` 实例时，您有责任确保从不调用 `as_mut`，并且从不使用 `as_ptr` 进行可变的。",
        "translate": ""
    },
    {
        "source": "pointers are not `Send` because the data they reference may be aliased.",
        "suggest": "指针不是 `Send`，因为它们引用的数据可能是别名的。",
        "translate": ""
    },
    {
        "source": "N.B., this impl is unnecessary, but should provide better error messages.",
        "suggest": "注意，此暗示不是必需的，但应提供更好的错误消息。",
        "translate": ""
    },
    {
        "source": "pointers are not `Sync` because the data they reference may be aliased.",
        "suggest": "指针不是 `Sync`，因为它们引用的数据可能是别名的。",
        "translate": ""
    },
    {
        "source": "Creates a new `NonNull` that is dangling, but well-aligned.",
        "suggest": "创建一个悬空但对齐良好的新 `NonNull`。",
        "translate": ""
    },
    {
        "source": "This is useful for initializing types which lazily allocate, like `Vec::new` does.",
        "suggest": "与 `Vec::new` 一样，这对于初始化延迟分配的类型很有用。",
        "translate": ""
    },
    {
        "source": "Note that the pointer value may potentially represent a valid pointer to a `T`, which means this must not be used as a \"not yet initialized\" sentinel value.",
        "suggest": "请注意，该指针值可能表示一个指向 `T` 的有效指针，这意味着不得将其用作 \"not yet initialized\" 标记值。",
        "translate": ""
    },
    {
        "source": "mem::align_of() returns a non-zero usize which is then casted to a *mut T.",
        "suggest": "mem::align_of () 返回一个非零的 usize，然后将其强制转换为 *mut T。",
        "translate": ""
    },
    {
        "source": "Therefore, `ptr` is not null and the conditions for calling new_unchecked() are respected.",
        "suggest": "因此，`ptr` 不为空，并且遵守了调用 new_unchecked() 的条件。",
        "translate": ""
    },
    {
        "source": "Returns a shared references to the value.",
        "suggest": "返回该值的共享引用。",
        "translate": ""
    },
    {
        "source": "When calling this method, you have to ensure that all of the following is true:",
        "suggest": "调用此方法时，必须确保满足以下所有条件:",
        "translate": ""
    },
    {
        "source": "Returns a unique references to the value.",
        "suggest": "返回该值的唯一引用。",
        "translate": ""
    },
    {
        "source": "Creates a new `NonNull`.",
        "suggest": "创建一个新的 `NonNull`。",
        "translate": ""
    },
    {
        "source": "must be non-null.",
        "suggest": "必须为非 null。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `ptr` is non-null.",
        "suggest": "调用者必须保证 `ptr` 不为空。",
        "translate": ""
    },
    {
        "source": "Creates a new `NonNull` if `ptr` is non-null.",
        "suggest": "如果 `ptr` 不为空，则创建一个新的 `NonNull`。",
        "translate": ""
    },
    {
        "source": "The pointer is already checked and is not null",
        "suggest": "指针已被检查并且不为 null",
        "translate": ""
    },
    {
        "source": "Performs the same functionality as [`std::ptr::from_raw_parts`], except that a `NonNull` pointer is returned, as opposed to a raw `*const` pointer.",
        "suggest": "执行与 [`std::ptr::from_raw_parts`] 相同的功能，除了返回 `NonNull` 指针 (与原始 `*const` 指针相反)。",
        "translate": ""
    },
    {
        "source": "See the documentation of [`std::ptr::from_raw_parts`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`std::ptr::from_raw_parts`] 的文档。",
        "translate": ""
    },
    {
        "source": "The result of `ptr::from::raw_parts_mut` is non-null because `data_address` is.",
        "suggest": "`ptr::from::raw_parts_mut` 的结果为非空值，因为 `data_address` 为非。",
        "translate": ""
    },
    {
        "source": "The pointer can be later reconstructed with [`NonNull::from_raw_parts`].",
        "suggest": "以后可以使用 [`NonNull::from_raw_parts`] 重建指针。",
        "translate": ""
    },
    {
        "source": "Acquires the underlying `*mut` pointer.",
        "suggest": "获取基础的 `*mut` 指针。",
        "translate": ""
    },
    {
        "source": "Returns a shared reference to the value.",
        "suggest": "返回该值的共享引用。",
        "translate": ""
    },
    {
        "source": "Returns a unique reference to the value.",
        "suggest": "返回该值的唯一引用。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` meets all the requirements for a mutable reference.",
        "suggest": "调用者必须保证 `self` 满足可变引用的所有要求。",
        "translate": ""
    },
    {
        "source": "`self` is a `NonNull` pointer which is necessarily non-null",
        "suggest": "`self` 是一个 `NonNull` 指针，该指针必须非空",
        "translate": ""
    },
    {
        "source": "Creates a non-null raw slice from a thin pointer and a length.",
        "suggest": "根据细指针和长度创建非空的原始切片。",
        "translate": ""
    },
    {
        "source": "This function is safe, but dereferencing the return value is unsafe.",
        "suggest": "此函数是安全的，但解引用的返回值不安全。",
        "translate": ""
    },
    {
        "source": "(Note that this example artificially demonstrates a use of this method, but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)",
        "suggest": "(请注意，此示例人为地演示了此方法的用法，但是 `let slice = NonNull::from(&x[..]);` 是编写这样的代码的更好方法。)",
        "translate": ""
    },
    {
        "source": "`data` is a `NonNull` pointer which is necessarily non-null",
        "suggest": "`data` 是一个 `NonNull` 指针，该指针必须非空",
        "translate": ""
    },
    {
        "source": "Returns the length of a non-null raw slice.",
        "suggest": "返回非空原始切片的长度。",
        "translate": ""
    },
    {
        "source": "This function is safe, even when the non-null raw slice cannot be dereferenced to a slice because the pointer does not have a valid address.",
        "suggest": "即使由于指针没有有效地址而无法将非空原始切片重新引用到切片时，此函数也是安全的。",
        "translate": ""
    },
    {
        "source": "Returns a non-null pointer to the slice's buffer.",
        "suggest": "返回指向切片缓冲区的非 null 指针。",
        "translate": ""
    },
    {
        "source": "We know `self` is non-null.",
        "suggest": "我们知道 `self` 不为空。",
        "translate": ""
    },
    {
        "source": "Returns a shared reference to a slice of possibly uninitialized values.",
        "suggest": "返回对可能未初始化的值的切片的共享引用。",
        "translate": ""
    },
    {
        "source": "See also [`slice::from_raw_parts`].",
        "suggest": "另请参见 [`slice::from_raw_parts`]。",
        "translate": ""
    },
    {
        "source": "Returns a unique reference to a slice of possibly uninitialized values.",
        "suggest": "返回可能未初始化值的切片的唯一引用。",
        "translate": ""
    },
    {
        "source": "See also [`slice::from_raw_parts_mut`].",
        "suggest": "另请参见 [`slice::from_raw_parts_mut`]。",
        "translate": ""
    },
    {
        "source": "As a consequence, the resulting pointer cannot be NULL.",
        "suggest": "因此，结果指针不能为 NULL。",
        "translate": ""
    },
    {
        "source": "A Unique pointer cannot be null, so the conditions for new_unchecked() are respected.",
        "suggest": "唯一指针不能为空，因此必须遵守 new_unchecked() 的条件。",
        "translate": ""
    },
    {
        "source": "A mutable reference cannot be null.",
        "suggest": "可变引用不能为空。",
        "translate": ""
    },
    {
        "source": "A reference cannot be null, so the conditions for new_unchecked() are respected.",
        "suggest": "引用不能为空，因此必须遵守 new_unchecked() 的条件。",
        "translate": ""
    },
    {
        "source": "A wrapper around a raw non-null `*mut T` that indicates that the possessor of this wrapper owns the referent.",
        "suggest": "原始非空 `*mut T` 周围的包装器，指示该包装器的拥有者拥有引用对象。",
        "translate": ""
    },
    {
        "source": "Useful for building abstractions like `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.",
        "suggest": "对于构建 `Box<T>`，`Vec<T>`，`String` 和 `HashMap<K, V>` 等抽象很有用。",
        "translate": ""
    },
    {
        "source": "Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.",
        "suggest": "与 `*mut T` 不同，`Unique<T>` 的行为与 \"as if\" 相同，它是 `T` 的实例。",
        "translate": ""
    },
    {
        "source": "It implements `Send`/`Sync` if `T` is `Send`/`Sync`.",
        "suggest": "如果 `T` 为 `Send`/`Sync`，则实现 `Send`/`Sync`。",
        "translate": ""
    },
    {
        "source": "It also implies the kind of strong aliasing guarantees an instance of `T` can expect:",
        "suggest": "这也暗示了 `T` 实例可以期望的那种强别名保证:",
        "translate": ""
    },
    {
        "source": "the referent of the pointer should not be modified without a unique path to its owning Unique.",
        "suggest": "如果没有指向其所属 `unique` 的唯一路径，则不应修改指针的引用对象。",
        "translate": ""
    },
    {
        "source": "If you're uncertain of whether it's correct to use `Unique` for your purposes, consider using `NonNull`, which has weaker semantics.",
        "suggest": "如果不确定使用 `Unique` 是否正确，请考虑使用语义较弱的 `NonNull`。",
        "translate": ""
    },
    {
        "source": "This is so that enums may use this forbidden value as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.",
        "suggest": "这样一来，枚举就可以将此禁止值用作判别式 - `Option<Unique<T>>` 与 `Unique<T>` 具有相同的大小。",
        "translate": ""
    },
    {
        "source": "Unlike `*mut T`, `Unique<T>` is covariant over `T`.",
        "suggest": "与 `*mut T` 不同，`Unique<T>` 在 `T` 上是协变的。",
        "translate": ""
    },
    {
        "source": "This should always be correct for any type which upholds Unique's aliasing requirements.",
        "suggest": "对于任何符合 `Unique` 别名要求的类型，这应该总是正确的。",
        "translate": ""
    },
    {
        "source": "this marker has no consequences for variance, but is necessary for dropck to understand that we logically own a `T`.",
        "suggest": "此标记不会对差异产生任何影响，但对于 dropck 来说，了解我们在逻辑上拥有 `T` 是必需的。",
        "translate": ""
    },
    {
        "source": "For details, see:",
        "suggest": "有关详细信息，请参见:",
        "translate": ""
    },
    {
        "source": "pointers are `Send` if `T` is `Send` because the data they reference is unaliased.",
        "suggest": "如果 `T` 为 `Send`，则指针为 `Send`，因为它们引用的数据是未混叠的。",
        "translate": ""
    },
    {
        "source": "Note that this aliasing invariant is unenforced by the type system;",
        "suggest": "请注意，类型系统不强制使用此别名不变式。",
        "translate": ""
    },
    {
        "source": "the abstraction using the `Unique` must enforce it.",
        "suggest": "使用 `Unique` 的抽象必须强制使用它。",
        "translate": ""
    },
    {
        "source": "pointers are `Sync` if `T` is `Sync` because the data they reference is unaliased.",
        "suggest": "如果 `T` 为 `Sync`，则指针为 `Sync`，因为它们引用的数据是未混叠的。",
        "translate": ""
    },
    {
        "source": "Creates a new `Unique` that is dangling, but well-aligned.",
        "suggest": "创建一个悬空但对齐良好的新 `Unique`。",
        "translate": ""
    },
    {
        "source": "mem::align_of() returns a valid, non-null pointer.",
        "suggest": "mem::align_of () 返回有效的非 null 指针。",
        "translate": ""
    },
    {
        "source": "The conditions to call new_unchecked() are thus respected.",
        "suggest": "因此遵守了调用 new_unchecked() 的条件。",
        "translate": ""
    },
    {
        "source": "Creates a new `Unique`.",
        "suggest": "创建一个新的 `Unique`。",
        "translate": ""
    },
    {
        "source": "Creates a new `Unique` if `ptr` is non-null.",
        "suggest": "如果 `ptr` 不为空，则创建一个新的 `Unique`。",
        "translate": ""
    },
    {
        "source": "The pointer has already been checked and is not null.",
        "suggest": "该指针已被检查并且不为空。",
        "translate": ""
    },
    {
        "source": "Dereferences the content.",
        "suggest": "解引用内容。",
        "translate": ""
    },
    {
        "source": "The resulting lifetime is bound to self so this behaves \"as if\" it were actually an instance of T that is getting borrowed.",
        "suggest": "最终的生命周期与自身绑定，因此其行为 \"as if\" 实际上是被借用的 T 的一个实例。",
        "translate": ""
    },
    {
        "source": "If a longer (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.",
        "suggest": "如果需要更长的 (unbound) 生命周期，请使用 `&*my_ptr.as_ptr()`。",
        "translate": ""
    },
    {
        "source": "Mutably dereferences the content.",
        "suggest": "相互解引用内容。",
        "translate": ""
    },
    {
        "source": "If a longer (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.",
        "suggest": "如果需要更长的 (unbound) 生命周期，请使用 `&mut *my_ptr.as_ptr()`。",
        "translate": ""
    },
    {
        "source": "Unique::new_unchecked() creates a new unique and needs the given pointer to not be null.",
        "suggest": "Unique::new_unchecked () 创建一个新的唯一性，并且需要给定的指针不为 null。",
        "translate": ""
    },
    {
        "source": "Since we are passing self as a pointer, it cannot be null.",
        "suggest": "由于我们将 self 作为指针传递，因此它不能为 null。",
        "translate": ""
    },
    {
        "source": "A mutable reference cannot be null",
        "suggest": "可变引用不能为空",
        "translate": ""
    },
    {
        "source": "an example trait",
        "suggest": "示例 trait",
        "translate": ""
    },
    {
        "source": "let the compiler make a trait object",
        "suggest": "让编译器制作一个 trait 对象",
        "translate": ""
    },
    {
        "source": "look at the raw representation",
        "suggest": "看原始表示",
        "translate": ""
    },
    {
        "source": "the data pointer is the address of `value`",
        "suggest": "数据指针是 `value` 的地址",
        "translate": ""
    },
    {
        "source": "construct a new object, pointing to a different `i32`, being careful to use the `i32` vtable from `object`",
        "suggest": "创建一个指向另一个 `i32` 的新对象，请小心使用 `object` 的 `i32` vtable",
        "translate": ""
    },
    {
        "source": "it should work just as if we had constructed a trait object out of `other_value` directly",
        "suggest": "它应该就像我们直接从 `other_value` 构造了一个 trait 对象一样工作",
        "translate": ""
    },
    {
        "source": "Contains struct definitions for the layout of compiler built-in types.",
        "suggest": "包含用于编译器内置类型的布局的结构体定义。",
        "translate": ""
    },
    {
        "source": "They can be used as targets of transmutes in unsafe code for manipulating the raw representations directly.",
        "suggest": "它们可以用作不安全代码中的变形目标，以直接操作原始表示。",
        "translate": ""
    },
    {
        "source": "Their definition should always match the ABI defined in `rustc_middle::ty::layout`.",
        "suggest": "它们的定义应始终与 `rustc_middle::ty::layout` 中定义的 ABI 相匹配。",
        "translate": ""
    },
    {
        "source": "The representation of a trait object like `&dyn SomeTrait`.",
        "suggest": "trait 对象 (如 `&dyn SomeTrait`) 的表示形式。",
        "translate": ""
    },
    {
        "source": "This struct has the same layout as types like `&dyn SomeTrait` and `Box<dyn AnotherTrait>`.",
        "suggest": "该结构体的布局与 `&dyn SomeTrait` 和 `Box<dyn AnotherTrait>` 等类型的布局相同。",
        "translate": ""
    },
    {
        "source": "is guaranteed to match layouts, but it is not the type of trait objects (e.g., the fields are not directly accessible on a `&dyn SomeTrait`) nor does it control that layout (changing the definition will not change the layout of a `&dyn SomeTrait`).",
        "suggest": "保证匹配布局，但这不是 trait 对象的类型 (例如，不能在 `&dyn SomeTrait` 上直接访问字段)，也不是控制布局 (更改定义不会更改 `&dyn SomeTrait` 的布局)。",
        "translate": ""
    },
    {
        "source": "It is only designed to be used by unsafe code that needs to manipulate the low-level details.",
        "suggest": "它仅设计用于需要操纵脆弱细节的不安全代码。",
        "translate": ""
    },
    {
        "source": "There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like [`std::mem::transmute`][transmute].",
        "suggest": "无法通用地引用所有 trait 对象，因此创建此类型的值的唯一方法是使用 [`std::mem::transmute`][transmute] 之类的函数。",
        "translate": ""
    },
    {
        "source": "Similarly, the only way to create a true trait object from a `TraitObject` value is with `transmute`.",
        "suggest": "同样，从 `TraitObject` 值创建真正的 trait 对象的唯一方法是使用 `transmute`。",
        "translate": ""
    },
    {
        "source": "Synthesizing a trait object with mismatched types—one where the vtable does not correspond to the type of the value to which the data pointer points—is highly likely to lead to undefined behavior.",
        "suggest": "使用不匹配的类型 (一个 vtable 不对应于数据指针所指向的值的类型) 合成 trait 对象的可能性极高，这会导致不确定的行为。",
        "translate": ""
    },
    {
        "source": "The `is_ok` and `is_err` methods do what they say.",
        "suggest": "`is_ok` 和 `is_err` 方法按照他们说的做。",
        "translate": ""
    },
    {
        "source": "consumes the `Result` and produces another.",
        "suggest": "消耗 `Result` 并产生另一个。",
        "translate": ""
    },
    {
        "source": "Use `and_then` to continue the computation.",
        "suggest": "使用 `and_then` 继续计算。",
        "translate": ""
    },
    {
        "source": "Use `or_else` to handle the error.",
        "suggest": "使用 `or_else` 处理该错误。",
        "translate": ""
    },
    {
        "source": "Consume the result and return the contents with `unwrap`.",
        "suggest": "消费结果并用 `unwrap` 返回内容。",
        "translate": ""
    },
    {
        "source": "If `write_all` errors, then we'll never know, because the return value is ignored.",
        "suggest": "如果 `write_all` 错误，那么我们将永远不会知道，因为返回值将被忽略。",
        "translate": ""
    },
    {
        "source": "Early return on error",
        "suggest": "尽早返回错误",
        "translate": ""
    },
    {
        "source": "panics with `Testing expect: emergency failure`",
        "suggest": "`Testing expect: emergency failure` 的 panics",
        "translate": ""
    },
    {
        "source": "panics with `emergency failure`",
        "suggest": "`emergency failure` 的 panics",
        "translate": ""
    },
    {
        "source": "panics with `Testing expect_err: 10`",
        "suggest": "`Testing expect_err: 10` 的 panics",
        "translate": ""
    },
    {
        "source": "panics with `2`",
        "suggest": "`2` 的 panics",
        "translate": ""
    },
    {
        "source": "Error handling with the `Result` type.",
        "suggest": "`Result` 类型的错误处理。",
        "translate": ""
    },
    {
        "source": "is the type used for returning and propagating errors.",
        "suggest": "是用于返回和传播错误的类型。",
        "translate": ""
    },
    {
        "source": "It is an enum with the variants, [`Ok(T)`], representing success and containing a value, and [`Err(E)`], representing error and containing an error value.",
        "suggest": "它是一个枚举，成员 [`Ok(T)`] 表示成功并包含一个值，而 [`Err(E)`] 表示错误并包含错误值。",
        "translate": ""
    },
    {
        "source": "Functions return [`Result`] whenever errors are expected and recoverable.",
        "suggest": "只要预期到错误并且可以恢复，函数就返回 [`Result`]。",
        "translate": ""
    },
    {
        "source": "In the `std` crate, [`Result`] is most prominently used for [I/O](../../std/io/index.html).",
        "suggest": "在 `std` crate 中，[`Result`] 最主要用于 [I/O](../../std/io/index.html)。",
        "translate": ""
    },
    {
        "source": "A simple function returning [`Result`] might be defined and used like so:",
        "suggest": "返回 [`Result`] 的简单函数可以像这样定义和使用:",
        "translate": ""
    },
    {
        "source": "Pattern matching on [`Result`]s is clear and straightforward for simple cases, but [`Result`] comes with some convenience methods that make working with it more succinct.",
        "suggest": "在简单情况下，在 [`Result`] 上进行模式匹配非常简单明了，但是 [`Result`] 附带了一些方便的方法，使使用它更加简洁。",
        "translate": ""
    },
    {
        "source": "Results must be used",
        "suggest": "必须使用结果",
        "translate": ""
    },
    {
        "source": "A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error.",
        "suggest": "使用返回值指示错误的一个常见问题是，很容易忽略返回值，从而无法处理错误。",
        "translate": ""
    },
    {
        "source": "is annotated with the `#[must_use]` attribute, which will cause the compiler to issue a warning when a Result value is ignored.",
        "suggest": "带有 `#[must_use]` 属性的注解，它将导致编译器在忽略 Result 值时发出警告。",
        "translate": ""
    },
    {
        "source": "This makes [`Result`] especially useful with functions that may encounter errors but don't otherwise return a useful value.",
        "suggest": "这使得 [`Result`] 对于可能遇到错误但不会返回有用值的函数特别有用。",
        "translate": ""
    },
    {
        "source": "Consider the [`write_all`] method defined for I/O types by the [`Write`] trait:",
        "suggest": "考虑 [`Write`] trait 为 I/O 类型定义的 [`write_all`] 方法:",
        "translate": ""
    },
    {
        "source": "The actual definition of [`Write`] uses [`io::Result`], which is just a synonym for [`Result`]`<T,",
        "suggest": "[`Write`] 的实际定义使用 [`io::Result`]，它只是 [`Result`]` 的同义词。",
        "translate": ""
    },
    {
        "source": "This method doesn't produce a value, but the write may fail.",
        "suggest": "该方法不会产生值，但是写入可能会失败。",
        "translate": ""
    },
    {
        "source": "It's crucial to handle the error case, and *not* write something like this:",
        "suggest": "处理错误情况至关重要，并且 *不要* 编写类似以下内容的代码:",
        "translate": ""
    },
    {
        "source": "If you *do* write that in Rust, the compiler will give you a warning (by default, controlled by the `unused_must_use` lint).",
        "suggest": "如果您确实将其写在 Rust 中，则编译器将向您发出警告 (默认情况下，由 `unused_must_use` lint 控制)。",
        "translate": ""
    },
    {
        "source": "You might instead, if you don't want to handle the error, simply assert success with [`expect`].",
        "suggest": "相反，如果您不想处理该错误，则可以断言 [`expect`] 成功。",
        "translate": ""
    },
    {
        "source": "This will panic if the write fails, providing a marginally useful message indicating why:",
        "suggest": "如果写入失败，这将为 panic，提供了一条边际有用的消息，指出原因:",
        "translate": ""
    },
    {
        "source": "You might also simply assert success:",
        "suggest": "您可能还简单地宣称成功:",
        "translate": ""
    },
    {
        "source": "Or propagate the error up the call stack with [`?`]:",
        "suggest": "或者使用 [`?`] 在调用栈中传播错误:",
        "translate": ""
    },
    {
        "source": "The question mark operator,",
        "suggest": "问号运算符，",
        "translate": ""
    },
    {
        "source": "When writing code that calls many functions that return the [`Result`] type, the error handling can be tedious.",
        "suggest": "在编写调用许多返回 [`Result`] 类型的函数的代码时，错误处理可能很乏味。",
        "translate": ""
    },
    {
        "source": "The question mark operator, [`?`], hides some of the boilerplate of propagating errors up the call stack.",
        "suggest": "问号运算符 [`?`] 在调用栈中隐藏了一些传播错误的样板。",
        "translate": ""
    },
    {
        "source": "It replaces this:",
        "suggest": "它将替换为:",
        "translate": ""
    },
    {
        "source": "With this:",
        "suggest": "有了这个:",
        "translate": ""
    },
    {
        "source": "It's much nicer!",
        "suggest": "好多了!",
        "translate": ""
    },
    {
        "source": "Ending the expression with [`?`] will result in the unwrapped success ([`Ok`]) value, unless the result is [`Err`], in which case [`Err`] is returned early from the enclosing function.",
        "suggest": "用 [`?`] 结束表达式将得到未包装的成功 ([`Ok`]) 值，除非结果为 [`Err`]，在这种情况下，[`Err`] 会从封闭的函数中提前返回。",
        "translate": ""
    },
    {
        "source": "can only be used in functions that return [`Result`] because of the early return of [`Err`] that it provides.",
        "suggest": "只能在返回 [`Result`] 的函数中使用，因为它提供了 [`Err`] 的较早返回。",
        "translate": ""
    },
    {
        "source": "is a type that represents either success ([`Ok`]) or failure ([`Err`]).",
        "suggest": "是代表成功 ([`Ok`]) 或失败 ([`Err`]) 的类型。",
        "translate": ""
    },
    {
        "source": "See the [module documentation](self) for details.",
        "suggest": "有关详细信息，请参见 [module documentation](self)。",
        "translate": ""
    },
    {
        "source": "Contains the success value",
        "suggest": "包含成功值",
        "translate": ""
    },
    {
        "source": "Contains the error value",
        "suggest": "包含错误值",
        "translate": ""
    },
    {
        "source": "Returns `true` if the result is [`Ok`].",
        "suggest": "如果结果为 [`Ok`]，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the result is [`Err`].",
        "suggest": "如果结果为 [`Err`]，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the result is an [`Ok`] value containing the given value.",
        "suggest": "如果结果是包含给定值的 [`Ok`] 值，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the result is an [`Err`] value containing the given value.",
        "suggest": "如果结果是包含给定值的 [`Err`] 值，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Adapter for each variant",
        "suggest": "每个成员的适配器",
        "translate": ""
    },
    {
        "source": "Converts from `Result<T, E>` to [`Option<T>`].",
        "suggest": "从 `Result<T, E>` 转换为 [`Option<T>`]。",
        "translate": ""
    },
    {
        "source": "Converts `self` into an [`Option<T>`], consuming `self`, and discarding the error, if any.",
        "suggest": "将 `self` 转换为 [`Option<T>`]，使用 `self`，并丢弃错误 (如果有)。",
        "translate": ""
    },
    {
        "source": "Converts from `Result<T, E>` to [`Option<E>`].",
        "suggest": "从 `Result<T, E>` 转换为 [`Option<E>`]。",
        "translate": ""
    },
    {
        "source": "Converts `self` into an [`Option<E>`], consuming `self`, and discarding the success value, if any.",
        "suggest": "将 `self` 转换为 [`Option<E>`]，使用 `self`，并丢弃成功值 (如果有)。",
        "translate": ""
    },
    {
        "source": "Converts from `&Result<T, E>` to `Result<&T, &E>`.",
        "suggest": "从 `&Result<T, E>` 转换为 `Result<&T, &E>`。",
        "translate": ""
    },
    {
        "source": "Produces a new `Result`, containing a reference into the original, leaving the original in place.",
        "suggest": "产生一个新的 `Result`，其中包含对原始引用的引用，并将原始保留在原处。",
        "translate": ""
    },
    {
        "source": "Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.",
        "suggest": "从 `&mut Result<T, E>` 转换为 `Result<&mut T, &mut E>`。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained [`Ok`] value, leaving an [`Err`] value untouched.",
        "suggest": "通过对包含的 [`Ok`] 值应用函数，将 [`Err`] 值 Maps 转换为 `Result<U, E>`，而保持 [`Err`] 值不变。",
        "translate": ""
    },
    {
        "source": "This function can be used to compose the results of two functions.",
        "suggest": "该函数可用于组合两个函数的结果。",
        "translate": ""
    },
    {
        "source": "Print the numbers on each line of a string multiplied by two.",
        "suggest": "在字符串的每一行上将数字乘以 2 来打印数字。",
        "translate": ""
    },
    {
        "source": "Applies a function to the contained value (if [`Ok`]), or returns the provided default (if [`Err`]).",
        "suggest": "将函数应用于所包含的值 (如果为 [`Ok`])，或者返回提供的默认值 (如果为 [`Err`])。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `U` by applying a function to a contained [`Ok`] value, or a fallback function to a contained [`Err`] value.",
        "suggest": "通过将函数应用于所包含的 [`Ok`] 值或将回退函数应用于所包含的 [`Err`] 值，将 `Result<T, E>` 转换为 `Result<T, E>` 到 Z01X。",
        "translate": ""
    },
    {
        "source": "This function can be used to unpack a successful result while handling an error.",
        "suggest": "此函数可用于在处理错误时解压成功的结果。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained [`Err`] value, leaving an [`Ok`] value untouched.",
        "suggest": "通过对包含的 [`Err`] 值应用函数，将 [`Ok`] 值 Maps 转换为 `Result<T, F>`，而保持 [`Ok`] 值不变。",
        "translate": ""
    },
    {
        "source": "This function can be used to pass through a successful result while handling an error.",
        "suggest": "此函数可用于在处理错误时传递成功的结果。",
        "translate": ""
    },
    {
        "source": "The iterator yields one value if the result is [`Result::Ok`], otherwise none.",
        "suggest": "如果结果为 [`Result::Ok`]，则迭代器将产生一个值，否则将不产生任何值。",
        "translate": ""
    },
    {
        "source": "Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.",
        "suggest": "如果结果为 [`Ok`]，则返回 `res`; 否则，返回 `self` 的 [`Err`] 值。",
        "translate": ""
    },
    {
        "source": "Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.",
        "suggest": "如果结果为 [`Ok`]，则调用 `op`，否则返回 `self` 的 [`Err`] 值。",
        "translate": ""
    },
    {
        "source": "This function can be used for control flow based on `Result` values.",
        "suggest": "该函数可用于基于 `Result` 值的控制流。",
        "translate": ""
    },
    {
        "source": "Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.",
        "suggest": "如果结果为 [`Err`]，则返回 `res`; 否则，返回 `self` 的 [`Ok`] 值。",
        "translate": ""
    },
    {
        "source": "Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.",
        "suggest": "如果结果为 [`Err`]，则调用 `op`，否则返回 `self` 的 [`Ok`] 值。",
        "translate": ""
    },
    {
        "source": "This function can be used for control flow based on result values.",
        "suggest": "该函数可用于基于结果值的控制流。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Ok`] value or a provided default.",
        "suggest": "返回包含的 [`Ok`] 值或提供的默认值。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Ok`] value or computes it from a closure.",
        "suggest": "返回包含的 [`Ok`] 值或从闭包中计算得出。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Ok`] value, consuming the `self` value, without checking that the value is not an [`Err`].",
        "suggest": "返回包含 `self` 值的包含的 [`Ok`] 值，而不检查该值是否不是 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Calling this method on an [`Err`] is *[undefined behavior]*.",
        "suggest": "在 [`Err`] 上调用此方法是 *[undefined 行为]*。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Err`] value, consuming the `self` value, without checking that the value is not an [`Ok`].",
        "suggest": "返回包含 `self` 值的包含的 [`Err`] 值，而不检查该值是否不是 [`Ok`]。",
        "translate": ""
    },
    {
        "source": "Calling this method on an [`Ok`] is *[undefined behavior]*.",
        "suggest": "在 [`Ok`] 上调用此方法是 *[undefined 行为]*。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the `Ok` part.",
        "suggest": "通过复制 `Ok` 部件的内容，将 `Result<&T, E>` 的 Maps 转换为 `Result<T, E>`。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the `Ok` part.",
        "suggest": "通过复制 `Ok` 部件的内容，将 `Result<&mut T, E>` 的 Maps 转换为 `Result<T, E>`。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the `Ok` part.",
        "suggest": "通过克隆 `Ok` 部分的内容，将 `Result<&T, E>` Maps 转换为 `Result<T, E>`。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the `Ok` part.",
        "suggest": "通过克隆 `Ok` 部分的内容，将 `Result<&mut T, E>` Maps 转换为 `Result<T, E>`。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Ok`] value, consuming the `self` value.",
        "suggest": "返回包含 `self` 值的包含的 [`Ok`] 值。",
        "translate": ""
    },
    {
        "source": "Panics if the value is an [`Err`], with a panic message including the passed message, and the content of the [`Err`].",
        "suggest": "Panics (如果值为 [`Err`])，其中 panic 消息包括传递的消息以及 [`Err`] 的内容。",
        "translate": ""
    },
    {
        "source": "Instead, prefer to use pattern matching and handle the [`Err`] case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or [`unwrap_or_default`].",
        "suggest": "相反，更喜欢使用模式匹配并显式处理 [`Err`] 大小写，或者调用 [`unwrap_or`]，[`unwrap_or_else`] 或 [`unwrap_or_default`]。",
        "translate": ""
    },
    {
        "source": "Panics if the value is an [`Err`], with a panic message provided by the [`Err`]'s value.",
        "suggest": "如果该值为 [`Err`]，则为 Panics，并由 [`Err`] 的值提供 panic 消息。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Err`] value, consuming the `self` value.",
        "suggest": "返回包含 `self` 值的包含的 [`Err`] 值。",
        "translate": ""
    },
    {
        "source": "Panics if the value is an [`Ok`], with a panic message including the passed message, and the content of the [`Ok`].",
        "suggest": "Panics (如果值为 [`Ok`])，其中 panic 消息包括传递的消息以及 [`Ok`] 的内容。",
        "translate": ""
    },
    {
        "source": "Panics if the value is an [`Ok`], with a custom panic message provided by the [`Ok`]'s value.",
        "suggest": "Panics，如果该值为 [`Ok`]，则由 [Ok] 的值提供自定义 panic 消息。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Ok`] value or a default",
        "suggest": "返回包含的 [`Ok`] 值或默认值",
        "translate": ""
    },
    {
        "source": "Consumes the `self` argument then, if [`Ok`], returns the contained value, otherwise if [`Err`], returns the default value for that type.",
        "suggest": "然后使用 `self` 参数，如果使用 [`Ok`]，则返回包含的值，如果使用 [`Err`]，则返回该类型的默认值。",
        "translate": ""
    },
    {
        "source": "converts a string to any other type that implements [`FromStr`], returning an [`Err`] on error.",
        "suggest": "将字符串转换为实现 [`FromStr`] 的任何其他类型，并在错误时返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Ok`] value, but never panics.",
        "suggest": "返回包含的 [`Ok`] 值，但不返回 panics。",
        "translate": ""
    },
    {
        "source": "Unlike [`unwrap`], this method is known to never panic on the result types it is implemented for.",
        "suggest": "与 [`unwrap`] 不同，已知该方法永远不会对其实现的结果类型进行 panic 的处理。",
        "translate": ""
    },
    {
        "source": "Therefore, it can be used instead of `unwrap` as a maintainability safeguard that will fail to compile if the error type of the `Result` is later changed to an error that can actually occur.",
        "suggest": "因此，它可以代替 `unwrap` 用作可维护性保护措施，如果以后将 `Result` 的错误类型更改为实际可能发生的错误，它将无法编译。",
        "translate": ""
    },
    {
        "source": "Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.",
        "suggest": "从 `Result<T, E>` (或 `&Result<T, E>`) 转换为 `Result<&<T as Deref>::Target, &E>`。",
        "translate": ""
    },
    {
        "source": "Coerces the [`Ok`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref) and returns the new [`Result`].",
        "suggest": "通过 [`Deref`](crate::ops::Deref) 强制转换原始 [`Result`] 的 [`Ok`] 成员，并返回新的 [`Result`]。",
        "translate": ""
    },
    {
        "source": "Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.",
        "suggest": "从 `Result<T, E>` (或 `&mut Result<T, E>`) 转换为 `Result<&mut <T as DerefMut>::Target, &mut E>`。",
        "translate": ""
    },
    {
        "source": "Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut) and returns the new [`Result`].",
        "suggest": "通过 [`DerefMut`](crate::ops::DerefMut) 强制转换原始 [`Result`] 的 [`Ok`] 成员，并返回新的 [`Result`]。",
        "translate": ""
    },
    {
        "source": "Transposes a `Result` of an `Option` into an `Option` of a `Result`.",
        "suggest": "将 `Option` 的 `Result` 转换为 `Result` 的 `Option`。",
        "translate": ""
    },
    {
        "source": "will be mapped to `None`.",
        "suggest": "将被映射到 `None`。",
        "translate": ""
    },
    {
        "source": "and `Err(_)` will be mapped to `Some(Ok(_))` and `Some(Err(_))`.",
        "suggest": "`Err(_)` 将被映射到 `Some(Ok(_))` 和 `Some(Err(_))`。",
        "translate": ""
    },
    {
        "source": "Converts from `Result<Result<T, E>, E>` to `Result<T, E>`",
        "suggest": "从 `Result<Result<T, E>, E>` 转换为 `Result<T, E>`",
        "translate": ""
    },
    {
        "source": "Returns the [`Ok`] value if `self` is `Ok`, and the [`Err`] value if `self` is `Err`.",
        "suggest": "如果 `self` 是 `Ok`，则返回 [`Ok`] 值; 如果 `self` 是 `Err`，则返回 [`Err`] 值。",
        "translate": ""
    },
    {
        "source": "In other words, this function returns the value (the `T`) of a `Result<T, T>`, regardless of whether or not that result is `Ok` or `Err`.",
        "suggest": "换句话说，此函数返回 `Result<T, T>` 的值 (`T`)，而不管结果是 `Ok` 还是 `Err`。",
        "translate": ""
    },
    {
        "source": "This can be useful in conjunction with APIs such as [`Atomic*::compare_exchange`], or [`slice::binary_search`], but only in cases where you don't care if the result was `Ok` or not.",
        "suggest": "与 [`Atomic*::compare_exchange`] 或 [`slice::binary_search`] 等 API 结合使用时，此功能很有用，但仅在您不关心结果是否为 `Ok` 的情况下才有用。",
        "translate": ""
    },
    {
        "source": "This is a separate function to reduce the code size of the methods",
        "suggest": "这是一个单独的函数，以减少方法的代码大小",
        "translate": ""
    },
    {
        "source": "The Result Iterators",
        "suggest": "结果迭代器",
        "translate": ""
    },
    {
        "source": "An iterator over a reference to the [`Ok`] variant of a [`Result`].",
        "suggest": "[`Result`] 的 [`Ok`] 成员的引用上的迭代器。",
        "translate": ""
    },
    {
        "source": "The iterator yields one value if the result is [`Ok`], otherwise none.",
        "suggest": "如果结果为 [`Ok`]，则迭代器将产生一个值，否则将不产生任何值。",
        "translate": ""
    },
    {
        "source": "Created by [`Result::iter`].",
        "suggest": "由 [`Result::iter`] 创建。",
        "translate": ""
    },
    {
        "source": "An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].",
        "suggest": "[`Result`] 的 [`Ok`] 成员的可变引用上的迭代器。",
        "translate": ""
    },
    {
        "source": "Created by [`Result::iter_mut`].",
        "suggest": "由 [`Result::iter_mut`] 创建。",
        "translate": ""
    },
    {
        "source": "An iterator over the value in a [`Ok`] variant of a [`Result`].",
        "suggest": "[`Result`] 的 [`Ok`] 成员中的值的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`into_iter`] method on [`Result`] (provided by the [`IntoIterator`] trait).",
        "suggest": "该结构体是通过 [`Result`] (由 [`IntoIterator`] trait 提供) 上的 [`into_iter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned.",
        "suggest": "接受 `Iterator` 中的每个元素: 如果它是 `Err`，则不再获取其他元素，并返回 `Err`。",
        "translate": ""
    },
    {
        "source": "Should no `Err` occur, a container with the values of each `Result` is returned.",
        "suggest": "如果没有发生 `Err`，则返回包含每个 `Result` 值的容器。",
        "translate": ""
    },
    {
        "source": "Here is an example which increments every integer in a vector, checking for overflow:",
        "suggest": "这是一个示例，该示例将 vector 中的每个整数递增，并检查溢出:",
        "translate": ""
    },
    {
        "source": "Here is a variation on the previous example, showing that no further elements are taken from `iter` after the first `Err`.",
        "suggest": "这是前一个示例的变体，显示在第一个 `Err` 之后不再从 `iter` 提取其他元素。",
        "translate": ""
    },
    {
        "source": "Operations on ASCII `[u8]`.",
        "suggest": "在 ASCII `[u8]` 上的操作。",
        "translate": ""
    },
    {
        "source": "Checks if all bytes in this slice are within the ASCII range.",
        "suggest": "检查此切片中的所有字节是否都在 ASCII 范围内。",
        "translate": ""
    },
    {
        "source": "Checks that two slices are an ASCII case-insensitive match.",
        "suggest": "检查两个片是否是 ASCII 大小写不敏感的匹配项。",
        "translate": ""
    },
    {
        "source": "Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`, but without allocating and copying temporaries.",
        "suggest": "与 `to_ascii_lowercase(a) == to_ascii_lowercase(b)` 相同，但不分配和复制临时文件。",
        "translate": ""
    },
    {
        "source": "Converts this slice to its ASCII upper case equivalent in-place.",
        "suggest": "将该片段原位转换为其 ASCII 大写形式。",
        "translate": ""
    },
    {
        "source": "Converts this slice to its ASCII lower case equivalent in-place.",
        "suggest": "将该片段原位转换为其 ASCII 小写等效项。",
        "translate": ""
    },
    {
        "source": "Returns `true` if any byte in the word `v` is nonascii (>= 128).",
        "suggest": "如果单词 `v` 中的任何字节为 nonascii (>=128)，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Snarfed from `../str/mod.rs`, which does something similar for utf8 validation.",
        "suggest": "来自 `../str/mod.rs`，它对 utf8 验证执行类似的操作。",
        "translate": ""
    },
    {
        "source": "Optimized ASCII test that will use usize-at-a-time operations instead of byte-at-a-time operations (when possible).",
        "suggest": "优化的 ASCII 测试，将使用每次使用一次的操作，而不是一次使用字节的操作 (如果可能)。",
        "translate": ""
    },
    {
        "source": "The algorithm we use here is pretty simple.",
        "suggest": "我们在这里使用的算法非常简单。",
        "translate": ""
    },
    {
        "source": "If `s` is too short, we just check each byte and be done with it.",
        "suggest": "如果 `s` 太短，我们只检查每个字节并完成它。",
        "translate": ""
    },
    {
        "source": "Otherwise:",
        "suggest": "除此以外:",
        "translate": ""
    },
    {
        "source": "Read the first word with an unaligned load.",
        "suggest": "读取未对齐负载的第一个单词。。",
        "translate": ""
    },
    {
        "source": "Align the pointer, read subsequent words until end with aligned loads.",
        "suggest": "对齐指针，读取后续单词，直到对齐负载结束。",
        "translate": ""
    },
    {
        "source": "Read the last `usize` from `s` with an unaligned load.",
        "suggest": "从 `s` 读取未装载的最后一个 `usize`。",
        "translate": ""
    },
    {
        "source": "If any of these loads produces something for which `contains_nonascii` (above) returns true, then we know the answer is false.",
        "suggest": "如果这些负载中的任何一个产生了 `contains_nonascii` (above) 返回 true 的值，则我们知道答案为 false。",
        "translate": ""
    },
    {
        "source": "If we wouldn't gain anything from the word-at-a-time implementation, fall back to a scalar loop.",
        "suggest": "如果我们不能从一次单词的实现中获得任何收益，请回到标量循环。",
        "translate": ""
    },
    {
        "source": "We also do this for architectures where `size_of::<usize>()` isn't sufficient alignment for `usize`, because it's a weird edge case.",
        "suggest": "我们还针对 `size_of::<usize>()` 不足以与 `usize` 对齐的体系结构执行此操作，因为这是一种奇怪的 edge 情况。",
        "translate": ""
    },
    {
        "source": "We always read the first word unaligned, which means `align_offset` is",
        "suggest": "我们总是读第一个单词 unaligned，这意味着 `align_offset` 是",
        "translate": ""
    },
    {
        "source": "0, we'd read the same value again for the aligned read.",
        "suggest": "0，对于对齐的读取，我们将再次读取相同的值。",
        "translate": ""
    },
    {
        "source": "We verify `len < USIZE_SIZE` above.",
        "suggest": "我们在上面验证 `len < USIZE_SIZE`。",
        "translate": ""
    },
    {
        "source": "We checked this above, somewhat implicitly.",
        "suggest": "我们在上面对此进行了某种程度的隐式检查。",
        "translate": ""
    },
    {
        "source": "Note that `offset_to_aligned` is either `align_offset` or `USIZE_SIZE`, both of are explicitly checked above.",
        "suggest": "请注意，`offset_to_aligned` 是 `align_offset` 或 `USIZE_SIZE`，以上均已明确检查了两者。",
        "translate": ""
    },
    {
        "source": "word_ptr is the (properly aligned) usize ptr we use to read the middle chunk of the slice.",
        "suggest": "word_ptr 是 (正确对齐的) usize ptr，用于读取切片的中间块。",
        "translate": ""
    },
    {
        "source": "is the byte index of `word_ptr`, used for loop end checks.",
        "suggest": "是 `word_ptr` 的字节索引，用于循环结束检查。",
        "translate": ""
    },
    {
        "source": "Paranoia check about alignment, since we're about to do a bunch of unaligned loads.",
        "suggest": "偏执狂会检查对齐情况，因为我们将要进行一堆未对齐的负载。",
        "translate": ""
    },
    {
        "source": "In practice this should be impossible barring a bug in `align_offset` though.",
        "suggest": "实际上，除非有 `align_offset` 中的错误，否则这应该是不可能的。",
        "translate": ""
    },
    {
        "source": "Read subsequent words until the last aligned word, excluding the last aligned word by itself to be done in tail check later, to ensure that tail is always one `usize` at most to extra branch `byte_pos == len`.",
        "suggest": "读取后续的单词，直到最后一个对齐的单词为止 (不包括最后一个对齐的单词本身)，以便稍后在尾部检查中完成，以确保尾部对于额外的分支 `byte_pos == len` 始终最多为一个 `usize`。",
        "translate": ""
    },
    {
        "source": "Sanity check that the read is in bounds",
        "suggest": "完好无损的检查，以确保读取的范围",
        "translate": ""
    },
    {
        "source": "And that our assumptions about `byte_pos` hold.",
        "suggest": "并且我们关于 `byte_pos` 的假设成立。",
        "translate": ""
    },
    {
        "source": "We know `word_ptr` is properly aligned (because of `align_offset`), and we know that we have enough bytes between `word_ptr` and the end",
        "suggest": "我们知道 `word_ptr` 正确对齐 (因为 `align_offset`)，并且我们知道 `word_ptr` 和末尾之间有足够的字节",
        "translate": ""
    },
    {
        "source": "We know that `byte_pos <= len - USIZE_SIZE`, which means that after this `add`, `word_ptr` will be at most one-past-the-end.",
        "suggest": "我们知道 `byte_pos <= len - USIZE_SIZE`，这意味着在此 `add` 之后，`word_ptr` 最多只能是最后一个。",
        "translate": ""
    },
    {
        "source": "Sanity check to ensure there really is only one `usize` left.",
        "suggest": "进行健全性检查，确保仅剩 `usize` 个。",
        "translate": ""
    },
    {
        "source": "This should be guaranteed by our loop condition.",
        "suggest": "这应该由我们的循环条件来保证。",
        "translate": ""
    },
    {
        "source": "This relies on `len >= USIZE_SIZE`, which we check at the start.",
        "suggest": "这依赖于 `len >= USIZE_SIZE`，我们将在开始时对其进行检查。",
        "translate": ""
    },
    {
        "source": "Comparison traits for `[T]`.",
        "suggest": "比较 `[T]` 的 traits。",
        "translate": ""
    },
    {
        "source": "Calls implementation provided memcmp.",
        "suggest": "调用实现提供了 memcmp。",
        "translate": ""
    },
    {
        "source": "Interprets the data as u8.",
        "suggest": "将数据解释为 u8。",
        "translate": ""
    },
    {
        "source": "Returns 0 for equal, < 0 for less than and > 0 for greater than.",
        "suggest": "返回等于 0 的 < 0，小于等于 0，大于等于 0。",
        "translate": ""
    },
    {
        "source": "Return type should be c_int",
        "suggest": "返回类型应为 c_int",
        "translate": ""
    },
    {
        "source": "Implements comparison of vectors [lexicographically](Ord#lexicographical-comparison).",
        "suggest": "实现 vectors [lexicographically](Ord#lexicographical-comparison) 的比较。",
        "translate": ""
    },
    {
        "source": "intermediate trait for specialization of slice's PartialEq",
        "suggest": "专门用于切片的 PartialEq 的中间 trait",
        "translate": ""
    },
    {
        "source": "Generic slice equality",
        "suggest": "泛型切片平等",
        "translate": ""
    },
    {
        "source": "Use memcmp for bytewise equality when the types allow",
        "suggest": "当类型允许时，使用 memcmp 进行按字节相等",
        "translate": ""
    },
    {
        "source": "`self` and `other` are references and are thus guaranteed to be valid.",
        "suggest": "`self` 和 `other` 是引用，因此可以保证是有效的。",
        "translate": ""
    },
    {
        "source": "The two slices have been checked to have the same size above.",
        "suggest": "上面已经检查了两个切片的大小是否相同。",
        "translate": ""
    },
    {
        "source": "intermediate trait for specialization of slice's PartialOrd",
        "suggest": "专门用于切片 PartialOrd 的中间 trait",
        "translate": ""
    },
    {
        "source": "Slice to the loop iteration range to enable bound check elimination in the compiler",
        "suggest": "切片到循环迭代范围，以在编译器中启用边界检查消除",
        "translate": ""
    },
    {
        "source": "This is the impl that we would like to have.",
        "suggest": "这就是我们想要的暗示。",
        "translate": ""
    },
    {
        "source": "Unfortunately it's not sound.",
        "suggest": "不幸的是，这不是声音。",
        "translate": ""
    },
    {
        "source": "See `partial_ord_slice.rs`.",
        "suggest": "请参见 `partial_ord_slice.rs`。",
        "translate": ""
    },
    {
        "source": "intermediate trait for specialization of slice's Ord",
        "suggest": "用于切片 Ord 专业化的中间 trait",
        "translate": ""
    },
    {
        "source": "memcmp compares a sequence of unsigned bytes lexicographically.",
        "suggest": "memcmp 按字典顺序比较无符号字节序列。",
        "translate": ""
    },
    {
        "source": "this matches the order we want for [u8], but no others (not even [i8]).",
        "suggest": "这与我们想要的 [u8] 顺序相匹配，但没有其他顺序 (甚至 [i8] 也没有)。",
        "translate": ""
    },
    {
        "source": "`left` and `right` are references and are thus guaranteed to be valid.",
        "suggest": "`left` 和 `right` 是引用，因此可以保证是有效的。",
        "translate": ""
    },
    {
        "source": "We use the minimum of both lengths which guarantees that both regions are valid for reads in that interval.",
        "suggest": "我们使用两个长度中的最小值，以确保两个区域都适用于该时间间隔内的读取。",
        "translate": ""
    },
    {
        "source": "Trait implemented for types that can be compared for equality using their bytewise representation",
        "suggest": "Trait 为可使用其字节表示形式进行相等性比较的类型实现",
        "translate": ""
    },
    {
        "source": "`i8` and `u8` have the same memory layout, thus casting `x.as_ptr()` as `*const u8` is safe.",
        "suggest": "`i8` 和 `u8` 具有相同的内存布局，因此将 `x.as_ptr()` 强制转换为 `*const u8` 是安全的。",
        "translate": ""
    },
    {
        "source": "The `x.as_ptr()` comes from a reference and is thus guaranteed to be valid for reads for the length of the slice `x.len()`, which cannot be larger than `isize::MAX`.",
        "suggest": "`x.as_ptr()` 来自引用，因此可以保证对切片 `x.len()` 的长度有效，该长度不能大于 `isize::MAX`。",
        "translate": ""
    },
    {
        "source": "The returned slice is never mutated.",
        "suggest": "返回的切片永远不会发生可变的。",
        "translate": ""
    },
    {
        "source": "Indexing implementations for `[T]`.",
        "suggest": "`[T]` 的索引实现。",
        "translate": ""
    },
    {
        "source": "A helper trait used for indexing operations.",
        "suggest": "帮助程序 trait 用于索引操作。",
        "translate": ""
    },
    {
        "source": "Implementations of this trait have to promise that if the argument to `get_(mut_)unchecked` is a safe reference, then so is the result.",
        "suggest": "trait 的实现必须针对 promise，如果 `get_(mut_)unchecked` 的参数是安全引用，则结果也是如此。",
        "translate": ""
    },
    {
        "source": "The output type returned by methods.",
        "suggest": "方法返回的输出类型。",
        "translate": ""
    },
    {
        "source": "Returns a shared reference to the output at this location, if in bounds.",
        "suggest": "如果在边界内，则返回此位置输出的共享引用。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to the output at this location, if in bounds.",
        "suggest": "如果在边界内，则对此位置的输出返回一个可变引用。",
        "translate": ""
    },
    {
        "source": "Returns a shared reference to the output at this location, without performing any bounds checking.",
        "suggest": "返回此位置输出的共享引用，而不执行任何边界检查。",
        "translate": ""
    },
    {
        "source": "Calling this method with an out-of-bounds index or a dangling `slice` pointer is *[undefined behavior]* even if the resulting reference is not used.",
        "suggest": "即使未使用所得的引用，使用越界索引或悬空的 `slice` 指针调用此方法也是 *[undefined 行为]*。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to the output at this location, without performing any bounds checking.",
        "suggest": "返回此位置输出的变量引用，而不执行任何边界检查。",
        "translate": ""
    },
    {
        "source": "Returns a shared reference to the output at this location, panicking if out of bounds.",
        "suggest": "返回此位置输出的共享引用，如果越界则会触发 panic。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to the output at this location, panicking if out of bounds.",
        "suggest": "返回此位置输出的变量引用，如果越界则会触发 panic。",
        "translate": ""
    },
    {
        "source": "`self` is checked to be in bounds.",
        "suggest": "`self` 已检查在范围之内。",
        "translate": ""
    },
    {
        "source": "the caller guarantees that `slice` is not dangling, so it cannot be longer than `isize::MAX`.",
        "suggest": "调用者保证 `slice` 不悬空，因此长度不能超过 `isize::MAX`。",
        "translate": ""
    },
    {
        "source": "They also guarantee that `self` is in bounds of `slice` so `self` cannot overflow an `isize`, so the call to `add` is safe.",
        "suggest": "它们还保证 `self` 在 `slice` 的范围内，因此 `self` 不会溢出 `isize`，因此调用 `add` 是安全的。",
        "translate": ""
    },
    {
        "source": "see comments for `get_unchecked` above.",
        "suggest": "请参见上面的 `get_unchecked` 注释。",
        "translate": ""
    },
    {
        "source": "N.B., use intrinsic indexing",
        "suggest": "注意，使用内在索引",
        "translate": ""
    },
    {
        "source": "`self` is checked to be valid and in bounds above.",
        "suggest": "`self` 已被检查为有效且在上面的范围内。",
        "translate": ""
    },
    {
        "source": "the caller has to uphold the safety contract for `get_unchecked`.",
        "suggest": "调用者必须维护 `get_unchecked` 的安全保证。",
        "translate": ""
    },
    {
        "source": "the caller has to uphold the safety contract for `get_unchecked_mut`.",
        "suggest": "调用者必须维护 `get_unchecked_mut` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Performs bounds-checking of a range.",
        "suggest": "执行范围的边界检查。",
        "translate": ""
    },
    {
        "source": "This method is similar to [`Index::index`] for slices, but it returns a [`Range`] equivalent to `range`.",
        "suggest": "对于切片，此方法类似于 [`Index::index`]，但是它返回的 [`Range`] 等效于 `range`。",
        "translate": ""
    },
    {
        "source": "You can use this method to turn any range into `start` and `end` values.",
        "suggest": "您可以使用此方法将任何范围转换为 `start` 和 `end` 值。",
        "translate": ""
    },
    {
        "source": "is the range of the slice to use for bounds-checking.",
        "suggest": "是用于边界检查的切片的范围。",
        "translate": ""
    },
    {
        "source": "It should be a [`RangeTo`] range that ends at the length of the slice.",
        "suggest": "它应该是 [`RangeTo`] 范围，以切片的长度结尾。",
        "translate": ""
    },
    {
        "source": "The returned [`Range`] is safe to pass to [`slice::get_unchecked`] and [`slice::get_unchecked_mut`] for slices with the given range.",
        "suggest": "对于给定范围的切片，返回的 [`Range`] 可以安全地传递到 [`slice::get_unchecked`] 和 [`slice::get_unchecked_mut`]。",
        "translate": ""
    },
    {
        "source": "Panics if `range` would be out of bounds.",
        "suggest": "如果 `range` 越界，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Panics when [`Index::index`] would panic:",
        "suggest": "当 [`Index::index`] 将为 panic 时为 Panics:",
        "translate": ""
    },
    {
        "source": "Macros used by iterators of slice.",
        "suggest": "切片的迭代器使用的宏。",
        "translate": ""
    },
    {
        "source": "Inlining is_empty and len makes a huge performance difference",
        "suggest": "内联 is_empty 和 len 会产生巨大的性能差异",
        "translate": ""
    },
    {
        "source": "The way we encode the length of a ZST iterator, this works both for ZST and non-ZST.",
        "suggest": "我们对 ZST 迭代器的长度进行编码的方式，这对 ZST 和非 ZST 均有效。",
        "translate": ""
    },
    {
        "source": "To get rid of some bounds checks (see `position`), we compute the length in a somewhat unexpected way.",
        "suggest": "为了摆脱某些边界检查 (请参见 `position`)，我们以某种出乎意料的方式来计算长度。",
        "translate": ""
    },
    {
        "source": "(Tested by `codegen/slice-position-bounds-check`.)",
        "suggest": "(通过 `codegen/slice-position-bounds-check` 测试。)",
        "translate": ""
    },
    {
        "source": "we're sometimes used within an unsafe block",
        "suggest": "我们有时会在不安全的区域内使用",
        "translate": ""
    },
    {
        "source": "This _cannot_ use `unchecked_sub` because we depend on wrapping to represent the length of long ZST slice iterators.",
        "suggest": "该 _cannot_ 使用 `unchecked_sub`，因为我们依靠包装来表示长 ZST 切片迭代器的长度。",
        "translate": ""
    },
    {
        "source": "We know that `start <= end`, so can do better than `offset_from`, which needs to deal in signed.",
        "suggest": "我们知道 `start <= end` 可以比需要签名处理的 `offset_from` 做得更好。",
        "translate": ""
    },
    {
        "source": "By setting appropriate flags here we can tell LLVM this, which helps it remove bounds checks.",
        "suggest": "通过在此处设置适当的标志，我们可以告诉 LLVM，这有助于消除边界检查。",
        "translate": ""
    },
    {
        "source": "By the type invariant,",
        "suggest": "通过类型不变，",
        "translate": ""
    },
    {
        "source": "By also telling LLVM that the pointers are apart by an exact multiple of the type size, it can optimize `len() == 0` down to `start == end` instead of `(end - start) < size`.",
        "suggest": "通过还告诉 LLVM 指针相隔一个类型大小的精确倍数，它可以将 `len() == 0` 优化到 `start == end`，而不是 `(end - start) < size`。",
        "translate": ""
    },
    {
        "source": "By the type invariant, the pointers are aligned so the distance between them must be a multiple of pointee size",
        "suggest": "通过类型不变，指针将对齐，因此它们之间的距离必须是指针大小的倍数",
        "translate": ""
    },
    {
        "source": "The shared definition of the `Iter` and `IterMut` iterators",
        "suggest": "`Iter` 和 `IterMut` 迭代器的共享定义",
        "translate": ""
    },
    {
        "source": "Returns the first element and moves the start of the iterator forwards by 1.",
        "suggest": "返回第一个元素，并将迭代器的开始向前移动 1。",
        "translate": ""
    },
    {
        "source": "Greatly improves performance compared to an inlined function.",
        "suggest": "与内联函数相比，极大地提高了性能。",
        "translate": ""
    },
    {
        "source": "The iterator must not be empty.",
        "suggest": "迭代器不能为空。",
        "translate": ""
    },
    {
        "source": "Returns the last element and moves the end of the iterator backwards by 1.",
        "suggest": "返回最后一个元素，并将迭代器的末尾向后移动 1。",
        "translate": ""
    },
    {
        "source": "Shrinks the iterator when T is a ZST, by moving the end of the iterator backwards by `n`.",
        "suggest": "当 T 为 ZST 时，通过将迭代器的末尾向后移动 `n` 来缩小迭代器。",
        "translate": ""
    },
    {
        "source": "must not exceed `self.len()`.",
        "suggest": "不得超过 `self.len()`。",
        "translate": ""
    },
    {
        "source": "Helper function for creating a slice from the iterator.",
        "suggest": "用于从迭代器创建切片的 Helper 函数。",
        "translate": ""
    },
    {
        "source": "the iterator was created from a slice with pointer `self.ptr` and length `len!(self)`.",
        "suggest": "迭代器是从具有指针 `self.ptr` 和长度 `len!(self)` 的切片创建的。",
        "translate": ""
    },
    {
        "source": "This guarantees that all the prerequisites for `from_raw_parts` are fulfilled.",
        "suggest": "这样可以保证满足 `from_raw_parts` 的所有先决条件。",
        "translate": ""
    },
    {
        "source": "Helper function for moving the start of the iterator forwards by `offset` elements, returning the old start.",
        "suggest": "Helper 函数，用于通过 `offset` 元素向前移动迭代器的开始，并返回旧的开始。",
        "translate": ""
    },
    {
        "source": "Unsafe because the offset must not exceed `self.len()`.",
        "suggest": "不安全，因为偏移不得超过 `self.len()`。",
        "translate": ""
    },
    {
        "source": "the caller guarantees that `offset` doesn't exceed `self.len()`, so this new pointer is inside `self` and thus guaranteed to be non-null.",
        "suggest": "调用者保证 `offset` 不超过 `self.len()`，因此此新指针位于 `self` 内，因此保证为非空。",
        "translate": ""
    },
    {
        "source": "Helper function for moving the end of the iterator backwards by `offset` elements, returning the new end.",
        "suggest": "Helper 函数，用于通过 `offset` 元素向后移动迭代器的末尾，并返回新的末尾。",
        "translate": ""
    },
    {
        "source": "the caller guarantees that `offset` doesn't exceed `self.len()`, which is guaranteed to not overflow an `isize`.",
        "suggest": "调用者保证 `offset` 不超过 `self.len()`，这保证不会溢出 `isize`。",
        "translate": ""
    },
    {
        "source": "Also, the resulting pointer is in bounds of `slice`, which fulfills the other requirements for `offset`.",
        "suggest": "同样，结果指针位于 `slice` 的范围内，这满足了 `offset` 的其他要求。",
        "translate": ""
    },
    {
        "source": "could be implemented with slices, but this avoids bounds checks",
        "suggest": "可以用切片实现，但这避免了边界检查",
        "translate": ""
    },
    {
        "source": "`assume` calls are safe since a slice's start pointer must be non-null, and slices over non-ZSTs must also have a non-null end pointer.",
        "suggest": "`assume` 调用是安全的，因为切片的开始指针必须为非空，并且非 ZST 上的切片也必须具有非空的结束指针。",
        "translate": ""
    },
    {
        "source": "The call to `next_unchecked!` is safe since we check if the iterator is empty first.",
        "suggest": "`next_unchecked!` 的调用是安全的，因为我们先检查迭代器是否为空。",
        "translate": ""
    },
    {
        "source": "This iterator is now empty.",
        "suggest": "该迭代器现在为空。",
        "translate": ""
    },
    {
        "source": "We have to do it this way as `ptr` may never be 0, but `end` could be (due to wrapping).",
        "suggest": "我们必须这样做，因为 `ptr` 可能永远不会为 0，但 `end` 可能是 (由于包装)。",
        "translate": ""
    },
    {
        "source": "end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr",
        "suggest": "如果 T 不是 ZST，则 end 不能为 0，因为 ptr 不为 0 并且 end>=ptr",
        "translate": ""
    },
    {
        "source": "We are in bounds.",
        "suggest": "我们无所适从。",
        "translate": ""
    },
    {
        "source": "`post_inc_start` does the right thing even for ZSTs.",
        "suggest": "`post_inc_start` 甚至对 ZST 来说也做对了。",
        "translate": ""
    },
    {
        "source": "We override the default implementation, which uses `try_fold`, because this simple implementation generates less LLVM IR and is faster to compile.",
        "suggest": "我们覆盖了使用 `try_fold` 的默认实现，因为此简单实现生成的 LLVM IR 更少，并且编译速度更快。",
        "translate": ""
    },
    {
        "source": "Also, the `assume` avoids a bounds check.",
        "suggest": "另外，`assume` 避免了边界检查。",
        "translate": ""
    },
    {
        "source": "we are guaranteed to be in bounds by the loop invariant:",
        "suggest": "通过循环不变性，我们可以保证处于一定范围内:",
        "translate": ""
    },
    {
        "source": "when `i >= n`, `self.next()` returns `None` and the loop breaks.",
        "suggest": "当 `i >= n` 时，`self.next()` 返回 `None`，循环中断。",
        "translate": ""
    },
    {
        "source": "`i` must be lower than `n` since it starts at `n` and is only decreasing.",
        "suggest": "`i` 必须低于 `n`，因为它始于 `n`，并且仅在减小。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `i` is in bounds of the underlying slice, so `i` cannot overflow an `isize`, and the returned references is guaranteed to refer to an element of the slice and thus guaranteed to be valid.",
        "suggest": "调用者必须保证 `i` 在基础切片的范围内，因此 `i` 不会溢出 `isize`，并且返回的引言保证引用了切片的元素，因此保证是有效的。",
        "translate": ""
    },
    {
        "source": "Also note that the caller also guarantees that we're never called with the same index again, and that no other methods that will access this subslice are called, so it is valid for the returned reference to be mutable in the case of",
        "suggest": "还要注意，调用者还保证不会再使用相同的索引来调用我们，并且不会调用将访问此子片段的其他方法，因此对于返回的引用，在以下情况下是可变的是有效的",
        "translate": ""
    },
    {
        "source": "The call to `next_back_unchecked!` is safe since we check if the iterator is empty first.",
        "suggest": "`next_back_unchecked!` 的调用是安全的，因为我们先检查迭代器是否为空。",
        "translate": ""
    },
    {
        "source": "First, we declare a type which has `iter` method to get the `Iter` struct (`&[usize]` here):",
        "suggest": "首先，我们声明一个具有 `iter` 方法的类型以获取 `Iter` 结构体 (此处为 `&[usize]`) :",
        "translate": ""
    },
    {
        "source": "Then, we iterate over it:",
        "suggest": "然后，我们对其进行迭代:",
        "translate": ""
    },
    {
        "source": "First, we declare a type which has the `iter` method to get the `Iter` struct (`&[usize]` here):",
        "suggest": "首先，我们声明一个具有 `iter` 方法的类型以获取 `Iter` 结构体 (此处为 `&[usize]`) :",
        "translate": ""
    },
    {
        "source": "Then, we get the iterator:",
        "suggest": "然后，我们得到迭代器:",
        "translate": ""
    },
    {
        "source": "So if we print what `as_slice` method returns here, we have \"[1, 2, 3]\":",
        "suggest": "因此，如果我们在此处打印 `as_slice` 方法返回的内容，则得到 \"[1, 2, 3]\":",
        "translate": ""
    },
    {
        "source": "Next, we move to the second element of the slice:",
        "suggest": "接下来，我们转到切片的第二个元素:",
        "translate": ""
    },
    {
        "source": "Now `as_slice` returns \"[2, 3]\":",
        "suggest": "现在 `as_slice` 返回 \"[2, 3]\":",
        "translate": ""
    },
    {
        "source": "First, we declare a type which has `iter_mut` method to get the `IterMut` struct (`&[usize]` here):",
        "suggest": "首先，我们声明一个具有 `iter_mut` 方法的类型以获取 `IterMut` 结构体 (此处为 `&[usize]`) :",
        "translate": ""
    },
    {
        "source": "Then, we iterate over it and increment each element value:",
        "suggest": "然后，我们对其进行迭代并增加每个元素的值:",
        "translate": ""
    },
    {
        "source": "We now have \"[2, 3, 4]\":",
        "suggest": "现在，我们有了 \"[2, 3, 4]\":",
        "translate": ""
    },
    {
        "source": "We move to next element:",
        "suggest": "我们转到下一个元素:",
        "translate": ""
    },
    {
        "source": "So if we print what `into_slice` method returns here, we have \"[2, 3]\":",
        "suggest": "因此，如果我们在此处打印 `into_slice` 方法返回的内容，则得到 \"[2, 3]\":",
        "translate": ""
    },
    {
        "source": "Now let's modify a value of the slice:",
        "suggest": "现在，让我们修改切片的值:",
        "translate": ""
    },
    {
        "source": "First we get back the iterator:",
        "suggest": "首先，我们返回迭代器:",
        "translate": ""
    },
    {
        "source": "We change the value of the first element of the slice returned by the `next` method:",
        "suggest": "我们更改 `next` 方法返回的切片的第一个元素的值:",
        "translate": ""
    },
    {
        "source": "Now slice is \"[2, 2, 3]\":",
        "suggest": "现在切片是 \"[2, 2, 3]\":",
        "translate": ""
    },
    {
        "source": "First, we get the iterator:",
        "suggest": "首先，我们得到迭代器:",
        "translate": ""
    },
    {
        "source": "So if we check what the `as_slice` method returns here, we have \"[1, 2, 3]\":",
        "suggest": "因此，如果我们检查 `as_slice` 方法在这里返回的内容，则得到 \"[1, 2, 3]\":",
        "translate": ""
    },
    {
        "source": "Definitions of a bunch of iterators for `[T]`.",
        "suggest": "一堆 `[T]` 迭代器的定义。",
        "translate": ""
    },
    {
        "source": "import iterator!",
        "suggest": "导入迭代器!",
        "translate": ""
    },
    {
        "source": "and forward_iterator!",
        "suggest": "和 forward_iterator!",
        "translate": ""
    },
    {
        "source": "Macro helper functions",
        "suggest": "宏 helper 函数",
        "translate": ""
    },
    {
        "source": "Immutable slice iterator",
        "suggest": "不可变切片迭代器",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`iter`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`iter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "If T is a ZST, this is actually ptr+len.",
        "suggest": "如果 T 是 ZST，则实际上是 ptr + len。",
        "translate": ""
    },
    {
        "source": "This encoding is picked so that",
        "suggest": "选择此编码，以便",
        "translate": ""
    },
    {
        "source": "ptr == end is a quick test for the Iterator being empty, that works for both ZST and non-ZST.",
        "suggest": "ptr == end 是对 Iterator 为空的快速测试，适用于 ZST 和非 ZST。",
        "translate": ""
    },
    {
        "source": "Similar to `IterMut::new`.",
        "suggest": "类似于 `IterMut::new`。",
        "translate": ""
    },
    {
        "source": "Views the underlying data as a subslice of the original data.",
        "suggest": "将基础数据视为原始数据的子切片。",
        "translate": ""
    },
    {
        "source": "This has the same lifetime as the original slice, and so the iterator can continue to be used while this exists.",
        "suggest": "它具有与原始切片相同的生命周期，因此迭代器可以在存在时继续使用。",
        "translate": ""
    },
    {
        "source": "Mutable slice iterator.",
        "suggest": "可变切片迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`iter_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`iter_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "There are several things here:",
        "suggest": "这里有几件事:",
        "translate": ""
    },
    {
        "source": "has been obtained by `slice.as_ptr()` where `slice` is a valid reference thus it is non-NUL and safe to use and pass to `NonNull::new_unchecked` .",
        "suggest": "由 `slice.as_ptr()` 获得，其中 `slice` 是有效的引用，因此它是非 NUL 且使用安全并传递给 `NonNull::new_unchecked`。",
        "translate": ""
    },
    {
        "source": "Adding `slice.len()` to the starting pointer gives a pointer at the end of `slice`.",
        "suggest": "将 `slice.len()` 添加到起始指针会在 `slice` 的末尾提供一个指针。",
        "translate": ""
    },
    {
        "source": "will never be dereferenced, only checked for direct pointer equality with `ptr` to check if the iterator is done.",
        "suggest": "永远不会被解引用，仅使用 `ptr` 检查直接指针是否相等，以检查迭代器是否完成。",
        "translate": ""
    },
    {
        "source": "In the case of a ZST, the end pointer is just the start pointer plus the length, to also allows for the fast `ptr == end` check.",
        "suggest": "在使用 ZST 的情况下，结束指针只是开始指针加长度，也可以进行快速 `ptr == end` 检查。",
        "translate": ""
    },
    {
        "source": "See the `next_unchecked!` and `is_empty!` macros as well as the `post_inc_start` method for more informations.",
        "suggest": "有关更多信息，请参见 `next_unchecked!` 和 `is_empty!` 宏以及 `post_inc_start` 方法。",
        "translate": ""
    },
    {
        "source": "To avoid creating `&mut` references that alias, this is forced to consume the iterator.",
        "suggest": "为避免创建 `&mut` 引用该别名，将强制使用该迭代器。",
        "translate": ""
    },
    {
        "source": "the iterator was created from a mutable slice with pointer `self.ptr` and length `len!(self)`.",
        "suggest": "迭代器是根据具有指针 `self.ptr` 和长度 `len!(self)` 的可变切片创建的。",
        "translate": ""
    },
    {
        "source": "This guarantees that all the prerequisites for `from_raw_parts_mut` are fulfilled.",
        "suggest": "这样可以保证满足 `from_raw_parts_mut` 的所有先决条件。",
        "translate": ""
    },
    {
        "source": "To avoid creating `&mut [T]` references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.",
        "suggest": "为了避免创建 `&mut [T]` 引用该别名，返回的切片借用了应用了该方法的迭代器的生命周期。",
        "translate": ""
    },
    {
        "source": "An internal abstraction over the splitting iterators, so that splitn, splitn_mut etc can be implemented once.",
        "suggest": "拆分迭代器的内部抽象，因此 splitn，splitn_mut 等可以实现一次。",
        "translate": ""
    },
    {
        "source": "Marks the underlying iterator as complete, extracting the remaining portion of the slice.",
        "suggest": "将基础迭代器标记为完成，提取切片的其余部分。",
        "translate": ""
    },
    {
        "source": "An iterator over subslices separated by elements that match a predicate function.",
        "suggest": "在子切片上进行迭代的迭代器，这些子切片由与谓词函数匹配的元素分隔。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`split`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`split`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Used for `SplitAsciiWhitespace` `as_str` method",
        "suggest": "用于 `SplitAsciiWhitespace` `as_str` 方法",
        "translate": ""
    },
    {
        "source": "Unlike `Split`, it contains the matched part as a terminator of the subslice.",
        "suggest": "与 `Split` 不同，它包含匹配的部分作为子切片的终止符。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`split_inclusive`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`split_inclusive`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "The last index of self.v is already checked and found to match by the last iteration, so we start searching a new match one index to the left.",
        "suggest": "self.v 的最后一个索引已经过检查，并在上一次迭代中找到了匹配项，因此我们开始在左侧搜索一个新的匹配项。",
        "translate": ""
    },
    {
        "source": "An iterator over the mutable subslices of the vector which are separated by elements that match `pred`.",
        "suggest": "vector 的可变子片段上的迭代器，该子片段由与 `pred` 匹配的元素分隔。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`split_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`split_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "work around borrowck limitations",
        "suggest": "克服 rowck 限制",
        "translate": ""
    },
    {
        "source": "if the predicate doesn't match anything, we yield one slice if it matches every element, we yield len+1 empty slices.",
        "suggest": "如果谓词不匹配任何内容，则产生一个切片，如果它匹配每个元素，则产生 len + 1 个空切片。",
        "translate": ""
    },
    {
        "source": "Unlike `SplitMut`, it contains the matched parts in the ends of the subslices.",
        "suggest": "与 `SplitMut` 不同，它在子切片的末尾包含匹配的部分。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`split_inclusive_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`split_inclusive_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.",
        "suggest": "从切片的末尾开始，由与谓词函数匹配的元素分隔的子切片上的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rsplit`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rsplit`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Is this correct, or does it incorrectly require `T: Clone`?",
        "suggest": "这是正确的，还是不正确地要求使用 `T: Clone`?",
        "translate": ""
    },
    {
        "source": "An iterator over the subslices of the vector which are separated by elements that match `pred`, starting from the end of the slice.",
        "suggest": "vector 的子切片上的迭代器，该迭代器由与 `pred` 匹配的元素分隔，从切片的末尾开始。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rsplit_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rsplit_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An private iterator over subslices separated by elements that match a predicate function, splitting at most a fixed number of times.",
        "suggest": "在由与谓词函数匹配的元素分隔的子片段上的私有迭代器，最多分裂固定次数。",
        "translate": ""
    },
    {
        "source": "An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.",
        "suggest": "在子切片上进行迭代的迭代器，这些子切片由与谓词函数匹配的元素分隔，限于给定的拆分数。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`splitn`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`splitn`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.",
        "suggest": "在子切片上进行迭代的迭代器，这些子切片由与谓词函数匹配的元素分隔，从切片的末尾开始，并限于给定的拆分数。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rsplitn`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rsplitn`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`splitn_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`splitn_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rsplitn_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rsplitn_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator over overlapping subslices of length `size`.",
        "suggest": "长度为 `size` 的重叠子切片上的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`windows`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`windows`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "since the caller guarantees that `i` is in bounds, which means that `i` cannot overflow an `isize`, and the slice created by `from_raw_parts` is a subslice of `self.v` thus is guaranteed to be valid for the lifetime `'a` of `self.v`.",
        "suggest": "因为调用者保证 `i` 在范围之内，这意味着 `i` 不会溢出 `isize`，并且 `from_raw_parts` 创建的切片是 `self.v` 的子切片，因此可以保证对于 `self.v` 的生命周期 `'a` 有效。",
        "translate": ""
    },
    {
        "source": "An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a time), starting at the beginning of the slice.",
        "suggest": "在 (non-overlapping) 块 (一次 `chunk_size` 元素) 中的切片上进行迭代，从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.",
        "suggest": "当切片 len 不均匀地除以块大小时，迭代的最后一个切片将是余数。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`chunks`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`chunks`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "the caller guarantees that `i` is in bounds, which means that `start` must be in bounds of the underlying `self.v` slice, and we made sure that `end` is also in bounds of `self.v`.",
        "suggest": "调用者保证 `i` 在边界内，这意味着 `start` 必须在基础 `self.v` 切片的边界内，并且我们确保 `end` 也在 `self.v` 的边界内。",
        "translate": ""
    },
    {
        "source": "Thus, `start` cannot overflow an `isize`, and the slice constructed by `from_raw_parts` is a subslice of `self.v` which is guaranteed to be valid for the lifetime `'a` of `self.v`.",
        "suggest": "因此，`start` 不会溢出 `isize`，并且 `from_raw_parts` 构造的切片是 `self.v` 的子切片，保证对 `self.v` 的生命周期 `'a` 有效。",
        "translate": ""
    },
    {
        "source": "An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size` elements at a time), starting at the beginning of the slice.",
        "suggest": "在 (non-overlapping) 可变块 (一次 `chunk_size` 元素) 中的切片上进行迭代，从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`chunks_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`chunks_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "see comments for `Chunks::__iterator_get_unchecked`.",
        "suggest": "请参见 `Chunks::__iterator_get_unchecked` 的注释。",
        "translate": ""
    },
    {
        "source": "Also note that the caller also guarantees that we're never called with the same index again, and that no other methods that will access this subslice are called, so it is valid for the returned slice to be mutable.",
        "suggest": "还要注意，调用者还保证不会再使用相同的索引来调用我们，并且不会调用将访问此子片段的其他方法，因此对于返回的切片可变是有效的。",
        "translate": ""
    },
    {
        "source": "When the slice len is not evenly divided by the chunk size, the last up to `chunk_size-1` elements will be omitted but can be retrieved from the [`remainder`] function from the iterator.",
        "suggest": "当切片 len 不均匀地除以块大小时，最后 `chunk_size-1` 个元素将被省略，但可以从迭代器的 [`remainder`] 函数中检索。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`chunks_exact`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`chunks_exact`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "0 <= fst_len <= slice.len() by construction above",
        "suggest": "0 <= fst_len <= slice.len()，通过上面的构造",
        "translate": ""
    },
    {
        "source": "Returns the remainder of the original slice that is not going to be returned by the iterator.",
        "suggest": "返回迭代器将不会返回的原始切片的其余部分。",
        "translate": ""
    },
    {
        "source": "The returned slice has at most `chunk_size-1` elements.",
        "suggest": "返回的切片最多包含 `chunk_size-1` 个元素。",
        "translate": ""
    },
    {
        "source": "mostly identical to `Chunks::__iterator_get_unchecked`.",
        "suggest": "与 `Chunks::__iterator_get_unchecked` 大致相同。",
        "translate": ""
    },
    {
        "source": "When the slice len is not evenly divided by the chunk size, the last up to `chunk_size-1` elements will be omitted but can be retrieved from the [`into_remainder`] function from the iterator.",
        "suggest": "当切片 len 不均匀地除以块大小时，最后 `chunk_size-1` 个元素将被省略，但可以从迭代器的 [`into_remainder`] 函数中检索。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`chunks_exact_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`chunks_exact_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "see comments for `ChunksMut::__iterator_get_unchecked`.",
        "suggest": "请参见 `ChunksMut::__iterator_get_unchecked` 的注释。",
        "translate": ""
    },
    {
        "source": "A windowed iterator over a slice in overlapping chunks (`N` elements at a time), starting at the beginning of the slice",
        "suggest": "在切片上以重叠块 (一次 `N` 个元素) 的方式在切片上进行窗口化的迭代器，从切片的开头开始",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`array_windows`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`array_windows`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "This is safe because it's indexing into a slice guaranteed to be length > N.",
        "suggest": "这是安全的，因为它被索引到保证长度 > N 的切片中。",
        "translate": ""
    },
    {
        "source": "Guaranteed that there are at least 1 item remaining otherwise earlier branch would've been hit",
        "suggest": "保证至少剩余 1 个项目，否则会打到较早的分支",
        "translate": ""
    },
    {
        "source": "Guaranteed that there are at least n items remaining",
        "suggest": "保证至少剩余 n 项",
        "translate": ""
    },
    {
        "source": "Guaranteed that there are n items remaining, n-1 for 0-indexing.",
        "suggest": "保证剩余 n 项，n-1 用于 0 索引。",
        "translate": ""
    },
    {
        "source": "An iterator over a slice in (non-overlapping) chunks (`N` elements at a time), starting at the beginning of the slice.",
        "suggest": "在 (non-overlapping) 块 (一次 `N` 元素) 中的切片上进行迭代，从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "When the slice len is not evenly divided by the chunk size, the last up to `N-1` elements will be omitted but can be retrieved from the [`remainder`] function from the iterator.",
        "suggest": "当切片 len 不均匀地除以块大小时，最后 `N-1` 个元素将被省略，但可以从迭代器的 [`remainder`] 函数中检索。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`array_chunks`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`array_chunks`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "The returned slice has at most `N-1` elements.",
        "suggest": "返回的切片最多包含 `N-1` 个元素。",
        "translate": ""
    },
    {
        "source": "The safety guarantees of `__iterator_get_unchecked` are transferred to the caller.",
        "suggest": "`__iterator_get_unchecked` 的安全保证已转移到调用者。",
        "translate": ""
    },
    {
        "source": "An iterator over a slice in (non-overlapping) mutable chunks (`N` elements at a time), starting at the beginning of the slice.",
        "suggest": "在 (non-overlapping) 可变块 (一次 `N` 元素) 中的切片上进行迭代，从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "When the slice len is not evenly divided by the chunk size, the last up to `N-1` elements will be omitted but can be retrieved from the [`into_remainder`] function from the iterator.",
        "suggest": "当切片 len 不均匀地除以块大小时，最后 `N-1` 个元素将被省略，但可以从迭代器的 [`into_remainder`] 函数中检索。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`array_chunks_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`array_chunks_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a time), starting at the end of the slice.",
        "suggest": "在 (non-overlapping) 块 (一次 `chunk_size` 元素) 中的切片上进行迭代，从切片的末尾开始。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rchunks`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rchunks`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Can't underflow because of the check above",
        "suggest": "由于上述检查而无法下溢",
        "translate": ""
    },
    {
        "source": "can't underflow because `n < len`",
        "suggest": "`n < len` 无法下溢",
        "translate": ""
    },
    {
        "source": "An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size` elements at a time), starting at the end of the slice.",
        "suggest": "从切片末尾开始，在 (non-overlapping) 可变块 (一次 `chunk_size` 个元素) 中的切片上进行迭代。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rchunks_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rchunks_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "see comments for `RChunks::__iterator_get_unchecked` and",
        "suggest": "查看 `RChunks::__iterator_get_unchecked` 和",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rchunks_exact`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rchunks_exact`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "0 <= rem <= slice.len() by construction above",
        "suggest": "0 <= rem <= slice.len() 以上构造",
        "translate": ""
    },
    {
        "source": "mostmy identical to `Chunks::__iterator_get_unchecked`.",
        "suggest": "最与 `Chunks::__iterator_get_unchecked` 相同。",
        "translate": ""
    },
    {
        "source": "now that we know that `n` corresponds to a chunk, none of these operations can underflow/overflow",
        "suggest": "现在我们知道 `n` 对应于一个块，underflow/overflow 这些操作都不能",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`rchunks_exact_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`rchunks_exact_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "see comments for `RChunksMut::__iterator_get_unchecked`.",
        "suggest": "请参见 `RChunksMut::__iterator_get_unchecked` 的注释。",
        "translate": ""
    },
    {
        "source": "An iterator over slice in (non-overlapping) chunks separated by a predicate.",
        "suggest": "(non-overlapping) 块中由谓词分隔的切片上的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`group_by`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`group_by`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator over slice in (non-overlapping) mutable chunks separated by a predicate.",
        "suggest": "在 (non-overlapping) 可变块中由谓词分隔的切片上的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by the [`group_by_mut`] method on [slices].",
        "suggest": "该结构体是通过 [slices] 上的 [`group_by_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Original implementation taken from rust-memchr.",
        "suggest": "原始实现来自 rust-memchr。",
        "translate": ""
    },
    {
        "source": "Copyright 2015 Andrew Gallant, bluss and Nicolas Koch",
        "suggest": "版权所有 2015 Andrew Gallant，bluss 和 Nicolas Koch",
        "translate": ""
    },
    {
        "source": "Use truncation.",
        "suggest": "使用截断。",
        "translate": ""
    },
    {
        "source": "Returns `true` if `x` contains any zero byte.",
        "suggest": "如果 `x` 包含任何零字节，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "From *Matters Computational*, J.",
        "suggest": "从 *Matters 计算*，J.",
        "translate": ""
    },
    {
        "source": "\"The idea is to subtract one from each of the bytes and then look for bytes where the borrow propagated all the way to the most significant",
        "suggest": "` 这个想法是从每个字节中减去一个，然后寻找借用一直传播到最高有效位的字节。",
        "translate": ""
    },
    {
        "source": "Returns the first index matching the byte `x` in `text`.",
        "suggest": "返回与 `text` 中的字节 `x` 匹配的第一个索引。",
        "translate": ""
    },
    {
        "source": "Fast path for small slices",
        "suggest": "小切片的快速路径",
        "translate": ""
    },
    {
        "source": "Scan for a single byte value by reading two `usize` words at a time.",
        "suggest": "通过一次读取两个 `usize` 字来扫描单个字节值。",
        "translate": ""
    },
    {
        "source": "Split `text` in three parts",
        "suggest": "将 `text` 分为三部分",
        "translate": ""
    },
    {
        "source": "unaligned initial part, before the first word aligned address in text",
        "suggest": "未对齐的初始部分，在文本中第一个单词对齐的地址之前",
        "translate": ""
    },
    {
        "source": "body, scan by 2 words at a time",
        "suggest": "身体，一次扫描 2 个字",
        "translate": ""
    },
    {
        "source": "the last remaining part, < 2 word size",
        "suggest": "最后剩下的部分，<2 字大小",
        "translate": ""
    },
    {
        "source": "search up to an aligned boundary",
        "suggest": "搜索到对齐的边界",
        "translate": ""
    },
    {
        "source": "search the body of the text",
        "suggest": "搜索正文",
        "translate": ""
    },
    {
        "source": "the while's predicate guarantees a distance of at least 2 * usize_bytes between the offset and the end of the slice.",
        "suggest": "while 的谓词保证偏移量和切片末尾之间至少有 2 * usize_bytes 的距离。",
        "translate": ""
    },
    {
        "source": "break if there is a matching byte",
        "suggest": "如果有匹配的字节则中断",
        "translate": ""
    },
    {
        "source": "Find the byte after the point the body loop stopped.",
        "suggest": "在主体循环停止的点之后找到字节。",
        "translate": ""
    },
    {
        "source": "Returns the last index matching the byte `x` in `text`.",
        "suggest": "返回与 `text` 中的字节 `x` 匹配的最后一个索引。",
        "translate": ""
    },
    {
        "source": "Split `text` in three parts:",
        "suggest": "将 `text` 分为三个部分:",
        "translate": ""
    },
    {
        "source": "unaligned tail, after the last word aligned address in text,",
        "suggest": "未对齐的尾部，在文本中最后一个单词对齐的地址之后，",
        "translate": ""
    },
    {
        "source": "body, scanned by 2 words at a time,",
        "suggest": "身体，一次扫描 2 个字，",
        "translate": ""
    },
    {
        "source": "the first remaining bytes, < 2 word size.",
        "suggest": "剩余的前一个字节，<2 个字长。",
        "translate": ""
    },
    {
        "source": "We call this just to obtain the length of the prefix and suffix.",
        "suggest": "我们称其为仅仅是获得前缀和后缀的长度。",
        "translate": ""
    },
    {
        "source": "In the middle we always process two chunks at once.",
        "suggest": "在中间，我们总是一次处理两个块。",
        "translate": ""
    },
    {
        "source": "transmuting `[u8]` to `[usize]` is safe except for size differences which are handled by `align_to`.",
        "suggest": "将 `[u8]` 转换为 `[usize]` 是安全的，但 `align_to` 处理的大小差异除外。",
        "translate": ""
    },
    {
        "source": "Search the body of the text, make sure we don't cross min_aligned_offset.",
        "suggest": "搜索文本的正文，确保我们不跨越 min_aligned_offset。",
        "translate": ""
    },
    {
        "source": "offset is always aligned, so just testing `>` is sufficient and avoids possible overflow.",
        "suggest": "偏移量总是对齐的，因此仅测试 `>` 就足够了，并避免了可能的溢出。",
        "translate": ""
    },
    {
        "source": "offset starts at len - suffix.len(), as long as it is greater than min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.",
        "suggest": "偏移量从 len-suffix.len() 开始，只要大于 min_aligned_offset (prefix.len())，则剩余距离至少为 2 * chunk_bytes。",
        "translate": ""
    },
    {
        "source": "Break if there is a matching byte.",
        "suggest": "如果有匹配的字节，则中断。",
        "translate": ""
    },
    {
        "source": "Find the byte before the point the body loop stopped.",
        "suggest": "在主体循环停止的点之前找到字节。",
        "translate": ""
    },
    {
        "source": "1-element chunks never have remainder",
        "suggest": "1 个元素的块永远不会剩余",
        "translate": ""
    },
    {
        "source": "The slice length (6) is a multiple of 3",
        "suggest": "切片长度 (6) 是 3 的倍数",
        "translate": ""
    },
    {
        "source": "These would be unsound:",
        "suggest": "这些是不合理的:",
        "translate": ""
    },
    {
        "source": "let chunks: &[[_; 5]] = slice.as_chunks_unchecked() // The slice length is not a multiple of 5 let chunks: &[[_; 0]] = slice.as_chunks_unchecked() // Zero-length chunks are never allowed",
        "suggest": "`let chunks: &[[_; 5]] = slice.as_chunks_unchecked()` // 切片长度不是 5 个的倍数: `let chunks: &[[_; 0]] = slice.as_chunks_unchecked()` // 永远不允许零长度的块",
        "translate": ""
    },
    {
        "source": "let chunks: &[[_; 5]] = slice.as_chunks_unchecked_mut() // The slice length is not a multiple of 5 let chunks: &[[_; 0]] = slice.as_chunks_unchecked_mut() // Zero-length chunks are never allowed",
        "suggest": "`let chunks: &[[_; 5]] = slice.as_chunks_unchecked_mut()` // 切片长度不是 5 的倍数: `let chunks: &[[_; 0]] = slice.as_chunks_unchecked_mut()` // 永远不允许零长度的块",
        "translate": ""
    },
    {
        "source": "scoped to restrict the lifetime of the borrows",
        "suggest": "限制借用的生命周期",
        "translate": ""
    },
    {
        "source": "slice of `String`",
        "suggest": "`String` 切片",
        "translate": ""
    },
    {
        "source": "search with `&str`",
        "suggest": "用 `&str` 搜索",
        "translate": ""
    },
    {
        "source": "Find the median",
        "suggest": "求中位数",
        "translate": ""
    },
    {
        "source": "We are only guaranteed the slice will be one of the following, based on the way we sort about the specified index.",
        "suggest": "根据我们对指定索引的排序方式，我们仅保证切片将是以下内容之一。",
        "translate": ""
    },
    {
        "source": "Find the median as if the slice were sorted in descending order.",
        "suggest": "查找中间值，好像切片是按降序排序的。",
        "translate": ""
    },
    {
        "source": "Return the median as if the array were sorted according to absolute value.",
        "suggest": "返回中间值，就好像数组是根据绝对值排序的一样。",
        "translate": ""
    },
    {
        "source": "Because the slices have to be the same length, we slice the source slice from four elements to two.",
        "suggest": "由于切片必须具有相同的长度，因此我们将源切片从四个元素切成两个。",
        "translate": ""
    },
    {
        "source": "It will panic if we don't do this.",
        "suggest": "如果不这样做，它将为 panic。",
        "translate": ""
    },
    {
        "source": "compile fail!",
        "suggest": "编译失败!",
        "translate": ""
    },
    {
        "source": "Slice management and manipulation.",
        "suggest": "切片管理和操作。",
        "translate": ""
    },
    {
        "source": "For more details see [`std::slice`].",
        "suggest": "有关更多详细信息，请参见 [`std::slice`]。",
        "translate": ""
    },
    {
        "source": "Pure rust memchr implementation, taken from rust-memchr",
        "suggest": "纯粹的 rust memchr 实现，取自 rust-memchr",
        "translate": ""
    },
    {
        "source": "This function is public only because there is no other way to unit test heapsort.",
        "suggest": "该函数仅是公开的，因为没有其他方法可以进行单元测试堆排序。",
        "translate": ""
    },
    {
        "source": "Returns the number of elements in the slice.",
        "suggest": "返回切片中的元素数。",
        "translate": ""
    },
    {
        "source": "const sound because we transmute out the length field as a usize (which it must be)",
        "suggest": "const sound，因为我们将长度字段转换为 usize (必须是)",
        "translate": ""
    },
    {
        "source": "this is safe because `&[T]` and `FatPtr<T>` have the same layout.",
        "suggest": "这是安全的，因为 `&[T]` 和 `FatPtr<T>` 具有相同的布局。",
        "translate": ""
    },
    {
        "source": "Replace with `crate::ptr::metadata(self)` when that is const-stable.",
        "suggest": "当 `crate::ptr::metadata(self)` 稳定时，替换为 `crate::ptr::metadata(self)`。",
        "translate": ""
    },
    {
        "source": "As of this writing this causes a \"Const-stable functions can only call other const-stable functions\" error.",
        "suggest": "在撰写本文时，这将导致 \"Const-stable functions can only call other const-stable functions\" 错误。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the slice has a length of 0.",
        "suggest": "如果切片的长度为 0，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns the first element of the slice, or `None` if it is empty.",
        "suggest": "返回切片的第一个元素; 如果为空，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns a mutable pointer to the first element of the slice, or `None` if it is empty.",
        "suggest": "返回指向切片第一个元素的可变指针，如果为空则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns the first and all the rest of the elements of the slice, or `None` if it is empty.",
        "suggest": "返回切片的第一个元素和所有其他元素，如果为空，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns the last and all the rest of the elements of the slice, or `None` if it is empty.",
        "suggest": "返回切片的最后一个元素和所有其他元素，如果为空，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns the last element of the slice, or `None` if it is empty.",
        "suggest": "返回切片的最后一个元素; 如果为空，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns a mutable pointer to the last item in the slice.",
        "suggest": "返回指向切片中最后一个项的可变指针。",
        "translate": ""
    },
    {
        "source": "Returns a reference to an element or subslice depending on the type of index.",
        "suggest": "根据索引的类型返回对元素或子切片的引用。",
        "translate": ""
    },
    {
        "source": "If given a position, returns a reference to the element at that position or `None` if out of bounds.",
        "suggest": "如果给定位置，则返回该位置上的元素的引用，如果越界则返回 `None`。",
        "translate": ""
    },
    {
        "source": "If given a range, returns the subslice corresponding to that range, or `None` if out of bounds.",
        "suggest": "如果给定范围，则返回对应于该范围的子切片; 如果越界，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to an element or subslice depending on the type of index (see [`get`]) or `None` if the index is out of bounds.",
        "suggest": "根据索引的类型 (请参见 [`get`]) 或 `None` (如果索引越界)，对元素或子切片返回可变引用。",
        "translate": ""
    },
    {
        "source": "Returns a reference to an element or subslice, without doing bounds checking.",
        "suggest": "返回对元素或子切片的引用，而不进行边界检查。",
        "translate": ""
    },
    {
        "source": "For a safe alternative see [`get`].",
        "suggest": "有关安全的选择，请参见 [`get`]。",
        "translate": ""
    },
    {
        "source": "Calling this method with an out-of-bounds index is *[undefined behavior]* even if the resulting reference is not used.",
        "suggest": "即使没有使用所得的引用，使用越界索引调用此方法也是 *[undefined behavior]*。",
        "translate": ""
    },
    {
        "source": "the caller must uphold most of the safety requirements for `get_unchecked`;",
        "suggest": "调用者必须遵守 `get_unchecked` 的大多数安全要求;",
        "translate": ""
    },
    {
        "source": "the slice is dereferencable because `self` is a safe reference.",
        "suggest": "因为 `self` 是安全引用，所以该切片是不可取的。",
        "translate": ""
    },
    {
        "source": "The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.",
        "suggest": "返回的指针是安全的，因为 `SliceIndex` 的 impls 必须保证它是正确的。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to an element or subslice, without doing bounds checking.",
        "suggest": "返回元素或子切片的可变引用，而不进行边界检查。",
        "translate": ""
    },
    {
        "source": "For a safe alternative see [`get_mut`].",
        "suggest": "有关安全的选择，请参见 [`get_mut`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety requirements for `get_unchecked_mut`;",
        "suggest": "调用者必须遵守 `get_unchecked_mut` 的安全要求;",
        "translate": ""
    },
    {
        "source": "The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.",
        "suggest": "调用者必须确保切片比该函数返回的指针有效，否则它将最终指向垃圾。",
        "translate": ""
    },
    {
        "source": "Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it invalid.",
        "suggest": "修改此切片引用的容器可能会导致重新分配其缓冲区，这也将使指向它的任何指针无效。",
        "translate": ""
    },
    {
        "source": "Returns an unsafe mutable pointer to the slice's buffer.",
        "suggest": "返回指向切片缓冲区的不安全可变指针。",
        "translate": ""
    },
    {
        "source": "Returns the two raw pointers spanning the slice.",
        "suggest": "返回跨越切片的两个裸指针。",
        "translate": ""
    },
    {
        "source": "The returned range is half-open, which means that the end pointer points *one past* the last element of the slice.",
        "suggest": "返回的范围是半开的，这意味着结束指针将 *one 指向* 切片的最后一个元素。",
        "translate": ""
    },
    {
        "source": "This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.",
        "suggest": "这样，一个空的切片由两个相等的指针表示，两个指针之间的差表示切片的大小。",
        "translate": ""
    },
    {
        "source": "See [`as_ptr`] for warnings on using these pointers.",
        "suggest": "有关使用这些指针的警告，请参见 [`as_ptr`]。",
        "translate": ""
    },
    {
        "source": "The end pointer requires extra caution, as it does not point to a valid element in the slice.",
        "suggest": "结束指针需要格外小心，因为它没有指向切片中的有效元素。",
        "translate": ""
    },
    {
        "source": "This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory, as is common in C++.",
        "suggest": "此函数对于与外部接口进行交互很有用，该外部接口使用两个指针来引用内存中的一系列元素，这在 C++ 中很常见。",
        "translate": ""
    },
    {
        "source": "It can also be useful to check if a pointer to an element refers to an element of this slice:",
        "suggest": "检查指向元素的指针是否引用了此切片的元素，这也可能很有用:",
        "translate": ""
    },
    {
        "source": "The `add` here is safe, because:",
        "suggest": "这里的 `add` 是安全的，因为:",
        "translate": ""
    },
    {
        "source": "Both pointers are part of the same object, as pointing directly past the object also counts.",
        "suggest": "两个指针都是同一对象的一部分，因为直接指向该对象的指针也很重要。",
        "translate": ""
    },
    {
        "source": "The size of the slice is never larger than isize::MAX bytes, as noted here:",
        "suggest": "切片的大小永远不会大于 isize::MAX 字节，如下所示:",
        "translate": ""
    },
    {
        "source": "https://doc.rust-lang.org/core/slice/fn.from_raw_parts.html#safety(This doesn't seem normative yet, but the very same assumption is made in many places, including the Index implementation of slices.)",
        "suggest": "https://doc.rust-lang.org/core/slice/fn.from_raw_parts.html#safety (这似乎尚不规范，但是在很多地方都做出了相同的假设，包括切片的 Index 实现。)",
        "translate": ""
    },
    {
        "source": "There is no wrapping around involved, as slices do not wrap past the end of the address space.",
        "suggest": "没有切片环绕，因为切片不会环绕地址空间的末尾。",
        "translate": ""
    },
    {
        "source": "See the documentation of pointer::add.",
        "suggest": "请参见 pointer::add 的文档。",
        "translate": ""
    },
    {
        "source": "Returns the two unsafe mutable pointers spanning the slice.",
        "suggest": "返回跨越切片的两个不安全的可变指针。",
        "translate": ""
    },
    {
        "source": "See [`as_mut_ptr`] for warnings on using these pointers.",
        "suggest": "有关使用这些指针的警告，请参见 [`as_mut_ptr`]。",
        "translate": ""
    },
    {
        "source": "See as_ptr_range() above for why `add` here is safe.",
        "suggest": "有关为什么 `add` 此处安全的信息，请参见上面的 as_ptr_range()。",
        "translate": ""
    },
    {
        "source": "Swaps two elements in the slice.",
        "suggest": "在切片中交换两个元素。",
        "translate": ""
    },
    {
        "source": "a - The index of the first element",
        "suggest": "a - 第一个元素的索引",
        "translate": ""
    },
    {
        "source": "b - The index of the second element",
        "suggest": "b - 第二个元素的索引",
        "translate": ""
    },
    {
        "source": "Panics if `a` or `b` are out of bounds.",
        "suggest": "如果 `a` 或 `b` 越界，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Can't take two mutable loans from one vector, so instead use raw pointers.",
        "suggest": "不能从一个 vector 借两笔可变贷款，所以改用裸指针。",
        "translate": ""
    },
    {
        "source": "`pa` and `pb` have been created from safe mutable references and refer to elements in the slice and therefore are guaranteed to be valid and aligned.",
        "suggest": "`pa` 和 `pb` 是根据安全变量引用创建的，它们引用切片中的元素，因此可以保证它们有效且对齐。",
        "translate": ""
    },
    {
        "source": "Note that accessing the elements behind `a` and `b` is checked and will panic when out of bounds.",
        "suggest": "请注意，将检查访问 `a` 和 `b` 后面的元素，并且越界时将访问 panic。",
        "translate": ""
    },
    {
        "source": "Reverses the order of elements in the slice, in place.",
        "suggest": "适当地反转切片中元素的顺序。",
        "translate": ""
    },
    {
        "source": "For very small types, all the individual reads in the normal path perform poorly.",
        "suggest": "对于非常小的类型，正常路径中的所有单个读取均表现不佳。",
        "translate": ""
    },
    {
        "source": "We can do better, given efficient unaligned load/store, by loading a larger chunk and reversing a register.",
        "suggest": "给定有效的未对齐 load/store，我们可以通过加载更大的块并反转寄存器来做得更好。",
        "translate": ""
    },
    {
        "source": "Ideally LLVM would do this for us, as it knows better than we do whether unaligned reads are efficient (since that changes between different ARM versions, for example) and what the best chunk size would be.",
        "suggest": "理想情况下，LLVM 会为我们做到这一点，因为它比我们更了解未对齐的读取是否有效 (例如，由于不同 ARM 版本之间的变化) 以及最佳块大小将是有效的。",
        "translate": ""
    },
    {
        "source": "Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls the loop, so we need to do this ourselves.",
        "suggest": "不幸的是，从 LLVM 4.0 (2017-05) 开始，它仅展开循环，因此我们需要自己做。",
        "translate": ""
    },
    {
        "source": "(Hypothesis: reverse is troublesome because the sides can be aligned differently -- will be, when the length is odd -- so there's no way of emitting pre- and postludes to use fully-aligned SIMD in the middle.)",
        "suggest": "(假设: 反向是麻烦的，因为当长度为奇数时，边的对齐方式可能会有所不同 - 因此，无法在中间使用完全对齐的 SIMD 发出前奏和后奏的方式。)",
        "translate": ""
    },
    {
        "source": "Use the llvm.bswap intrinsic to reverse u8s in a usize",
        "suggest": "使用 llvm.bswap 内联函数在 usize 中反转 u8",
        "translate": ""
    },
    {
        "source": "There are several things to check here:",
        "suggest": "这里有几件事要检查:",
        "translate": ""
    },
    {
        "source": "Note that `chunk` is either 4 or 8 due to the cfg check above.",
        "suggest": "请注意，由于上述 cfg 检查，`chunk` 为 4 或 8。",
        "translate": ""
    },
    {
        "source": "So `chunk - 1` is positive.",
        "suggest": "因此 `chunk - 1` 为正。",
        "translate": ""
    },
    {
        "source": "Indexing with index `i` is fine as the loop check guarantees",
        "suggest": "使用索引 `i` 进行索引可以很好地进行循环检查",
        "translate": ""
    },
    {
        "source": "Indexing with index `ln - i - chunk = ln - (i + chunk)` is fine:",
        "suggest": "索引为 `ln - i - chunk = ln - (i + chunk)` 的索引很好:",
        "translate": ""
    },
    {
        "source": "is trivially true.",
        "suggest": "确实是对的。",
        "translate": ""
    },
    {
        "source": "The loop check guarantees:",
        "suggest": "循环检查保证:",
        "translate": ""
    },
    {
        "source": "<=> `i + chunk ≤ ln / 2 ≤ ln`, thus subtraction does not underflow.",
        "suggest": "<=> `i + chunk ≤ ln / 2 ≤ ln`，因此减法不会下溢。",
        "translate": ""
    },
    {
        "source": "The `read_unaligned` and `write_unaligned` calls are fine:",
        "suggest": "`read_unaligned` 和 `write_unaligned` 调用很好:",
        "translate": ""
    },
    {
        "source": "points to index `i` where `i < ln / 2 - (chunk - 1)` (see above) and `pb` points to index `ln - i - chunk`, so both are at least `chunk` many bytes away from the end of `self`.",
        "suggest": "指向索引 `i`，其中 `i < ln / 2 - (chunk - 1)` (请参见上文) 和 `pb` 指向索引 `ln - i - chunk`，因此两者至少相距 `self` 末尾至少 `chunk` 个字节。",
        "translate": ""
    },
    {
        "source": "Any initialized memory is valid `usize`.",
        "suggest": "任何初始化的内存都是有效的 `usize`。",
        "translate": ""
    },
    {
        "source": "Use rotate-by-16 to reverse u16s in a u32",
        "suggest": "使用 X16 旋转以反转 u32 中的 u16",
        "translate": ""
    },
    {
        "source": "An unaligned u32 can be read from `i` if `i + 1 < ln` (and obviously `i < ln`), because each element is 2 bytes and we're reading 4.",
        "suggest": "如果 `i + 1 < ln` (显然是 `i < ln`)，则可以从 `i` 读取未对齐的 u32，因为每个元素都是 2 个字节，而我们正在读取 4。",
        "translate": ""
    },
    {
        "source": "while condition",
        "suggest": "条件",
        "translate": ""
    },
    {
        "source": "Since it's less than the length divided by 2, then it must be in bounds.",
        "suggest": "由于它小于长度除以 2 的长度，因此它必须是有界的。",
        "translate": ""
    },
    {
        "source": "This also means that the condition `0 < i + chunk <= ln` is always respected, ensuring the `pb` pointer can be used safely.",
        "suggest": "这也意味着始终要遵守条件 `0 < i + chunk <= ln`，以确保可以安全地使用 `pb` 指针。",
        "translate": ""
    },
    {
        "source": "`i` is inferior to half the length of the slice so accessing `i` and `ln - i - 1` is safe (`i` starts at 0 and will not go further than `ln / 2 - 1`).",
        "suggest": "`i` 小于切片长度的一半，因此访问 `i` 和 `ln - i - 1` 是安全的 (`i` 从 0 开始，不会比 `ln / 2 - 1` 更远)。",
        "translate": ""
    },
    {
        "source": "The resulting pointers `pa` and `pb` are therefore valid and aligned, and can be read from and written to.",
        "suggest": "因此，生成的指针 `pa` 和 `pb` 是有效的并且已对齐，并且可以从中读取和写入。",
        "translate": ""
    },
    {
        "source": "Unsafe swap to avoid the bounds check in safe swap.",
        "suggest": "不安全交换以避免边界检查安全交换。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the slice.",
        "suggest": "返回切片上的迭代器。",
        "translate": ""
    },
    {
        "source": "Returns an iterator that allows modifying each value.",
        "suggest": "返回允许修改每个值的迭代器。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over all contiguous windows of length `size`.",
        "suggest": "返回长度为 `size` 的所有连续 windows 上的迭代器。",
        "translate": ""
    },
    {
        "source": "The windows overlap.",
        "suggest": "windows 重叠。",
        "translate": ""
    },
    {
        "source": "If the slice is shorter than `size`, the iterator returns no values.",
        "suggest": "如果切片短于 `size`，则迭代器不返回任何值。",
        "translate": ""
    },
    {
        "source": "Panics if `size` is 0.",
        "suggest": "如果 `size` 为 0，则为 Panics。",
        "translate": ""
    },
    {
        "source": "If the slice is shorter than `size`:",
        "suggest": "如果切片短于 `size`:",
        "translate": ""
    },
    {
        "source": "Returns an iterator over `chunk_size` elements of the slice at a time, starting at the beginning of the slice.",
        "suggest": "从切片的开头开始，一次返回对切片的 `chunk_size` 元素的迭代器。",
        "translate": ""
    },
    {
        "source": "The chunks are slices and do not overlap.",
        "suggest": "块是切片，并且不重叠。",
        "translate": ""
    },
    {
        "source": "If `chunk_size` does not divide the length of the slice, then the last chunk will not have length `chunk_size`.",
        "suggest": "如果 `chunk_size` 不划分切片的长度，则最后一块的长度将不为 `chunk_size`。",
        "translate": ""
    },
    {
        "source": "See [`chunks_exact`] for a variant of this iterator that returns chunks of always exactly `chunk_size` elements, and [`rchunks`] for the same iterator but starting at the end of the slice.",
        "suggest": "有关此迭代器的成员的信息，请参见 [`chunks_exact`]，该成员返回始终完全相同的 `chunk_size` 元素的块; 对于相同的迭代器，请返回 [`rchunks`]，但均从切片的末尾开始。",
        "translate": ""
    },
    {
        "source": "Panics if `chunk_size` is 0.",
        "suggest": "如果 `chunk_size` 为 0，则为 Panics。",
        "translate": ""
    },
    {
        "source": "The chunks are mutable slices, and do not overlap.",
        "suggest": "块是可变切片，并且不重叠。",
        "translate": ""
    },
    {
        "source": "See [`chunks_exact_mut`] for a variant of this iterator that returns chunks of always exactly `chunk_size` elements, and [`rchunks_mut`] for the same iterator but starting at the end of the slice.",
        "suggest": "有关此迭代器的成员的信息，请参见 [`chunks_exact_mut`]，该成员返回始终完全相同的 `chunk_size` 元素的块; 对于相同的迭代器，请返回 [`rchunks_mut`]，但均从切片的末尾开始。",
        "translate": ""
    },
    {
        "source": "If `chunk_size` does not divide the length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved from the `remainder` function of the iterator.",
        "suggest": "如果 `chunk_size` 不划分切片的长度，则最后 `chunk_size-1` 个元素将被省略，并可从迭代器的 `remainder` 函数中检索。",
        "translate": ""
    },
    {
        "source": "Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the resulting code better than in the case of [`chunks`].",
        "suggest": "由于每个块都具有完全 `chunk_size` 元素，因此与 [`chunks`] 相比，编译器通常可以更好地优化结果代码。",
        "translate": ""
    },
    {
        "source": "See [`chunks`] for a variant of this iterator that also returns the remainder as a smaller chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice.",
        "suggest": "请参见 [`chunks`] 以获取此迭代器的成员，该成员还以较小的块的形式返回其余部分，并以 [`rchunks_exact`] 获取相同的迭代器，但从切片的末尾开始。",
        "translate": ""
    },
    {
        "source": "If `chunk_size` does not divide the length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved from the `into_remainder` function of the iterator.",
        "suggest": "如果 `chunk_size` 不划分切片的长度，则最后 `chunk_size-1` 个元素将被省略，并可从迭代器的 `into_remainder` 函数中检索。",
        "translate": ""
    },
    {
        "source": "Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the resulting code better than in the case of [`chunks_mut`].",
        "suggest": "由于每个块都具有完全 `chunk_size` 元素，因此与 [`chunks_mut`] 相比，编译器通常可以更好地优化结果代码。",
        "translate": ""
    },
    {
        "source": "See [`chunks_mut`] for a variant of this iterator that also returns the remainder as a smaller chunk, and [`rchunks_exact_mut`] for the same iterator but starting at the end of the slice.",
        "suggest": "请参见 [`chunks_mut`] 以获取此迭代器的成员，该成员还以较小的块的形式返回其余部分，并以 [`rchunks_exact_mut`] 获取相同的迭代器，但从切片的末尾开始。",
        "translate": ""
    },
    {
        "source": "Splits the slice into a slice of `N`-element arrays, assuming that there's no remainder.",
        "suggest": "假设没有余数，将切片拆分为 N 个元素数组的切片。",
        "translate": ""
    },
    {
        "source": "This may only be called when",
        "suggest": "只能在以下情况下调用",
        "translate": ""
    },
    {
        "source": "The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).",
        "suggest": "切片精确地分为 `N` 个元素块 (也称为 `self.len() % N == 0`)。",
        "translate": ""
    },
    {
        "source": "Our precondition is exactly what's needed to call this",
        "suggest": "我们的先决条件恰恰是调用此命令所需要的",
        "translate": ""
    },
    {
        "source": "We cast a slice of `new_len * N` elements into a slice of `new_len` many `N` elements chunks.",
        "suggest": "我们将 `new_len * N` 元素的切片转换为 `new_len` 的切片，其中包含许多 `N` 元素块。",
        "translate": ""
    },
    {
        "source": "Splits the slice into a slice of `N`-element arrays, starting at the beginning of the slice, and a remainder slice with length strictly less than `N`.",
        "suggest": "从切片的开头开始，将切片分成 `N` 个元素数组的切片，然后将其长度严格小于 `N` 的其余切片切成薄片。",
        "translate": ""
    },
    {
        "source": "Panics if `N` is 0.",
        "suggest": "如果 `N` 为 0，则为 Panics。",
        "translate": ""
    },
    {
        "source": "This check will most probably get changed to a compile time error before this method gets stabilized.",
        "suggest": "在此方法稳定之前，此检查很可能会更改为编译时错误。",
        "translate": ""
    },
    {
        "source": "We already panicked for zero, and ensured by construction that the length of the subslice is a multiple of N.",
        "suggest": "我们已经感到恐慌为零，并通过构造确保子切片的长度是 N 的倍数。",
        "translate": ""
    },
    {
        "source": "Splits the slice into a slice of `N`-element arrays, starting at the end of the slice, and a remainder slice with length strictly less than `N`.",
        "suggest": "从切片的末尾开始，将切片分成 `N` 个元素数组的切片，然后将其长度严格小于 `N` 的其余切片切成薄片。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over `N` elements of the slice at a time, starting at the beginning of the slice.",
        "suggest": "从切片的开头开始，一次返回对切片的 `N` 元素的迭代器。",
        "translate": ""
    },
    {
        "source": "The chunks are array references and do not overlap.",
        "suggest": "这些块是数组引用，并且不重叠。",
        "translate": ""
    },
    {
        "source": "If `N` does not divide the length of the slice, then the last up to `N-1` elements will be omitted and can be retrieved from the `remainder` function of the iterator.",
        "suggest": "如果 `N` 不划分切片的长度，则最后 `N-1` 个元素将被省略，并可从迭代器的 `remainder` 函数中检索。",
        "translate": ""
    },
    {
        "source": "This method is the const generic equivalent of [`chunks_exact`].",
        "suggest": "此方法与 [`chunks_exact`] 等效为 const 泛型。",
        "translate": ""
    },
    {
        "source": "The chunks are mutable array references and do not overlap.",
        "suggest": "这些块是可变数组引用，并且不重叠。",
        "translate": ""
    },
    {
        "source": "If `N` does not divide the length of the slice, then the last up to `N-1` elements will be omitted and can be retrieved from the `into_remainder` function of the iterator.",
        "suggest": "如果 `N` 不划分切片的长度，则最后 `N-1` 个元素将被省略，并可从迭代器的 `into_remainder` 函数中检索。",
        "translate": ""
    },
    {
        "source": "This method is the const generic equivalent of [`chunks_exact_mut`].",
        "suggest": "此方法与 [`chunks_exact_mut`] 等效为 const 泛型。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over overlapping windows of `N` elements of  a slice, starting at the beginning of the slice.",
        "suggest": "从切片的开头开始，在切片的 `N` 元素的重叠 windows 上返回迭代器。",
        "translate": ""
    },
    {
        "source": "This is the const generic equivalent of [`windows`].",
        "suggest": "这是 [`windows`] 的 const 泛型等效项。",
        "translate": ""
    },
    {
        "source": "If `N` is greater than the size of the slice, it will return no windows.",
        "suggest": "如果 `N` 大于切片的大小，则不会返回 windows。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end of the slice.",
        "suggest": "从切片的末尾开始，一次返回对切片的 `chunk_size` 元素的迭代器。",
        "translate": ""
    },
    {
        "source": "See [`rchunks_exact`] for a variant of this iterator that returns chunks of always exactly `chunk_size` elements, and [`chunks`] for the same iterator but starting at the beginning of the slice.",
        "suggest": "有关此迭代器的成员的信息，请参见 [`rchunks_exact`]，该成员返回始终完全相同的 `chunk_size` 元素的块; 对于相同的迭代器，请返回 [`chunks`]，但从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "See [`rchunks_exact_mut`] for a variant of this iterator that returns chunks of always exactly `chunk_size` elements, and [`chunks_mut`] for the same iterator but starting at the beginning of the slice.",
        "suggest": "有关此迭代器的成员的信息，请参见 [`rchunks_exact_mut`]，该成员返回始终完全相同的 `chunk_size` 元素的块; 对于相同的迭代器，请返回 [`chunks_mut`]，但从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "See [`rchunks`] for a variant of this iterator that also returns the remainder as a smaller chunk, and [`chunks_exact`] for the same iterator but starting at the beginning of the slice.",
        "suggest": "请参见 [`rchunks`] 以获取此迭代器的成员，该成员还以较小的块的形式返回其余部分，并以 [`chunks_exact`] 获取相同的迭代器，但从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "See [`rchunks_mut`] for a variant of this iterator that also returns the remainder as a smaller chunk, and [`chunks_exact_mut`] for the same iterator but starting at the beginning of the slice.",
        "suggest": "请参见 [`rchunks_mut`] 以获取此迭代器的成员，该成员还以较小的块的形式返回其余部分，并以 [`chunks_exact_mut`] 获取相同的迭代器，但从切片的开头开始。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the slice producing non-overlapping runs of elements using the predicate to separate them.",
        "suggest": "返回在切片上使用迭代器生成迭代器的迭代器，这些谓词使用谓词将它们分隔开。",
        "translate": ""
    },
    {
        "source": "The predicate is called on two elements following themselves, it means the predicate is called on `slice[0]` and `slice[1]` then on `slice[1]` and `slice[2]` and so on.",
        "suggest": "谓词在紧随其后的两个元素上调用，这意味着谓词在 `slice[0]` 和 `slice[1]` 上调用，然后在 `slice[1]` 和 `slice[2]` 上调用，依此类推。",
        "translate": ""
    },
    {
        "source": "This method can be used to extract the sorted subslices:",
        "suggest": "此方法可用于提取排序的子切片:",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the slice producing non-overlapping mutable runs of elements using the predicate to separate them.",
        "suggest": "返回在切片上使用谓词将其分离的迭代器，以生成不重叠的可变元素游程。",
        "translate": ""
    },
    {
        "source": "Divides one slice into two at an index.",
        "suggest": "在索引处将一个切片分为两个。",
        "translate": ""
    },
    {
        "source": "The first will contain all indices from `[0, mid)` (excluding the index `mid` itself) and the second will contain all indices from `[mid, len)` (excluding the index `len` itself).",
        "suggest": "第一个将包含 `[0, mid)` 的所有索引 (不包括索引 `mid` 本身)，第二个将包含 `[mid, len)` 的所有索引 (不包括索引 `len` 本身)。",
        "translate": ""
    },
    {
        "source": "Panics if `mid > len`.",
        "suggest": "如果为 `mid > len`，则为 Panics。",
        "translate": ""
    },
    {
        "source": "`[ptr; mid]` and `[mid; len]` are inside `self`, which fulfills the requirements of `from_raw_parts_mut`.",
        "suggest": "`[ptr; mid]` 和 `[mid; len]` 在 `self` 内部，可以满足 `from_raw_parts_mut` 的要求。",
        "translate": ""
    },
    {
        "source": "Divides one mutable slice into two at an index.",
        "suggest": "在索引处将一个可变切片分成两个。",
        "translate": ""
    },
    {
        "source": "Divides one slice into two at an index, without doing bounds checking.",
        "suggest": "在索引处将一个切片分为两个，而无需进行边界检查。",
        "translate": ""
    },
    {
        "source": "For a safe alternative see [`split_at`].",
        "suggest": "有关安全的选择，请参见 [`split_at`]。",
        "translate": ""
    },
    {
        "source": "Caller has to check that `0 <= mid <= self.len()`",
        "suggest": "调用者必须检查 `0 <= mid <= self.len()`",
        "translate": ""
    },
    {
        "source": "Divides one mutable slice into two at an index, without doing bounds checking.",
        "suggest": "在索引处将一个可变切片分为两个，而无需进行边界检查。",
        "translate": ""
    },
    {
        "source": "For a safe alternative see [`split_at_mut`].",
        "suggest": "有关安全的选择，请参见 [`split_at_mut`]。",
        "translate": ""
    },
    {
        "source": "Caller has to check that `0 <= mid <= self.len()`.",
        "suggest": "调用者必须检查 `0 <= mid <= self.len()`。",
        "translate": ""
    },
    {
        "source": "and `[mid; len]` are not overlapping, so returning a mutable reference is fine.",
        "suggest": "和 `[mid; len]` 不重叠，因此返回变量引用是可以的。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over subslices separated by elements that match `pred`.",
        "suggest": "返回由与 `pred` 匹配的元素分隔的子切片上的迭代器。",
        "translate": ""
    },
    {
        "source": "The matched element is not contained in the subslices.",
        "suggest": "匹配的元素不包含在子切片中。",
        "translate": ""
    },
    {
        "source": "If the first element is matched, an empty slice will be the first item returned by the iterator.",
        "suggest": "如果第一个元素匹配，则空切片将是迭代器返回的第一个项。",
        "translate": ""
    },
    {
        "source": "Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:",
        "suggest": "同样，如果切片中的最后一个元素匹配，则空切片将是迭代器返回的最后一个项:",
        "translate": ""
    },
    {
        "source": "If two matched elements are directly adjacent, an empty slice will be present between them:",
        "suggest": "如果两个匹配的元素直接相邻，则它们之间将出现一个空的切片:",
        "translate": ""
    },
    {
        "source": "Returns an iterator over mutable subslices separated by elements that match `pred`.",
        "suggest": "返回由匹配 `pred` 的元素分隔的可变子片段上的迭代器。",
        "translate": ""
    },
    {
        "source": "The matched element is contained in the end of the previous subslice as a terminator.",
        "suggest": "匹配的元素包含在上一个子切片的末尾作为终止符。",
        "translate": ""
    },
    {
        "source": "If the last element of the slice is matched, that element will be considered the terminator of the preceding slice.",
        "suggest": "如果切片的最后一个元素匹配，则该元素将被视为前一个切片的终止符。",
        "translate": ""
    },
    {
        "source": "That slice will be the last item returned by the iterator.",
        "suggest": "该切片将是迭代器返回的最后一个项目。",
        "translate": ""
    },
    {
        "source": "The matched element is contained in the previous subslice as a terminator.",
        "suggest": "匹配的元素作为终止符包含在先前的子切片中。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over subslices separated by elements that match `pred`, starting at the end of the slice and working backwards.",
        "suggest": "在子切片上返回一个迭代器，该迭代器由与 `pred` 匹配的元素分隔，从切片的末尾开始并向后工作。",
        "translate": ""
    },
    {
        "source": "As with `split()`, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.",
        "suggest": "与 `split()` 一样，如果第一个或最后一个元素匹配，则空切片将是迭代器返回的第一个 (或最后一个) 项。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over mutable subslices separated by elements that match `pred`, starting at the end of the slice and working backwards.",
        "suggest": "返回在可变子切片上的迭代器，该子切片由与 `pred` 匹配的元素分隔，从切片的末尾开始并向后工作。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over subslices separated by elements that match `pred`, limited to returning at most `n` items.",
        "suggest": "在子切片上返回一个迭代器，该子切片由与 `pred` 匹配的元素分隔，限于最多返回 `n` 项。",
        "translate": ""
    },
    {
        "source": "The last element returned, if any, will contain the remainder of the slice.",
        "suggest": "返回的最后一个元素 (如果有) 将包含切片的其余部分。",
        "translate": ""
    },
    {
        "source": "Print the slice split once by numbers divisible by 3 (i.e., `[10, 40]`, `[20, 60, 50]`):",
        "suggest": "按 3 的整数倍数 (即 `[10, 40]`，`[20, 60, 50]`) 打印一次切片分割:",
        "translate": ""
    },
    {
        "source": "Returns an iterator over subslices separated by elements that match `pred` limited to returning at most `n` items.",
        "suggest": "在子切片上返回一个迭代器，该子切片由与 `pred` 匹配的元素分隔，最多只能返回 `n` 项。",
        "translate": ""
    },
    {
        "source": "This starts at the end of the slice and works backwards.",
        "suggest": "该操作从切片的末尾开始并向后工作。",
        "translate": ""
    },
    {
        "source": "Print the slice split once, starting from the end, by numbers divisible by 3 (i.e., `[50]`, `[10, 40, 30, 20]`):",
        "suggest": "从末尾开始，将切片拆分打印一次，并被 3 整除的数字 (即 `[50]`，`[10, 40, 30, 20]`) :",
        "translate": ""
    },
    {
        "source": "Returns `true` if the slice contains an element with the given value.",
        "suggest": "如果切片包含具有给定值的元素，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "If you do not have an `&T`, but just an `&U` such that `T: Borrow<U>` (e.g.",
        "suggest": "如果您没有 `&T`，而只有 `&U` 这样的 `T: Borrow<U>` (例如",
        "translate": ""
    },
    {
        "source": "`String: Borrow<str>`), you can use `iter().any`:",
        "suggest": "`字符串: 借用 <str>`)，则可以使用 `iter().any`:",
        "translate": ""
    },
    {
        "source": "Returns `true` if `needle` is a prefix of the slice.",
        "suggest": "如果 `needle` 是切片的前缀，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Always returns `true` if `needle` is an empty slice:",
        "suggest": "如果 `needle` 为空切片，则始终返回 `true`:",
        "translate": ""
    },
    {
        "source": "Returns `true` if `needle` is a suffix of the slice.",
        "suggest": "如果 `needle` 是切片的后缀，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns a subslice with the prefix removed.",
        "suggest": "返回带有删除的前缀的子切片。",
        "translate": ""
    },
    {
        "source": "If the slice starts with `prefix`, returns the subslice after the prefix, wrapped in `Some`.",
        "suggest": "如果切片以 `prefix` 开头，则返回前缀在 `Some` 中的子切片。",
        "translate": ""
    },
    {
        "source": "If `prefix` is empty, simply returns the original slice.",
        "suggest": "如果 `prefix` 为空，则只需返回原始切片。",
        "translate": ""
    },
    {
        "source": "If the slice does not start with `prefix`, returns `None`.",
        "suggest": "如果切片不是以 `prefix` 开头，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "This function will need rewriting if and when SlicePattern becomes more sophisticated.",
        "suggest": "当 SlicePattern 变得更加复杂时，将需要重写此函数。",
        "translate": ""
    },
    {
        "source": "Returns a subslice with the suffix removed.",
        "suggest": "返回删除后缀的子分片。",
        "translate": ""
    },
    {
        "source": "If the slice ends with `suffix`, returns the subslice before the suffix, wrapped in `Some`.",
        "suggest": "如果切片以 `suffix` 结尾，则返回后缀在 `Some` 中的子切片。",
        "translate": ""
    },
    {
        "source": "If `suffix` is empty, simply returns the original slice.",
        "suggest": "如果 `suffix` 为空，则只需返回原始切片。",
        "translate": ""
    },
    {
        "source": "If the slice does not end with `suffix`, returns `None`.",
        "suggest": "如果切片不以 `suffix` 结尾，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Binary searches this sorted slice for a given element.",
        "suggest": "Binary 在排序后的切片中搜索给定的元素。",
        "translate": ""
    },
    {
        "source": "See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].",
        "suggest": "另请参见 [`binary_search_by`]，[`binary_search_by_key`] 和 [`partition_point`]。",
        "translate": ""
    },
    {
        "source": "If you want to insert an item to a sorted vector, while maintaining sort order:",
        "suggest": "如果要在排序的 vector 中插入项目，同时保持排序顺序，请执行以下操作:",
        "translate": ""
    },
    {
        "source": "Binary searches this sorted slice with a comparator function.",
        "suggest": "Binary 使用比较器函数搜索排序后的切片。",
        "translate": ""
    },
    {
        "source": "The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is `Less`, `Equal` or `Greater` the desired target.",
        "suggest": "比较器函数应实现与基础切片的排序顺序一致的顺序，并返回指示其参数是所需目标的 `Less`，`Equal` 还是 `Greater` 的顺序代码。",
        "translate": ""
    },
    {
        "source": "See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].",
        "suggest": "另请参见 [`binary_search`]，[`binary_search_by_key`] 和 [`partition_point`]。",
        "translate": ""
    },
    {
        "source": "the call is made safe by the following invariants:",
        "suggest": "通过以下不可变变量使调用变得安全:",
        "translate": ""
    },
    {
        "source": "`mid` is limited by `[left; right)` bound.",
        "suggest": "`mid` 受 `[left; right)` 限制。",
        "translate": ""
    },
    {
        "source": "The reason why we use if/else control flow rather than match is because match reorders comparison operations, which is perf sensitive.",
        "suggest": "我们之所以使用 if/else 控制流而不是 match 的原因是因为 match 对性能比较敏感的比较操作进行重新排序。",
        "translate": ""
    },
    {
        "source": "This is x86 asm for u8:",
        "suggest": "这是 u8 的 x86 ASM:",
        "translate": ""
    },
    {
        "source": "Binary searches this sorted slice with a key extraction function.",
        "suggest": "Binary 使用关键字提取函数搜索排序后的切片。",
        "translate": ""
    },
    {
        "source": "Assumes that the slice is sorted by the key, for instance with [`sort_by_key`] using the same key extraction function.",
        "suggest": "假定按关键字对切片进行排序，例如使用相同的关键字提取函数对 [`sort_by_key`] 进行排序。",
        "translate": ""
    },
    {
        "source": "See also [`binary_search`], [`binary_search_by`], and [`partition_point`].",
        "suggest": "另请参见 [`binary_search`]，[`binary_search_by`] 和 [`partition_point`]。",
        "translate": ""
    },
    {
        "source": "Lint rustdoc::broken_intra_doc_links is allowed as `slice::sort_by_key` is in crate `alloc`, and as such doesn't exists yet when building `core`.",
        "suggest": "允许使用 Lint rustdoc::broken_intra_doc_links，因为 `slice::sort_by_key` 在 crate `alloc` 中，因此在构建 `core` 时尚不存在。",
        "translate": ""
    },
    {
        "source": "links to downstream crate: #74481.",
        "suggest": "链接到下游 crate: #74481。",
        "translate": ""
    },
    {
        "source": "Since primitives are only documented in libstd (#73423), this never leads to broken links in practice.",
        "suggest": "由于仅在 libstd (#73423) 中记录了原语，因此在实践中绝不会导致链接断开。",
        "translate": ""
    },
    {
        "source": "Sorts the slice, but may not preserve the order of equal elements.",
        "suggest": "对切片进行排序，但可能不会保留相等元素的顺序。",
        "translate": ""
    },
    {
        "source": "This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and *O*(*n* \\* log(*n*)) worst-case.",
        "suggest": "这种排序是不稳定的 (即可能重新排序相等的元素)，就地 (即不分配) 和 *O*(*n*\\*log(* n*)) 最坏的情况)。",
        "translate": ""
    },
    {
        "source": "It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated sorted sequences.",
        "suggest": "除了在一些特殊情况下 (例如，当切片由多个串联的排序序列组成) 以外，它通常比稳定排序快。",
        "translate": ""
    },
    {
        "source": "Sorts the slice with a comparator function, but may not preserve the order of equal elements.",
        "suggest": "使用比较器函数对切片进行排序，但可能不会保留相等元素的顺序。",
        "translate": ""
    },
    {
        "source": "Sorts the slice with a key extraction function, but may not preserve the order of equal elements.",
        "suggest": "使用键提取函数对切片进行排序，但可能不会保留相等元素的顺序。",
        "translate": ""
    },
    {
        "source": "This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and *O*(m \\* *n* \\* log(*n*)) worst-case, where the key function is *O*(*m*).",
        "suggest": "这种排序是不稳定的 (即可能重新排序相等的元素)，就地 (即不分配) 和 *O*(m\\* * n *\\* log(*n*)) 最坏的情况，其中键函数为 *O*(*m*)。",
        "translate": ""
    },
    {
        "source": "Due to its key calling strategy, [`sort_unstable_by_key`](#method.sort_unstable_by_key) is likely to be slower than [`sort_by_cached_key`](#method.sort_by_cached_key) in cases where the key function is expensive.",
        "suggest": "由于其键调用策略，在键函数很昂贵的情况下，[`sort_unstable_by_key`](#method.sort_unstable_by_key) 可能比 [`sort_by_cached_key`](#method.sort_by_cached_key) 慢。",
        "translate": ""
    },
    {
        "source": "Reorder the slice such that the element at `index` is at its final sorted position.",
        "suggest": "重新排序切片，以使 `index` 处的元素处于其最终排序位置。",
        "translate": ""
    },
    {
        "source": "Reorder the slice with a comparator function such that the element at `index` is at its final sorted position.",
        "suggest": "使用比较器函数对切片进行重新排序，以使 `index` 处的元素处于其最终排序位置。",
        "translate": ""
    },
    {
        "source": "Reorder the slice with a key extraction function such that the element at `index` is at its final sorted position.",
        "suggest": "使用键提取函数对切片进行重新排序，以使 `index` 处的元素处于其最终排序位置。",
        "translate": ""
    },
    {
        "source": "This reordering has the additional property that any value at position `i < index` will be less than or equal to any value at a position `j > index`.",
        "suggest": "此重新排序具有附加属性，即位置 `i < index` 处的任何值都将小于或等于位置 `j > index` 处的任何值。",
        "translate": ""
    },
    {
        "source": "Additionally, this reordering is unstable (i.e.",
        "suggest": "此外，这种重新排序是不稳定的 (即",
        "translate": ""
    },
    {
        "source": "any number of equal elements may end up at position `index`), in-place (i.e.",
        "suggest": "任何数量的相等元素都可以在位置 `index` 处就位 (即",
        "translate": ""
    },
    {
        "source": "does not allocate), and *O*(*n*) worst-case.",
        "suggest": "不分配)，以及 *O*(*n*) 最坏的情况。",
        "translate": ""
    },
    {
        "source": "This function is also/ known as \"kth element\" in other libraries.",
        "suggest": "在其他库中，该函数也被称为 \"kth element\"。",
        "translate": ""
    },
    {
        "source": "It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.",
        "suggest": "它返回以下值的三元组: 所有元素在给定索引处小于一个，在给定索引处的值，以及所有在给定索引处大于一个的元素。",
        "translate": ""
    },
    {
        "source": "The current algorithm is based on the quickselect portion of the same quicksort algorithm used for [`sort_unstable`].",
        "suggest": "当前算法基于用于 [`sort_unstable`] 的相同 quicksort 算法的 quickselect 部分。",
        "translate": ""
    }
]
