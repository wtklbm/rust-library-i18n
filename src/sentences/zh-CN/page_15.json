[
    {
        "source": "Positive angles measured counter-clockwise from positive x axis -pi/4 radians (45 deg clockwise)",
        "suggest": "从正 x 轴 -pi/4 弧度逆时针测量的正角 (顺时针 45 度)",
        "translate": ""
    },
    {
        "source": "radians (135 deg counter-clockwise)",
        "suggest": "弧度 (逆时针 135 度)",
        "translate": ""
    },
    {
        "source": "for very small x, e^x is approximately 1 + x + x^2 / 2",
        "suggest": "对于非常小的 x，e^x 约为 1 + x + x^2 / 2",
        "translate": ""
    },
    {
        "source": "for very small x, ln(1 + x) is approximately x - x^2 / 2",
        "suggest": "对于非常小的 x，ln(1 + x) 大约为 x - x^2 / 2",
        "translate": ""
    },
    {
        "source": "Solving sinh() at 1 gives `(e^2-1)/(2e)`",
        "suggest": "将 sinh() 求解为 1 得到 `(e^2-1)/(2e)`",
        "translate": ""
    },
    {
        "source": "Solving cosh() at 1 gives this result",
        "suggest": "将 cosh() 求解为 1 可得出此结果",
        "translate": ""
    },
    {
        "source": "Same result",
        "suggest": "结果相同",
        "translate": ""
    },
    {
        "source": "Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`",
        "suggest": "将 tanh() 求解为 1 得到 `(1 - e^(-2))/(1 + e^(-2))`",
        "translate": ""
    },
    {
        "source": "Returns the largest integer less than or equal to a number.",
        "suggest": "返回小于或等于数字的最大整数。",
        "translate": ""
    },
    {
        "source": "Returns the smallest integer greater than or equal to a number.",
        "suggest": "返回大于或等于数字的最小整数。",
        "translate": ""
    },
    {
        "source": "Returns the nearest integer to a number.",
        "suggest": "返回最接近整数的数字。",
        "translate": ""
    },
    {
        "source": "Round half-way cases away from `0.0`.",
        "suggest": "远离 `0.0` 的圆形中途机箱。",
        "translate": ""
    },
    {
        "source": "Returns the integer part of a number.",
        "suggest": "返回数字的整数部分。",
        "translate": ""
    },
    {
        "source": "Returns the fractional part of a number.",
        "suggest": "返回数字的小数部分。",
        "translate": ""
    },
    {
        "source": "Returns `NAN` if the number is `NAN`.",
        "suggest": "如果数字为 `NAN`，则返回 `NAN`。",
        "translate": ""
    },
    {
        "source": "Returns a number that represents the sign of `self`.",
        "suggest": "返回一个表示 `self` 符号的数字。",
        "translate": ""
    },
    {
        "source": "if the number is positive, `+0.0` or `INFINITY`",
        "suggest": "如果数字为正，则为 `+0.0` 或 `INFINITY`",
        "translate": ""
    },
    {
        "source": "if the number is negative, `-0.0` or `NEG_INFINITY`",
        "suggest": "如果数字为负，则 `-0.0` 或 `NEG_INFINITY`",
        "translate": ""
    },
    {
        "source": "if the number is `NAN`",
        "suggest": "如果数字是 `NAN`",
        "translate": ""
    },
    {
        "source": "Returns a number composed of the magnitude of `self` and the sign of `sign`.",
        "suggest": "返回一个数字，该数字由 `self` 的大小和 `sign` 的符号组成。",
        "translate": ""
    },
    {
        "source": "Equal to `self` if the sign of `self` and `sign` are the same, otherwise equal to `-self`.",
        "suggest": "如果 `self` 和 `sign` 的符号相同，则等于 `self`，否则等于 `-self`。",
        "translate": ""
    },
    {
        "source": "If `self` is a `NAN`, then a `NAN` with the sign of `sign` is returned.",
        "suggest": "如果 `self` 是 `NAN`，则返回带有 `sign` 符号的 `NAN`。",
        "translate": ""
    },
    {
        "source": "Fused multiply-add.",
        "suggest": "融合乘法加法。",
        "translate": ""
    },
    {
        "source": "Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",
        "suggest": "仅用一个舍入误差计算 `(self * a) + b`，比未融合的乘法加法产生更准确的结果。",
        "translate": ""
    },
    {
        "source": "Using `mul_add` *may* be more performant than an unfused multiply-add if the target architecture has a dedicated `fma` CPU instruction.",
        "suggest": "如果目标体系结构具有专用的 `fma` CPU 指令，则使用 `mul_add` 的性能可能比未融合的乘加性能更高。",
        "translate": ""
    },
    {
        "source": "However, this is not always true, and will be heavily dependant on designing algorithms with specific target hardware in mind.",
        "suggest": "但是，这并不总是正确的，并且在很大程度上取决于设计算法时要考虑特定的目标硬件。",
        "translate": ""
    },
    {
        "source": "Calculates Euclidean division, the matching method for `rem_euclid`.",
        "suggest": "计算欧几里得除法，即 `rem_euclid` 的匹配方法。",
        "translate": ""
    },
    {
        "source": "This computes the integer `n` such that `self = n * rhs + self.rem_euclid(rhs)`.",
        "suggest": "这将计算整数 `n`，如 `self = n * rhs + self.rem_euclid(rhs)`。",
        "translate": ""
    },
    {
        "source": "In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in most cases.",
        "suggest": "特别地，在大多数情况下，返回值 `r` 满足 `0.0 <= r < rhs.abs()`。",
        "translate": ""
    },
    {
        "source": "However, due to a floating point round-off error it can result in `r == rhs.abs()`, violating the mathematical definition, if `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.",
        "suggest": "但是，由于浮点舍入误差，如果 `self` 的幅值和 `self < 0.0` 远小于 `rhs.abs()`，则可能会导致 `r == rhs.abs()` 违反数学定义。",
        "translate": ""
    },
    {
        "source": "This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)` approximatively.",
        "suggest": "此结果不是函数共域的元素，但它是实数中最接近的浮点数，因此近似满足属性 `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`。",
        "translate": ""
    },
    {
        "source": "Raises a number to an integer power.",
        "suggest": "将数字提高到整数幂。",
        "translate": ""
    },
    {
        "source": "Using this function is generally faster than using `powf`",
        "suggest": "使用此函数通常比使用 `powf` 更快",
        "translate": ""
    },
    {
        "source": "Raises a number to a floating point power.",
        "suggest": "将数字加到浮点幂。",
        "translate": ""
    },
    {
        "source": "Returns the square root of a number.",
        "suggest": "返回数字的平方根。",
        "translate": ""
    },
    {
        "source": "Returns NaN if `self` is a negative number.",
        "suggest": "如果 `self` 为负数，则返回 NaN。",
        "translate": ""
    },
    {
        "source": "Returns `e^(self)`, (the exponential function).",
        "suggest": "返回 `e^(self)` (指数函数)。",
        "translate": ""
    },
    {
        "source": "Returns `2^(self)`.",
        "suggest": "返回 `2^(self)`。",
        "translate": ""
    },
    {
        "source": "Returns the natural logarithm of the number.",
        "suggest": "返回数字的自然对数。",
        "translate": ""
    },
    {
        "source": "Returns the logarithm of the number with respect to an arbitrary base.",
        "suggest": "返回数字相对于任意基数的对数。",
        "translate": ""
    },
    {
        "source": "The result may not be correctly rounded owing to implementation details;",
        "suggest": "由于实现细节，结果可能无法正确舍入;",
        "translate": ""
    },
    {
        "source": "can produce more accurate results for base 2, and `self.log10()` can produce more accurate results for base 10.",
        "suggest": "可以针对基准 2 产生更准确的结果，而 `self.log10()` 可以针对基准 10 产生更准确的结果。",
        "translate": ""
    },
    {
        "source": "Returns the base 2 logarithm of the number.",
        "suggest": "返回数字的以 2 为底的对数。",
        "translate": ""
    },
    {
        "source": "Returns the base 10 logarithm of the number.",
        "suggest": "返回数字的以 10 为底的对数。",
        "translate": ""
    },
    {
        "source": "The positive difference of two numbers.",
        "suggest": "两个数字的正差。",
        "translate": ""
    },
    {
        "source": "If `self <= other`:",
        "suggest": "如果是 `self <= other`:",
        "translate": ""
    },
    {
        "source": "Returns the cube root of a number.",
        "suggest": "返回数字的立方根。",
        "translate": ""
    },
    {
        "source": "Calculates the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",
        "suggest": "给定长度为 `x` 和 `y` 的支路，计算直角三角形的斜边的长度。",
        "translate": ""
    },
    {
        "source": "Computes the sine of a number (in radians).",
        "suggest": "计算数字的正弦 (以弧度为单位)。",
        "translate": ""
    },
    {
        "source": "Computes the cosine of a number (in radians).",
        "suggest": "计算数字的余弦 (以弧度为单位)。",
        "translate": ""
    },
    {
        "source": "Computes the tangent of a number (in radians).",
        "suggest": "计算数字的切线 (以弧度为单位)。",
        "translate": ""
    },
    {
        "source": "Computes the arcsine of a number.",
        "suggest": "计算数字的反正弦。",
        "translate": ""
    },
    {
        "source": "Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",
        "suggest": "如果数字超出 [-1, 1] 范围，则返回值的弧度范围为 [-pi/2, pi/2] 或 NaN。",
        "translate": ""
    },
    {
        "source": "Computes the arccosine of a number.",
        "suggest": "计算数字的反余弦值。",
        "translate": ""
    },
    {
        "source": "Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",
        "suggest": "如果数字超出 [-1, 1] 范围，则返回值的弧度范围为 [0, pi] 或 NaN。",
        "translate": ""
    },
    {
        "source": "Computes the arctangent of a number.",
        "suggest": "计算数字的反正切。",
        "translate": ""
    },
    {
        "source": "Return value is in radians in the range [-pi/2, pi/2];",
        "suggest": "返回值的弧度范围为 [-pi/2, pi/2];",
        "translate": ""
    },
    {
        "source": "Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.",
        "suggest": "计算弧度 `self` (`y`) 和 `other` (`x`) 的四个象限反正切。",
        "translate": ""
    },
    {
        "source": "Simultaneously computes the sine and cosine of the number,",
        "suggest": "同时计算数字的正弦和余弦，",
        "translate": ""
    },
    {
        "source": "Returns `(sin(x), cos(x))`.",
        "suggest": "返回 `(sin(x), cos(x))`。",
        "translate": ""
    },
    {
        "source": "Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",
        "suggest": "即使数字接近零，也以准确的方式返回 `e^(self) - 1`。",
        "translate": ""
    },
    {
        "source": "Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",
        "suggest": "与单独执行操作相比，返回 `ln(1+n)` (自然对数) 的准确性更高。",
        "translate": ""
    },
    {
        "source": "Hyperbolic sine function.",
        "suggest": "双曲正弦函数。",
        "translate": ""
    },
    {
        "source": "Hyperbolic cosine function.",
        "suggest": "双曲余弦函数。",
        "translate": ""
    },
    {
        "source": "Hyperbolic tangent function.",
        "suggest": "双曲正切函数。",
        "translate": ""
    },
    {
        "source": "Inverse hyperbolic sine function.",
        "suggest": "反双曲正弦函数。",
        "translate": ""
    },
    {
        "source": "Inverse hyperbolic cosine function.",
        "suggest": "反双曲余弦函数。",
        "translate": ""
    },
    {
        "source": "Inverse hyperbolic tangent function.",
        "suggest": "反双曲正切函数。",
        "translate": ""
    },
    {
        "source": "requires a wrapper around log, log2, and log10 functions because of their non-standard behavior (e.g.,",
        "suggest": "由于它们的非标准行为 (例如，",
        "translate": ""
    },
    {
        "source": "The exact same size shouldn't have needed to move its allocation",
        "suggest": "不必完全相同的大小来移动其分配",
        "translate": ""
    },
    {
        "source": "We are certain that our string doesn't have 0 bytes in the middle, so we can .expect()",
        "suggest": "我们确定我们的字符串中间没有 0 个字节，因此我们可以 .expect()",
        "translate": ""
    },
    {
        "source": "Some invalid bytes in a vector",
        "suggest": "vector 中的一些无效字节",
        "translate": ""
    },
    {
        "source": "retake pointer to free memory",
        "suggest": "重新获得指向空闲内存的指针",
        "translate": ""
    },
    {
        "source": "Interior nul byte",
        "suggest": "内部 nul 字节",
        "translate": ""
    },
    {
        "source": "No nul byte",
        "suggest": "无空字节",
        "translate": ""
    },
    {
        "source": "is dangling",
        "suggest": "是悬垂的",
        "translate": ""
    },
    {
        "source": "is valid because `hello` is in scope",
        "suggest": "有效，因为 `hello` 在作用域中",
        "translate": ""
    },
    {
        "source": "A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.",
        "suggest": "一种类型，表示拥有的，C 兼容的，以 nul 终止的字符串，中间没有 nul 字节。",
        "translate": ""
    },
    {
        "source": "This type serves the purpose of being able to safely generate a C-compatible string from a Rust byte slice or vector.",
        "suggest": "此类型的目的是能够从 Rust 字节切片或 vector 安全地生成 C 兼容字符串。",
        "translate": ""
    },
    {
        "source": "An instance of this type is a static guarantee that the underlying bytes contain no interior 0 bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").",
        "suggest": "此类型的一个实例是静态保证，底层字节不包含内部 0 字节 (`nul 字符`)，并且最后一个字节为 0 (`nul 终止符`)。",
        "translate": ""
    },
    {
        "source": "is to [`&CStr`] as [`String`] is to [`&str`]: the former in each pair are owned strings;",
        "suggest": "对 [`&CStr`] 就像对 [`String`] 对 [`&str`] 一样: 每对中的前者是拥有的字符串;",
        "translate": ""
    },
    {
        "source": "the latter are borrowed references.",
        "suggest": "后者是借用的。",
        "translate": ""
    },
    {
        "source": "Creating a `CString`",
        "suggest": "创建一个 `CString`",
        "translate": ""
    },
    {
        "source": "A `CString` is created from either a byte slice or a byte vector, or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for example, you can build a `CString` straight out of a [`String`] or a [`&str`], since both implement that trait).",
        "suggest": "`CString` 是从字节片或字节 vector 或任何实现 [`Into`]`<`[`Vec`]`<`[`u8`]`>>` 的文件创建的 (例如，您可以直接从 [`String`] 或 [`&str`] 构建 `CString`，因为两者都实现了 trait)。",
        "translate": ""
    },
    {
        "source": "The [`CString::new`] method will actually check that the provided `&[u8]` does not have 0 bytes in the middle, and return an error if it finds one.",
        "suggest": "[`CString::new`] 方法实际上将检查所提供的 `&[u8]` 中间是否没有 0 字节，如果找到一个，则返回错误。",
        "translate": ""
    },
    {
        "source": "Extracting a raw pointer to the whole C string",
        "suggest": "将裸指针提取到整个 C 字符串",
        "translate": ""
    },
    {
        "source": "implements a [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`] trait.",
        "suggest": "通过 [`Deref`] trait 实现 [`as_ptr`][`CStr::as_ptr`] 方法。",
        "translate": ""
    },
    {
        "source": "This method will give you a `*const c_char` which you can feed directly to extern functions that expect a nul-terminated string, like C's `strdup()`.",
        "suggest": "此方法将为您提供 `*const c_char`，您可以直接将其输入期望包含以 N 结束的字符串的 extern 函数，例如 C 的 `strdup()`。",
        "translate": ""
    },
    {
        "source": "Notice that [`as_ptr`][`CStr::as_ptr`] returns a read-only pointer;",
        "suggest": "注意，[`as_ptr`][`CStr::as_ptr`] 返回一个只读指针。",
        "translate": ""
    },
    {
        "source": "if the C code writes to it, that causes undefined behavior.",
        "suggest": "如果 C 代码写入它，则会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "Extracting a slice of the whole C string",
        "suggest": "提取整个 C 字符串的片段",
        "translate": ""
    },
    {
        "source": "Alternatively, you can obtain a `&[`[`u8`]`]` slice from a `CString` with the [`CString::as_bytes`] method.",
        "suggest": "或者，您可以使用 [`CString::as_bytes`] 方法从 `CString` 获得 `&[`[`u8`]`]` 切片。",
        "translate": ""
    },
    {
        "source": "Slices produced in this way do *not* contain the trailing nul terminator.",
        "suggest": "以这种方式产生的切片不包含尾随 nul 终止符。",
        "translate": ""
    },
    {
        "source": "This is useful when you will be calling an extern function that takes a `*const u8` argument which is not necessarily nul-terminated, plus another argument with the length of the string — like C's `strndup()`.",
        "suggest": "当您要调用带有 `*const u8` 参数 (不一定是 nul 终止) 的 extern 函数，以及带有字符串长度的另一个参数 (如 C 的 `strndup()`) 时，此功能很有用。",
        "translate": ""
    },
    {
        "source": "You can of course get the slice's length with its [`len`][slice::len] method.",
        "suggest": "当然，您可以使用 [`len`][slice::len] 方法获取切片的长度。",
        "translate": ""
    },
    {
        "source": "If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you can use [`CString::as_bytes_with_nul`] instead.",
        "suggest": "如果需要带有 nul 终止符的 `&[`[`u8`]`]` 切片，则可以改用 [`CString::as_bytes_with_nul`]。",
        "translate": ""
    },
    {
        "source": "Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own [`as_ptr`][slice::as_ptr] method to get a read-only raw pointer to pass to extern functions.",
        "suggest": "一旦有了所需的切片类型 (带或不带 nul 终止符)，就可以调用切片自己的 [`as_ptr`][slice::as_ptr] 方法来获取只读的裸指针，以将其传递给 extern 函数。",
        "translate": ""
    },
    {
        "source": "See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.",
        "suggest": "有关确保裸指针的生命周期的讨论，请参见该函数的文档。",
        "translate": ""
    },
    {
        "source": "is intended for working with traditional C-style strings (a sequence of non-nul bytes terminated by a single nul byte);",
        "suggest": "用于处理传统的 C 样式字符串 (由单个 nul 字节终止的非 nul 字节序列) ;",
        "translate": ""
    },
    {
        "source": "the primary use case for these kinds of strings is interoperating with C-like code.",
        "suggest": "这些类型的字符串的主要用例是与类似 C 的代码进行互操作。",
        "translate": ""
    },
    {
        "source": "Often you will need to transfer ownership to/from that external code.",
        "suggest": "通常，您将需要转让该外部代码的所有权 to/from。",
        "translate": ""
    },
    {
        "source": "It is strongly recommended that you thoroughly read through the documentation of `CString` before use, as improper ownership management of `CString` instances can lead to invalid memory accesses, memory leaks, and other memory errors.",
        "suggest": "强烈建议您在使用 `CString` 之前通读 `CString` 文档，因为对 `CString` 实例的所有权管理不当会导致无效的内存访问，内存泄漏和其他内存错误。",
        "translate": ""
    },
    {
        "source": "Invariant 1: the slice ends with a zero byte and has a length of at least one.",
        "suggest": "不变式 1: 切片的结尾为零字节，长度至少为一。",
        "translate": ""
    },
    {
        "source": "Invariant 2: the slice contains only one zero byte.",
        "suggest": "不变式 2: 切片仅包含一个零字节。",
        "translate": ""
    },
    {
        "source": "Improper usage of unsafe function can break Invariant 2, but not Invariant 1.",
        "suggest": "错误使用不安全的函数会破坏不变式 2，但不会破坏不变式 1。",
        "translate": ""
    },
    {
        "source": "Representation of a borrowed C string.",
        "suggest": "借用的 C 字符串的表示形式。",
        "translate": ""
    },
    {
        "source": "This type represents a borrowed reference to a nul-terminated array of bytes.",
        "suggest": "此类型表示对以 n 结尾的字节数组的引用。",
        "translate": ""
    },
    {
        "source": "It can be constructed safely from a `&[`[`u8`]`]` slice, or unsafely from a raw `*const c_char`.",
        "suggest": "可以从 `&[`[`u8`]`]` 切片安全地构造它，也可以从原始 `*const c_char` 不安全地构造它。",
        "translate": ""
    },
    {
        "source": "It can then be converted to a Rust [`&str`] by performing UTF-8 validation, or into an owned [`CString`].",
        "suggest": "然后可以通过执行 UTF-8 验证将其转换为 Rust [`&str`]，或转换为拥有的 [`CString`]。",
        "translate": ""
    },
    {
        "source": "is to [`CString`] as [`&str`] is to [`String`]: the former in each pair are borrowed references;",
        "suggest": "是 [`CString`] 就像 [`&str`] 到 [`String`]: 每对中的前者都是借来的;",
        "translate": ""
    },
    {
        "source": "the latter are owned strings.",
        "suggest": "后者是拥有的字符串。",
        "translate": ""
    },
    {
        "source": "Note that this structure is **not** `repr(C)` and is not recommended to be placed in the signatures of FFI functions.",
        "suggest": "请注意，此结构体不是 `repr(C)`，不建议放置在 FFI 函数的签名中。",
        "translate": ""
    },
    {
        "source": "Instead, safe wrappers of FFI functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide a safe interface to other consumers.",
        "suggest": "而是，FFI 函数的安全包装程序可以利用不安全的 [`CStr::from_ptr`] 构造函数为其他使用者提供安全的接口。",
        "translate": ""
    },
    {
        "source": "Inspecting a foreign C string:",
        "suggest": "检查外部 C 字符串:",
        "translate": ""
    },
    {
        "source": "Passing a Rust-originating C string:",
        "suggest": "传递源自 Rust 的 C 字符串:",
        "translate": ""
    },
    {
        "source": "Converting a foreign C string into a Rust [`String`]:",
        "suggest": "将外部 C 字符串转换为 Rust [`String`]:",
        "translate": ""
    },
    {
        "source": "in `impl From<&CStr> for Box<CStr>` current implementation relies on `CStr` being layout-compatible with `[u8]`.",
        "suggest": "在 `impl From<&CStr> for Box<CStr>` 中，当前实现依赖于 `CStr` 在布局上与 `[u8]` 兼容。",
        "translate": ""
    },
    {
        "source": "When attribute privacy is implemented, `CStr` should be annotated as `#[repr(transparent)]`.",
        "suggest": "实现属性隐私时，应将 `CStr` 注解为 `#[repr(transparent)]`。",
        "translate": ""
    },
    {
        "source": "Anyway, `CStr` representation and layout are considered implementation detail, are not documented and must not be relied upon.",
        "suggest": "无论如何，`CStr` 表示形式和布局被视为实现细节，没有文档记录，因此不能依赖。",
        "translate": ""
    },
    {
        "source": "this should not be represented with a DST slice but rather with just a raw `c_char` along with some form of marker to make this an unsized type.",
        "suggest": "这不应该用 DST 切片来表示，而只能用原始 `c_char` 以及某种形式的标记将其表示为未定义大小的类型。",
        "translate": ""
    },
    {
        "source": "Essentially `sizeof(&CStr)` should be the same as `sizeof(&c_char)` but `CStr` should be an unsized type.",
        "suggest": "本质上，`sizeof(&CStr)` 应该与 `sizeof(&c_char)` 相同，但是 `CStr` 应该是未定义大小的类型。",
        "translate": ""
    },
    {
        "source": "An error indicating that an interior nul byte was found.",
        "suggest": "指示发现内部 nul 字节的错误。",
        "translate": ""
    },
    {
        "source": "While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.",
        "suggest": "尽管 Rust 字符串的中间可能包含 nul 个字节，但 C 字符串却不能，因为该字节会有效地截断该字符串。",
        "translate": ""
    },
    {
        "source": "This error is created by the [`new`][`CString::new`] method on [`CString`].",
        "suggest": "该错误是由 [`CString`] 上的 [`new`][`CString::new`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An error indicating that a nul byte was not in the expected position.",
        "suggest": "指示 nul 字节不在预期位置中的错误。",
        "translate": ""
    },
    {
        "source": "The slice used to create a [`CStr`] must have one and only one nul byte, positioned at the end.",
        "suggest": "用于创建 [`CStr`] 的切片必须位于末尾且只有一个 nul 字节。",
        "translate": ""
    },
    {
        "source": "This error is created by the [`CStr::from_bytes_with_nul`] method.",
        "suggest": "此错误是由 [`CStr::from_bytes_with_nul`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "The vector used to create a [`CString`] must have one and only one nul byte, positioned at the end.",
        "suggest": "用于创建 [`CString`] 的 vector 的末尾必须只有一个 nul 字节。",
        "translate": ""
    },
    {
        "source": "This error is created by the [`CString::from_vec_with_nul`] method.",
        "suggest": "此错误是由 [`CString::from_vec_with_nul`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Returns a slice of [`u8`]s bytes that were attempted to convert to a [`CString`].",
        "suggest": "返回试图转换为 [`CString`] 的 [u8] s 个字节的片段。",
        "translate": ""
    },
    {
        "source": "Returns the bytes that were attempted to convert to a [`CString`].",
        "suggest": "返回尝试转换为 [`CString`] 的字节。",
        "translate": ""
    },
    {
        "source": "An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].",
        "suggest": "将 [`CString`] 转换为 [`String`] 时，指示 UTF-8 无效的错误。",
        "translate": ""
    },
    {
        "source": "is just a wrapper over a buffer of bytes with a nul terminator;",
        "suggest": "只是带有 nul 终止符的字节缓冲区的包装器;",
        "translate": ""
    },
    {
        "source": "performs UTF-8 validation on those bytes and may return this error.",
        "suggest": "对那些字节执行 UTF-8 验证，并可能返回此错误。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`CString::into_string()`].",
        "suggest": "该 `struct` 由 [`CString::into_string()`] 创建。",
        "translate": ""
    },
    {
        "source": "Creates a new C-compatible string from a container of bytes.",
        "suggest": "从字节容器创建一个新的 C 兼容字符串。",
        "translate": ""
    },
    {
        "source": "This function will consume the provided data and use the underlying bytes to construct a new string, ensuring that there is a trailing 0 byte.",
        "suggest": "此函数将使用提供的数据，并使用基础字节构造新的字符串，从而确保尾随 0 字节。",
        "translate": ""
    },
    {
        "source": "This trailing 0 byte will be appended by this function;",
        "suggest": "此函数的末尾将附加这个 0 字节;",
        "translate": ""
    },
    {
        "source": "the provided data should *not* contain any 0 bytes in it.",
        "suggest": "提供的数据不应包含任何 0 字节。",
        "translate": ""
    },
    {
        "source": "This function will return an error if the supplied bytes contain an internal 0 byte.",
        "suggest": "如果提供的字节包含内部 0 字节，则此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "The [`NulError`] returned will contain the bytes as well as the position of the nul byte.",
        "suggest": "返回的 [`NulError`] 将包含字节以及 nul 字节的位置。",
        "translate": ""
    },
    {
        "source": "Specialization for avoiding reallocation.",
        "suggest": "避免重新分配的专业化。",
        "translate": ""
    },
    {
        "source": "Creates a C-compatible string by consuming a byte vector, without checking for interior 0 bytes.",
        "suggest": "通过使用字节 vector 来创建 C 兼容字符串，而无需检查内部 0 字节。",
        "translate": ""
    },
    {
        "source": "This method is equivalent to [`CString::new`] except that no runtime assertion is made that `v` contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.",
        "suggest": "此方法等效于 [`CString::new`]，除了不进行运行时断言，即 `v` 不包含 0 字节，并且它需要实际的字节 vector，而不是可以使用 Into 转换为 1 的任何内容。",
        "translate": ""
    },
    {
        "source": "Retakes ownership of a `CString` that was transferred to C via [`CString::into_raw`].",
        "suggest": "重新获得通过 [`CString::into_raw`] 转移到 C 的 `CString` 的所有权。",
        "translate": ""
    },
    {
        "source": "Additionally, the length of the string will be recalculated from the pointer.",
        "suggest": "此外，将根据指针重新计算字符串的长度。",
        "translate": ""
    },
    {
        "source": "This should only ever be called with a pointer that was earlier obtained by calling [`CString::into_raw`].",
        "suggest": "仅应使用先前通过调用 [`CString::into_raw`] 获得的指针进行调用。",
        "translate": ""
    },
    {
        "source": "Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.",
        "suggest": "其他用法 (例如，尝试获取由外来代码分配的字符串的所有权) 可能导致未定义的行为或分配器损坏。",
        "translate": ""
    },
    {
        "source": "It should be noted that the length isn't just \"recomputed,\" but that the recomputed length must match the original length from the [`CString::into_raw`] call.",
        "suggest": "应该注意的是，长度不仅是 \"recomputed,\"，而且重新计算的长度必须与 [`CString::into_raw`] 调用的原始长度匹配。",
        "translate": ""
    },
    {
        "source": "This means the [`CString::into_raw`]/`from_raw` methods should not be used when passing the string to C functions that can modify the string's length.",
        "suggest": "这意味着在将字符串传递到可以修改字符串长度的 C 函数时，不应使用 [`CString::into_raw`]/`from_raw` 方法。",
        "translate": ""
    },
    {
        "source": "If you need to borrow a string that was allocated by",
        "suggest": "如果您需要借用由",
        "translate": ""
    },
    {
        "source": "foreign code, use [`CStr`].",
        "suggest": "外码，请使用 [`CStr`]。",
        "translate": ""
    },
    {
        "source": "If you need to take ownership of",
        "suggest": "如果您需要拥有",
        "translate": ""
    },
    {
        "source": "a string that was allocated by foreign code, you will need to",
        "suggest": "由外来代码分配的字符串，您将需要",
        "translate": ""
    },
    {
        "source": "make your own provisions for freeing it appropriately, likely",
        "suggest": "制定自己的规定以适当地，可能地释放它",
        "translate": ""
    },
    {
        "source": "with the foreign code's API to do that.",
        "suggest": "使用外来代码的 API 来做到这一点。",
        "translate": ""
    },
    {
        "source": "Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake ownership with `from_raw`:",
        "suggest": "创建一个 `CString`，将所有权传递给 `extern` 函数 (通过裸指针)，然后使用 `from_raw` 重新获得所有权:",
        "translate": ""
    },
    {
        "source": "This is called with a pointer that was obtained from a call to `CString::into_raw` and the length has not been modified.",
        "suggest": "这是通过从 `CString::into_raw` 调用获得的指针来调用的，并且长度没有被修改。",
        "translate": ""
    },
    {
        "source": "As such, we know there is a NUL byte (and only one) at the end and that the information about the size of the allocation is correct on Rust's side.",
        "suggest": "因此，我们知道在末尾有一个 NUL 字节 (只有一个)，并且有关分配大小的信息在 Rust 侧是正确的。",
        "translate": ""
    },
    {
        "source": "Including the NUL byte",
        "suggest": "包括 NUL 字节",
        "translate": ""
    },
    {
        "source": "Consumes the `CString` and transfers ownership of the string to a C caller.",
        "suggest": "消耗 `CString`，并将字符串的所有权转让给 C 调用者。",
        "translate": ""
    },
    {
        "source": "The pointer which this function returns must be returned to Rust and reconstituted using [`CString::from_raw`] to be properly deallocated.",
        "suggest": "此函数返回的指针必须返回到 Rust，并使用 [`CString::from_raw`] 进行重构以正确释放。",
        "translate": ""
    },
    {
        "source": "Specifically, one should *not* use the standard C `free()` function to deallocate this string.",
        "suggest": "具体来说，应该 *不要* 使用标准的 C `free()` 函数来释放该字符串。",
        "translate": ""
    },
    {
        "source": "Failure to call [`CString::from_raw`] will lead to a memory leak.",
        "suggest": "未能调用 [`CString::from_raw`] 将导致内存泄漏。",
        "translate": ""
    },
    {
        "source": "The C side must **not** modify the length of the string (by writing a `NULL` somewhere inside the string or removing the final one) before it makes it back into Rust using [`CString::from_raw`].",
        "suggest": "C 端必须在通过 [`CString::from_raw`] 将其返回到 Rust 之前，不可以修改字符串的长度 (通过在字符串内的某个地方编写 `NULL` 或删除最后一个) 来修改字符串的长度。",
        "translate": ""
    },
    {
        "source": "See the safety section in [`CString::from_raw`].",
        "suggest": "请参见 [`CString::from_raw`] 中的安全性部分。",
        "translate": ""
    },
    {
        "source": "Converts the `CString` into a [`String`] if it contains valid UTF-8 data.",
        "suggest": "如果 `CString` 包含有效的 UTF-8 数据，则将其转换为 [`String`]。",
        "translate": ""
    },
    {
        "source": "On failure, ownership of the original `CString` is returned.",
        "suggest": "失败时，将返回原始 `CString` 的所有权。",
        "translate": ""
    },
    {
        "source": "Consumes the `CString` and returns the underlying byte buffer.",
        "suggest": "消耗 `CString` 并返回基础的字节缓冲区。",
        "translate": ""
    },
    {
        "source": "The returned buffer does **not** contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.",
        "suggest": "返回的缓冲区不包含尾随 nul 终止符，并且保证不包含任何内部 nul 字节。",
        "translate": ""
    },
    {
        "source": "Equivalent to [`CString::into_bytes()`] except that the returned vector includes the trailing nul terminator.",
        "suggest": "等效于 [`CString::into_bytes()`]，除了返回的 vector 包括结尾的 nul 终止符。",
        "translate": ""
    },
    {
        "source": "Returns the contents of this `CString` as a slice of bytes.",
        "suggest": "以字节片形式返回此 `CString` 的内容。",
        "translate": ""
    },
    {
        "source": "The returned slice does **not** contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.",
        "suggest": "返回的切片不包含尾随 nul 终止符，并且保证不包含任何内部 nul 字节。",
        "translate": ""
    },
    {
        "source": "If you need the nul terminator, use [`CString::as_bytes_with_nul`] instead.",
        "suggest": "如果需要 nul 终止符，请改用 [`CString::as_bytes_with_nul`]。",
        "translate": ""
    },
    {
        "source": "Equivalent to [`CString::as_bytes()`] except that the returned slice includes the trailing nul terminator.",
        "suggest": "等效于 [`CString::as_bytes()`]，但返回的切片包括结尾的 nul 终止符。",
        "translate": ""
    },
    {
        "source": "Extracts a [`CStr`] slice containing the entire string.",
        "suggest": "提取包含整个字符串的 [`CStr`] 切片。",
        "translate": ""
    },
    {
        "source": "Converts this `CString` into a boxed [`CStr`].",
        "suggest": "将此 `CString` 转换为 boxed [`CStr`]。",
        "translate": ""
    },
    {
        "source": "Bypass \"move out of struct which implements [`Drop`] trait\" restriction.",
        "suggest": "绕过 \"move out of struct which implements [`Drop`] trait\" 限制。",
        "translate": ""
    },
    {
        "source": "Rationale: `mem::forget(self)` invalidates the previous call to `ptr::read(&self.inner)` so we use `ManuallyDrop` to ensure `self` is not dropped.",
        "suggest": "理由: `mem::forget(self)` 使对 `ptr::read(&self.inner)` 的先前调用无效，因此我们使用 `ManuallyDrop` 来确保不删除 `self`。",
        "translate": ""
    },
    {
        "source": "Then we can return the box directly without invalidating it.",
        "suggest": "然后我们可以直接返回 box 而不会使其无效。",
        "translate": ""
    },
    {
        "source": "Converts a [`Vec`]`<u8>` to a [`CString`] without checking the invariants on the given [`Vec`].",
        "suggest": "将 [`Vec`]`<u8>` 转换为 [`CString`]，而不检查给定 [`Vec`] 的不变式。",
        "translate": ""
    },
    {
        "source": "The given [`Vec`] **must** have one nul byte as its last element.",
        "suggest": "给定的 [`Vec`] 必须最后一个元素为一个 nul 字节。",
        "translate": ""
    },
    {
        "source": "This means it cannot be empty nor have any other nul byte anywhere else.",
        "suggest": "这意味着它不能为空，也不能在其他任何地方有任何其他 nul 字节。",
        "translate": ""
    },
    {
        "source": "Attempts to converts a [`Vec`]`<u8>` to a [`CString`].",
        "suggest": "尝试将 [`Vec`]`<u8>` 转换为 [`CString`]。",
        "translate": ""
    },
    {
        "source": "Runtime checks are present to ensure there is only one nul byte in the [`Vec`], its last element.",
        "suggest": "存在运行时检查以确保 [`Vec`] (它的最后一个元素) 中只有一个 nul 字节。",
        "translate": ""
    },
    {
        "source": "If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.",
        "suggest": "如果存在 nul 字节而不是最后一个元素，或者不存在 nul 字节，则将返回错误。",
        "translate": ""
    },
    {
        "source": "A successful conversion will produce the same result as [`CString::new`] when called without the ending nul byte.",
        "suggest": "如果调用成功而没有结尾的 nul 字节，则转换将产生与 [`CString::new`] 相同的结果。",
        "translate": ""
    },
    {
        "source": "A incorrectly formatted [`Vec`] will produce an error.",
        "suggest": "格式错误的 [`Vec`] 将产生错误。",
        "translate": ""
    },
    {
        "source": "We know there is only one nul byte, at the end of the vec.",
        "suggest": "我们知道在 vec 的末尾只有一个 nul 字节。",
        "translate": ""
    },
    {
        "source": "Turns this `CString` into an empty string to prevent memory-unsafe code from working by accident.",
        "suggest": "将此 `CString` 转换为空字符串，以防止意外执行内存不安全代码。",
        "translate": ""
    },
    {
        "source": "Inline to prevent LLVM from optimizing it away in debug builds.",
        "suggest": "内联以防止 LLVM 在调试版本中进行优化。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a [`Vec`]`<u8>`.",
        "suggest": "将 [`CString`] 转换为 [`Vec`]`<u8>`。",
        "translate": ""
    },
    {
        "source": "The conversion consumes the [`CString`], and removes the terminating NUL byte.",
        "suggest": "转换消耗 [`CString`]，并删除终止的 NUL 字节。",
        "translate": ""
    },
    {
        "source": "Creates an empty `CString`.",
        "suggest": "创建一个空的 `CString`。",
        "translate": ""
    },
    {
        "source": "Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`Box`]`<CStr>` 转换为 [`CString`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`Vec`]`<`[`NonZeroU8`]`>` into a [`CString`] without copying nor checking for inner null bytes.",
        "suggest": "将 [`Vec`]`<`[`NonZeroU8`]`>` 转换为 [`CString`]，而无需复制或检查内部空字节。",
        "translate": ""
    },
    {
        "source": "Transmute `Vec<NonZeroU8>` to `Vec<u8>`.",
        "suggest": "将 `Vec<NonZeroU8>` 转换为 `Vec<u8>`。",
        "translate": ""
    },
    {
        "source": "transmuting between `NonZeroU8` and `u8` is sound;",
        "suggest": "`NonZeroU8` 和 `u8` 之间的转换是声音;",
        "translate": ""
    },
    {
        "source": "`v` cannot contain null bytes, given the type-level invariant of `NonZeroU8`.",
        "suggest": "给定 `NonZeroU8` 的类型级别不变性，`v` 不能包含空字节。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为 [`Box`]`<CStr>`。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为 [`Arc`]`<CStr>`。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为 [`Rc`]`<CStr>`。",
        "translate": ""
    },
    {
        "source": "Returns the position of the nul byte in the slice that caused [`CString::new`] to fail.",
        "suggest": "返回导致 [`CString::new`] 失败的切片中 nul 字节的位置。",
        "translate": ""
    },
    {
        "source": "Consumes this error, returning the underlying vector of bytes which generated the error in the first place.",
        "suggest": "消耗此错误，返回底层的 vector 字节，该字节首先生成错误。",
        "translate": ""
    },
    {
        "source": "Converts a [`NulError`] into a [`io::Error`].",
        "suggest": "将 [`NulError`] 转换为 [`io::Error`]。",
        "translate": ""
    },
    {
        "source": "Consumes this error, returning original [`CString`] which generated the error.",
        "suggest": "消耗此错误，返回产生错误的原始 [`CString`]。",
        "translate": ""
    },
    {
        "source": "Access the underlying UTF-8 error that was the cause of this error.",
        "suggest": "访问根本的 UTF-8 错误，该错误是引起此错误的原因。",
        "translate": ""
    },
    {
        "source": "Wraps a raw C string with a safe C string wrapper.",
        "suggest": "用安全的 C 字符串包装器包装原始 C 字符串。",
        "translate": ""
    },
    {
        "source": "This function will wrap the provided `ptr` with a `CStr` wrapper, which allows inspection and interoperation of non-owned C strings.",
        "suggest": "此函数将使用 `CStr` 包装器包装提供的 `ptr`，从而允许检查和互操作非所有的 C 字符串。",
        "translate": ""
    },
    {
        "source": "The total size of the raw C string must be smaller than `isize::MAX` **bytes** in memory due to calling the `slice::from_raw_parts` function.",
        "suggest": "由于调用了 `slice::from_raw_parts` 函数，原始 C 字符串的总大小必须小于 `isize::MAX` 字节` 在内存中。",
        "translate": ""
    },
    {
        "source": "This method is unsafe for a number of reasons:",
        "suggest": "由于多种原因，此方法不安全:",
        "translate": ""
    },
    {
        "source": "There is no guarantee to the validity of `ptr`.",
        "suggest": "不能保证 `ptr` 的有效性。",
        "translate": ""
    },
    {
        "source": "The returned lifetime is not guaranteed to be the actual lifetime of `ptr`.",
        "suggest": "不能保证返回的生命周期是 `ptr` 的实际生命周期。",
        "translate": ""
    },
    {
        "source": "There is no guarantee that the memory pointed to by `ptr` contains a valid nul terminator byte at the end of the string.",
        "suggest": "不能保证 `ptr` 指向的内存在字符串末尾包含有效的 nul 终止符字节。",
        "translate": ""
    },
    {
        "source": "It is not guaranteed that the memory pointed by `ptr` won't change before the `CStr` has been destroyed.",
        "suggest": "不能保证 `ptr` 指向的内存在 `CStr` 被销毁之前不会改变。",
        "translate": ""
    },
    {
        "source": "This operation is intended to be a 0-cost cast but it is",
        "suggest": "该操作原定为零成本投放，但",
        "translate": ""
    },
    {
        "source": "currently implemented with an up-front calculation of the length of",
        "suggest": "目前已通过预先计算长度来实现",
        "translate": ""
    },
    {
        "source": "the string.",
        "suggest": "字符串。",
        "translate": ""
    },
    {
        "source": "This is not guaranteed to always be the case.",
        "suggest": "不能保证总是这样。",
        "translate": ""
    },
    {
        "source": "The caller has provided a pointer that points to a valid C string with a NUL terminator of size less than `isize::MAX`, whose content remain valid and doesn't change for the lifetime of the returned `CStr`.",
        "suggest": "调用方提供了一个指针，该指针指向大小小于 `isize::MAX` 的 NUL 终止符的有效 C 字符串，其内容保持有效，并且对于返回的 `CStr` 的生命周期不会更改。",
        "translate": ""
    },
    {
        "source": "Thus computing the length is fine (a NUL byte exists), the call to from_raw_parts is safe because we know the length is at most `isize::MAX`, meaning the call to `from_bytes_with_nul_unchecked` is correct.",
        "suggest": "这样计算长度就可以了 (存在一个 NUL 字节)，对 from_raw_parts 的调用是安全的，因为我们知道长度最多为 `isize::MAX`，这意味着对 `from_bytes_with_nul_unchecked` 的调用是正确的。",
        "translate": ""
    },
    {
        "source": "The cast from c_char to u8 is ok because a c_char is always one byte.",
        "suggest": "从 c_char 到 u8 的转换是可以的，因为 c_char 始终是一个字节。",
        "translate": ""
    },
    {
        "source": "Creates a C string wrapper from a byte slice.",
        "suggest": "从字节切片创建 C 字符串包装器。",
        "translate": ""
    },
    {
        "source": "This function will cast the provided `bytes` to a `CStr` wrapper after ensuring that the byte slice is nul-terminated and does not contain any interior nul bytes.",
        "suggest": "在确保字节切片以 nul 终止并且不包含任何内部 nul 字节之后，此函数会将提供的 `bytes` 强制转换为 `CStr` 包装器。",
        "translate": ""
    },
    {
        "source": "Creating a `CStr` without a trailing nul terminator is an error:",
        "suggest": "创建没有尾随 nul 终止符的 `CStr` 是错误的:",
        "translate": ""
    },
    {
        "source": "Creating a `CStr` with an interior nul byte is an error:",
        "suggest": "使用内部 nul 字节创建 `CStr` 是错误的:",
        "translate": ""
    },
    {
        "source": "Unsafely creates a C string wrapper from a byte slice.",
        "suggest": "从字节切片不安全地创建 C 字符串包装器。",
        "translate": ""
    },
    {
        "source": "This function will cast the provided `bytes` to a `CStr` wrapper without performing any sanity checks.",
        "suggest": "此函数会将提供的 `bytes` 强制转换为 `CStr` 包装器，而无需执行任何健全性检查。",
        "translate": ""
    },
    {
        "source": "The provided slice **must** be nul-terminated and not contain any interior nul bytes.",
        "suggest": "所提供的切片必须以 nul 结尾，并且不包含任何内部 nul 字节。",
        "translate": ""
    },
    {
        "source": "Casting to CStr is safe because its internal representation is a [u8] too (safe only inside std).",
        "suggest": "强制转换为 CStr 是安全的，因为其内部表示形式也是 [u8] (仅在 std 内部安全)。",
        "translate": ""
    },
    {
        "source": "Dereferencing the obtained pointer is safe because it comes from a reference.",
        "suggest": "解引用获得的指针是安全的，因为它来自引用。",
        "translate": ""
    },
    {
        "source": "Making a reference is then safe because its lifetime is bound by the lifetime of the given `bytes`.",
        "suggest": "这样，进行引用是安全的，因为其生命周期受给定 `bytes` 的生命周期的约束。",
        "translate": ""
    },
    {
        "source": "Returns the inner pointer to this C string.",
        "suggest": "返回此 C 字符串的内部指针。",
        "translate": ""
    },
    {
        "source": "The returned pointer will be valid for as long as `self` is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.",
        "suggest": "返回的指针在 `self` 内一直有效，并且指向以 0 字节结尾的连续区域，以表示字符串的结尾。",
        "translate": ""
    },
    {
        "source": "The returned pointer is read-only;",
        "suggest": "返回的指针是只读的;",
        "translate": ""
    },
    {
        "source": "writing to it (including passing it to C code that writes to it) causes undefined behavior.",
        "suggest": "对其进行写入 (包括将其传递给进行写入的 C 代码) 会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "It is your responsibility to make sure that the underlying memory is not freed too early.",
        "suggest": "您有责任确保底层内存不会过早释放。",
        "translate": ""
    },
    {
        "source": "For example, the following code will cause undefined behavior when `ptr` is used inside the `unsafe` block:",
        "suggest": "例如，当在 `unsafe` 块中使用 `ptr` 时，以下代码将导致未定义的行为:",
        "translate": ""
    },
    {
        "source": "This happens because the pointer returned by `as_ptr` does not carry any lifetime information and the [`CString`] is deallocated immediately after the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()` expression is evaluated.",
        "suggest": "发生这种情况是因为 `as_ptr` 返回的指针不携带任何生命周期信息，并且在评估 `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()` 表达式后立即释放了 [`CString`]。",
        "translate": ""
    },
    {
        "source": "To fix the problem, bind the `CString` to a local variable:",
        "suggest": "要解决此问题，请将 `CString` 绑定到本地变量:",
        "translate": ""
    },
    {
        "source": "This way, the lifetime of the [`CString`] in `hello` encompasses the lifetime of `ptr` and the `unsafe` block.",
        "suggest": "这样，`hello` 中 [`CString`] 的生命周期包含 `ptr` 和 `unsafe` 块的生命周期。",
        "translate": ""
    },
    {
        "source": "Converts this C string to a byte slice.",
        "suggest": "将此 C 字符串转换为字节片。",
        "translate": ""
    },
    {
        "source": "The returned slice will **not** contain the trailing nul terminator that this C string has.",
        "suggest": "返回的切片将不包含此 C 字符串具有的尾随 nul 终止符。",
        "translate": ""
    },
    {
        "source": "This method is currently implemented as a constant-time",
        "suggest": "该方法当前被实现为恒定时间",
        "translate": ""
    },
    {
        "source": "cast, but it is planned to alter its definition in the future to",
        "suggest": "强制转换，但计划将其在 future 中的定义更改为",
        "translate": ""
    },
    {
        "source": "perform the length calculation whenever this method is called.",
        "suggest": "每当调用此方法时，都要执行长度计算。",
        "translate": ""
    },
    {
        "source": "Converts this C string to a byte slice containing the trailing 0 byte.",
        "suggest": "将此 C 字符串转换为包含尾随 0 字节的字节切片。",
        "translate": ""
    },
    {
        "source": "This function is the equivalent of [`CStr::to_bytes`] except that it will retain the trailing nul terminator instead of chopping it off.",
        "suggest": "此函数与 [`CStr::to_bytes`] 等效，除了保留尾随的 nul 终止符而不是将其截断之外。",
        "translate": ""
    },
    {
        "source": "This method is currently implemented as a 0-cost cast, but",
        "suggest": "目前，此方法已实现为零费用强制转换，但是",
        "translate": ""
    },
    {
        "source": "it is planned to alter its definition in the future to perform the",
        "suggest": "计划在 future 中更改其定义以执行",
        "translate": ""
    },
    {
        "source": "length calculation whenever this method is called.",
        "suggest": "每次调用此方法时的长度计算。",
        "translate": ""
    },
    {
        "source": "Yields a [`&str`] slice if the `CStr` contains valid UTF-8.",
        "suggest": "如果 `CStr` 包含有效的 UTF-8，则产生 [`&str`] 切片。",
        "translate": ""
    },
    {
        "source": "If the contents of the `CStr` are valid UTF-8 data, this function will return the corresponding [`&str`] slice.",
        "suggest": "如果 `CStr` 的内容是有效的 UTF-8 数据，则此函数将返回相应的 [`&str`] 切片。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will return an error with details of where UTF-8 validation failed.",
        "suggest": "否则，它将返回错误，并详细说明 UTF-8 验证失败的位置。",
        "translate": ""
    },
    {
        "source": "N.B., when `CStr` is changed to perform the length check in `.to_bytes()` instead of in `from_ptr()`, it may be worth considering if this should be rewritten to do the UTF-8 check inline with the length calculation instead of doing it afterwards.",
        "suggest": "注意，将 `CStr` 更改为在 `.to_bytes()` 中而不是 `from_ptr()` 中执行长度检查时，可能值得考虑是否应该重写此代码，以便在进行长度计算时内联 UTF-8 检查，而不是随后进行。",
        "translate": ""
    },
    {
        "source": "Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.",
        "suggest": "将 `CStr` 转换为 [`Cow`]`<`[`str`]`>`。",
        "translate": ""
    },
    {
        "source": "If the contents of the `CStr` are valid UTF-8 data, this function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)` with the corresponding [`&str`] slice.",
        "suggest": "如果 `CStr` 的内容是有效的 UTF-8 数据，则此函数将返回带有相应 [`&str`] 切片的 [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will replace any invalid UTF-8 sequences with [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.",
        "suggest": "否则，它将用 [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] 替换所有无效的 UTF-8 序列，并返回带有结果的 [`Cow`]`::`[`Owned`]`(`[`String`]`)`。",
        "translate": ""
    },
    {
        "source": "Calling `to_string_lossy` on a `CStr` containing valid UTF-8:",
        "suggest": "在包含有效 UTF-8 的 `CStr` 上调用 `to_string_lossy`:",
        "translate": ""
    },
    {
        "source": "Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:",
        "suggest": "在包含无效 UTF-8 的 `CStr` 上调用 `to_string_lossy`:",
        "translate": ""
    },
    {
        "source": "we need to manually check the starting index to account for the null byte, since otherwise we could get an empty string that doesn't end in a null.",
        "suggest": "我们需要手动检查起始索引来说明空字节，因为否则我们会得到一个不以空结尾的空字符串。",
        "translate": ""
    },
    {
        "source": "Utilities related to FFI bindings.",
        "suggest": "与 FFI 绑定有关的实用工具。",
        "translate": ""
    },
    {
        "source": "This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system.",
        "suggest": "该模块提供了实用工具来处理跨非 Rust 接口的数据，例如其他编程语言和底层操作系统。",
        "translate": ""
    },
    {
        "source": "It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.",
        "suggest": "它主要用于 FFI (外部函数接口) 绑定和需要与其他语言交换类 C 字符串的代码。",
        "translate": ""
    },
    {
        "source": "Rust represents owned strings with the [`String`] type, and borrowed slices of strings with the [`str`] primitive.",
        "suggest": "Rust 代表 [`String`] 类型的拥有的字符串，而借用 [`str`] 原语的字符串切片。",
        "translate": ""
    },
    {
        "source": "Both are always in UTF-8 encoding, and may contain nul bytes in the middle, i.e., if you look at the bytes that make up the string, there may be a `\\0` among them.",
        "suggest": "两者始终都是 UTF-8 编码，并且中间可能包含 nul 个字节，即，如果您查看组成字符串的字节，则其中可能有一个 `\\0`。",
        "translate": ""
    },
    {
        "source": "Both `String` and `str` store their length explicitly;",
        "suggest": "`String` 和 `str` 都明确存储它们的长度。",
        "translate": ""
    },
    {
        "source": "there are no nul terminators at the end of strings like in C.",
        "suggest": "像 C 中的字符串末尾没有 nul 终止符。",
        "translate": ""
    },
    {
        "source": "C strings are different from Rust strings:",
        "suggest": "C 字符串不同于 Rust 字符串:",
        "translate": ""
    },
    {
        "source": "**Encodings** - Rust strings are UTF-8, but C strings may use other encodings.",
        "suggest": "**编码**-Rust 字符串是 UTF-8，但是 C 字符串可以使用其他编码。",
        "translate": ""
    },
    {
        "source": "If you are using a string from C, you should check its encoding explicitly, rather than just assuming that it is UTF-8 like you can do in Rust.",
        "suggest": "如果使用的是来自 C 的字符串，则应显式检查其编码，而不是像在 Rust 中那样假定它是 UTF-8。",
        "translate": ""
    },
    {
        "source": "**Character size** - C strings may use `char` or `wchar_t`-sized characters;",
        "suggest": "**字符大小**-C 字符串可以使用 `char` 或 `wchar_t` 大小的字符;",
        "translate": ""
    },
    {
        "source": "please **note** that C's `char` is different from Rust's.",
        "suggest": "请 **注意** C 的 `char` 与 Rust 的不同。",
        "translate": ""
    },
    {
        "source": "The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type.",
        "suggest": "C 标准使这些类型的实际大小易于解释，但是为由每个字符类型组成的字符串定义了不同的 API。",
        "translate": ""
    },
    {
        "source": "Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each.",
        "suggest": "Rust 字符串始终为 UTF-8，因此每个不同的 Unicode 字符将以可变的字节数进行编码。",
        "translate": ""
    },
    {
        "source": "The Rust type [`char`] represents a '[Unicode scalar value]', which is similar to, but not the same as, a '[Unicode code point]'.",
        "suggest": "Rust 类型 [`char`] 表示 `[Unicode 标量值]`，与 `[Unicode 代码点]` 相似但不相同。",
        "translate": ""
    },
    {
        "source": "**Nul terminators and implicit string lengths** - Often, C strings are nul-terminated, i.e., they have a `\\0` character at the end.",
        "suggest": "**Nul 终止符和隐式字符串长度**-C 字符串通常以 Nul 终止，即，它们的末尾有 `\\0` 字符。",
        "translate": ""
    },
    {
        "source": "The length of a string buffer is not stored, but has to be calculated;",
        "suggest": "字符串缓冲区的长度不存储，而是必须计算;",
        "translate": ""
    },
    {
        "source": "to compute the length of a string, C code must manually call a function like `strlen()` for `char`-based strings, or `wcslen()` for `wchar_t`-based ones.",
        "suggest": "要计算字符串的长度，C 代码必须手动调用一个函数，例如 `strlen()` 表示基于 char 的字符串，`wcslen()` 表示基于 wchar_t 的字符串。",
        "translate": ""
    },
    {
        "source": "Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really `len+1` characters.",
        "suggest": "这些函数返回字符串中不包括 nul 终止符的字符数，因此缓冲区长度实际上是 `len+1` 字符。",
        "translate": ""
    },
    {
        "source": "Rust strings don't have a nul terminator;",
        "suggest": "Rust 字符串没有 nul 终止符;",
        "translate": ""
    },
    {
        "source": "their length is always stored and does not need to be calculated.",
        "suggest": "它们的长度总是存储的，不需要计算。",
        "translate": ""
    },
    {
        "source": "While in Rust accessing a string's length is a `O(1)` operation (because the length is stored);",
        "suggest": "在 Rust 中，访问字符串的长度是 `O(1)` 操作 (因为存储了长度) ;",
        "translate": ""
    },
    {
        "source": "in C it is an `O(length)` operation because the length needs to be computed by scanning the string for the nul terminator.",
        "suggest": "在 C 中，它是 `O(length)` 操作，因为需要通过扫描字符串中的 nul 终止符来计算长度。",
        "translate": ""
    },
    {
        "source": "**Internal nul characters** - When C strings have a nul terminator character, this usually means that they cannot have nul characters in the middle — a nul character would essentially truncate the string.",
        "suggest": "**内部 nul 字符**- 当 C 字符串具有 nul 终止符时，这通常意味着它们中间不能包含 nul 字符 - nul 字符实际上会截断字符串。",
        "translate": ""
    },
    {
        "source": "Rust strings *can* have nul characters in the middle, because nul does not have to mark the end of the string in Rust.",
        "suggest": "Rust 字符串 *可以* 中间有 nul 个字符，因为 nul 不必在 Rust 中标记字符串的结尾。",
        "translate": ""
    },
    {
        "source": "Representations of non-Rust strings",
        "suggest": "非 Rust 字符串的表示形式",
        "translate": ""
    },
    {
        "source": "and [`CStr`] are useful when you need to transfer UTF-8 strings to and from languages with a C ABI, like Python.",
        "suggest": "当您需要在具有 C ABI 的语言之间来回传输 UTF-8 字符串时 (例如 Python)，X 和 [`CStr`] 很有用。",
        "translate": ""
    },
    {
        "source": "**From Rust to C:** [`CString`] represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters.",
        "suggest": "**从 Rust 到 C:**[`CString`] 表示一个拥有的，对 C 友好的字符串: 它是 nul 终止的，并且没有内部 nul 字符。",
        "translate": ""
    },
    {
        "source": "Rust code can create a [`CString`] out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw `*mut `[`u8`] that can then be passed as an argument to functions which use the C conventions for strings.",
        "suggest": "Rust 代码可以从普通字符串中创建 [`CString`] (前提是该字符串的中间没有 nul 字符)，然后使用多种方法来获取原始的 * mut [[u8]]，然后作为参数传递给使用 C 约定的字符串的函数。",
        "translate": ""
    },
    {
        "source": "**From C to Rust:** [`CStr`] represents a borrowed C string;",
        "suggest": "**从 C 到 Rust:**[`CStr`] 表示借用的 C 字符串;",
        "translate": ""
    },
    {
        "source": "it is what you would use to wrap a raw `*const `[`u8`] that you got from a C function.",
        "suggest": "这就是您用来包装从 C 函数获得的原始 `* const`[`u8`] 的方式。",
        "translate": ""
    },
    {
        "source": "A [`CStr`] is guaranteed to be a nul-terminated array of bytes.",
        "suggest": "[`CStr`] 保证是一个以 nul 结尾的字节数组。",
        "translate": ""
    },
    {
        "source": "Once you have a [`CStr`], you can convert it to a Rust [`&str`][`str`] if it's valid UTF-8, or lossily convert it by adding replacement characters.",
        "suggest": "拥有 [`CStr`] 后，可以将其转换为 Rust [`&str`][`str`] (如果它是有效的 UTF-8)，或者通过添加替换字符有损地对其进行转换。",
        "translate": ""
    },
    {
        "source": "and [`OsStr`] are useful when you need to transfer strings to and from the operating system itself, or when capturing the output of external commands.",
        "suggest": "当您需要在操作系统本身之间来回传输字符串，或者在捕获外部命令的输出时，X 和 [`OsStr`] 很有用。",
        "translate": ""
    },
    {
        "source": "Conversions between [`OsString`], [`OsStr`] and Rust strings work similarly to those for [`CString`] and [`CStr`].",
        "suggest": "[`OsString`]，[`OsStr`] 和 Rust 字符串之间的转换与 [`CString`] 和 [`CStr`] 的转换相似。",
        "translate": ""
    },
    {
        "source": "represents an owned string in whatever representation the operating system prefers.",
        "suggest": "以操作系统喜欢的任何表示形式表示一个拥有的字符串。",
        "translate": ""
    },
    {
        "source": "In the Rust standard library, various APIs that transfer strings to/from the operating system use [`OsString`] instead of plain strings.",
        "suggest": "在 Rust 标准库中，用于传输字符串 to/from 的各种 API，操作系统使用 [`OsString`] 代替纯字符串。",
        "translate": ""
    },
    {
        "source": "For example, [`env::var_os()`] is used to query environment variables;",
        "suggest": "例如，[`env::var_os()`] 用于查询环境变量;",
        "translate": ""
    },
    {
        "source": "it returns an [`Option`]`<`[`OsString`]`>`.",
        "suggest": "它返回一个 [`Option`]`<`[`OsString`]`>`。",
        "translate": ""
    },
    {
        "source": "If the environment variable exists you will get a [`Some`]`(os_string)`, which you can *then* try to convert to a Rust string.",
        "suggest": "如果环境变量存在，您将得到一个 [`Some`]`(os_string)`，然后您可以 *然后* 尝试将其转换为 Rust 字符串。",
        "translate": ""
    },
    {
        "source": "This yields a [`Result`], so that your code can detect errors in case the environment variable did not in fact contain valid Unicode data.",
        "suggest": "这将产生一个 [`Result`]，以便在环境变量实际上不包含有效的 Unicode 数据的情况下，您的代码可以检测到错误。",
        "translate": ""
    },
    {
        "source": "represents a borrowed reference to a string in a format that can be passed to the operating system.",
        "suggest": "表示借用字符串引用的形式，该形式可以传递给操作系统。",
        "translate": ""
    },
    {
        "source": "It can be converted into an UTF-8 Rust string slice in a similar way to [`OsString`].",
        "suggest": "可以按照与 [`OsString`] 相似的方式将其转换为 UTF-8 Rust 字符串切片。",
        "translate": ""
    },
    {
        "source": "On Unix",
        "suggest": "在 Unix 上",
        "translate": ""
    },
    {
        "source": "On Unix, [`OsStr`] implements the `std::os::unix::ffi::`[`OsStrExt`][unix.OsStrExt] trait, which augments it with two methods, [`from_bytes`] and [`as_bytes`].",
        "suggest": "在 Unix 上，[`OsStr`] 实现了 std::ffi::`[`OsStrExt`][unix.OsStrExt] trait，并使用两种方法 [`from_bytes`] 和 [`as_bytes`] 对其进行了扩充。",
        "translate": ""
    },
    {
        "source": "These do inexpensive conversions from and to UTF-8 byte slices.",
        "suggest": "它们可以进行 UTF-8 字节片和 UTF-8 字节片之间的廉价转换。",
        "translate": ""
    },
    {
        "source": "Additionally, on Unix [`OsString`] implements the `std::os::unix::ffi::`[`OsStringExt`][unix.OsStringExt] trait, which provides [`from_vec`] and [`into_vec`] methods that consume their arguments, and take or produce vectors of [`u8`].",
        "suggest": "此外，在 Unix 上，[`OsString`] 实现了 std::ffi::`[OsStringExt]][unix.OsStringExt] trait，它提供了 [`from_vec`] 和 [`into_vec`] 方法，这些方法使用其参数，并采用或产生 vectors 作为 [`u8`]。",
        "translate": ""
    },
    {
        "source": "On Windows",
        "suggest": "在 Windows 上",
        "translate": ""
    },
    {
        "source": "On Windows, [`OsStr`] implements the `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait, which provides an [`encode_wide`] method.",
        "suggest": "在 Windows 上，[`OsStr`] 实现了 std::ffi::`[`OsStrExt`][windows.OsStrExt] trait，它提供了 [`encode_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "This provides an iterator that can be [`collect`]ed into a vector of [`u16`].",
        "suggest": "这提供了一个迭代器，可以将其迭代到 [`u16`] 的 vector 中。",
        "translate": ""
    },
    {
        "source": "Additionally, on Windows [`OsString`] implements the `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt] trait, which provides a [`from_wide`] method.",
        "suggest": "另外，在 Windows 上，[`OsString`] 实现了 std::windows: ffi::`[`OsStringExt`][windows.OsStringExt] trait，它提供了 [`from_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "The result of this method is an [`OsString`] which can be round-tripped to a Windows string losslessly.",
        "suggest": "此方法的结果是一个 [`OsString`]，它可以无损地往返于 Windows 字符串。",
        "translate": ""
    },
    {
        "source": "This push is done without reallocating",
        "suggest": "无需重新分配即可完成此推送",
        "translate": ""
    },
    {
        "source": "Note, due to differences in how Unix and Windows represent strings, we are forced to complicate this example, setting up example `OsStr`s with different source data and via different platform extensions.",
        "suggest": "注意，由于 Unix 和 Windows 表示字符串的方式不同，我们不得不使该示例复杂化，使用不同的源数据和通过不同的平台扩展来设置示例 `OsStr`。",
        "translate": ""
    },
    {
        "source": "Understand that in reality you could end up with such example invalid sequences simply through collecting user command line arguments, for example.",
        "suggest": "可以理解，实际上，仅通过收集用户命令行参数，您就可以得到这样的示例无效序列。",
        "translate": ""
    },
    {
        "source": "Here, the values 0x66 and 0x6f correspond to 'f' and 'o' respectively.",
        "suggest": "此处，值 0x66 和 0x6f 分别对应于 'f' 和 'o'。",
        "translate": ""
    },
    {
        "source": "The value 0x80 is a lone continuation byte, invalid in a UTF-8 sequence.",
        "suggest": "值 0x80 是一个单独的连续字节，在 UTF-8 序列中无效。",
        "translate": ""
    },
    {
        "source": "Here the values 0x0066 and 0x006f correspond to 'f' and 'o' respectively.",
        "suggest": "在此，值 0x0066 和 0x006f 分别对应于 'f' 和 'o'。",
        "translate": ""
    },
    {
        "source": "The value 0xD800 is a lone surrogate half, invalid in a UTF-16 sequence.",
        "suggest": "值 0xD800 是一个单独的替代一半，在 UTF-16 序列中无效。",
        "translate": ""
    },
    {
        "source": "A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.",
        "suggest": "一种类型，可以表示拥有的，可变的平台原生字符串，但可以廉价地与 Rust 字符串互转换。",
        "translate": ""
    },
    {
        "source": "The need for this type arises from the fact that:",
        "suggest": "对这种类型的需求源于以下事实:",
        "translate": ""
    },
    {
        "source": "On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.",
        "suggest": "在 Unix 系统上，字符串通常是非零字节的任意序列，在许多情况下解释为 UTF-8。",
        "translate": ""
    },
    {
        "source": "On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.",
        "suggest": "在 Windows 上，字符串通常是非零的 16 位值的任意序列，如果有效，则将其解释为 UTF-16。",
        "translate": ""
    },
    {
        "source": "In Rust, strings are always valid UTF-8, which may contain zeros.",
        "suggest": "在 Rust 中，字符串始终是有效的 UTF-8，其中可能包含零。",
        "translate": ""
    },
    {
        "source": "and [`OsStr`] bridge this gap by simultaneously representing Rust and platform-native string values, and in particular allowing a Rust string to be converted into an \"OS\" string with no cost if possible.",
        "suggest": "[`OsStr`] 和 [`OsStr`] 通过同时表示 Rust 和平台原生字符串值来弥合这种差距，并且特别是允许将 Rust 字符串尽可能地转换为 \"OS\" 字符串。",
        "translate": ""
    },
    {
        "source": "A consequence of this is that `OsString` instances are *not* `NUL` terminated;",
        "suggest": "这样的结果是 `OsString` 实例不是 * `NUL` 终止的;",
        "translate": ""
    },
    {
        "source": "in order to pass to e.g., Unix system call, you should create a [`CStr`].",
        "suggest": "为了传递给例如 Unix 系统调用，您应该创建一个 [`CStr`]。",
        "translate": ""
    },
    {
        "source": "is to [`&OsStr`] as [`String`] is to [`&str`]: the former in each pair are owned strings;",
        "suggest": "对 [`&OsStr`] 就像对 [`String`] 对 [`&str`] 一样: 每对中的前者是拥有的字符串;",
        "translate": ""
    },
    {
        "source": "Note, `OsString` and [`OsStr`] internally do not necessarily hold strings in the form native to the platform;",
        "suggest": "注意，`OsString` 和 [`OsStr`] 在内部不一定要以平台固有的形式保存字符串。",
        "translate": ""
    },
    {
        "source": "While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8.",
        "suggest": "在 Unix 上，字符串存储为 8 位值的序列，而在 Windows 上，字符串如刚刚讨论的那样是 16 位值，实际上，字符串也存储为 8 位值的序列，并以 UTF-8 的严格成员。",
        "translate": ""
    },
    {
        "source": "This is useful to understand when handling capacity and length values.",
        "suggest": "这对于理解处理容量和长度值时很有用。",
        "translate": ""
    },
    {
        "source": "Creating an `OsString`",
        "suggest": "创建一个 `OsString`",
        "translate": ""
    },
    {
        "source": "**From a Rust string**: `OsString` implements [`From`]`<`[`String`]`>`, so you can use `my_string.from` to create an `OsString` from a normal Rust string.",
        "suggest": "**从 Rust 字符串**: `OsString` 实现 [`From`]`<`[`String`]`>`，因此您可以使用 `my_string.from` 从普通的 Rust 字符串创建 `OsString`。",
        "translate": ""
    },
    {
        "source": "**From slices:** Just like you can start with an empty Rust [`String`] and then [`String::push_str`] `&str` sub-string slices into it, you can create an empty `OsString` with the [`OsString::new`] method and then push string slices into it with the [`OsString::push`] method.",
        "suggest": "**从切片:** 就像您可以先从一个空的 Rust [`String`] 开始，然后将 [`String::push_str`] `&str` 子字符串切片放入其中一样，您可以使用 [`OsString::new`] 方法创建一个空的 `OsString`，然后使用 [`OsString::push`] 方法将其插入到其中。",
        "translate": ""
    },
    {
        "source": "Extracting a borrowed reference to the whole OS string",
        "suggest": "提取整个操作系统字符串中的借用引用",
        "translate": ""
    },
    {
        "source": "You can use the [`OsString::as_os_str`] method to get an `&`[`OsStr`] from an `OsString`;",
        "suggest": "您可以使用 [`OsString::as_os_str`] 方法从 `OsString` 获取 `&`[`OsStr`];",
        "translate": ""
    },
    {
        "source": "this is effectively a borrowed reference to the whole string.",
        "suggest": "这实际上是对整个字符串的借用引用。",
        "translate": ""
    },
    {
        "source": "See the [module's toplevel documentation about conversions][conversions] for a discussion on the traits which `OsString` implements for [conversions] from/to native representations.",
        "suggest": "有关 [module's toplevel documentation about conversions][conversions] 为 [conversions] from/to 原生表示形式实现的 traits 的讨论，请参见 [module's toplevel documentation about conversions][conversions]。",
        "translate": ""
    },
    {
        "source": "Allows extension traits within `std`.",
        "suggest": "允许在 `std` 内扩展 traits。",
        "translate": ""
    },
    {
        "source": "Borrowed reference to an OS string (see [`OsString`]).",
        "suggest": "借用引用到 OS 字符串 (请参见 [`OsString`])。",
        "translate": ""
    },
    {
        "source": "This type represents a borrowed reference to a string in the operating system's preferred representation.",
        "suggest": "此类型表示操作系统首选表示形式中字符串的借用引用。",
        "translate": ""
    },
    {
        "source": "is to [`OsString`] as [`&str`] is to [`String`]: the former in each pair are borrowed references;",
        "suggest": "是 [`OsString`] 就像 [`&str`] 到 [`String`]: 每对中的前者都是借来的;",
        "translate": ""
    },
    {
        "source": "See the [module's toplevel documentation about conversions][conversions] for a discussion on the traits which `OsStr` implements for [conversions] from/to native representations.",
        "suggest": "有关 [module's toplevel documentation about conversions][conversions] 为 [conversions] from/to 原生表示形式实现的 traits 的讨论，请参见 [module's toplevel documentation about conversions][conversions]。",
        "translate": ""
    },
    {
        "source": "current implementation relies on `OsStr` being layout-compatible with `Slice`.",
        "suggest": "当前的实现依赖于 `OsStr` 与 `Slice` 在布局上兼容。",
        "translate": ""
    },
    {
        "source": "When attribute privacy is implemented, `OsStr` should be annotated as `#[repr(transparent)]`.",
        "suggest": "实现属性隐私时，应将 `OsStr` 注解为 `#[repr(transparent)]`。",
        "translate": ""
    },
    {
        "source": "Anyway, `OsStr` representation and layout are considered implementation details, are not documented and must not be relied upon.",
        "suggest": "无论如何，`OsStr` 表示形式和布局被视为实现细节，没有文档记录，因此不能依赖。",
        "translate": ""
    },
    {
        "source": "Constructs a new empty `OsString`.",
        "suggest": "创建一个新的空 `OsString`。",
        "translate": ""
    },
    {
        "source": "Converts to an [`OsStr`] slice.",
        "suggest": "转换为 [`OsStr`] 切片。",
        "translate": ""
    },
    {
        "source": "Converts the `OsString` into a [`String`] if it contains valid Unicode data.",
        "suggest": "如果 `OsString` 包含有效的 Unicode 数据，则将其转换为 [`String`]。",
        "translate": ""
    },
    {
        "source": "On failure, ownership of the original `OsString` is returned.",
        "suggest": "失败时，将返回原始 `OsString` 的所有权。",
        "translate": ""
    },
    {
        "source": "Extends the string with the given [`&OsStr`] slice.",
        "suggest": "用给定的 [`&OsStr`] 切片扩展字符串。",
        "translate": ""
    },
    {
        "source": "Creates a new `OsString` with the given capacity.",
        "suggest": "创建具有给定容量的新 `OsString`。",
        "translate": ""
    },
    {
        "source": "The string will be able to hold exactly `capacity` length units of other OS strings without reallocating.",
        "suggest": "该字符串将能够完全容纳其他 OS 字符串的 `capacity` 长度单位，而无需重新分配。",
        "translate": ""
    },
    {
        "source": "If `capacity` is 0, the string will not allocate.",
        "suggest": "如果 `capacity` 为 0，则不会分配该字符串。",
        "translate": ""
    },
    {
        "source": "See main `OsString` documentation information about encoding.",
        "suggest": "请参见有关编码的主要 `OsString` 文档信息。",
        "translate": ""
    },
    {
        "source": "Truncates the `OsString` to zero length.",
        "suggest": "将 `OsString` 截断为零长度。",
        "translate": ""
    },
    {
        "source": "Returns the capacity this `OsString` can hold without reallocating.",
        "suggest": "返回此 `OsString` 无需重新分配即可容纳的容量。",
        "translate": ""
    },
    {
        "source": "See `OsString` introduction for information about encoding.",
        "suggest": "有关编码的信息，请参见 `OsString` 简介。",
        "translate": ""
    },
    {
        "source": "Reserves capacity for at least `additional` more capacity to be inserted in the given `OsString`.",
        "suggest": "为给定的 `OsString` 插入至少至少 `additional` 的容量保留容量。",
        "translate": ""
    },
    {
        "source": "Reserves the minimum capacity for exactly `additional` more capacity to be inserted in the given `OsString`.",
        "suggest": "保留最小容量，以便将 `additional` 精确地插入给定的 `OsString` 中。",
        "translate": ""
    },
    {
        "source": "Prefer reserve if future insertions are expected.",
        "suggest": "如果希望插入 future，则建议保留。",
        "translate": ""
    },
    {
        "source": "Shrinks the capacity of the `OsString` to match its length.",
        "suggest": "缩小 `OsString` 的容量以使其长度匹配。",
        "translate": ""
    },
    {
        "source": "Shrinks the capacity of the `OsString` with a lower bound.",
        "suggest": "降低 `OsString` 的容量。",
        "translate": ""
    },
    {
        "source": "Converts this `OsString` into a boxed [`OsStr`].",
        "suggest": "将此 `OsString` 转换为 boxed [`OsStr`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`String`] into a [`OsString`].",
        "suggest": "将 [`String`] 转换为 [`OsString`]。",
        "translate": ""
    },
    {
        "source": "The conversion copies the data, and includes an allocation on the heap.",
        "suggest": "转换将复制数据，并在堆上包括分配。",
        "translate": ""
    },
    {
        "source": "Constructs an empty `OsString`.",
        "suggest": "创建一个空的 `OsString`。",
        "translate": ""
    },
    {
        "source": "Coerces into an `OsStr` slice.",
        "suggest": "强制转换为 `OsStr` 切片。",
        "translate": ""
    },
    {
        "source": "OsStr is just a wrapper of Slice, therefore converting &Slice to &OsStr is safe.",
        "suggest": "OsStr 只是切片的包装，因此将 &Slice 转换为 &OsStr 是安全的。",
        "translate": ""
    },
    {
        "source": "OsStr is just a wrapper of Slice, therefore converting &mut Slice to &mut OsStr is safe.",
        "suggest": "OsStr 只是切片的包装，因此将 &mut 切片转换为 &mut OsStr 是安全的。",
        "translate": ""
    },
    {
        "source": "Any method that mutates OsStr must be careful not to break platform-specific encoding, in particular Wtf8 on Windows.",
        "suggest": "更改 OsStr 的任何方法都必须小心，不要破坏平台特定的编码，尤其是 Windows 上的 Wtf8。",
        "translate": ""
    },
    {
        "source": "Yields a [`&str`] slice if the `OsStr` is valid Unicode.",
        "suggest": "如果 `OsStr` 是有效的 Unicode，则生成 [`&str`] 切片。",
        "translate": ""
    },
    {
        "source": "This conversion may entail doing a check for UTF-8 validity.",
        "suggest": "此转换可能需要检查 UTF-8 有效性。",
        "translate": ""
    },
    {
        "source": "Converts an `OsStr` to a [`Cow`]`<`[`str`]`>`.",
        "suggest": "将 `OsStr` 转换为 [`Cow`]`<`[`str`]`>`。",
        "translate": ""
    },
    {
        "source": "Any non-Unicode sequences are replaced with [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].",
        "suggest": "任何非 Unicode 序列都将替换为 [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD]。",
        "translate": ""
    },
    {
        "source": "Calling `to_string_lossy` on an `OsStr` with invalid unicode:",
        "suggest": "使用无效的 Unicode 在 `OsStr` 上调用 `to_string_lossy`:",
        "translate": ""
    },
    {
        "source": "Copies the slice into an owned [`OsString`].",
        "suggest": "将切片复制到拥有的 [`OsString`] 中。",
        "translate": ""
    },
    {
        "source": "Checks whether the `OsStr` is empty.",
        "suggest": "检查 `OsStr` 是否为空。",
        "translate": ""
    },
    {
        "source": "Returns the length of this `OsStr`.",
        "suggest": "返回此 `OsStr` 的长度。",
        "translate": ""
    },
    {
        "source": "Note that this does **not** return the number of bytes in the string in OS string form.",
        "suggest": "请注意，这不会以 OS 字符串形式返回字符串中的字节数。",
        "translate": ""
    },
    {
        "source": "The length returned is that of the underlying storage used by `OsStr`.",
        "suggest": "返回的长度是 `OsStr` 使用的基础存储的长度。",
        "translate": ""
    },
    {
        "source": "As discussed in the [`OsString`] introduction, [`OsString`] and `OsStr` store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.",
        "suggest": "如 [`OsString`] 简介中所讨论的，[`OsString`] 和 `OsStr` 以最适合于原生平台和 Rust 字符串形式之间的廉价相互转换的形式存储字符串，这两种形式在存储大小和编码方面可能都大不相同。",
        "translate": ""
    },
    {
        "source": "This number is simply useful for passing to other methods, like [`OsString::with_capacity`] to avoid reallocations.",
        "suggest": "此数字对于传递给其他方法 (例如 [`OsString::with_capacity`]) 以避免重新分配非常有用。",
        "translate": ""
    },
    {
        "source": "Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`Box`]`<OsStr>` 转换为 [`OsString`]。",
        "translate": ""
    },
    {
        "source": "Gets the underlying byte representation.",
        "suggest": "获取基础的字节表示形式。",
        "translate": ""
    },
    {
        "source": "it is *crucial* that this API is not externally public, to avoid revealing the internal, platform-specific encodings.",
        "suggest": "至关重要的是，此 API 不应在外部公开，以避免泄露内部的，平台特定的编码。",
        "translate": ""
    },
    {
        "source": "To return a new lowercased value without modifying the existing one, use [`OsStr::to_ascii_lowercase`].",
        "suggest": "要返回新的小写值而不修改现有值，请使用 [`OsStr::to_ascii_lowercase`]。",
        "translate": ""
    },
    {
        "source": "To return a new uppercased value without modifying the existing one, use [`OsStr::to_ascii_uppercase`].",
        "suggest": "要返回新的大写值而不修改现有值，请使用 [`OsStr::to_ascii_uppercase`]。",
        "translate": ""
    },
    {
        "source": "To lowercase the value in-place, use [`OsStr::make_ascii_lowercase`].",
        "suggest": "要就地小写该值，请使用 [`OsStr::make_ascii_lowercase`]。",
        "translate": ""
    },
    {
        "source": "To uppercase the value in-place, use [`OsStr::make_ascii_uppercase`].",
        "suggest": "要就地将值大写，请使用 [`OsStr::make_ascii_uppercase`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`Box`]`<`[`OsStr`]`>` into a `OsString` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`Box`]`<`[`OsStr`]`>` 转换为 `OsString`。",
        "translate": ""
    },
    {
        "source": "Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`OsString`] 转换为 [`Box`]`<OsStr>`。",
        "translate": ""
    },
    {
        "source": "Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`OsString`] 转换为 [`Arc`]`<OsStr>`。",
        "translate": ""
    },
    {
        "source": "Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`OsString`] 转换为 [`Rc`]`<OsStr>`。",
        "translate": ""
    },
    {
        "source": "Creates an empty `OsStr`.",
        "suggest": "创建一个空的 `OsStr`。",
        "translate": ""
    },
    {
        "source": "FIXME (#19470): cannot provide PartialOrd<OsStr> for str until we have more flexible coherence rules.",
        "suggest": "FIXME (#19470): 在我们拥有更灵活的一致性规则之前，无法为 str 提供 PartialOrd<OsStr>。",
        "translate": ""
    },
    {
        "source": "Because we're iterating over `OsString`s, we can avoid at least one allocation by getting the first string from the iterator and appending to it all the subsequent strings.",
        "suggest": "因为我们要遍历 OsString，所以可以通过从迭代器获取第一个字符串并将所有后续字符串附加到它上面来避免至少一个分配。",
        "translate": ""
    },
    {
        "source": "Because we're iterating over `OsString`s, we can avoid at least one allocation by getting the first owned string from the iterator and appending to it all the subsequent strings.",
        "suggest": "因为我们要遍历 OsString，所以可以通过从迭代器获取第一个拥有的字符串并将所有后续字符串附加到它上面来避免至少一次分配。",
        "translate": ""
    },
    {
        "source": "Several test fail on windows if the user does not have permission to create symlinks (the `SeCreateSymbolicLinkPrivilege`).",
        "suggest": "如果用户没有创建符号链接 (`SeCreateSymbolicLinkPrivilege`) 的权限，则 windows 上的多个测试将失败。",
        "translate": ""
    },
    {
        "source": "Instead of disabling these test on Windows, use this function to test whether we have permission, and return otherwise.",
        "suggest": "不用在 Windows 上禁用这些测试，而是使用此函数来测试我们是否具有权限，否则返回。",
        "translate": ""
    },
    {
        "source": "This way, we still don't run these tests most of the time, but at least we do if the user has the right permissions.",
        "suggest": "这样，我们仍然不会在大多数时间运行这些测试，但是至少在用户具有正确权限的情况下我们才运行这些测试。",
        "translate": ""
    },
    {
        "source": "No `Display` on result of `join()`",
        "suggest": "`join()` 的结果上没有 `Display`",
        "translate": ""
    },
    {
        "source": "test we do not recursively delete a symlink but only dirs.",
        "suggest": "测试我们不递归删除符号链接，而仅删除目录。",
        "translate": ""
    },
    {
        "source": "only Windows makes a distinction between file and directory symlinks.",
        "suggest": "只有 Windows 区分文件和目录符号链接。",
        "translate": ""
    },
    {
        "source": "ignore return;",
        "suggest": "忽略回报;",
        "translate": ""
    },
    {
        "source": "touch only",
        "suggest": "仅触摸",
        "translate": ""
    },
    {
        "source": "Symlinks can point to things that don't exist",
        "suggest": "符号链接可以指向不存在的事物",
        "translate": ""
    },
    {
        "source": "Use a relative path for testing.",
        "suggest": "使用相对路径进行测试。",
        "translate": ""
    },
    {
        "source": "Symlinks get normalized by Windows, so we may not get the same path back for absolute paths",
        "suggest": "符号链接已由 Windows 规范化，因此对于绝对路径，我们可能无法获得相同的路径",
        "translate": ""
    },
    {
        "source": "directory symlink",
        "suggest": "目录符号链接",
        "translate": ""
    },
    {
        "source": "junction with special permissions",
        "suggest": "具有特殊权限的路口",
        "translate": ""
    },
    {
        "source": "can't link to yourself",
        "suggest": "不能链接到您自己",
        "translate": ""
    },
    {
        "source": "can't link to something that doesn't exist",
        "suggest": "无法链接到不存在的内容",
        "translate": ""
    },
    {
        "source": "Do some simple things with truncation",
        "suggest": "用截断做一些简单的事情",
        "translate": ""
    },
    {
        "source": "Truncate to a smaller length, don't seek, and then write something.",
        "suggest": "截短长度，不要寻找，然后再写一些东西。",
        "translate": ""
    },
    {
        "source": "Ensure that the intermediate zeroes are all filled in (we have `seek`ed past the end of the file).",
        "suggest": "确保所有的中间零都被填满 (我们已经搜索了文件的末尾)。",
        "translate": ""
    },
    {
        "source": "Test various combinations of creation modes and access modes.",
        "suggest": "测试创建模式和访问模式的各种组合。",
        "translate": ""
    },
    {
        "source": "tested in reverse order, so 'create_new' creates the file, and 'open existing' opens it.",
        "suggest": "以相反的顺序进行测试，因此 'create_new' 创建文件，然后 `open existing` 打开它。",
        "translate": ""
    },
    {
        "source": "try opening the file created with write_only",
        "suggest": "尝试打开使用 write_only 创建的文件",
        "translate": ""
    },
    {
        "source": "Test opening a file without setting an access mode",
        "suggest": "在不设置访问模式的情况下测试打开文件",
        "translate": ""
    },
    {
        "source": "Test write works",
        "suggest": "测试写作作品",
        "translate": ""
    },
    {
        "source": "Test write fails for read-only",
        "suggest": "测试写入失败，只读",
        "translate": ""
    },
    {
        "source": "Test write overwrites",
        "suggest": "测试写覆盖",
        "translate": ""
    },
    {
        "source": "Test truncate works",
        "suggest": "测试截断作品",
        "translate": ""
    },
    {
        "source": "Test append works",
        "suggest": "测试附加作品",
        "translate": ""
    },
    {
        "source": "Test .append(true) equals .write(true).append(true)",
        "suggest": "测试 .append(true) 等于.write (true) .append (true)",
        "translate": ""
    },
    {
        "source": "the junction itself is not a directory, but `is_dir()` on a Path follows links",
        "suggest": "联结本身不是目录，但是路径上的 `is_dir()` 遵循链接",
        "translate": ""
    },
    {
        "source": "Not always available",
        "suggest": "并非总是可用",
        "translate": ""
    },
    {
        "source": "Test creating hard links to symlinks.",
        "suggest": "测试创建到符号链接的硬链接。",
        "translate": ""
    },
    {
        "source": "Create \"file\", a file.",
        "suggest": "创建文件 \"file\"。",
        "translate": ""
    },
    {
        "source": "Create \"symlink\", a symlink to \"file\".",
        "suggest": "创建 \"symlink\"，它是 \"file\" 的符号链接。",
        "translate": ""
    },
    {
        "source": "Create \"hard_link\", a hard link to \"symlink\".",
        "suggest": "创建 \"hard_link\"，这是 \"symlink\" 的硬链接。",
        "translate": ""
    },
    {
        "source": "should appear as a symlink.",
        "suggest": "应该显示为符号链接。",
        "translate": ""
    },
    {
        "source": "We sould be able to open \"file\" via any of the above names.",
        "suggest": "我们可以通过上述任何一个名称来打开 \"file\"。",
        "translate": ""
    },
    {
        "source": "Rename \"file\" to \"file.renamed\".",
        "suggest": "将 \"file\" 重命名为 \"file.renamed\"。",
        "translate": ""
    },
    {
        "source": "Now, the symlink and the hard link should be dangling.",
        "suggest": "现在，符号链接和硬链接应该悬而未决了。",
        "translate": ""
    },
    {
        "source": "The symlink and the hard link should both still point to \"file\".",
        "suggest": "符号链接和硬链接都应仍指向 \"file\"。",
        "translate": ""
    },
    {
        "source": "Remove \"file.renamed\".",
        "suggest": "删除 \"file.renamed\"。",
        "translate": ""
    },
    {
        "source": "Now, we can't open the file by any name.",
        "suggest": "现在，我们无法使用任何名称打开文件。",
        "translate": ""
    },
    {
        "source": "should still appear as a symlink.",
        "suggest": "仍应显示为符号链接。",
        "translate": ""
    },
    {
        "source": "filesystem doesn't change",
        "suggest": "文件系统不变",
        "translate": ""
    },
    {
        "source": "just this particular `permissions`.",
        "suggest": "只是这个特定的 `permissions`。",
        "translate": ""
    },
    {
        "source": "Here, `entry` is a `DirEntry`.",
        "suggest": "在此，`entry` 是 `DirEntry`。",
        "translate": ""
    },
    {
        "source": "Now let's show our entry's permissions!",
        "suggest": "现在，让我们显示条目的权限!",
        "translate": ""
    },
    {
        "source": "Now let's show our entry's file type!",
        "suggest": "现在，让我们显示条目的文件类型!",
        "translate": ""
    },
    {
        "source": "inspect attr ...",
        "suggest": "检查属性...",
        "translate": ""
    },
    {
        "source": "Rename a.txt to b.txt",
        "suggest": "将 a.txt 重命名为 b.txt",
        "translate": ""
    },
    {
        "source": "Copy foo.txt to bar.txt",
        "suggest": "将 foo.txt 复制到 bar.txt",
        "translate": ""
    },
    {
        "source": "Hard link a.txt to b.txt",
        "suggest": "硬链接 a.txt 到 b.txt",
        "translate": ""
    },
    {
        "source": "one possible implementation of walking a directory only visiting files",
        "suggest": "一种只访问文件的目录的可能实现",
        "translate": ""
    },
    {
        "source": "The order in which `read_dir` returns entries is not guaranteed.",
        "suggest": "不保证 `read_dir` 返回条目的顺序。",
        "translate": ""
    },
    {
        "source": "If reproducible ordering is required the entries should be explicitly sorted.",
        "suggest": "如果需要可重复的排序，则应对条目进行显式排序。",
        "translate": ""
    },
    {
        "source": "The entries have now been sorted by their path.",
        "suggest": "现在，条目已按其路径排序。",
        "translate": ""
    },
    {
        "source": "Filesystem manipulation operations.",
        "suggest": "文件系统操纵操作。",
        "translate": ""
    },
    {
        "source": "This module contains basic methods to manipulate the contents of the local filesystem.",
        "suggest": "该模块包含一些操作本地文件系统内容的基本方法。",
        "translate": ""
    },
    {
        "source": "All methods in this module represent cross-platform filesystem operations.",
        "suggest": "该模块中的所有方法均表示跨平台文件系统操作。",
        "translate": ""
    },
    {
        "source": "Extra platform-specific functionality can be found in the extension traits of `std::os::$platform`.",
        "suggest": "在 `std::os::$platform` 的扩展名 traits 中可以找到特定于平台的其他功能。",
        "translate": ""
    },
    {
        "source": "A reference to an open file on the filesystem.",
        "suggest": "对文件系统上打开的文件的引用。",
        "translate": ""
    },
    {
        "source": "An instance of a `File` can be read and/or written depending on what options it was opened with.",
        "suggest": "可以通过打开 `File` 的选项来读取或者写入 `File` 的实例。",
        "translate": ""
    },
    {
        "source": "Files also implement [`Seek`] to alter the logical cursor that the file contains internally.",
        "suggest": "文件还实现 [`Seek`]，以更改文件内部包含的逻辑游标。",
        "translate": ""
    },
    {
        "source": "Files are automatically closed when they go out of scope.",
        "suggest": "文件离开作用域时将自动关闭。",
        "translate": ""
    },
    {
        "source": "Errors detected on closing are ignored by the implementation of `Drop`.",
        "suggest": "`Drop` 的实现将忽略在关闭时检测到的错误。",
        "translate": ""
    },
    {
        "source": "Use the method [`sync_all`] if these errors must be manually handled.",
        "suggest": "如果必须手动处理这些错误，请使用方法 [`sync_all`]。",
        "translate": ""
    },
    {
        "source": "Creates a new file and write bytes to it (you can also use [`write()`]):",
        "suggest": "创建一个新文件并向其写入字节 (您也可以使用 [`write()`]) :",
        "translate": ""
    },
    {
        "source": "Read the contents of a file into a [`String`] (you can also use [`read`]):",
        "suggest": "将文件内容读入 [`String`] (也可以使用 [`read`]) :",
        "translate": ""
    },
    {
        "source": "It can be more efficient to read the contents of a file with a buffered [`Read`]er. This can be accomplished with [`BufReader<R>`]:",
        "suggest": "使用缓冲的 [`Read`] er 来读取文件的内容可能会更有效。这可以用 [`BufReader<R>`] 完成:",
        "translate": ""
    },
    {
        "source": "Note that, although read and write methods require a `&mut File`, because of the interfaces for [`Read`] and [`Write`], the holder of a `&File` can still modify the file, either through methods that take `&File` or by retrieving the underlying OS object and modifying the file that way.",
        "suggest": "请注意，尽管读写方法需要 `&mut File`，但是由于 [`Read`] 和 [`Write`] 的接口，`&File` 的持有者仍可以通过采用 `&File` 的方法或通过检索基础 OS object 并修改该文件来修改文件。办法。",
        "translate": ""
    },
    {
        "source": "Additionally, many operating systems allow concurrent modification of files by different processes.",
        "suggest": "另外，许多操作系统允许通过不同的进程并发修改文件。",
        "translate": ""
    },
    {
        "source": "Avoid assuming that holding a `&File` means that the file will not change.",
        "suggest": "避免假定持有 `&File` 意味着文件不会更改。",
        "translate": ""
    },
    {
        "source": "Metadata information about a file.",
        "suggest": "有关文件的元数据信息。",
        "translate": ""
    },
    {
        "source": "This structure is returned from the [`metadata`] or [`symlink_metadata`] function or method and represents known metadata about a file such as its permissions, size, modification times, etc.",
        "suggest": "此结构体是从 [`metadata`] 或 [`symlink_metadata`] 函数或方法返回的，表示有关文件的已知元数据，例如其权限，大小，修改时间等。",
        "translate": ""
    },
    {
        "source": "Iterator over the entries in a directory.",
        "suggest": "遍历目录中的条目。",
        "translate": ""
    },
    {
        "source": "This iterator is returned from the [`read_dir`] function of this module and will yield instances of [`io::Result`]`<`[`DirEntry`]`>`.",
        "suggest": "该迭代器从该模块的 [`read_dir`] 函数返回，并将产生 [`io::Result`]`<`[`DirEntry`]`>` 的实例。",
        "translate": ""
    },
    {
        "source": "Through a [`DirEntry`] information like the entry's path and possibly other metadata can be learned.",
        "suggest": "通过 [`DirEntry`]，可以了解类似条目路径以及可能的其他元数据的信息。",
        "translate": ""
    },
    {
        "source": "The order in which this iterator returns entries is platform and filesystem dependent.",
        "suggest": "该迭代器返回条目的顺序取决于平台和文件系统。",
        "translate": ""
    },
    {
        "source": "This [`io::Result`] will be an [`Err`] if there's some sort of intermittent IO error during iteration.",
        "suggest": "如果在迭代过程中出现某种间歇性的 IO 错误，则该 [`io::Result`] 将是 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Entries returned by the [`ReadDir`] iterator.",
        "suggest": "[`ReadDir`] 迭代器返回的条目。",
        "translate": ""
    },
    {
        "source": "An instance of `DirEntry` represents an entry inside of a directory on the filesystem.",
        "suggest": "`DirEntry` 的实例表示文件系统上目录内的一个条目。",
        "translate": ""
    },
    {
        "source": "Each entry can be inspected via methods to learn about the full path or possibly other metadata through per-platform extension traits.",
        "suggest": "可以通过方法检查每个条目，以通过全平台扩展 traits 了解完整路径或可能的其他元数据。",
        "translate": ""
    },
    {
        "source": "Options and flags which can be used to configure how a file is opened.",
        "suggest": "可用于配置文件打开方式的选项和标志。",
        "translate": ""
    },
    {
        "source": "This builder exposes the ability to configure how a [`File`] is opened and what operations are permitted on the open file.",
        "suggest": "此构建器提供了配置 [`File`] 的打开方式以及打开的文件上允许哪些操作的功能。",
        "translate": ""
    },
    {
        "source": "The [`File::open`] and [`File::create`] methods are aliases for commonly used options using this builder.",
        "suggest": "[`File::open`] 和 [`File::create`] 方法是使用此构建器的常用选项的别名。",
        "translate": ""
    },
    {
        "source": "Generally speaking, when using `OpenOptions`, you'll first call [`OpenOptions::new`], then chain calls to methods to set each option, then call [`OpenOptions::open`], passing the path of the file you're trying to open.",
        "suggest": "一般而言，使用 `OpenOptions` 时，首先要调用 [`OpenOptions::new`]，然后链式调用方法以设置每个选项，然后调用 [`OpenOptions::open`]，传递要打开的文件的路径。",
        "translate": ""
    },
    {
        "source": "This will give you a [`io::Result`] with a [`File`] inside that you can further operate on.",
        "suggest": "这将为您提供一个内部带有 [`File`] 的 [`io::Result`]，您可以对其进行进一步的操作。",
        "translate": ""
    },
    {
        "source": "Opening a file to read:",
        "suggest": "打开一个文件以读取:",
        "translate": ""
    },
    {
        "source": "Opening a file for both reading and writing, as well as creating it if it doesn't exist:",
        "suggest": "打开一个文件进行读写，如果不存在则创建一个文件:",
        "translate": ""
    },
    {
        "source": "Representation of the various permissions on a file.",
        "suggest": "表示文件上的各种权限。",
        "translate": ""
    },
    {
        "source": "This module only currently provides one bit of information, [`Permissions::readonly`], which is exposed on all currently supported platforms.",
        "suggest": "该模块当前仅提供一点信息 [`Permissions::readonly`]，该信息在所有当前支持的平台上公开。",
        "translate": ""
    },
    {
        "source": "Unix-specific functionality, such as mode bits, is available through the [`PermissionsExt`] trait.",
        "suggest": "特定于 Unix 的功能 (例如模式位) 可通过 [`PermissionsExt`] trait 获得。",
        "translate": ""
    },
    {
        "source": "A structure representing a type of file with accessors for each file type.",
        "suggest": "表示文件类型的结构体，每个文件类型都有访问器。",
        "translate": ""
    },
    {
        "source": "It is returned by [`Metadata::file_type`] method.",
        "suggest": "通过 [`Metadata::file_type`] 方法返回。",
        "translate": ""
    },
    {
        "source": "A builder used to create directories in various manners.",
        "suggest": "用于以各种方式创建目录的构建器。",
        "translate": ""
    },
    {
        "source": "This builder also supports platform-specific options.",
        "suggest": "该构建器还支持特定于平台的选项。",
        "translate": ""
    },
    {
        "source": "Indicates how large a buffer to pre-allocate before reading the entire file.",
        "suggest": "指示读取整个文件之前要预分配的缓冲区大小。",
        "translate": ""
    },
    {
        "source": "Allocate one extra byte so the buffer doesn't need to grow before the final `read` call at the end of the file.",
        "suggest": "分配一个额外的字节，这样就不需要在文件末尾的最后 `read` 调用之前增加缓冲区。",
        "translate": ""
    },
    {
        "source": "Don't worry about `usize` overflow because reading will fail regardless in that case.",
        "suggest": "不必担心 `usize` 溢出，因为无论那种情况，读取都会失败。",
        "translate": ""
    },
    {
        "source": "Read the entire contents of a file into a bytes vector.",
        "suggest": "将文件的全部内容读取为字节 vector。",
        "translate": ""
    },
    {
        "source": "This is a convenience function for using [`File::open`] and [`read_to_end`] with fewer imports and without an intermediate variable.",
        "suggest": "这是使用 [`File::open`] 和 [`read_to_end`] 且导入次数较少且没有中间变量的便捷函数。",
        "translate": ""
    },
    {
        "source": "It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with [`Vec::new()`].",
        "suggest": "它会根据文件大小 (如果可用) 预分配缓冲区，因此通常比读入 [`Vec::new()`] 创建的 vector 更快。",
        "translate": ""
    },
    {
        "source": "This function will return an error if `path` does not already exist.",
        "suggest": "如果 `path` 还不存在，则此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "Other errors may also be returned according to [`OpenOptions::open`].",
        "suggest": "根据 [`OpenOptions::open`]，可能还会返回其他错误。",
        "translate": ""
    },
    {
        "source": "It will also return an error if it encounters while reading an error of a kind other than [`io::ErrorKind::Interrupted`].",
        "suggest": "如果在读取 [`io::ErrorKind::Interrupted`] 以外的其他类型的错误时遇到错误，它也会返回错误。",
        "translate": ""
    },
    {
        "source": "Read the entire contents of a file into a string.",
        "suggest": "将文件的全部内容读取为字符串。",
        "translate": ""
    },
    {
        "source": "This is a convenience function for using [`File::open`] and [`read_to_string`] with fewer imports and without an intermediate variable.",
        "suggest": "这是使用 [`File::open`] 和 [`read_to_string`] 且导入次数较少且没有中间变量的便捷函数。",
        "translate": ""
    },
    {
        "source": "It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with [`String::new()`].",
        "suggest": "它会根据文件大小 (如果可用) 预先分配一个缓冲区，因此通常比读取用 [`String::new()`] 创建的字符串要快。",
        "translate": ""
    },
    {
        "source": "It will also return an error if it encounters while reading an error of a kind other than [`io::ErrorKind::Interrupted`], or if the contents of the file are not valid UTF-8.",
        "suggest": "如果在读取 [`io::ErrorKind::Interrupted`] 以外的其他错误时遇到错误，或者文件的内容不是有效的 UTF-8，它也会返回错误。",
        "translate": ""
    },
    {
        "source": "Write a slice as the entire contents of a file.",
        "suggest": "写一个切片作为文件的全部内容。",
        "translate": ""
    },
    {
        "source": "This function will create a file if it does not exist, and will entirely replace its contents if it does.",
        "suggest": "如果该函数不存在，则此函数将创建一个文件，如果存在，则将完全替换其内容。",
        "translate": ""
    },
    {
        "source": "This is a convenience function for using [`File::create`] and [`write_all`] with fewer imports.",
        "suggest": "这是使用 [`File::create`] 和 [`write_all`] 且导入次数较少的便捷函数。",
        "translate": ""
    },
    {
        "source": "Attempts to open a file in read-only mode.",
        "suggest": "尝试以只读模式打开文件。",
        "translate": ""
    },
    {
        "source": "See the [`OpenOptions::open`] method for more details.",
        "suggest": "有关更多详细信息，请参见 [`OpenOptions::open`] 方法。",
        "translate": ""
    },
    {
        "source": "Opens a file in write-only mode.",
        "suggest": "以只写模式打开文件。",
        "translate": ""
    },
    {
        "source": "This function will create a file if it does not exist, and will truncate it if it does.",
        "suggest": "如果该函数不存在，则此函数将创建一个文件，如果存在则将截断该文件。",
        "translate": ""
    },
    {
        "source": "See the [`OpenOptions::open`] function for more details.",
        "suggest": "有关更多详细信息，请参见 [`OpenOptions::open`] 函数。",
        "translate": ""
    },
    {
        "source": "Returns a new OpenOptions object.",
        "suggest": "返回一个新的 OpenOptions object。",
        "translate": ""
    },
    {
        "source": "This function returns a new OpenOptions object that you can use to open or create a file with specific options if `open()` or `create()` are not appropriate.",
        "suggest": "如果不适合使用 `open()` 或 `create()`，则此函数返回一个新的 OpenOptions object，可用于打开或创建具有特定选项的文件。",
        "translate": ""
    },
    {
        "source": "It is equivalent to `OpenOptions::new()` but allows you to write more readable code.",
        "suggest": "它等效于 `OpenOptions::new()`，但允许您编写更具可读性的代码。",
        "translate": ""
    },
    {
        "source": "Instead of `OpenOptions::new().read(true).open(\"foo.txt\")` you can write `File::with_options().read(true).open(\"foo.txt\")`.",
        "suggest": "可以用 `File::with_options().read(true).open(\"foo.txt\")` 代替 `OpenOptions::new().read(true).open(\"foo.txt\")`。",
        "translate": ""
    },
    {
        "source": "This also avoids the need to import `OpenOptions`.",
        "suggest": "这也避免了导入 `OpenOptions` 的需要。",
        "translate": ""
    },
    {
        "source": "See the [`OpenOptions::new`] function for more details.",
        "suggest": "有关更多详细信息，请参见 [`OpenOptions::new`] 函数。",
        "translate": ""
    },
    {
        "source": "Attempts to sync all OS-internal metadata to disk.",
        "suggest": "尝试将所有操作系统内部元数据同步到磁盘。",
        "translate": ""
    },
    {
        "source": "This function will attempt to ensure that all in-memory data reaches the filesystem before returning.",
        "suggest": "此函数将尝试确保所有内存数据在返回之前都已到达文件系统。",
        "translate": ""
    },
    {
        "source": "This can be used to handle errors that would otherwise only be caught when the `File` is closed.",
        "suggest": "这可用于处理错误，否则这些错误仅在 `File` 关闭时才会被捕获。",
        "translate": ""
    },
    {
        "source": "Dropping a file will ignore errors in synchronizing this in-memory data.",
        "suggest": "丢弃文件将忽略同步此内存中数据的错误。",
        "translate": ""
    },
    {
        "source": "This function is similar to [`sync_all`], except that it may not synchronize file metadata to the filesystem.",
        "suggest": "该函数与 [`sync_all`] 相似，不同之处在于它可能不会将文件元数据同步到文件系统。",
        "translate": ""
    },
    {
        "source": "This is intended for use cases that must synchronize content, but don't need the metadata on disk.",
        "suggest": "这适用于必须同步内容但不需要磁盘上元数据的用例。",
        "translate": ""
    },
    {
        "source": "The goal of this method is to reduce disk operations.",
        "suggest": "此方法的目标是减少磁盘操作。",
        "translate": ""
    },
    {
        "source": "Note that some platforms may simply implement this in terms of [`sync_all`].",
        "suggest": "请注意，某些平台可能只是根据 [`sync_all`] 来实现此目的。",
        "translate": ""
    },
    {
        "source": "Truncates or extends the underlying file, updating the size of this file to become `size`.",
        "suggest": "截断或扩展基础文件，将此文件的大小更新为 `size`。",
        "translate": ""
    },
    {
        "source": "If the `size` is less than the current file's size, then the file will be shrunk.",
        "suggest": "如果 `size` 小于当前文件的大小，则文件将被缩小。",
        "translate": ""
    },
    {
        "source": "If it is greater than the current file's size, then the file will be extended to `size` and have all of the intermediate data filled in with 0s.",
        "suggest": "如果它大于当前文件的大小，则文件将扩展到 `size`，并且所有中间数据都用 0 填充。",
        "translate": ""
    },
    {
        "source": "The file's cursor isn't changed.",
        "suggest": "文件的游标未更改。",
        "translate": ""
    },
    {
        "source": "In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.",
        "suggest": "特别是，如果游标位于末尾，并且使用此操作将文件缩小了，那么游标现在将超过末尾。",
        "translate": ""
    },
    {
        "source": "This function will return an error if the file is not opened for writing.",
        "suggest": "如果未打开文件进行写入，则此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "Also, std::io::ErrorKind::InvalidInput will be returned if the desired length would cause an overflow due to the implementation specifics.",
        "suggest": "同样，如果期望的长度由于实现细节而导致溢出，则将返回 std::io::ErrorKind::InvalidInput。",
        "translate": ""
    },
    {
        "source": "Note that this method alters the content of the underlying file, even though it takes `&self` rather than `&mut self`.",
        "suggest": "请注意，即使使用 `&self` 而不是 `&mut self`，此方法也会更改基础文件的内容。",
        "translate": ""
    },
    {
        "source": "Queries metadata about the underlying file.",
        "suggest": "查询有关基础文件的元数据。",
        "translate": ""
    },
    {
        "source": "Creates a new `File` instance that shares the same underlying file handle as the existing `File` instance.",
        "suggest": "创建一个新的 `File` 实例，该实例与现有 `File` 实例共享相同的基础文件句柄。",
        "translate": ""
    },
    {
        "source": "Reads, writes, and seeks will affect both `File` instances simultaneously.",
        "suggest": "读取，写入和查找将同时影响两个 `File` 实例。",
        "translate": ""
    },
    {
        "source": "Creates two handles for a file named `foo.txt`:",
        "suggest": "为名为 `foo.txt` 的文件创建两个句柄:",
        "translate": ""
    },
    {
        "source": "Assuming there’s a file named `foo.txt` with contents `abcdef\\n`, create two handles, seek one of them, and read the remaining bytes from the other handle:",
        "suggest": "假设有一个名为 `foo.txt` 的文件，其内容为 `abcdef\\n`，创建两个句柄，查找其中一个，然后从另一个句柄读取剩余的字节:",
        "translate": ""
    },
    {
        "source": "Changes the permissions on the underlying file.",
        "suggest": "更改基础文件的权限。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `fchmod` function on Unix and the `SetFileInformationByHandle` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `fchmod` 函数和 Windows 上的 `SetFileInformationByHandle` 函数。",
        "translate": ""
    },
    {
        "source": "Note that, this [may change in the future][changes].",
        "suggest": "注意，这个 [may change in the future][changes]。",
        "translate": ""
    },
    {
        "source": "This function will return an error if the user lacks permission change attributes on the underlying file.",
        "suggest": "如果用户在基础文件上缺少权限更改属性，则此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "It may also return an error in other os-specific unspecified cases.",
        "suggest": "在其他特定于 OS 的未指定情况下，它也可能返回错误。",
        "translate": ""
    },
    {
        "source": "Note that this method alters the permissions of the underlying file, even though it takes `&self` rather than `&mut self`.",
        "suggest": "请注意，即使使用 `&self` 而不是 `&mut self`，此方法也会更改基础文件的权限。",
        "translate": ""
    },
    {
        "source": "Read is guaranteed to work on uninitialized memory",
        "suggest": "保证读取可以在未初始化的内存上进行",
        "translate": ""
    },
    {
        "source": "Creates a blank new set of options ready for configuration.",
        "suggest": "创建一组可供配置的空白新选项。",
        "translate": ""
    },
    {
        "source": "All options are initially set to `false`.",
        "suggest": "所有选项最初都设置为 `false`。",
        "translate": ""
    },
    {
        "source": "Sets the option for read access.",
        "suggest": "设置读取访问权限的选项。",
        "translate": ""
    },
    {
        "source": "This option, when true, will indicate that the file should be `read`-able if opened.",
        "suggest": "该选项为 true 时，则表示打开的文件应该是可读的。",
        "translate": ""
    },
    {
        "source": "Sets the option for write access.",
        "suggest": "设置写访问权限的选项。",
        "translate": ""
    },
    {
        "source": "This option, when true, will indicate that the file should be `write`-able if opened.",
        "suggest": "此选项为 true 时，则表示打开的文件应该是可写的。",
        "translate": ""
    },
    {
        "source": "If the file already exists, any write calls on it will overwrite its contents, without truncating it.",
        "suggest": "如果该文件已经存在，则对该文件的任何写调用都将覆盖其内容，而不会将其截断。",
        "translate": ""
    },
    {
        "source": "Sets the option for the append mode.",
        "suggest": "设置附加模式的选项。",
        "translate": ""
    },
    {
        "source": "This option, when true, means that writes will append to a file instead of overwriting previous contents.",
        "suggest": "此选项为 true 时，表示写入将追加到文件中，而不是覆盖以前的内容。",
        "translate": ""
    },
    {
        "source": "Note that setting `.write(true).append(true)` has the same effect as setting only `.append(true)`.",
        "suggest": "请注意，设置 `.write(true).append(true)` 与仅设置 `.append(true)` 具有相同的效果。",
        "translate": ""
    },
    {
        "source": "For most filesystems, the operating system guarantees that all writes are atomic: no writes get mangled because another process writes at the same time.",
        "suggest": "对于大多数文件系统，操作系统保证所有写操作都是原子的: 不会浪费任何写操作，因为另一个进程会同时进行写操作。",
        "translate": ""
    },
    {
        "source": "One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation.",
        "suggest": "使用追加模式时，可能有一个明显的注意事项: 确保一次完成将所有在一起的数据写入文件。",
        "translate": ""
    },
    {
        "source": "This can be done by concatenating strings before passing them to [`write()`], or using a buffered writer (with a buffer of adequate size), and calling [`flush()`] when the message is complete.",
        "suggest": "这可以通过在将字符串传递给 [`write()`] 之前串联字符串，或使用缓冲的 writer (具有足够大小的缓冲区) 并在消息完成后调用 [`flush()`] 来完成。",
        "translate": ""
    },
    {
        "source": "If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file.",
        "suggest": "如果打开文件同时具有读取和附加访问权限，请注意在打开之后以及每次写入之后，都可以在文件末尾设置读取位置。",
        "translate": ""
    },
    {
        "source": "So, before writing, save the current position (using [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`), and restore it before the next read.",
        "suggest": "因此，在写入之前，请保存当前位置 (使用 [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`)，并在下一次读取之前将其还原。",
        "translate": ""
    },
    {
        "source": "This function doesn't create the file if it doesn't exist.",
        "suggest": "如果该函数不存在，则该函数不会创建该文件。",
        "translate": ""
    },
    {
        "source": "Use the [`OpenOptions::create`] method to do so.",
        "suggest": "使用 [`OpenOptions::create`] 方法来执行此操作。",
        "translate": ""
    },
    {
        "source": "Sets the option for truncating a previous file.",
        "suggest": "设置截断上一个文件的选项。",
        "translate": ""
    },
    {
        "source": "If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.",
        "suggest": "如果使用此选项设置成功打开了文件，则如果文件已经存在，它将把文件的长度截断为 0。",
        "translate": ""
    },
    {
        "source": "The file must be opened with write access for truncate to work.",
        "suggest": "该文件必须具有写访问权限才能打开，才能进行截断。",
        "translate": ""
    },
    {
        "source": "Sets the option to create a new file, or open it if it already exists.",
        "suggest": "设置选项以创建一个新文件，或者如果已经存在则将其打开。",
        "translate": ""
    },
    {
        "source": "In order for the file to be created, [`OpenOptions::write`] or [`OpenOptions::append`] access must be used.",
        "suggest": "为了创建文件，必须使用 [`OpenOptions::write`] 或 [`OpenOptions::append`] 访问。",
        "translate": ""
    },
    {
        "source": "Sets the option to create a new file, failing if it already exists.",
        "suggest": "设置创建新文件的选项，如果该文件已经存在则失败。",
        "translate": ""
    },
    {
        "source": "No file is allowed to exist at the target location, also no (dangling) symlink.",
        "suggest": "目标位置不允许存在任何文件，(dangling) 符号链接也不允许存在。",
        "translate": ""
    },
    {
        "source": "In this way, if the call succeeds, the file returned is guaranteed to be new.",
        "suggest": "这样，如果调用成功，则保证返回的文件是新文件。",
        "translate": ""
    },
    {
        "source": "This option is useful because it is atomic.",
        "suggest": "此选项很有用，因为它是原子的。",
        "translate": ""
    },
    {
        "source": "Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).",
        "suggest": "否则，在检查文件是否存在与创建新文件之间，文件可能是由另一个进程创建的 (TOCTOU 竞态条件 / 攻击)。",
        "translate": ""
    },
    {
        "source": "If `.create_new(true)` is set, [`.create()`] and [`.truncate()`] are ignored.",
        "suggest": "如果设置了 `.create_new(true)`，则忽略 [`.create()`] 和 [`.truncate()`]。",
        "translate": ""
    },
    {
        "source": "The file must be opened with write or append access in order to create a new file.",
        "suggest": "必须使用写或追加访问权限打开文件才能创建新文件。",
        "translate": ""
    },
    {
        "source": "Opens a file at `path` with the options specified by `self`.",
        "suggest": "使用 `self` 指定的选项在 `path` 打开文件。",
        "translate": ""
    },
    {
        "source": "This function will return an error under a number of different circumstances.",
        "suggest": "在许多不同的情况下，此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "Some of these error conditions are listed here, together with their [`io::ErrorKind`].",
        "suggest": "其中列出了一些错误条件及其 [`io::ErrorKind`]。",
        "translate": ""
    },
    {
        "source": "The mapping to [`io::ErrorKind`]s is not part of the compatibility contract of the function, especially the [`Other`] kind might change to more specific kinds in the future.",
        "suggest": "到 [`io::ErrorKind`] 的映射不是函数兼容性契约的一部分，尤其是 [`Other`] 类型可能会在 future 中更改为更特定的类型。",
        "translate": ""
    },
    {
        "source": "The specified file does not exist and neither `create` or `create_new` is set.",
        "suggest": "指定的文件不存在，并且没有设置 `create` 或 `create_new`。",
        "translate": ""
    },
    {
        "source": "One of the directory components of the file path does not exist.",
        "suggest": "文件路径的目录组件之一不存在。",
        "translate": ""
    },
    {
        "source": "The user lacks permission to get the specified access rights for the file.",
        "suggest": "用户缺少获取文件的指定访问权限的权限。",
        "translate": ""
    },
    {
        "source": "The user lacks permission to open one of the directory components of the specified path.",
        "suggest": "用户没有权限打开指定路径的目录组件之一。",
        "translate": ""
    },
    {
        "source": "`create_new` was specified and the file already exists.",
        "suggest": "指定了 `create_new`，并且该文件已经存在。",
        "translate": ""
    },
    {
        "source": "Invalid combinations of open options (truncate without write access, no access mode set, etc.).",
        "suggest": "打开选项的无效组合 (在没有写访问权，没有设置访问模式的情况下进行截断等)。",
        "translate": ""
    },
    {
        "source": "One of the directory components of the specified file path was not, in fact, a directory.",
        "suggest": "实际上，指定文件路径的目录组件之一不是目录。",
        "translate": ""
    },
    {
        "source": "Filesystem-level errors: full disk, write permission requested on a read-only file system, exceeded disk quota, too many open files, too long filename, too many symbolic links in the specified path (Unix-like systems only), etc.",
        "suggest": "文件系统级错误: 已满磁盘，对只读文件系统请求的写许可权，超出磁盘配额，打开的文件过多，文件名太长，指定路径中的符号链接太多 (仅适用于 Unix 系统)，等等。",
        "translate": ""
    },
    {
        "source": "Returns the file type for this metadata.",
        "suggest": "返回此元数据的文件类型。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this metadata is for a directory.",
        "suggest": "如果此元数据用于目录，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "The result is mutually exclusive to the result of [`Metadata::is_file`], and will be false for symlink metadata obtained from [`symlink_metadata`].",
        "suggest": "结果与 [`Metadata::is_file`] 的结果互斥，并且对于从 [`symlink_metadata`] 获得的符号链接元数据将为 false。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this metadata is for a regular file.",
        "suggest": "如果此元数据用于常规文件，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "The result is mutually exclusive to the result of [`Metadata::is_dir`], and will be false for symlink metadata obtained from [`symlink_metadata`].",
        "suggest": "结果与 [`Metadata::is_dir`] 的结果互斥，并且对于从 [`symlink_metadata`] 获得的符号链接元数据将为 false。",
        "translate": ""
    },
    {
        "source": "When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it.",
        "suggest": "当目标只是读取 (或写入) 源时，可以读取 (或写入) 最可靠的测试源方法是打开它。",
        "translate": ""
    },
    {
        "source": "Only using `is_file` can break workflows like `diff <( prog_a )` on a Unix-like system for example.",
        "suggest": "例如，仅使用 `is_file` 才能中断类似 Unix 的系统上的工作流，例如 `diff <( prog_a )`。",
        "translate": ""
    },
    {
        "source": "See [`File::open`] or [`OpenOptions::open`] for more information.",
        "suggest": "有关更多信息，请参见 [`File::open`] 或 [`OpenOptions::open`]。",
        "translate": ""
    },
    {
        "source": "Returns the size of the file, in bytes, this metadata is for.",
        "suggest": "返回此元数据用于的文件大小 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "Returns the permissions of the file this metadata is for.",
        "suggest": "返回此元数据所针对的文件的权限。",
        "translate": ""
    },
    {
        "source": "Returns the last modification time listed in this metadata.",
        "suggest": "返回此元数据中列出的最后修改时间。",
        "translate": ""
    },
    {
        "source": "The returned value corresponds to the `mtime` field of `stat` on Unix platforms and the `ftLastWriteTime` field on Windows platforms.",
        "suggest": "返回的值对应于 Unix 平台上的 `stat` 的 `mtime` 字段和 Windows 平台上的 `ftLastWriteTime` 字段。",
        "translate": ""
    },
    {
        "source": "This field may not be available on all platforms, and will return an `Err` on platforms where it is not available.",
        "suggest": "此字段可能并非在所有平台上都可用，并且会在不可用的平台上返回 `Err`。",
        "translate": ""
    },
    {
        "source": "Returns the last access time of this metadata.",
        "suggest": "返回此元数据的最后访问时间。",
        "translate": ""
    },
    {
        "source": "The returned value corresponds to the `atime` field of `stat` on Unix platforms and the `ftLastAccessTime` field on Windows platforms.",
        "suggest": "返回的值对应于 Unix 平台上的 `stat` 的 `atime` 字段和 Windows 平台上的 `ftLastAccessTime` 字段。",
        "translate": ""
    },
    {
        "source": "Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has `noatime`.",
        "suggest": "请注意，并非所有平台都会在文件的元数据中保留此字段的更新，例如，Windows 可以选择在访问文件时禁用此更新，而 Linux 同样具有 `noatime`。",
        "translate": ""
    },
    {
        "source": "Returns the creation time listed in this metadata.",
        "suggest": "返回此元数据中列出的创建时间。",
        "translate": ""
    },
    {
        "source": "The returned value corresponds to the `btime` field of `statx` on Linux kernel starting from to 4.11, the `birthtime` field of `stat` on other Unix platforms, and the `ftCreationTime` field on Windows platforms.",
        "suggest": "返回的值与从 4.11 开始的 Linux 内核上的 `statx` 的 `btime` 字段，在其他 Unix 平台上的 `stat` 的 `birthtime` 字段以及在 Windows 平台上的 `ftCreationTime` 字段相对应。",
        "translate": ""
    },
    {
        "source": "This field may not be available on all platforms, and will return an `Err` on platforms or filesystems where it is not available.",
        "suggest": "此字段可能并非在所有平台上都可用，并且将在不可用的平台或文件系统上返回 `Err`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if these permissions describe a readonly (unwritable) file.",
        "suggest": "如果这些权限描述了只读 (unwritable) 文件，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Modifies the readonly flag for this set of permissions.",
        "suggest": "修改此权限集的只读标志。",
        "translate": ""
    },
    {
        "source": "If the `readonly` argument is `true`, using the resulting `Permission` will update file permissions to forbid writing.",
        "suggest": "如果 `readonly` 参数是 `true`，则使用生成的 `Permission` 将更新文件权限以禁止写入。",
        "translate": ""
    },
    {
        "source": "Conversely, if it's `false`, using the resulting `Permission` will update file permissions to allow writing.",
        "suggest": "相反，如果是 `false`，则使用生成的 `Permission` 将更新文件权限以允许写入。",
        "translate": ""
    },
    {
        "source": "This operation does **not** modify the filesystem.",
        "suggest": "此操作不修改文件系统。",
        "translate": ""
    },
    {
        "source": "To modify the filesystem use the [`set_permissions`] function.",
        "suggest": "要修改文件系统，请使用 [`set_permissions`] 函数。",
        "translate": ""
    },
    {
        "source": "Tests whether this file type represents a directory.",
        "suggest": "测试此文件类型是否代表目录。",
        "translate": ""
    },
    {
        "source": "The result is mutually exclusive to the results of [`is_file`] and [`is_symlink`];",
        "suggest": "结果与 [`is_file`] 和 [`is_symlink`] 的结果互斥;",
        "translate": ""
    },
    {
        "source": "only zero or one of these tests may pass.",
        "suggest": "这些测试只能通过零或其中一项。",
        "translate": ""
    },
    {
        "source": "Tests whether this file type represents a regular file.",
        "suggest": "测试此文件类型是否代表常规文件。",
        "translate": ""
    },
    {
        "source": "The result is  mutually exclusive to the results of [`is_dir`] and [`is_symlink`];",
        "suggest": "结果与 [`is_dir`] 和 [`is_symlink`] 的结果互斥;",
        "translate": ""
    },
    {
        "source": "Tests whether this file type represents a symbolic link.",
        "suggest": "测试此文件类型是否代表符号链接。",
        "translate": ""
    },
    {
        "source": "The result is mutually exclusive to the results of [`is_dir`] and [`is_file`];",
        "suggest": "结果与 [`is_dir`] 和 [`is_file`] 的结果互斥;",
        "translate": ""
    },
    {
        "source": "The underlying [`Metadata`] struct needs to be retrieved with the [`fs::symlink_metadata`] function and not the [`fs::metadata`] function.",
        "suggest": "需要使用 [`fs::symlink_metadata`] 函数而不是 [`fs::metadata`] 函数来检索基础 [`Metadata`] 结构体。",
        "translate": ""
    },
    {
        "source": "The [`fs::metadata`] function follows symbolic links, so [`is_symlink`] would always return `false` for the target file.",
        "suggest": "[`fs::metadata`] 函数遵循符号链接，因此 [`is_symlink`] 将始终为目标文件返回 `false`。",
        "translate": ""
    },
    {
        "source": "Returns the full path to the file that this entry represents.",
        "suggest": "返回此条目表示的文件的完整路径。",
        "translate": ""
    },
    {
        "source": "The full path is created by joining the original path to `read_dir` with the filename of this entry.",
        "suggest": "通过将 `read_dir` 的原始路径与该条目的文件名连接起来，可以创建完整路径。",
        "translate": ""
    },
    {
        "source": "This prints output like:",
        "suggest": "打印输出如下:",
        "translate": ""
    },
    {
        "source": "The exact text, of course, depends on what files you have in `.`.",
        "suggest": "当然，确切的文本取决于 `.` 中包含的文件。",
        "translate": ""
    },
    {
        "source": "Returns the metadata for the file that this entry points at.",
        "suggest": "返回此条目指向的文件的元数据。",
        "translate": ""
    },
    {
        "source": "This function will not traverse symlinks if this entry points at a symlink.",
        "suggest": "如果此函数指向符号链接，则该函数将不会遍历符号链接。",
        "translate": ""
    },
    {
        "source": "To traverse symlinks use [`fs::metadata`] or [`fs::File::metadata`].",
        "suggest": "要遍历符号链接，请使用 [`fs::metadata`] 或 [`fs::File::metadata`]。",
        "translate": ""
    },
    {
        "source": "On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling `symlink_metadata` on the path.",
        "suggest": "在 Windows 上，此函数的调用很便宜 (不需要额外的系统调用)，但是在 Unix 平台上，此函数等效于在路径上调用 `symlink_metadata`。",
        "translate": ""
    },
    {
        "source": "Returns the file type for the file that this entry points at.",
        "suggest": "返回此条目指向的文件的文件类型。",
        "translate": ""
    },
    {
        "source": "On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to `symlink_metadata` to learn about the target file type.",
        "suggest": "在 Windows 和大多数 Unix 平台上，此函数是免费的 (不需要额外的系统调用)，但是某些 Unix 平台可能需要与 `symlink_metadata` 等效的调用才能了解目标文件类型。",
        "translate": ""
    },
    {
        "source": "Returns the bare file name of this directory entry without any other leading path component.",
        "suggest": "返回此目录条目的裸文件名，不包含任何其他前导路径组件。",
        "translate": ""
    },
    {
        "source": "Removes a file from the filesystem.",
        "suggest": "从文件系统中删除文件。",
        "translate": ""
    },
    {
        "source": "Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).",
        "suggest": "请注意，不能保证立即删除文件 (例如，取决于平台，其他打开的文件描述符可能会阻止立即删除)。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `unlink` function on Unix and the `DeleteFile` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `unlink` 函数和 Windows 上的 `DeleteFile` 函数。",
        "translate": ""
    },
    {
        "source": "This function will return an error in the following situations, but is not limited to just these cases:",
        "suggest": "在以下情况下，此函数将返回错误，但不仅限于这些情况:",
        "translate": ""
    },
    {
        "source": "points to a directory.",
        "suggest": "指向目录。",
        "translate": ""
    },
    {
        "source": "The file doesn't exist.",
        "suggest": "该文件不存在。",
        "translate": ""
    },
    {
        "source": "The user lacks permissions to remove the file.",
        "suggest": "用户没有删除文件的权限。",
        "translate": ""
    },
    {
        "source": "Given a path, query the file system to get information about a file, directory, etc.",
        "suggest": "给定路径，查询文件系统以获取有关文件，目录等的信息。",
        "translate": ""
    },
    {
        "source": "This function will traverse symbolic links to query information about the destination file.",
        "suggest": "该函数将遍历符号链接以查询有关目标文件的信息。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `stat` function on Unix and the `GetFileAttributesEx` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `stat` 函数和 Windows 上的 `GetFileAttributesEx` 函数。",
        "translate": ""
    },
    {
        "source": "The user lacks permissions to perform `metadata` call on `path`.",
        "suggest": "用户没有权限在 `path` 上执行 `metadata` 调用。",
        "translate": ""
    },
    {
        "source": "does not exist.",
        "suggest": "不存在。",
        "translate": ""
    },
    {
        "source": "Query the metadata about a file without following symlinks.",
        "suggest": "查询有关文件的元数据，而无需遵循符号链接。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `lstat` function on Unix and the `GetFileAttributesEx` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `lstat` 函数和 Windows 上的 `GetFileAttributesEx` 函数。",
        "translate": ""
    },
    {
        "source": "Rename a file or directory to a new name, replacing the original file if `to` already exists.",
        "suggest": "将文件或目录重命名为新名称，如果 `to` 已经存在，则替换原始文件。",
        "translate": ""
    },
    {
        "source": "This will not work if the new name is on a different mount point.",
        "suggest": "如果新名称在其他安装点上，则将无法使用。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `rename` function on Unix and the `MoveFileEx` function with the `MOVEFILE_REPLACE_EXISTING` flag on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `rename` 函数和 Windows 上带有 `MOVEFILE_REPLACE_EXISTING` 标志的 `MoveFileEx` 函数。",
        "translate": ""
    },
    {
        "source": "Because of this, the behavior when both `from` and `to` exist differs.",
        "suggest": "因此，`from` 和 `to` 都存在时的行为是不同的。",
        "translate": ""
    },
    {
        "source": "On Unix, if `from` is a directory, `to` must also be an (empty) directory.",
        "suggest": "在 Unix 上，如果 `from` 是目录，则 `to` 也必须是 (empty) 目录。",
        "translate": ""
    },
    {
        "source": "If `from` is not a directory, `to` must also be not a directory.",
        "suggest": "如果 `from` 不是目录，则 `to` 也必须不是目录。",
        "translate": ""
    },
    {
        "source": "In contrast, on Windows, `from` can be anything, but `to` must *not* be a directory.",
        "suggest": "相比之下，在 Windows 上，`from` 可以是任何东西，但是 `to` 一定不是目录。",
        "translate": ""
    },
    {
        "source": "The user lacks permissions to view contents.",
        "suggest": "用户没有查看内容的权限。",
        "translate": ""
    },
    {
        "source": "and `to` are on separate filesystems.",
        "suggest": "和 `to` 在单独的文件系统上。",
        "translate": ""
    },
    {
        "source": "Copies the contents of one file to another.",
        "suggest": "将一个文件的内容复制到另一个文件。",
        "translate": ""
    },
    {
        "source": "This function will also copy the permission bits of the original file to the destination file.",
        "suggest": "此函数还将复制原始文件的权限位到目标文件。",
        "translate": ""
    },
    {
        "source": "This function will **overwrite** the contents of `to`.",
        "suggest": "该函数将覆盖 `to` 的内容。",
        "translate": ""
    },
    {
        "source": "Note that if `from` and `to` both point to the same file, then the file will likely get truncated by this operation.",
        "suggest": "请注意，如果 `from` 和 `to` 都指向同一个文件，则此操作可能会截断该文件。",
        "translate": ""
    },
    {
        "source": "On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.",
        "suggest": "成功后，将返回复制的字节总数，该总数等于 `metadata` 报告的 `to` 文件的长度。",
        "translate": ""
    },
    {
        "source": "If you’re wanting to copy the contents of one file to another and you’re working with [`File`]s, see the [`io::copy()`] function.",
        "suggest": "如果您想将一个文件的内容复制到另一个文件，并且正在使用 [`File`]，请参见 [`io::copy()`] 函数。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `open` function in Unix with `O_RDONLY` for `from` and `O_WRONLY`, `O_CREAT`, and `O_TRUNC` for `to`.",
        "suggest": "此函数当前与 Unix 中的 `open` 函数相对应，其中 `from` 的 `O_RDONLY` 和 `to` 的 `O_WRONLY`，`O_CREAT` 和 `O_TRUNC`。",
        "translate": ""
    },
    {
        "source": "is set for returned file descriptors.",
        "suggest": "为返回的文件描述符设置。",
        "translate": ""
    },
    {
        "source": "On Windows, this function currently corresponds to `CopyFileEx`.",
        "suggest": "在 Windows 上，此函数当前对应于 `CopyFileEx`。",
        "translate": ""
    },
    {
        "source": "Alternate NTFS streams are copied but only the size of the main stream is returned by this function.",
        "suggest": "复制备用 NTFS 流，但此函数仅返回主流的大小。",
        "translate": ""
    },
    {
        "source": "On MacOS, this function corresponds to `fclonefileat` and `fcopyfile`.",
        "suggest": "在 MacOS 上，此函数对应于 `fclonefileat` 和 `fcopyfile`。",
        "translate": ""
    },
    {
        "source": "The `from` path is not a file.",
        "suggest": "`from` 路径不是文件。",
        "translate": ""
    },
    {
        "source": "The `from` file does not exist.",
        "suggest": "`from` 文件不存在。",
        "translate": ""
    },
    {
        "source": "The current process does not have the permission rights to access `from` or write `to`.",
        "suggest": "当前进程没有访问 `from` 或写入 `to` 的权限。",
        "translate": ""
    },
    {
        "source": "Creates a new hard link on the filesystem.",
        "suggest": "在文件系统上创建一个新的硬链接。",
        "translate": ""
    },
    {
        "source": "The `link` path will be a link pointing to the `original` path.",
        "suggest": "`link` 路径将是指向 `original` 路径的链接。",
        "translate": ""
    },
    {
        "source": "Note that systems often require these two paths to both be located on the same filesystem.",
        "suggest": "请注意，系统通常要求这两个路径都位于同一文件系统上。",
        "translate": ""
    },
    {
        "source": "If `original` names a symbolic link, it is platform-specific whether the symbolic link is followed.",
        "suggest": "如果 `original` 命名符号链接，则是否遵循符号链接是特定于平台的。",
        "translate": ""
    },
    {
        "source": "On platforms where it's possible to not follow it, it is not followed, and the created hard link points to the symbolic link itself.",
        "suggest": "在可能不遵循它的平台上，它不会被遵循，并且创建的硬链接指向符号链接本身。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `linkat` function with no flags on Unix and the `CreateHardLink` function on Windows.",
        "suggest": "该函数当前与 Unix 上没有标志的 `linkat` 函数相对应，在 Windows 上没有 `CreateHardLink` 函数。",
        "translate": ""
    },
    {
        "source": "The `original` path is not a file or doesn't exist.",
        "suggest": "`original` 路径不是文件或不存在。",
        "translate": ""
    },
    {
        "source": "Creates a new symbolic link on the filesystem.",
        "suggest": "在文件系统上创建一个新的符号链接。",
        "translate": ""
    },
    {
        "source": "The `link` path will be a symbolic link pointing to the `original` path.",
        "suggest": "`link` 路径将是指向 `original` 路径的符号链接。",
        "translate": ""
    },
    {
        "source": "On Windows, this will be a file symlink, not a directory symlink;",
        "suggest": "在 Windows 上，这将是文件符号链接，而不是目录符号链接。",
        "translate": ""
    },
    {
        "source": "for this reason, the platform-specific [`std::os::unix::fs::symlink`] and [`std::os::windows::fs::symlink_file`] or [`symlink_dir`] should be used instead to make the intent explicit.",
        "suggest": "因此，应该使用平台特定的 [`std::os::unix::fs::symlink`] 和 [`std::os::windows::fs::symlink_file`] 或 [`symlink_dir`] 来明确意图。",
        "translate": ""
    },
    {
        "source": "Reads a symbolic link, returning the file that the link points to.",
        "suggest": "读取符号链接，返回链接指向的文件。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `readlink` function on Unix and the `CreateFile` function with `FILE_FLAG_OPEN_REPARSE_POINT` and `FILE_FLAG_BACKUP_SEMANTICS` flags on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `readlink` 函数，以及 Windows 上带有 `FILE_FLAG_OPEN_REPARSE_POINT` 和 `FILE_FLAG_BACKUP_SEMANTICS` 标志的 `CreateFile` 函数。",
        "translate": ""
    },
    {
        "source": "is not a symbolic link.",
        "suggest": "不是符号链接。",
        "translate": ""
    },
    {
        "source": "Returns the canonical, absolute form of a path with all intermediate components normalized and symbolic links resolved.",
        "suggest": "返回路径的规范，绝对形式，所有中间组件均已规范化且符号链接已解析。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `realpath` function on Unix and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `realpath` 函数以及 Windows 上的 `CreateFile` 和 `GetFinalPathNameByHandle` 函数。",
        "translate": ""
    },
    {
        "source": "On Windows, this converts the path to use [extended length path][path] syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).",
        "suggest": "在 Windows 上，这会将路径转换为使用 [extended length path][path] 语法，这允许您的程序使用更长的路径名，但是意味着您只能将反斜杠分隔的路径连接到该路径，并且它可能与其他应用程序不兼容 (如果传递给该应用程序，命令行，或写入另一个应用程序可以读取的文件)。",
        "translate": ""
    },
    {
        "source": "A non-final component in path is not a directory.",
        "suggest": "path 中的非最终组件不是目录。",
        "translate": ""
    },
    {
        "source": "Creates a new, empty directory at the provided path",
        "suggest": "在提供的路径中创建一个新的空目录",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `mkdir` function on Unix and the `CreateDirectory` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `mkdir` 函数和 Windows 上的 `CreateDirectory` 函数。",
        "translate": ""
    },
    {
        "source": "If a parent of the given path doesn't exist, this function will return an error.",
        "suggest": "如果给定路径的父项不存在，则此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "To create a directory and all its missing parents at the same time, use the [`create_dir_all`] function.",
        "suggest": "要同时创建目录及其所有丢失的父目录，请使用 [`create_dir_all`] 函数。",
        "translate": ""
    },
    {
        "source": "User lacks permissions to create directory at `path`.",
        "suggest": "用户没有权限在 `path` 上创建目录。",
        "translate": ""
    },
    {
        "source": "A parent of the given path doesn't exist.",
        "suggest": "给定路径的父级不存在。",
        "translate": ""
    },
    {
        "source": "(To create a directory and all its missing parents at the same time, use the [`create_dir_all`] function.)",
        "suggest": "(要同时创建目录及其所有丢失的父目录，请使用 [`create_dir_all`] 函数。)",
        "translate": ""
    },
    {
        "source": "already exists.",
        "suggest": "已经存在。",
        "translate": ""
    },
    {
        "source": "Recursively create a directory and all of its parent components if they are missing.",
        "suggest": "递归创建目录及其所有父组件 (如果缺少)。",
        "translate": ""
    },
    {
        "source": "If any directory in the path specified by `path` does not already exist and it could not be created otherwise.",
        "suggest": "如果 `path` 指定的路径中的任何目录都不存在，否则无法创建。",
        "translate": ""
    },
    {
        "source": "The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by [`fs::create_dir`].",
        "suggest": "[`fs::create_dir`] 概述了创建目录时 (确定目录不存在后) 的特定错误条件。",
        "translate": ""
    },
    {
        "source": "Notable exception is made for situations where any of the directories specified in the `path` could not be created as it was being created concurrently.",
        "suggest": "对于在 `path` 中指定的任何目录无法同时创建的情况下，将创建一个明显的例外。",
        "translate": ""
    },
    {
        "source": "Such cases are considered to be successful.",
        "suggest": "这种情况被认为是成功的。",
        "translate": ""
    },
    {
        "source": "That is, calling `create_dir_all` concurrently from multiple threads or processes is guaranteed not to fail due to a race condition with itself.",
        "suggest": "即，保证了从多个线程或进程并发调用 `create_dir_all` 不会由于自身的竞争态而失败。",
        "translate": ""
    },
    {
        "source": "Removes an empty directory.",
        "suggest": "删除一个空目录。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `rmdir` function on Unix and the `RemoveDirectory` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `rmdir` 函数和 Windows 上的 `RemoveDirectory` 函数。",
        "translate": ""
    },
    {
        "source": "doesn't exist.",
        "suggest": "不存在。",
        "translate": ""
    },
    {
        "source": "isn't a directory.",
        "suggest": "不是目录。",
        "translate": ""
    },
    {
        "source": "The user lacks permissions to remove the directory at the provided `path`.",
        "suggest": "用户没有权限删除提供的 `path` 上的目录。",
        "translate": ""
    },
    {
        "source": "The directory isn't empty.",
        "suggest": "目录不为空。",
        "translate": ""
    },
    {
        "source": "Removes a directory at this path, after removing all its contents.",
        "suggest": "删除目录中的所有内容后，将在此路径中删除该目录。",
        "translate": ""
    },
    {
        "source": "Use carefully!",
        "suggest": "小心使用!",
        "translate": ""
    },
    {
        "source": "This function does **not** follow symbolic links and it will simply remove the symbolic link itself.",
        "suggest": "此函数不跟随符号链接，它会简单地删除符号链接本身。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to `opendir`, `lstat`, `rm` and `rmdir` functions on Unix and the `FindFirstFile`, `GetFileAttributesEx`, `DeleteFile`, and `RemoveDirectory` functions on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `opendir`，`lstat`，`rm` 和 `rmdir` 函数，以及 Windows 上的 `FindFirstFile`，`GetFileAttributesEx`，`DeleteFile` 和 `RemoveDirectory` 函数。",
        "translate": ""
    },
    {
        "source": "See [`fs::remove_file`] and [`fs::remove_dir`].",
        "suggest": "请参见 [`fs::remove_file`] 和 [`fs::remove_dir`]。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the entries within a directory.",
        "suggest": "返回目录中条目的迭代器。",
        "translate": ""
    },
    {
        "source": "The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`.",
        "suggest": "迭代器将产生 [`io::Result`]`<`[`DirEntry`]`>` 的实例。",
        "translate": ""
    },
    {
        "source": "New errors may be encountered after an iterator is initially constructed.",
        "suggest": "最初构造迭代器后，可能会遇到新的错误。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `opendir` function on Unix and the `FindFirstFile` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `opendir` 函数和 Windows 上的 `FindFirstFile` 函数。",
        "translate": ""
    },
    {
        "source": "Advancing the iterator currently corresponds to `readdir` on Unix and `FindNextFile` on Windows.",
        "suggest": "推进迭代器当前对应于 Unix 上的 `readdir` 和 Windows 上的 `FindNextFile`。",
        "translate": ""
    },
    {
        "source": "The provided `path` doesn't exist.",
        "suggest": "提供的 `path` 不存在。",
        "translate": ""
    },
    {
        "source": "The process lacks permissions to view the contents.",
        "suggest": "该进程没有查看内容的权限。",
        "translate": ""
    },
    {
        "source": "The `path` points at a non-directory file.",
        "suggest": "`path` 指向非目录文件。",
        "translate": ""
    },
    {
        "source": "Changes the permissions found on a file or a directory.",
        "suggest": "更改在文件或目录上找到的权限。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to the `chmod` function on Unix and the `SetFileAttributes` function on Windows.",
        "suggest": "该函数当前对应于 Unix 上的 `chmod` 函数和 Windows 上的 `SetFileAttributes` 函数。",
        "translate": ""
    },
    {
        "source": "The user lacks the permission to change attributes of the file.",
        "suggest": "用户没有更改文件属性的权限。",
        "translate": ""
    },
    {
        "source": "Creates a new set of options with default mode/security settings for all platforms and also non-recursive.",
        "suggest": "使用所有平台的默认 mode/security 设置创建一组新选项，并且这些选项也是非递归的。",
        "translate": ""
    },
    {
        "source": "Indicates that directories should be created recursively, creating all parent directories.",
        "suggest": "指示应递归创建目录，并创建所有父目录。",
        "translate": ""
    },
    {
        "source": "Parents that do not exist are created with the same security and permissions settings.",
        "suggest": "使用相同的安全性和权限设置创建不存在的父级。",
        "translate": ""
    },
    {
        "source": "This option defaults to `false`.",
        "suggest": "此选项默认为 `false`。",
        "translate": ""
    },
    {
        "source": "Creates the specified directory with the options configured in this builder.",
        "suggest": "使用在此构建器中配置的选项来创建指定的目录。",
        "translate": ""
    },
    {
        "source": "It is considered an error if the directory already exists unless recursive mode is enabled.",
        "suggest": "如果目录已经存在，除非启用了递归模式，否则将被视为错误。",
        "translate": ""
    },
    {
        "source": "The `BufReader<R>` struct adds buffering to any reader.",
        "suggest": "`BufReader<R>` 结构体将缓冲添加到任何 reader。",
        "translate": ""
    },
    {
        "source": "It can be excessively inefficient to work directly with a [`Read`] instance.",
        "suggest": "直接使用 [`Read`] 实例可能会非常低效。",
        "translate": ""
    },
    {
        "source": "For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`] results in a system call.",
        "suggest": "例如，对 [`TcpStream`] 上 [`read`][`TcpStream::read`] 的每次调用都会导致系统调用。",
        "translate": ""
    },
    {
        "source": "A `BufReader<R>` performs large, infrequent reads on the underlying [`Read`] and maintains an in-memory buffer of the results.",
        "suggest": "`BufReader<R>` 对基础 [`Read`] 进行大批量的不频繁读取，并维护结果的内存缓冲区。",
        "translate": ""
    },
    {
        "source": "can improve the speed of programs that make *small* and *repeated* read calls to the same file or network socket.",
        "suggest": "可以提高使 *小* 和 *重复* 读取对同一文件或网络套接字的调用的程序的速度。",
        "translate": ""
    },
    {
        "source": "It does not help when reading very large amounts at once, or reading just one or a few times.",
        "suggest": "一次读取非常多的内容，或者仅读取一次或几次，则无济于事。",
        "translate": ""
    },
    {
        "source": "It also provides no advantage when reading from a source that is already in memory, like a [`Vec`]`<u8>`.",
        "suggest": "从诸如 [`Vec`]`<u8>` 之类的内存中读取数据时，它也没有任何优势。",
        "translate": ""
    },
    {
        "source": "When the `BufReader<R>` is dropped, the contents of its buffer will be discarded.",
        "suggest": "当 `BufReader<R>` 被丢弃时，其缓冲区的内容将被丢弃。",
        "translate": ""
    },
    {
        "source": "Creating multiple instances of a `BufReader<R>` on the same stream can cause data loss.",
        "suggest": "在同一流上创建 `BufReader<R>` 的多个实例可能会导致数据丢失。",
        "translate": ""
    },
    {
        "source": "Reading from the underlying reader after unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause data loss.",
        "suggest": "将 `BufReader<R>` 与 [`BufReader::into_inner`] 展开包装后，从基础 reader 进行读取也会导致数据丢失。",
        "translate": ""
    },
    {
        "source": "can't use `crate` for associated items",
        "suggest": "不能将 `crate` 用于关联项",
        "translate": ""
    },
    {
        "source": "Creates a new `BufReader<R>` with a default buffer capacity.",
        "suggest": "创建一个具有默认缓冲区容量的新 `BufReader<R>`。",
        "translate": ""
    },
    {
        "source": "The default is currently 8 KB, but may change in the future.",
        "suggest": "当前默认值为 8 KB，但可能会在 future 中进行更改。",
        "translate": ""
    },
    {
        "source": "Creates a new `BufReader<R>` with the specified buffer capacity.",
        "suggest": "用指定的缓冲区容量创建一个新的 `BufReader<R>`。",
        "translate": ""
    },
    {
        "source": "Creating a buffer with ten bytes of capacity:",
        "suggest": "创建一个具有十个字节容量的缓冲区:",
        "translate": ""
    },
    {
        "source": "Gets a reference to the underlying reader.",
        "suggest": "获取对基础 reader 的引用。",
        "translate": ""
    },
    {
        "source": "It is inadvisable to directly read from the underlying reader.",
        "suggest": "不建议直接从基础 reader 中读取。",
        "translate": ""
    },
    {
        "source": "Gets a mutable reference to the underlying reader.",
        "suggest": "获取基础 reader 的可变引用。",
        "translate": ""
    },
    {
        "source": "Returns a reference to the internally buffered data.",
        "suggest": "返回对内部缓冲数据的引用。",
        "translate": ""
    },
    {
        "source": "Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.",
        "suggest": "与 [`fill_buf`] 不同，如果缓冲区为空，它将不会尝试填充缓冲区。",
        "translate": ""
    },
    {
        "source": "Returns the number of bytes the internal buffer can hold at once.",
        "suggest": "返回内部缓冲区可以一次保存的字节数。",
        "translate": ""
    },
    {
        "source": "Unwraps this `BufReader<R>`, returning the underlying reader.",
        "suggest": "解包此 `BufReader<R>`，返回基础 reader。",
        "translate": ""
    },
    {
        "source": "Note that any leftover data in the internal buffer is lost.",
        "suggest": "请注意，内部缓冲区中的所有剩余数据都会丢失。",
        "translate": ""
    },
    {
        "source": "Therefore, a following read from the underlying reader may lead to data loss.",
        "suggest": "因此，对基础 reader 的后续读取可能会导致数据丢失。",
        "translate": ""
    },
    {
        "source": "Invalidates all data in the internal buffer.",
        "suggest": "使内部缓冲区中的所有数据无效。",
        "translate": ""
    },
    {
        "source": "Seeks relative to the current position.",
        "suggest": "相对于当前位置寻找。",
        "translate": ""
    },
    {
        "source": "If the new position lies within the buffer, the buffer will not be flushed, allowing for more efficient seeks.",
        "suggest": "如果新位置位于缓冲区内，则不会刷新缓冲区，从而实现更有效的查找。",
        "translate": ""
    },
    {
        "source": "This method does not return the location of the underlying reader, so the caller must track this information themselves if it is required.",
        "suggest": "此方法不返回基础 reader 的位置，因此，如果需要，调用者必须自己跟踪此信息。",
        "translate": ""
    },
    {
        "source": "If we don't have any buffered data and we're doing a massive read (larger than our internal buffer), bypass our internal buffer entirely.",
        "suggest": "如果我们没有任何缓冲数据，并且正在进行大量读取 (大于内部缓冲区)，请完全绕过内部缓冲区。",
        "translate": ""
    },
    {
        "source": "Small read_exacts from a BufReader are extremely common when used with a deserializer.",
        "suggest": "与反序列化器一起使用时，来自 BufReader 的小 read_exacts 非常普遍。",
        "translate": ""
    },
    {
        "source": "The default implementation calls read in a loop, which results in surprisingly poor code generation for the common path where the buffer has enough bytes to fill the passed-in buffer.",
        "suggest": "默认实现在循环中调用 read，这会导致在公共路径中缓冲区具有足够的字节来填充传入缓冲区的公共路径，导致代码生成异常差。",
        "translate": ""
    },
    {
        "source": "we can't skip unconditionally because of the large buffer case in read.",
        "suggest": "我们不能无条件地跳过，因为读取时缓冲区很大。",
        "translate": ""
    },
    {
        "source": "If we've reached the end of our internal buffer then we need to fetch some more data from the underlying reader.",
        "suggest": "如果到达内部缓冲区的末尾，则需要从基础 reader 中获取更多数据。",
        "translate": ""
    },
    {
        "source": "Branch using `>=` instead of the more correct `==` to tell the compiler that the pos..cap slice is always valid.",
        "suggest": "使用 `>=` 而不是更正确的 `==` 进行分支，以告知编译器 pos..cap 切片始终有效。",
        "translate": ""
    },
    {
        "source": "Seek to an offset, in bytes, in the underlying reader.",
        "suggest": "在基础 reader 中寻找以字节为单位的偏移量。",
        "translate": ""
    },
    {
        "source": "The position used for seeking with [`SeekFrom::Current`]`(_)` is the position the underlying reader would be at if the `BufReader<R>` had no internal buffer.",
        "suggest": "用于 [`SeekFrom::Current`]`(_)` 的搜索位置是 `BufReader<R>` 没有内部缓冲区时基础 reader 所在的位置。",
        "translate": ""
    },
    {
        "source": "Seeking always discards the internal buffer, even if the seek position would otherwise fall within it.",
        "suggest": "搜寻总是会丢弃内部缓冲区，即使寻找位置本来会落在内部缓冲区内。",
        "translate": ""
    },
    {
        "source": "This guarantees that calling [`BufReader::into_inner()`] immediately after a seek yields the underlying reader at the same position.",
        "suggest": "这保证了在寻道之后立即调用 [`BufReader::into_inner()`] 会在相同位置产生基础 reader。",
        "translate": ""
    },
    {
        "source": "To seek without discarding the internal buffer, use [`BufReader::seek_relative`].",
        "suggest": "要查找而不丢弃内部缓冲区，请使用 [`BufReader::seek_relative`]。",
        "translate": ""
    },
    {
        "source": "See [`std::io::Seek`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`std::io::Seek`]。",
        "translate": ""
    },
    {
        "source": "In the edge case where you're seeking with [`SeekFrom::Current`]`(n)` where `n` minus the internal buffer length overflows an `i64`, two seeks will be performed instead of one.",
        "suggest": "在使用 [`SeekFrom::Current`]`(n)` 进行搜索的 edge 情况下，`n` 减去内部缓冲区长度使 `i64` 溢出，将执行两次搜索，而不是一次。",
        "translate": ""
    },
    {
        "source": "If the second seek returns [`Err`], the underlying reader will be left at the same position it would have if you called `seek` with [`SeekFrom::Current`]`(0)`.",
        "suggest": "如果第二个搜索返回 [`Err`]，则底层的 reader 将保留在与 [`SeekFrom::Current`]`(0)` 一起调用 `seek` 时的位置。",
        "translate": ""
    },
    {
        "source": "it should be safe to assume that remainder fits within an i64 as the alternative means we managed to allocate 8 exbibytes and that's absurd.",
        "suggest": "可以放心地认为其余部分适合 i64，因为这意味着我们设法分配了 8 EB，这是荒谬的。",
        "translate": ""
    },
    {
        "source": "But it's not out of the realm of possibility for some weird underlying reader to support seeking by i64::MIN so we need to handle underflow when subtracting remainder.",
        "suggest": "但是，某些奇怪的基础 reader 支持 i64::MIN 的搜索并非不可能，因此在减去余数时我们需要处理下溢。",
        "translate": ""
    },
    {
        "source": "seek backwards by our remainder, and then by the offset",
        "suggest": "向后搜索我们的余数，然后向后偏移",
        "translate": ""
    },
    {
        "source": "Seeking with Start/End doesn't care about our buffer length.",
        "suggest": "使用 Start/End 寻求与我们的缓冲区长度无关。",
        "translate": ""
    },
    {
        "source": "Returns the current seek position from the start of the stream.",
        "suggest": "从流的开头返回当前搜索位置。",
        "translate": ""
    },
    {
        "source": "The value returned is equivalent to `self.seek(SeekFrom::Current(0))` but does not flush the internal buffer.",
        "suggest": "返回的值等效于 `self.seek(SeekFrom::Current(0))`，但不刷新内部缓冲区。",
        "translate": ""
    },
    {
        "source": "Due to this optimization the function does not guarantee that calling `.into_inner()` immediately afterwards will yield the underlying reader at the same position.",
        "suggest": "由于进行了这种优化，该函数不能保证在此之后立即调用 `.into_inner()` 将在同一位置产生基础 reader。",
        "translate": ""
    },
    {
        "source": "Use [`BufReader::seek`] instead if you require that guarantee.",
        "suggest": "如果需要该保证，请改用 [`BufReader::seek`]。",
        "translate": ""
    },
    {
        "source": "This function will panic if the position of the inner reader is smaller than the amount of buffered data.",
        "suggest": "如果内部 reader 的位置小于缓冲数据量，则此函数将为 panic。",
        "translate": ""
    },
    {
        "source": "That can happen if the inner reader has an incorrect implementation of [`Seek::stream_position`], or if the position has gone out of sync due to calling [`Seek::seek`] directly on the underlying reader.",
        "suggest": "如果内部 reader 的 [`Seek::stream_position`] 实现不正确，或者由于直接在基础 reader 上调用 [`Seek::seek`] 而导致位置不同步，则可能发生这种情况。",
        "translate": ""
    },
    {
        "source": "we can use reference just like buffer",
        "suggest": "我们可以像缓冲区一样使用引用",
        "translate": ""
    },
    {
        "source": "See how many bytes are currently buffered",
        "suggest": "查看当前缓冲了多少字节",
        "translate": ""
    },
    {
        "source": "Check the capacity of the inner buffer",
        "suggest": "检查内部缓冲区的容量",
        "translate": ""
    },
    {
        "source": "Calculate how many bytes can be written without flushing",
        "suggest": "计算不刷新就可以写入多少个字节",
        "translate": ""
    },
    {
        "source": "unwrap the TcpStream and flush the buffer",
        "suggest": "拆开 TcpStream 并刷新缓冲区",
        "translate": ""
    },
    {
        "source": "Wraps a writer and buffers its output.",
        "suggest": "包装一个 writer 并缓冲其输出。",
        "translate": ""
    },
    {
        "source": "It can be excessively inefficient to work directly with something that implements [`Write`].",
        "suggest": "直接与实现 [`Write`] 的组件一起工作可能会非常低效。",
        "translate": ""
    },
    {
        "source": "For example, every call to [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call.",
        "suggest": "例如，对 [`TcpStream`] 上 [`write`][`TcpStream::write`] 的每次调用都会导致系统调用。",
        "translate": ""
    },
    {
        "source": "A `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying writer in large, infrequent batches.",
        "suggest": "`BufWriter<W>` 保留内存中的数据缓冲区，并以不大批量的方式将其写入基础 writer。",
        "translate": ""
    },
    {
        "source": "can improve the speed of programs that make *small* and *repeated* write calls to the same file or network socket.",
        "suggest": "可以提高使 *小* 和 *重复* 将调用写入同一文件或网络套接字的程序的速度。",
        "translate": ""
    },
    {
        "source": "It does not help when writing very large amounts at once, or writing just one or a few times.",
        "suggest": "一次写入大量或一次写入几次都无济于事。",
        "translate": ""
    },
    {
        "source": "It also provides no advantage when writing to a destination that is in memory, like a [`Vec`]`<u8>`.",
        "suggest": "当写入内存中的目标 (例如 [`Vec`]`<u8>`) 时，它也没有任何优势。",
        "translate": ""
    },
    {
        "source": "It is critical to call [`flush`] before `BufWriter<W>` is dropped.",
        "suggest": "在丢弃 `BufWriter<W>` 之前，调用 [`flush`] 至关重要。",
        "translate": ""
    },
    {
        "source": "Though dropping will attempt to flush the contents of the buffer, any errors that happen in the process of dropping will be ignored.",
        "suggest": "尽管丢弃将尝试刷新缓冲区的内容，但丢弃过程中发生的任何错误都将被忽略。",
        "translate": ""
    },
    {
        "source": "Calling [`flush`] ensures that the buffer is empty and thus dropping will not even attempt file operations.",
        "suggest": "调用 [`flush`] 可确保缓冲区为空，因此丢弃操作甚至不会尝试文件操作。",
        "translate": ""
    },
    {
        "source": "Let's write the numbers one through ten to a [`TcpStream`]:",
        "suggest": "让我们将数字 1 到 10 写入 [`TcpStream`]:",
        "translate": ""
    },
    {
        "source": "Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written.",
        "suggest": "因为我们没有缓冲，所以我们依次写入每个字节，从而导致写入的每个字节占用系统调用的开销。",
        "translate": ""
    },
    {
        "source": "We can fix this with a",
        "suggest": "我们可以用",
        "translate": ""
    },
    {
        "source": "By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped together by the buffer and will all be written out in one system call when the `stream` is flushed.",
        "suggest": "通过用 `BufWriter<W>` 包装流，这十次写操作全部由缓冲区分组，并且在刷新 `stream` 时将全部写在一个系统调用中。",
        "translate": ""
    },
    {
        "source": "If the inner writer panics in a call to write, we don't want to write the buffered data a second time in BufWriter's destructor.",
        "suggest": "如果内部 writer panics 在调用中进行写入，则我们不想在 BufWriter 的析构函数中第二次写入缓冲的数据。",
        "translate": ""
    },
    {
        "source": "This flag tells the Drop impl if it should skip the flush.",
        "suggest": "该标志告诉 Drop impl 是否应跳过刷新。",
        "translate": ""
    },
    {
        "source": "Creates a new `BufWriter<W>` with a default buffer capacity.",
        "suggest": "创建一个具有默认缓冲区容量的新 `BufWriter<W>`。",
        "translate": ""
    },
    {
        "source": "Creates a new `BufWriter<W>` with the specified buffer capacity.",
        "suggest": "用指定的缓冲区容量创建一个新的 `BufWriter<W>`。",
        "translate": ""
    },
    {
        "source": "Creating a buffer with a buffer of a hundred bytes.",
        "suggest": "用一个一百字节的缓冲区创建一个缓冲区。",
        "translate": ""
    },
    {
        "source": "Send data in our local buffer into the inner writer, looping as necessary until either it's all been sent or an error occurs.",
        "suggest": "将本地缓冲区中的数据发送到内部 writer 中，并根据需要进行循环，直到全部发送或发生错误为止。",
        "translate": ""
    },
    {
        "source": "Because all the data in the buffer has been reported to our owner as \"successfully written\" (by returning nonzero success values from `write`), any 0-length writes from `inner` must be reported as i/o errors from this method.",
        "suggest": "由于已将缓冲区中的所有数据报告为 \"successfully written\" (通过从 `write` 返回非零成功值) 通知给我们的所有者，因此，从 `inner` 进行任何 0 长度的写操作都必须通过此方法报告为 i/o 错误。",
        "translate": ""
    },
    {
        "source": "Helper struct to ensure the buffer is updated after all the writes are complete.",
        "suggest": "Helper 结构体，以确保在所有写操作完成后更新缓冲区。",
        "translate": ""
    },
    {
        "source": "It tracks the number of written bytes and drains them all from the front of the buffer when dropped.",
        "suggest": "它跟踪写入的字节数，并在丢弃时从缓冲区的前端排出所有字节。",
        "translate": ""
    },
    {
        "source": "The unwritten part of the buffer",
        "suggest": "缓冲区的未写部分",
        "translate": ""
    },
    {
        "source": "Flag some bytes as removed from the front of the buffer",
        "suggest": "将某些字节标记为从缓冲区的最前面删除",
        "translate": ""
    },
    {
        "source": "true if all of the bytes have been written",
        "suggest": "如果所有字节均已写入，则为 true",
        "translate": ""
    },
    {
        "source": "Buffer some data without flushing it, regardless of the size of the data.",
        "suggest": "无论数据大小如何，都可以缓冲某些数据而不刷新它们。",
        "translate": ""
    },
    {
        "source": "Writes as much as possible without exceeding capacity.",
        "suggest": "尽可能多地写入，而不会超出容量。",
        "translate": ""
    },
    {
        "source": "Returns the number of bytes written.",
        "suggest": "返回写入的字节数。",
        "translate": ""
    },
    {
        "source": "Gets a reference to the underlying writer.",
        "suggest": "获取对基础 writer 的引用。",
        "translate": ""
    },
    {
        "source": "Gets a mutable reference to the underlying writer.",
        "suggest": "获取基础 writer 的可变引用。",
        "translate": ""
    },
    {
        "source": "It is inadvisable to directly write to the underlying writer.",
        "suggest": "不建议直接写入基础 writer。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to the internal buffer.",
        "suggest": "返回一个可变引用到内部缓冲区。",
        "translate": ""
    },
    {
        "source": "This can be used to write data directly into the buffer without triggering writers to the underlying writer.",
        "suggest": "这可用于将数据直接写入缓冲区，而无需触发 writers 到基础 writer。",
        "translate": ""
    },
    {
        "source": "That the buffer is a `Vec` is an implementation detail.",
        "suggest": "缓冲区是 `Vec` 是实现细节。",
        "translate": ""
    },
    {
        "source": "Callers should not modify the capacity as there currently is no public API to do so and thus any capacity changes would be unexpected by the user.",
        "suggest": "调用者不应修改容量，因为当前没有公共 API 可以进行修改，因此，任何容量更改都将是用户无法预料的。",
        "translate": ""
    },
    {
        "source": "Returns the number of bytes the internal buffer can hold without flushing.",
        "suggest": "返回内部缓冲区在不刷新的情况下可以容纳的字节数。",
        "translate": ""
    },
    {
        "source": "Unwraps this `BufWriter<W>`, returning the underlying writer.",
        "suggest": "解包此 `BufWriter<W>`，返回基础 writer。",
        "translate": ""
    },
    {
        "source": "The buffer is written out before returning the writer.",
        "suggest": "在返回 writer 之前将缓冲区写出。",
        "translate": ""
    },
    {
        "source": "An [`Err`] will be returned if an error occurs while flushing the buffer.",
        "suggest": "如果刷新缓冲区时发生错误，将返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but unwritten data.",
        "suggest": "反汇编此 `BufWriter<W>`，返回基础 writer，以及所有缓冲但未写入的数据。",
        "translate": ""
    },
    {
        "source": "If the underlying writer panicked, it is not known what portion of the data was written.",
        "suggest": "如果基础 writer 恐慌，则不知道写入了数据的哪一部分。",
        "translate": ""
    },
    {
        "source": "In this case, we return `WriterPanicked` for the buffered data (from which the buffer contents can still be recovered).",
        "suggest": "在这种情况下，我们返回 `WriterPanicked` 作为缓冲数据 (仍然可以从中恢复缓冲内容)。",
        "translate": ""
    },
    {
        "source": "makes no attempt to flush data and cannot fail.",
        "suggest": "不尝试刷新数据，也不会失败。",
        "translate": ""
    },
    {
        "source": "Error returned for the buffered data from `BufWriter::into_raw_parts`, when the underlying writer has previously panicked.",
        "suggest": "当基础 writer 先前发生 panic 时，从 `BufWriter::into_raw_parts` 返回的缓冲数据返回错误。",
        "translate": ""
    },
    {
        "source": "Contains the (possibly partly written) buffered data.",
        "suggest": "包含 (可能是部分写入的) 缓冲数据。",
        "translate": ""
    },
    {
        "source": "Returns the perhaps-unwritten data.",
        "suggest": "返回可能未写入的数据。",
        "translate": ""
    },
    {
        "source": "Some of this data may have been written by the panicking call(s) to the underlying writer, so simply writing it again is not a good idea.",
        "suggest": "恐慌的 call(s) 可能已将某些数据写入基础 writer，因此，仅再次写入它不是一个好主意。",
        "translate": ""
    },
    {
        "source": "Why no len > capacity?",
        "suggest": "为什么没有 len > 容量?",
        "translate": ""
    },
    {
        "source": "Why not buffer len == capacity?",
        "suggest": "为什么不缓冲 len == 容量?",
        "translate": ""
    },
    {
        "source": "Normally, `write_all` just calls `write` in a loop.",
        "suggest": "通常，`write_all` 只是在循环中调用 `write`。",
        "translate": ""
    },
    {
        "source": "We can do better by calling `self.get_mut().write_all()` directly, which avoids round trips through the buffer in the event of a series of partial writes in some circumstances.",
        "suggest": "我们可以通过直接调用 `self.get_mut().write_all()` 来做得更好，这样可以避免在某些情况下发生一系列局部写操作时通过缓冲区的往返行程。",
        "translate": ""
    },
    {
        "source": "This is the first non-empty slice to write, so if it does not fit in the buffer, we still get to flush and proceed.",
        "suggest": "这是第一个要写入的非空切片，因此，如果它不适合缓冲区，我们仍然可以刷新并继续。",
        "translate": ""
    },
    {
        "source": "The slice is at least as large as the buffering capacity, so it's better to write it directly, bypassing the buffer.",
        "suggest": "切片至少与缓冲容量一样大，因此最好绕过缓冲区直接将其写入。",
        "translate": ""
    },
    {
        "source": "Seek to the offset, in bytes, in the underlying writer.",
        "suggest": "在基础 writer 中寻找以字节为单位的偏移量。",
        "translate": ""
    },
    {
        "source": "Seeking always writes out the internal buffer before seeking.",
        "suggest": "寻找总是在寻找之前写出内部缓冲区。",
        "translate": ""
    },
    {
        "source": "dtors should not panic, so we ignore a failed flush",
        "suggest": "dtors 不应为 panic，因此我们忽略失败的刷新",
        "translate": ""
    },
    {
        "source": "No bytes are written until a newline is encountered (or the internal buffer is filled).",
        "suggest": "在遇到换行符 (或内部缓冲区已满) 之前，不写入任何字节。",
        "translate": ""
    },
    {
        "source": "Write the rest of the poem.",
        "suggest": "写剩下的诗。",
        "translate": ""
    },
    {
        "source": "The last line of the poem doesn't end in a newline, so we have to flush or drop the `LineWriter` to finish writing.",
        "suggest": "这首诗的最后一行不是以换行符结束的，所以我们必须刷新或丢弃 `LineWriter` 来完成写作。",
        "translate": ""
    },
    {
        "source": "Confirm the whole poem was written.",
        "suggest": "确认整首诗是写好的。",
        "translate": ""
    },
    {
        "source": "we can use reference just like file",
        "suggest": "我们可以像文件一样使用引用",
        "translate": ""
    },
    {
        "source": "Wraps a writer and buffers output to it, flushing whenever a newline (`0x0a`, `'\\n'`) is detected.",
        "suggest": "包装一个 writer 并缓冲输出到它的内容，每当检测到换行符 (`0x0a，`'\\n'`) 时刷新一次。",
        "translate": ""
    },
    {
        "source": "The [`BufWriter`] struct wraps a writer and buffers its output.",
        "suggest": "[`BufWriter`] 结构体包装 writer 并缓冲其输出。",
        "translate": ""
    },
    {
        "source": "But it only does this batched write when it goes out of scope, or when the internal buffer is full.",
        "suggest": "但是，仅当它离开作用域或内部缓冲区已满时，才进行此批量写入。",
        "translate": ""
    },
    {
        "source": "Sometimes, you'd prefer to write each line as it's completed, rather than the entire buffer at once.",
        "suggest": "有时，您宁愿在完成时写每一行，而不是一次写整个缓冲区。",
        "translate": ""
    },
    {
        "source": "Enter `LineWriter`.",
        "suggest": "输入 `LineWriter`。",
        "translate": ""
    },
    {
        "source": "It does exactly that.",
        "suggest": "它确实做到了。",
        "translate": ""
    },
    {
        "source": "Like [`BufWriter`], a `LineWriter`’s buffer will also be flushed when the `LineWriter` goes out of scope or when its internal buffer is full.",
        "suggest": "像 [`BufWriter`] 一样，当 `LineWriter` 离开作用域或其内部缓冲区已满时，也会刷新 LineWriter 的缓冲区。",
        "translate": ""
    },
    {
        "source": "If there's still a partial line in the buffer when the `LineWriter` is dropped, it will flush those contents.",
        "suggest": "如果丢弃 `LineWriter` 时缓冲区中仍然有部分行，它将刷新这些内容。",
        "translate": ""
    },
    {
        "source": "We can use `LineWriter` to write one line at a time, significantly reducing the number of actual writes to the file.",
        "suggest": "我们可以使用 `LineWriter` 一次写入一行，从而大大减少了实际写入文件的次数。",
        "translate": ""
    },
    {
        "source": "Creates a new `LineWriter`.",
        "suggest": "创建一个新的 `LineWriter`。",
        "translate": ""
    },
    {
        "source": "Lines typically aren't that long, don't use a giant buffer",
        "suggest": "行通常不那么长，不要使用巨大的缓冲区",
        "translate": ""
    },
    {
        "source": "Creates a new `LineWriter` with a specified capacity for the internal buffer.",
        "suggest": "为内部缓冲区创建一个具有指定容量的新 `LineWriter`。",
        "translate": ""
    },
    {
        "source": "Caution must be taken when calling methods on the mutable reference returned as extra writes could corrupt the output stream.",
        "suggest": "在返回的变量引用上调用方法时必须小心，因为额外的写操作可能会破坏输出流。",
        "translate": ""
    },
    {
        "source": "Unwraps this `LineWriter`, returning the underlying writer.",
        "suggest": "解包此 `LineWriter`，返回基础 writer。",
        "translate": ""
    },
    {
        "source": "The internal buffer is written out before returning the writer.",
        "suggest": "返回 writer 之前，将内部缓冲区写出。",
        "translate": ""
    },
    {
        "source": "Private helper struct for implementing the line-buffered writing logic.",
        "suggest": "私有帮助器结构，用于实现行缓冲写入逻辑。",
        "translate": ""
    },
    {
        "source": "This shim temporarily wraps a BufWriter, and uses its internals to implement a line-buffered writer (specifically by using the internal methods like write_to_buf and flush_buf).",
        "suggest": "该填充程序临时包装了一个 BufWriter，并使用其内部实现了行缓冲的 writer (特别是通过使用诸如 write_to_buf 和 flush_buf 之类的内部方法)。",
        "translate": ""
    },
    {
        "source": "In this way, a more efficient abstraction can be created than one that only had access to `write` and `flush`, without needlessly duplicating a lot of the implementation details of BufWriter.",
        "suggest": "这样，可以创建比仅访问 `write` 和 `flush` 更高效率的抽象，而无需不必要地复制 BufWriter 的许多实现细节。",
        "translate": ""
    },
    {
        "source": "This also allows existing `BufWriters` to be temporarily given line-buffering logic;",
        "suggest": "这也使得可以将现有的 `BufWriters` 临时赋予行缓冲逻辑。",
        "translate": ""
    },
    {
        "source": "this is what enables Stdout to be alternately in line-buffered or block-buffered mode.",
        "suggest": "这就是使 Stdout 交替在行缓冲或块缓冲模式下的原因。",
        "translate": ""
    },
    {
        "source": "Get a reference to the inner writer (that is, the writer wrapped by the BufWriter).",
        "suggest": "引用内部 writer (即由 BufWriter 包装的 writer)。",
        "translate": ""
    },
    {
        "source": "Get a mutable reference to the inner writer (that is, the writer wrapped by the BufWriter).",
        "suggest": "获取内部 writer (即由 BufWriter 包装的 writer) 的可变引用。",
        "translate": ""
    },
    {
        "source": "Be careful with this writer, as writes to it will bypass the buffer.",
        "suggest": "小心 writer，因为对其进行写操作会绕过缓冲区。",
        "translate": ""
    },
    {
        "source": "Get the content currently buffered in self.buffer",
        "suggest": "获取当前在 self.buffer 中缓冲的内容",
        "translate": ""
    },
    {
        "source": "Flush the buffer iff the last byte is a newline (indicating that an earlier write only succeeded partially, and we want to retry flushing the buffered line before continuing with a subsequent write)",
        "suggest": "如果最后一个字节是换行符，则刷新缓冲区 (表明先前的写入仅部分成功，并且我们想在继续后续写入之前重试刷新缓冲的行)",
        "translate": ""
    },
    {
        "source": "Write some data into this BufReader with line buffering.",
        "suggest": "通过行缓冲将一些数据写入此 BufReader。",
        "translate": ""
    },
    {
        "source": "This means that, if any newlines are present in the data, the data up to the last newline is sent directly to the underlying writer, and data after it is buffered.",
        "suggest": "这意味着，如果数据中存在任何换行符，则直到最后一个换行符的数据都将直接发送到基础 writer，然后将数据缓冲。",
        "translate": ""
    },
    {
        "source": "This function operates on a \"best effort basis\";",
        "suggest": "该函数在 \"best effort basis\" 上运行;",
        "translate": ""
    },
    {
        "source": "in keeping with the convention of `Write::write`, it makes at most one attempt to write new data to the underlying writer.",
        "suggest": "按照 `Write::write` 的约定，它最多只能进行一次将新数据写入基础 writer 的尝试。",
        "translate": ""
    },
    {
        "source": "If that write only reports a partial success, the remaining data will be buffered.",
        "suggest": "如果该写入仅报告部分成功，则将缓冲其余数据。",
        "translate": ""
    },
    {
        "source": "Because this function attempts to send completed lines to the underlying writer, it will also flush the existing buffer if it ends with a newline, even if the incoming data does not contain any newlines.",
        "suggest": "因为此函数尝试将完成的行发送到基础 writer，所以即使传入的数据不包含任何换行符，它也将刷新现有缓冲区 (如果它以换行符结尾)。",
        "translate": ""
    },
    {
        "source": "If there are no new newlines (that is, if this write is less than one line), just do a regular buffered write (which may flush if we exceed the inner buffer's size)",
        "suggest": "如果没有新的换行符 (也就是说，如果此写操作少于一行)，则只需执行常规的缓冲写操作 (如果我们超过内部缓冲区的大小，则可能会刷新)",
        "translate": ""
    },
    {
        "source": "Otherwise, arrange for the lines to be written directly to the inner writer.",
        "suggest": "否则，安排将这些行直接写入内部 writer。",
        "translate": ""
    },
    {
        "source": "Flush existing content to prepare for our write.",
        "suggest": "刷新现有内容以准备我们的写作。",
        "translate": ""
    },
    {
        "source": "We have to do this before attempting to write `buf` in order to maintain consistency;",
        "suggest": "为了保持一致性，我们必须在尝试编写 `buf` 之前执行此操作。",
        "translate": ""
    },
    {
        "source": "if we add `buf` to the buffer then try to flush it all at once, we're obligated to return Ok(), which would mean suppressing any errors that occur during flush.",
        "suggest": "如果将 `buf` 添加到缓冲区中，然后尝试一次全部刷新，则必须返回 Ok()，这意味着可以抑制刷新期间发生的任何错误。",
        "translate": ""
    },
    {
        "source": "This is what we're going to try to write directly to the inner writer.",
        "suggest": "这就是我们要尝试直接写入内部 writer 的内容。",
        "translate": ""
    },
    {
        "source": "The rest will be buffered, if nothing goes wrong.",
        "suggest": "如果没有任何问题，其余部分将被缓冲。",
        "translate": ""
    },
    {
        "source": "Write `lines` directly to the inner writer.",
        "suggest": "将 `lines` 直接写入内部 writer。",
        "translate": ""
    },
    {
        "source": "In keeping with the `write` convention, make at most one attempt to add new (unbuffered) data.",
        "suggest": "与 `write` 约定保持一致，最多尝试添加新的 (unbuffered) 数据。",
        "translate": ""
    },
    {
        "source": "Because this write doesn't touch the BufWriter state directly, and the buffer is known to be empty, we don't need to worry about self.buffer.panicked here.",
        "suggest": "由于此写操作不会直接接触 BufWriter 状态，并且缓冲区已知为空，因此我们无需担心 self.buffer.panicked。",
        "translate": ""
    },
    {
        "source": "If buffer returns Ok(0), propagate that to the caller without doing additional buffering;",
        "suggest": "如果缓冲区返回 Ok(0)，则将其传播给调用方，而不进行额外的缓冲; 否则，将其传播给调用方。",
        "translate": ""
    },
    {
        "source": "otherwise we're just guaranteeing an \"ErrorKind::WriteZero\" later.",
        "suggest": "否则，我们只是在以后保证 \"ErrorKind::WriteZero\"。",
        "translate": ""
    },
    {
        "source": "Now that the write has succeeded, buffer the rest (or as much of the rest as possible).",
        "suggest": "现在写入已成功，请缓冲其余部分 (或尽可能多的其余部分)。",
        "translate": ""
    },
    {
        "source": "If there were any unwritten newlines, we only buffer out to the last unwritten newline that fits in the buffer;",
        "suggest": "如果有任何未写的换行符，我们只会缓冲到缓冲区中最后一个未写的换行符;",
        "translate": ""
    },
    {
        "source": "this helps prevent flushing partial lines on subsequent calls to LineWriterShim::write.",
        "suggest": "这有助于防止在随后的 LineWriterShim::write 调用中刷新部分行。",
        "translate": ""
    },
    {
        "source": "Handle the cases in order of most-common to least-common, under the presumption that most writes succeed in totality, and that most writes are smaller than the buffer.",
        "suggest": "在大多数写入总能成功且大多数写入小于缓冲区的前提下，按最常见到最不常见的顺序处理案件。",
        "translate": ""
    },
    {
        "source": "Is this a partial line (ie, no newlines left in the unwritten tail)",
        "suggest": "这是分行吗 (即，未写的尾部没有换行符)",
        "translate": ""
    },
    {
        "source": "If not, does the data out to the last unwritten newline fit in the buffer?",
        "suggest": "如果不是，则输出到最后未写入的换行符的数据是否适合缓冲区?",
        "translate": ""
    },
    {
        "source": "If not, scan for the last newline that *does* fit in the buffer",
        "suggest": "如果不是，请扫描 *适合* 缓冲区的最后一个换行符",
        "translate": ""
    },
    {
        "source": "Write some vectored data into this BufReader with line buffering.",
        "suggest": "通过行缓冲将一些矢量数据写入此 BufReader。",
        "translate": ""
    },
    {
        "source": "This means that, if any newlines are present in the data, the data up to and including the buffer containing the last newline is sent directly to the inner writer, and the data after it is buffered.",
        "suggest": "这意味着，如果数据中存在任何换行符，则直到包含最后一个换行符的缓冲区之前的数据 (包括该最后一个换行符的缓冲区) 都将直接发送到内部 writer，然后对其进行缓冲。",
        "translate": ""
    },
    {
        "source": "Because this function attempts to send completed lines to the underlying writer, it will also flush the existing buffer if it contains any newlines.",
        "suggest": "因为此函数尝试将完成的行发送到基础 writer，所以如果包含任何换行符，它还将刷新现有缓冲区。",
        "translate": ""
    },
    {
        "source": "Because sorting through an array of `IoSlice` can be a bit convoluted, This method differs from write in the following ways:",
        "suggest": "由于对 `IoSlice` 数组进行排序可能有点麻烦，因此该方法与 write 的区别在于以下方面:",
        "translate": ""
    },
    {
        "source": "It attempts to write the full content of all the buffers up to and including the one containing the last newline.",
        "suggest": "它尝试写入所有缓冲区的完整内容，直到包含最后一个换行符的缓冲区为止。",
        "translate": ""
    },
    {
        "source": "This means that it may attempt to write a partial line, that buffer has data past the newline.",
        "suggest": "这意味着它可能尝试写入部分行，该缓冲区的数据已超过换行符。",
        "translate": ""
    },
    {
        "source": "If the write only reports partial success, it does not attempt to find the precise location of the written bytes and buffer the rest.",
        "suggest": "如果写入仅报告部分成功，则不会尝试找到写入字节的精确位置并缓冲其余字节。",
        "translate": ""
    },
    {
        "source": "If the underlying vector doesn't support vectored writing, we instead simply write the first non-empty buffer with `write`.",
        "suggest": "如果底层的 vector 不支持向量写入，我们只需用 `write` 写入第一个非空缓冲区即可。",
        "translate": ""
    },
    {
        "source": "This way, we get the benefits of more granular partial-line handling without losing anything in efficiency",
        "suggest": "这样，我们可以获得更细的分线处理的好处，而不会损失任何效率",
        "translate": ""
    },
    {
        "source": "If there's no specialized behavior for write_vectored, just use write.",
        "suggest": "如果没有针对 write_vectored 的特殊行为，则只需使用 write。",
        "translate": ""
    },
    {
        "source": "This has the benefit of more granular partial-line handling.",
        "suggest": "这具有更细化的分行处理的好处。",
        "translate": ""
    },
    {
        "source": "Find the buffer containing the last newline",
        "suggest": "查找包含最后一个换行符的缓冲区",
        "translate": ""
    },
    {
        "source": "If there are no new newlines (that is, if this write is less than one line), just do a regular buffered write",
        "suggest": "如果没有新的换行符 (也就是说，如果此写少于一行)，则只需执行常规的缓冲写",
        "translate": ""
    },
    {
        "source": "No newlines;",
        "suggest": "没有换行符;",
        "translate": ""
    },
    {
        "source": "just do a normal buffered write",
        "suggest": "只是做一个正常的缓冲写入",
        "translate": ""
    },
    {
        "source": "Flush existing content to prepare for our write",
        "suggest": "刷新现有内容以准备我们的写作",
        "translate": ""
    },
    {
        "source": "Because this write doesn't touch the BufWriter state directly, and the buffer is known to be empty, we don't need to worry about self.panicked here.",
        "suggest": "由于此写操作不会直接触及 BufWriter 状态，并且缓冲区已知为空，因此我们无需在此担心 self.panicked。",
        "translate": ""
    },
    {
        "source": "If inner returns Ok(0), propagate that to the caller without doing additional buffering;",
        "suggest": "如果 inner 返回 Ok(0)，则将其传播给调用方，而不进行其他缓冲; 否则，将其传播给调用方。",
        "translate": ""
    },
    {
        "source": "Don't try to reconstruct the exact amount written;",
        "suggest": "不要试图重建确切的书写数量;",
        "translate": ""
    },
    {
        "source": "just bail in the event of a partial write",
        "suggest": "只是在部分写入的情况下保释",
        "translate": ""
    },
    {
        "source": "Now that the write has succeeded, buffer the rest (or as much of the rest as possible)",
        "suggest": "现在写成功了，缓冲其余的 (或尽可能多的剩余)",
        "translate": ""
    },
    {
        "source": "Because this function attempts to send completed lines to the underlying writer, it will also flush the existing buffer if it contains any newlines, even if the incoming data does not contain any newlines.",
        "suggest": "因为此函数尝试将完成的行发送到基础 writer，所以即使传入的数据不包含任何换行符，它也将刷新现有缓冲区 (如果包含任何换行符)。",
        "translate": ""
    },
    {
        "source": "If there is any buffered data, we add the incoming lines to that buffer before flushing, which saves us at least one write call.",
        "suggest": "如果有任何缓冲的数据，我们将在刷新前将输入行添加到该缓冲区中，这样至少可以节省一次写调用。",
        "translate": ""
    },
    {
        "source": "We can't really do this with `write`, since we can't do this *and* not suppress errors *and* report a consistent state to the caller in a return value, but here in write_all it's fine.",
        "suggest": "我们不能用 `write` 真正做到这一点，因为我们不能做到这一点 *并且* 不能抑制错误 *并且* 在返回值中向调用者报告一致的状态，但是在 write_all 中就可以了。",
        "translate": ""
    },
    {
        "source": "do stuff with the stream",
        "suggest": "用流做东西",
        "translate": ""
    },
    {
        "source": "we want to get our `TcpStream` back, so let's try:",
        "suggest": "我们想取回 `TcpStream`，所以让我们尝试:",
        "translate": ""
    },
    {
        "source": "Here, e is an IntoInnerError",
        "suggest": "在这里，e 是一个 IntoInnerError",
        "translate": ""
    },
    {
        "source": "Here, e is an IntoInnerError, let's log the inner error.",
        "suggest": "在这里，e 是一个 IntoInnerError，让我们记录内部错误。",
        "translate": ""
    },
    {
        "source": "We'll just 'log' to stdout for this example.",
        "suggest": "在此示例中，我们仅将 'log' 更改为 stdout。",
        "translate": ""
    },
    {
        "source": "Here, e is an IntoInnerError, let's re-examine the buffer:",
        "suggest": "在这里，e 是一个 IntoInnerError，让我们重新检查缓冲区:",
        "translate": ""
    },
    {
        "source": "do stuff to try to recover",
        "suggest": "做一些事情来尝试恢复",
        "translate": ""
    },
    {
        "source": "afterwards, let's just return the stream",
        "suggest": "之后，让我们返回流",
        "translate": ""
    },
    {
        "source": "Buffering wrappers for I/O traits",
        "suggest": "I/O traits 的缓冲包装器",
        "translate": ""
    },
    {
        "source": "An error returned by [`BufWriter::into_inner`] which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.",
        "suggest": "[`BufWriter::into_inner`] 返回的错误，将写出缓冲区时发生的错误与缓冲的 writer object 结合在一起，可用于从条件中恢复。",
        "translate": ""
    },
    {
        "source": "Construct a new IntoInnerError",
        "suggest": "创建一个新的 IntoInnerError",
        "translate": ""
    },
    {
        "source": "Helper to construct a new IntoInnerError;",
        "suggest": "帮助程序创建一个新的 IntoInnerError;",
        "translate": ""
    },
    {
        "source": "intended to help with adapters that wrap other adapters",
        "suggest": "旨在帮助包装其他适配器的适配器",
        "translate": ""
    },
    {
        "source": "Returns the error which caused the call to [`BufWriter::into_inner()`] to fail.",
        "suggest": "返回导致 [`BufWriter::into_inner()`] 调用失败的错误。",
        "translate": ""
    },
    {
        "source": "This error was returned when attempting to write the internal buffer.",
        "suggest": "尝试写入内部缓冲区时返回此错误。",
        "translate": ""
    },
    {
        "source": "Returns the buffered writer instance which generated the error.",
        "suggest": "返回产生错误的缓冲 writer 实例。",
        "translate": ""
    },
    {
        "source": "The returned object can be used for error recovery, such as re-inspecting the buffer.",
        "suggest": "返回的 object 可用于错误恢复，例如重新检查缓冲区。",
        "translate": ""
    },
    {
        "source": "Consumes the [`IntoInnerError`] and returns the error which caused the call to [`BufWriter::into_inner()`] to fail.",
        "suggest": "消耗 [`IntoInnerError`] 并返回导致 [`BufWriter::into_inner()`] 调用失败的错误。",
        "translate": ""
    },
    {
        "source": "Unlike `error`, this can be used to obtain ownership of the underlying error.",
        "suggest": "与 `error` 不同，它可用于获取基本错误的所有权。",
        "translate": ""
    },
    {
        "source": "Consumes the [`IntoInnerError`] and returns the error which caused the call to [`BufWriter::into_inner()`] to fail, and the underlying writer.",
        "suggest": "消耗 [`IntoInnerError`] 并返回导致 [`BufWriter::into_inner()`] 调用失败的错误，以及返回的 writer。",
        "translate": ""
    },
    {
        "source": "This can be used to simply obtain ownership of the underlying error;",
        "suggest": "这可以用来简单地获取潜在错误的所有权。",
        "translate": ""
    },
    {
        "source": "it can also be used for advanced error recovery.",
        "suggest": "它也可以用于高级错误恢复。",
        "translate": ""
    },
    {
        "source": "A dummy reader intended at testing short-reads propagation.",
        "suggest": "用于测试短读传播的伪 reader。",
        "translate": ""
    },
    {
        "source": "rustfmt and tidy disagree about the correct formatting of this function.",
        "suggest": "rustfmt 和 tidy 对于此函数的正确格式存在不同意见。",
        "translate": ""
    },
    {
        "source": "This leads to issues for users with editors configured to rustfmt-on-save.",
        "suggest": "对于配置为 rustfmt-on-save 的编辑器的用户，这会导致问题。",
        "translate": ""
    },
    {
        "source": "relative seeking within the buffer and reading position should keep the buffer",
        "suggest": "缓冲区内的相对搜索和读取位置应保持缓冲区",
        "translate": ""
    },
    {
        "source": "relative seeking outside the buffer will discard it",
        "suggest": "在缓冲区外的相对寻找将丢弃它",
        "translate": ""
    },
    {
        "source": "cause internal buffer to be filled but read only partially",
        "suggest": "导致内部缓冲区被填充，但仅部分读取",
        "translate": ""
    },
    {
        "source": "rewinding the internal reader will cause buffer to loose sync",
        "suggest": "倒转内部 reader 将导致缓冲区失去同步",
        "translate": ""
    },
    {
        "source": "overflow when subtracting the remaining buffer size from current position",
        "suggest": "从当前位置减去剩余缓冲区大小时溢出",
        "translate": ""
    },
    {
        "source": "gimmick reader that yields its position modulo 256 for each byte",
        "suggest": "gi 头 reader 为每个字节产生其模 256 的位置",
        "translate": ""
    },
    {
        "source": "the following seek will require two underlying seeks",
        "suggest": "以下搜寻将需要两个基本搜寻",
        "translate": ""
    },
    {
        "source": "seeking to 0 should empty the buffer.",
        "suggest": "寻求 0 应该清空缓冲区。",
        "translate": ""
    },
    {
        "source": "gimmick reader that returns Err after first seek",
        "suggest": "第一次搜寻后返回 Err 的头 reader",
        "translate": ""
    },
    {
        "source": "The following seek will require two underlying seeks.",
        "suggest": "以下搜寻将需要两个基本搜寻。",
        "translate": ""
    },
    {
        "source": "The first will succeed but the second will fail.",
        "suggest": "第一个将成功，但是第二个将失败。",
        "translate": ""
    },
    {
        "source": "This should still invalidate the buffer.",
        "suggest": "这仍将使缓冲区无效。",
        "translate": ""
    },
    {
        "source": "If writer panics *again* due to the flush error then the process will abort.",
        "suggest": "如果写入器由于刷新错误而再次 panic，那么进程将中止。",
        "translate": ""
    },
    {
        "source": "A simple `Write` target, designed to be wrapped by `LineWriter` / `BufWriter` / etc, that can have its `write` & `flush` behavior configured",
        "suggest": "一个简单的 `Write` 目标，设计为由 `LineWriter`/`BufWriter` 等包装，可以配置其 `write` 和 `flush` 行为",
        "translate": ""
    },
    {
        "source": "Writes append to this slice",
        "suggest": "追加到此切片",
        "translate": ""
    },
    {
        "source": "Flush sets this flag",
        "suggest": "刷新设置此标志",
        "translate": ""
    },
    {
        "source": "If true, writes will always be an error",
        "suggest": "如果为 true，则写入将始终是错误",
        "translate": ""
    },
    {
        "source": "If true, flushes will always be an error",
        "suggest": "如果为 true，则刷新将始终是错误",
        "translate": ""
    },
    {
        "source": "If set, only up to this number of bytes will be written in a single call to `write`",
        "suggest": "如果设置，一次调用最多只能写入此字节数。",
        "translate": ""
    },
    {
        "source": "If set, counts down with each write, and writes return an error when it hits 0",
        "suggest": "如果设置，则每次写入时递减计数，写入达到 0 时将返回错误",
        "translate": ""
    },
    {
        "source": "If set, attempting to write when max_writes == Some(0) will be an error;",
        "suggest": "如果设置，在 max_writes == Some(0) 时尝试写入将是错误;",
        "translate": ""
    },
    {
        "source": "otherwise, it will return Ok(0).",
        "suggest": "否则，它将返回 Ok(0)。",
        "translate": ""
    },
    {
        "source": "Previously the `LineWriter` could successfully write some bytes but then fail to report that it has done so.",
        "suggest": "以前，`LineWriter` 可以成功写入一些字节，但随后无法报告已这样做。",
        "translate": ""
    },
    {
        "source": "Additionally, an erroneous flush after a successful write was permanently ignored.",
        "suggest": "此外，成功写入后的错误刷新将被永久忽略。",
        "translate": ""
    },
    {
        "source": "Test that a line writer correctly reports the number of written bytes, and that it attempts to flush buffered lines from previous writes before processing new data",
        "suggest": "测试 writer 行是否正确报告已写入的字节数，并在处理新数据之前尝试刷新先前写入的缓冲行",
        "translate": ""
    },
    {
        "source": "Regression test for #37807",
        "suggest": "#37807 的回归测试",
        "translate": ""
    },
    {
        "source": "Only write up to 4 bytes at a time",
        "suggest": "一次最多只能写入 4 个字节",
        "translate": ""
    },
    {
        "source": "Accept the first two writes, then error the others",
        "suggest": "接受前两个写入，然后对其他两个写入错误",
        "translate": ""
    },
    {
        "source": "This should write the first 4 bytes.",
        "suggest": "这应该写入前 4 个字节。",
        "translate": ""
    },
    {
        "source": "The rest will be buffered, out to the last newline.",
        "suggest": "其余的将被缓冲，直到最后一个换行符。",
        "translate": ""
    },
    {
        "source": "This write should attempt to flush \"c\\nd\\n\", then buffer \"e\".",
        "suggest": "该写操作应尝试先刷新 \"c\\nd\\n\"，然后再刷新 \"e\"。",
        "translate": ""
    },
    {
        "source": "No errors should happen here because no further writes should be attempted against `writer`.",
        "suggest": "这里不会发生任何错误，因为不要再尝试对 `writer` 进行写操作。",
        "translate": ""
    },
    {
        "source": "partial writes keep going",
        "suggest": "部分写入继续进行",
        "translate": ""
    },
    {
        "source": "erroneous writes stop and don't write more",
        "suggest": "错误的写入停止并且不写更多",
        "translate": ""
    },
    {
        "source": "Test that, in cases where vectored writing is not enabled, the LineWriter uses the normal `write` call, which more-correctly handles partial lines",
        "suggest": "测试在未启用矢量写入的情况下，LineWriter 使用普通的 `write` 调用，该 `write` 调用可以更正确地处理部分行",
        "translate": ""
    },
    {
        "source": "Test that, given this input:",
        "suggest": "在给出以下输入的情况下进行测试:",
        "translate": ""
    },
    {
        "source": "And given a result that only writes to midway through Line 2",
        "suggest": "并给出只写入第 2 行中途的结果",
        "translate": ""
    },
    {
        "source": "That only up to the end of Line 3 is buffered",
        "suggest": "仅缓冲到第 3 行的末尾",
        "translate": ""
    },
    {
        "source": "This behavior is desirable because it prevents flushing partial lines",
        "suggest": "此行为是可取的，因为它可以防止刷新部分行",
        "translate": ""
    },
    {
        "source": "And given that the full write of lines 1 and 2 was successful That data up to Line 3 is buffered",
        "suggest": "并且假设第 1 行和第 2 行的完全写入成功，直到第 3 行的数据都被缓冲了",
        "translate": ""
    },
    {
        "source": "Test that, given a partial line that exceeds the length of LineBuffer's buffer (that is, without a trailing newline), that that line is written to the inner writer",
        "suggest": "在给定的部分行超出 LineBuffer 的缓冲区长度 (即没有尾随换行符) 的情况下，测试该行是否写入内部 writer",
        "translate": ""
    },
    {
        "source": "Test that, given a very long partial line *after* successfully flushing a complete line, that that line is buffered unconditionally, and no additional writes take place.",
        "suggest": "在给定的很长的部分行 *成功* 刷新完一条完整行之后，进行测试，以确保该行无条件缓冲，并且没有发生其他写操作。",
        "translate": ""
    },
    {
        "source": "This assures the property that `write` should make at-most-one attempt to write new data.",
        "suggest": "这确保了 `write` 最多应尝试写入新数据的属性。",
        "translate": ""
    },
    {
        "source": "Assert that Line 1\\n is flushed, and 01234 is buffered",
        "suggest": "断言刷新 1\\n 行，并缓冲 01234",
        "translate": ""
    },
    {
        "source": "Because the buffer is full, this subsequent write will flush it",
        "suggest": "由于缓冲区已满，因此后续写入将刷新该缓冲区",
        "translate": ""
    },
    {
        "source": "Test that, if an attempt to pre-flush buffered data returns Ok(0), this is propagated as an error.",
        "suggest": "测试，如果尝试预刷新缓冲的数据返回 Ok(0)，则将其传播为错误。",
        "translate": ""
    },
    {
        "source": "Accept one write, then return Ok(0) on subsequent ones",
        "suggest": "接受一次写入，然后在后续写入中返回 Ok(0)",
        "translate": ""
    },
    {
        "source": "This should write \"Line 1\\n\" and buffer \"Partial\"",
        "suggest": "这应该写 \"Line 1\\n\" 和缓冲区 \"Partial\"",
        "translate": ""
    },
    {
        "source": "This will attempt to flush \"partial\", which will return Ok(0), which needs to be an error, because we've already informed the client that we accepted the write.",
        "suggest": "这将尝试刷新 \"partial\"，这将返回 Ok(0)，这需要是一个错误，因为我们已经通知客户端我们接受了写入。",
        "translate": ""
    },
    {
        "source": "Test that, if a write returns Ok(0) after a successful pre-flush, this is propagated as Ok(0)",
        "suggest": "测试，如果一次成功的预刷新后写入返回 Ok(0)，则将其传播为 Ok(0)",
        "translate": ""
    }
]
