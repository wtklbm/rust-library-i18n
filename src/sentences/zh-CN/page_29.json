[
    {
        "source": "Returns a pointer to the reallocated memory or null if the operation fails.",
        "suggest": "返回指向重新分配的内存的指针，如果操作失败，则返回 null。",
        "translate": ""
    },
    {
        "source": "If the operation fails the given block will never have been freed.",
        "suggest": "如果操作失败，给定的块将永远不会被释放。",
        "translate": ""
    },
    {
        "source": "must be set to zero.",
        "suggest": "必须设置为零。",
        "translate": ""
    },
    {
        "source": "must be a non-null pointer to an allocated block returned by `HeapAlloc` or `HeapReAlloc`, that has not already been freed.",
        "suggest": "必须是一个非空指针，指向由 `HeapAlloc` 或 `HeapReAlloc` 返回的尚未被释放的已分配块。",
        "translate": ""
    },
    {
        "source": "If the block was successfully reallocated at a new location, pointers pointing to the freed memory, such as `lpMem`, must not be dereferenced ever again.",
        "suggest": "如果块在新位置成功重新分配，则不能再次解引用指向已释放内存的指针，例如 `lpMem`。",
        "translate": ""
    },
    {
        "source": "Free a block of memory behind a given pointer `lpMem` from a given heap `hHeap`.",
        "suggest": "从给定的堆 `hHeap` 中释放给定指针 `lpMem` 后面的一块内存。",
        "translate": ""
    },
    {
        "source": "Returns a nonzero value if the operation is successful, and zero if the operation fails.",
        "suggest": "如果操作成功则返回一个非零值，如果操作失败则返回零。",
        "translate": ""
    },
    {
        "source": "must be a pointer to an allocated block returned by `HeapAlloc` or `HeapReAlloc`, that has not already been freed.",
        "suggest": "必须是 `HeapAlloc` 或 `HeapReAlloc` 返回的一个尚未被释放的已分配块的指针。",
        "translate": ""
    },
    {
        "source": "If the block was successfully freed, pointers pointing to the freed memory, such as `lpMem`, must not be dereferenced ever again.",
        "suggest": "如果块被成功释放，指向被释放内存的指针，如 `lpMem`，不得再次解引用。",
        "translate": ""
    },
    {
        "source": "Note that `lpMem` is allowed to be null, which will not cause the operation to fail.",
        "suggest": "注意 `lpMem` 允许为空，这不会导致操作失败。",
        "translate": ""
    },
    {
        "source": "Cached handle to the default heap of the current process.",
        "suggest": "缓存到当前进程的默认堆的句柄。",
        "translate": ""
    },
    {
        "source": "Either a non-null handle returned by `GetProcessHeap`, or null when not yet initialized or `GetProcessHeap` failed.",
        "suggest": "`GetProcessHeap` 返回的非空句柄，或在尚未初始化或 `GetProcessHeap` 失败时为空。",
        "translate": ""
    },
    {
        "source": "If this operation is successful, `HEAP` will be successfully initialized and contain a non-null handle returned by `GetProcessHeap`.",
        "suggest": "如果此操作成功，则 `HEAP` 将成功初始化并包含 `GetProcessHeap` 返回的非空句柄。",
        "translate": ""
    },
    {
        "source": "has not yet been successfully initialized",
        "suggest": "尚未成功初始化",
        "translate": ""
    },
    {
        "source": "No locking is needed because within the same process, successful calls to `GetProcessHeap` will always return the same value, even on different threads.",
        "suggest": "不需要锁定，因为在同一个进程中，成功调用 `GetProcessHeap` 将始终返回相同的值，即使在不同的线程上也是如此。",
        "translate": ""
    },
    {
        "source": "`HEAP` contains a non-null handle returned by `GetProcessHeap`",
        "suggest": "`HEAP` 包含一个由 `GetProcessHeap` 返回的非空句柄",
        "translate": ""
    },
    {
        "source": "Could not get the current process heap.",
        "suggest": "无法获取当前进程堆。",
        "translate": ""
    },
    {
        "source": "Get a non-null handle to the default heap of the current process.",
        "suggest": "获取当前进程默认堆的非空句柄。",
        "translate": ""
    },
    {
        "source": "`HEAP` must have been successfully initialized.",
        "suggest": "`HEAP` 必须已成功初始化。",
        "translate": ""
    },
    {
        "source": "Header containing a pointer to the start of an allocated block.",
        "suggest": "包含指向已分配块开头的指针的标头。",
        "translate": ""
    },
    {
        "source": "Size and alignment must be <= `MIN_ALIGN`.",
        "suggest": "大小和对齐方式必须 <= `MIN_ALIGN`。",
        "translate": ""
    },
    {
        "source": "Allocate a block of optionally zeroed memory for a given `layout`.",
        "suggest": "为给定的 `layout` 分配一块可选为零的内存。",
        "translate": ""
    },
    {
        "source": "Returns a pointer satisfying the guarantees of `System` about allocated pointers, or null if the operation fails.",
        "suggest": "返回一个满足 `System` 关于已分配指针的保证的指针，如果操作失败，则返回 null。",
        "translate": ""
    },
    {
        "source": "If this returns non-null `HEAP` will have been successfully initialized.",
        "suggest": "如果返回非空，那么 `HEAP` 将被成功初始化。",
        "translate": ""
    },
    {
        "source": "Allocation has failed, could not get the current process heap.",
        "suggest": "分配失败，无法获取当前进程堆。",
        "translate": ""
    },
    {
        "source": "Allocated memory will be either zeroed or uninitialized.",
        "suggest": "分配的内存将被清零或未初始化。",
        "translate": ""
    },
    {
        "source": "`heap` is a non-null handle returned by `GetProcessHeap`.",
        "suggest": "`heap` 是 `GetProcessHeap` 返回的非空句柄。",
        "translate": ""
    },
    {
        "source": "The returned pointer points to the start of an allocated block.",
        "suggest": "返回的指针指向已分配块的开始。",
        "translate": ""
    },
    {
        "source": "Allocate extra padding in order to be able to satisfy the alignment.",
        "suggest": "分配额外的填充以便能够满足对齐。",
        "translate": ""
    },
    {
        "source": "Allocation has failed.",
        "suggest": "分配失败。",
        "translate": ""
    },
    {
        "source": "Create a correctly aligned pointer offset from the start of the allocated block, and write a header before it.",
        "suggest": "从分配的块的开头创建一个正确对齐的指针偏移量，并在它之前写入一个头。",
        "translate": ""
    },
    {
        "source": "`MIN_ALIGN` <= `offset` <= `layout.align()` and the size of the allocated block is `layout.align() + layout.size()`.",
        "suggest": "`MIN_ALIGN` <= `offset` <= `layout.align()`，分配块的大小为 `layout.align() + layout.size()`。",
        "translate": ""
    },
    {
        "source": "will thus be a correctly aligned pointer inside the allocated block with at least `layout.size()` bytes after it and at least `MIN_ALIGN` bytes of padding before it.",
        "suggest": "因此将是分配块内正确对齐的指针，其后面至少有 `layout.size()` 字节，前面至少有 `MIN_ALIGN` 字节的填充。",
        "translate": ""
    },
    {
        "source": "Because the size and alignment of a header is <= `MIN_ALIGN` and `aligned` is aligned to at least `MIN_ALIGN` and has at least `MIN_ALIGN` bytes of padding before it, it is safe to write a header directly before it.",
        "suggest": "因为标头的大小和对齐方式 <= `MIN_ALIGN` 并且 `aligned` 至少与 `MIN_ALIGN` 对齐并且在它之前至少有 `MIN_ALIGN` 个字节的填充，所以直接在它之前写入标头是安全的。",
        "translate": ""
    },
    {
        "source": "The returned pointer does not point to the to the start of an allocated block, but there is a header readable directly before it containing the location of the start of the block.",
        "suggest": "返回的指针不指向已分配块的开始，但在它包含块开始位置之前有一个直接可读的标头。",
        "translate": ""
    },
    {
        "source": "All pointers returned by this allocator have, in addition to the guarantees of `GlobalAlloc`, the following properties:",
        "suggest": "此分配器返回的所有指针除了 `GlobalAlloc` 的保证外，还具有以下属性:",
        "translate": ""
    },
    {
        "source": "If the pointer was allocated or reallocated with a `layout` specifying an alignment <= `MIN_ALIGN` the pointer will be aligned to at least `MIN_ALIGN` and point to the start of the allocated block.",
        "suggest": "如果使用 `layout` 指定对齐 <= `MIN_ALIGN` 分配或重新分配指针，则指针将至少与 `MIN_ALIGN` 对齐并指向已分配块的开头。",
        "translate": ""
    },
    {
        "source": "If the pointer was allocated or reallocated with a `layout` specifying an alignment > `MIN_ALIGN` the pointer will be aligned to the specified alignment and not point to the start of the allocated block.",
        "suggest": "如果使用 `layout` 指定对齐 > `MIN_ALIGN` 分配或重新分配指针，则指针将与指定对齐对齐，而不指向已分配块的开头。",
        "translate": ""
    },
    {
        "source": "Instead there will be a header readable directly before the returned pointer, containing the actual location of the start of the block.",
        "suggest": "相反，在返回的指针之前会有一个直接可读的标头，包含块开始的实际位置。",
        "translate": ""
    },
    {
        "source": "Pointers returned by `allocate` satisfy the guarantees of `System`",
        "suggest": "`allocate` 返回的指针满足 `System` 的保证",
        "translate": ""
    },
    {
        "source": "The location of the start of the block is stored in the padding before `ptr`.",
        "suggest": "块开始的位置存储在 `ptr` 之前的填充中。",
        "translate": ""
    },
    {
        "source": "Because of the contract of `System`, `ptr` is guaranteed to be non-null and have a header readable directly before it.",
        "suggest": "由于 `System` 的约定，`ptr` 被保证为非空并且在它之前有一个直接可读的标头。",
        "translate": ""
    },
    {
        "source": "because `ptr` has been successfully allocated with this allocator, `HEAP` must have been successfully initialized.",
        "suggest": "因为 `ptr` 已经用这个分配器成功分配了，所以 `HEAP` 一定已经成功初始化了。",
        "translate": ""
    },
    {
        "source": "`heap` is a non-null handle returned by `GetProcessHeap`, `block` is a pointer to the start of an allocated block.",
        "suggest": "`heap` 是 `GetProcessHeap` 返回的非空句柄，`block` 是指向已分配块开头的指针。",
        "translate": ""
    },
    {
        "source": "`heap` is a non-null handle returned by `GetProcessHeap`, `ptr` is a pointer to the start of an allocated block.",
        "suggest": "`heap` 是 `GetProcessHeap` 返回的非空句柄，`ptr` 是指向已分配块开头的指针。",
        "translate": ""
    },
    {
        "source": "`realloc_fallback` is implemented using `dealloc` and `alloc`, which will correctly handle `ptr` and return a pointer satisfying the guarantees of `System`",
        "suggest": "`realloc_fallback` 使用 `dealloc` 和 `alloc` 实现，它们将正确处理 `ptr` 并返回满足 `System` 保证的指针",
        "translate": ""
    },
    {
        "source": "only close the socket interface if it has actually been started",
        "suggest": "只有在套接字接口已经启动时才关闭它",
        "translate": ""
    },
    {
        "source": "This is because `sys_common` not only contains platform-independent code, but also code that is shared between the different platforms in `sys`.",
        "suggest": "这是因为 `sys_common` 不仅包含与平台无关的代码，还包含 `sys` 中不同平台之间共享的代码。",
        "translate": ""
    },
    {
        "source": "Ideally all that shared code should be moved to `sys::common`, and the dependencies between `std`, `sys_common` and `sys` all would form a dag.",
        "suggest": "理想情况下，所有共享代码都应该移动到 `sys::common`，并且 `std`、`sys_common` 和 `sys` 之间的依赖关系都会形成一个 dag。",
        "translate": ""
    },
    {
        "source": "One-time runtime initialization.",
        "suggest": "一次性运行时初始化。",
        "translate": ""
    },
    {
        "source": "Runs before `main`.",
        "suggest": "在 `main` 之前运行。",
        "translate": ""
    },
    {
        "source": "Runs after `main` or at program exit.",
        "suggest": "在 `main` 之后或在程序退出时运行。",
        "translate": ""
    },
    {
        "source": "Flush stdout and disable buffering.",
        "suggest": "刷新 stdout 并禁用缓冲。",
        "translate": ""
    },
    {
        "source": "Only called once during runtime cleanup.",
        "suggest": "仅在运行时清理期间调用一次。",
        "translate": ""
    },
    {
        "source": "This test tests that TLS destructors have run before the thread joins.",
        "suggest": "此测试测试 TLS 析构函数在线程加入之前是否已运行。",
        "translate": ""
    },
    {
        "source": "The test has no false positives (meaning: if the test fails, there's actually an ordering problem).",
        "suggest": "测试没有误报 (意思是: 如果测试失败，实际上存在排序问题)。",
        "translate": ""
    },
    {
        "source": "It may have false negatives, where the test passes but join is not guaranteed to be after the TLS destructors.",
        "suggest": "它可能有误报，其中测试通过但不保证连接在 TLS 析构函数之后。",
        "translate": ""
    },
    {
        "source": "However, false negatives should be exceedingly rare due to judicious use of thread::yield_now and running the test several times.",
        "suggest": "然而，由于 thread::yield_now 的明智使用和多次运行测试，假阴性应该是非常罕见的。",
        "translate": ""
    },
    {
        "source": "We emulate a synchronous MPSC rendezvous channel using only atomics and thread::yield_now.",
        "suggest": "我们仅使用原子和 thread::yield_now 模拟同步 MPSC 会合通道。",
        "translate": ""
    },
    {
        "source": "We can't use std::mpsc as the implementation itself may rely on thread locals.",
        "suggest": "我们不能使用 std::mpsc，因为实现本身可能依赖于线程局部变量。",
        "translate": ""
    },
    {
        "source": "The basic state machine for an SPSC rendezvous channel is:",
        "suggest": "SPSC 会合通道的基本状态机是:",
        "translate": ""
    },
    {
        "source": "FRESH -> THREAD1_WAITING -> MAIN_THREAD_RENDEZVOUS where the first transition is done by the “receiving” thread and the 2nd transition is done by the “sending” thread.",
        "suggest": "FRESH -> THREAD1_WAITING -> MAIN_THREAD_RENDEZVOUS 其中第一个转换由接收线程完成，第二个转换由发送线程完成。",
        "translate": ""
    },
    {
        "source": "We add an additional state `THREAD2_LAUNCHED` between `FRESH` and `THREAD1_WAITING` to block until all threads are actually running.",
        "suggest": "我们在 `FRESH` 和 `THREAD1_WAITING` 之间添加一个额外的状态 `THREAD2_LAUNCHED` 来阻塞直到所有线程实际运行。",
        "translate": ""
    },
    {
        "source": "A thread that joins on the “receiving” thread completion should never observe the channel in the `THREAD1_WAITING` state.",
        "suggest": "在接收线程完成时加入的线程不应该在 `THREAD1_WAITING` 状态下观察通道。",
        "translate": ""
    },
    {
        "source": "If this does occur, we switch to the “poison” state `THREAD2_JOINED` and panic all around.",
        "suggest": "如果发生这种情况，我们会切换到中毒状态 `THREAD2_JOINED` 并 panic。",
        "translate": ""
    },
    {
        "source": "(This is equivalent to “sending” from an alternate producer thread.)",
        "suggest": "(这相当于从备用生产者线程发送。)",
        "translate": ""
    },
    {
        "source": "used to generate the `LocalKey` value for const-initialized thread locals",
        "suggest": "用于为常量初始化的线程局部变量生成 `LocalKey` 值",
        "translate": ""
    },
    {
        "source": "without atomics maps directly to `static mut`, and dtors aren't implemented because thread dtors aren't really a thing on wasm right now",
        "suggest": "没有原子直接映射到 `static mut`，并且没有实现 dtor，因为线程 dtor 现在在 wasm 上并不是真正的东西",
        "translate": ""
    },
    {
        "source": "this should come after the `target_thread_local` block.",
        "suggest": "这应该在 `target_thread_local` 块之后。",
        "translate": ""
    },
    {
        "source": "If the platform has support for `#[thread_local]`, use it.",
        "suggest": "如果平台支持 `#[thread_local]`，请使用它。",
        "translate": ""
    },
    {
        "source": "If a dtor isn't needed we can do something \"very raw\" and just get going.",
        "suggest": "如果不需要 dtor，我们可以做一些 \"very raw\" 的事情，然后开始。",
        "translate": ""
    },
    {
        "source": "0 == dtor not registered",
        "suggest": "0 == dtor 未注册",
        "translate": ""
    },
    {
        "source": "1 == dtor registered, dtor not run",
        "suggest": "1 == dtor 已注册，dtor 未运行",
        "translate": ""
    },
    {
        "source": "2 == dtor registered and is running or has run",
        "suggest": "2 == dtor 已注册并正在运行或已运行",
        "translate": ""
    },
    {
        "source": "0 == we haven't registered a destructor, so do so now.",
        "suggest": "0 == 我们还没有注册析构函数，所以现在注册。",
        "translate": ""
    },
    {
        "source": "1 == the destructor is registered and the value is valid, so return the pointer.",
        "suggest": "1 == 析构函数已注册且值有效，因此返回指针。",
        "translate": ""
    },
    {
        "source": "otherwise the destructor has already run, so we can't give access.",
        "suggest": "否则析构函数已经运行，所以我们不能授予访问权限。",
        "translate": ""
    },
    {
        "source": "On platforms without `#[thread_local]` we fall back to the same implementation as below for os thread locals.",
        "suggest": "在没有 `#[thread_local]` 的平台上，我们回退到与下面的 os 线程局部变量相同的实现。",
        "translate": ""
    },
    {
        "source": "used to generate the `LocalKey` value for `thread_local!`",
        "suggest": "用于为 `thread_local!` 生成 `LocalKey` 值",
        "translate": ""
    },
    {
        "source": "note that this is just a publically-callable function only for the const-initialized form of thread locals, basically a way to call the free `register_dtor` function defined elsewhere in libstd.",
        "suggest": "请注意，这只是一个可公开调用的函数，仅适用于线程局部变量的常量初始化形式，基本上是调用 libstd 中其他地方定义的免费 `register_dtor` 函数的一种方式。",
        "translate": ""
    },
    {
        "source": "This is only used to make thread locals with `const { ..",
        "suggest": "这仅用于使用 `const {..",
        "translate": ""
    },
    {
        "source": "}` initialization expressions unstable.",
        "suggest": "}` 初始化表达式不稳定。",
        "translate": ""
    },
    {
        "source": "If and/or when that syntax is stabilized with thread locals this will simply be removed.",
        "suggest": "如果或者当该语法使用线程局部变量稳定时，这将被简单地删除。",
        "translate": ""
    },
    {
        "source": "not implment yet",
        "suggest": "尚未实现",
        "translate": ""
    },
    {
        "source": "For each of the 128-bit low and high halves of the vectors, the last",
        "suggest": "对于 vectors的 128 位低半部分和高半部分中，最后一个",
        "translate": ""
    },
    {
        "source": "4 bits of each byte of `b` are used as addresses into the respective low or high 16 bytes of `a`.",
        "suggest": "`b` 的每个字节的 4 位用作 `a` 相应低 16 字节或高 16 字节的地址。",
        "translate": ""
    },
    {
        "source": "That is, the halves are shuffled separately.",
        "suggest": "也就是说，两半分开打乱。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in two 128-bit vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in a",
        "suggest": "将两个 128 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a",
        "translate": ""
    },
    {
        "source": "128-bit wide vector.",
        "suggest": "128 位宽 vector。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in single vector dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当对应的掩码位为没有设置)。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in single vector dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in two 256-bit vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in a",
        "suggest": "将两个 256 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a",
        "translate": ""
    },
    {
        "source": "256-bit wide vector.",
        "suggest": "256 位宽 vector。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements and and store the results in single vector dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当相应的掩码位为没有设置)。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in two 512-bit vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in a",
        "suggest": "将两个 512 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a",
        "translate": ""
    },
    {
        "source": "512-bit wide vector.",
        "suggest": "512 位宽 vector。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst.",
        "suggest": "将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将包装的单精度 (32-bit) 浮点元素在 a 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst.",
        "suggest": "计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素相加，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当对应的元素从 src 复制时掩码位未设置)。",
        "translate": ""
    },
    {
        "source": "Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。",
        "translate": ""
    },
    {
        "source": "Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst.Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst.",
        "suggest": "计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素累加，结果存储在 BF16 (16-bit) 浮点对的 dst.Compute 点积中 b、将中间的单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存入 dst。",
        "translate": ""
    },
    {
        "source": "Load 256-bits (composed of 16 packed 16-bit integers) from memory into dst.",
        "suggest": "将 256 位 (由 16 个包装的 16 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Load 128-bits (composed of 8 packed 16-bit integers) from memory into dst.",
        "suggest": "将 128 位 (由 8 个包装的 16 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Load 256-bits (composed of 32 packed 8-bit integers) from memory into dst.",
        "suggest": "将 256 位 (由 32 个包装的 8 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Load 128-bits (composed of 16 packed 8-bit integers) from memory into dst.",
        "suggest": "将 128 位 (由 16 个包装的 8 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Store 256-bits (composed of 16 packed 16-bit integers) from a into memory.",
        "suggest": "将 a 中的 256 位 (由 16 个包装的 16 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Store 128-bits (composed of 8 packed 16-bit integers) from a into memory.",
        "suggest": "将 a 中的 128 位 (由 8 个包装的 16 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Store 256-bits (composed of 32 packed 8-bit integers) from a into memory.",
        "suggest": "将 a 中的 256 位 (由 32 个包装的 8 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Store 128-bits (composed of 16 packed 8-bit integers) from a into memory.",
        "suggest": "将 a 中的 128 位 (由 16 个包装的 8 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的有符号 32 位整数的绝对值，并使用 writemask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的有符号 32 位整数的绝对值，并使用 zeromask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "is a properly initialized i64x4",
        "suggest": "是正确初始化的 i64x4",
        "translate": ""
    },
    {
        "source": "Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存入 dst 中 (未设置相应掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数在 a 的低 8 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数 a 的低 8 字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in th elow 4 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数 a 的后 4 个字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 16 位整数 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "零扩展包装的无符号 16 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "shoud be vpermq",
        "suggest": "应该是 vpermq",
        "translate": ""
    },
    {
        "source": "should be vpermq",
        "suggest": "应该是 vpermq",
        "translate": ""
    },
    {
        "source": "shoud be vpermpd",
        "suggest": "应该是 vpermpd",
        "translate": ""
    },
    {
        "source": "should be vpermd",
        "suggest": "应该是 vpermd",
        "translate": ""
    },
    {
        "source": "llvm use llvm.x86.avx2.permd",
        "suggest": "llvm 使用 llvm.x86.avx2.permd",
        "translate": ""
    },
    {
        "source": "Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用 imm8 中的控件 shuffle a 中的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用 imm8 中的控件对 a 中的单精度 (32-bit) 浮点元素进行打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素会被清零)。",
        "translate": ""
    },
    {
        "source": "should be vshufi32x4",
        "suggest": "应该是 vshufi32x4",
        "translate": ""
    },
    {
        "source": "should be vshufi64x2",
        "suggest": "应该是 vshufi64x2",
        "translate": ""
    },
    {
        "source": "should be vshuff32x4",
        "suggest": "应该是 vshuff32x4",
        "translate": ""
    },
    {
        "source": "should be vshuff64x2",
        "suggest": "应该是 vshuff64x2",
        "translate": ""
    },
    {
        "source": "should be vextractf32x4",
        "suggest": "应该是 vextractf32x4",
        "translate": ""
    },
    {
        "source": "should be vinsertf32x4",
        "suggest": "应该是 vinsertf32x4",
        "translate": ""
    },
    {
        "source": "Copy the lower 32-bit integer in a to dst.",
        "suggest": "将 a 中的低 32 位整数复制到 dst。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst.",
        "suggest": "将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 32 字节 (8 个元素) 存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst.",
        "suggest": "将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 16 字节 (4 个元素) 存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "should be valignd",
        "suggest": "应该是 valigned",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当对应的掩码位为没有设置)。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst.",
        "suggest": "将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 32 字节 (4 个元素) 存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst.",
        "suggest": "将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 16 字节 (2 个元素) 存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "should be valignq",
        "suggest": "应该是 valignq",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。",
        "translate": ""
    },
    {
        "source": "Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。",
        "translate": ""
    },
    {
        "source": "Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "should be vpord",
        "suggest": "应该是 vpord",
        "translate": ""
    },
    {
        "source": "should be vporq",
        "suggest": "应该是 vporq",
        "translate": ""
    },
    {
        "source": "should be vpxord",
        "suggest": "应该是 vpxord",
        "translate": ""
    },
    {
        "source": "should be vpxorq",
        "suggest": "应该是 vpxorq",
        "translate": ""
    },
    {
        "source": "should be vcmpps",
        "suggest": "应该是 vcmpps",
        "translate": ""
    },
    {
        "source": "should be vcmps",
        "suggest": "应该是 vcmps",
        "translate": ""
    },
    {
        "source": "should be vcmppd",
        "suggest": "应该是 vcmppd",
        "translate": ""
    },
    {
        "source": "should be vpcmpud",
        "suggest": "应该是 vpcmpud",
        "translate": ""
    },
    {
        "source": "should be vpcmpd",
        "suggest": "应该是 vpcmpd",
        "translate": ""
    },
    {
        "source": "should be vpcmpuq",
        "suggest": "应该是 vpcmpuq",
        "translate": ""
    },
    {
        "source": "should be vpcmpq",
        "suggest": "应该是 vpcmpq",
        "translate": ""
    },
    {
        "source": "Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst.",
        "suggest": "将 256 位 (由 8 个包装的 32 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst.",
        "suggest": "将 128 位 (由 4 个包装的 32 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed unsigned 32-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的无符号 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.",
        "suggest": "将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。",
        "translate": ""
    },
    {
        "source": "Store 256-bits (composed of 8 packed 32-bit integers) from a into memory.",
        "suggest": "将 a 中的 256 位 (由 8 个包装的 32 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Store 128-bits (composed of 4 packed 32-bit integers) from a into memory.",
        "suggest": "将 a 中的 128 位 (由 4 个包装的 32 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst.",
        "suggest": "将 256 位 (由 4 个包装的 64 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst.",
        "suggest": "将 128 位 (由 2 个包装的 64 位整数组成) 从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Store 256-bits (composed of 4 packed 64-bit integers) from a into memory.",
        "suggest": "将 a 中的 256 位 (由 4 个包装的 64 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Store 128-bits (composed of 2 packed 64-bit integers) from a into memory.",
        "suggest": "将 a 中的 128 位 (由 2 个包装的 64 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.",
        "suggest": "mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。",
        "translate": ""
    },
    {
        "source": "mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.",
        "suggest": "mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。",
        "translate": ""
    },
    {
        "source": "Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.",
        "suggest": "使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "should be vpermi2b",
        "suggest": "应该是 vpermi2b",
        "translate": ""
    },
    {
        "source": "Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).",
        "suggest": "使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.",
        "suggest": "使用 idx 中的相应索引将 a 中的 8 位整数打乱到通道中，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.",
        "suggest": "对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。",
        "translate": ""
    },
    {
        "source": "For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。",
        "translate": ""
    },
    {
        "source": "For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。",
        "translate": ""
    },
    {
        "source": "Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.",
        "suggest": "将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。",
        "translate": ""
    },
    {
        "source": "Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.",
        "suggest": "将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。",
        "translate": ""
    },
    {
        "source": "Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.",
        "suggest": "将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。",
        "translate": ""
    },
    {
        "source": "Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.",
        "suggest": "将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。",
        "translate": ""
    },
    {
        "source": "Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result.",
        "suggest": "在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.",
        "suggest": "将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).",
        "suggest": "将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 复制)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result.",
        "suggest": "将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.",
        "suggest": "将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).",
        "suggest": "将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result.",
        "suggest": "在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.",
        "suggest": "将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).",
        "suggest": "将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result.",
        "suggest": "将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.",
        "suggest": "将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).",
        "suggest": "将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result.",
        "suggest": "连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.",
        "suggest": "将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).",
        "suggest": "将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result.",
        "suggest": "将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.",
        "suggest": "将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).",
        "suggest": "将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 64-bits in dst).",
        "suggest": "将结果左移 imm8 位，并将高 64 位存储在 dst 中)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 32-bits in dst.",
        "suggest": "将结果左移 imm8 位，并将高 32 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 16-bits in dst).",
        "suggest": "将结果左移 imm8 位，并将高 16 位存储在 dst 中)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 64-bits in dst.",
        "suggest": "将结果右移 imm8 位，并将低 64 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "should be vpshrdq",
        "suggest": "应该是 vpshrdq",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src\" when the corresponding mask bit is not set).",
        "suggest": "将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 src` 复制)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 32-bits in dst.",
        "suggest": "将结果右移 imm8 位，并将低 32 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "should be vpshldd",
        "suggest": "应该是 vpshldd",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 16-bits in dst.",
        "suggest": "将结果右移 imm8 位，并将低 16 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "should be vpshrdw",
        "suggest": "应该是 vpshrdw",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results.",
        "suggest": "将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。",
        "translate": ""
    },
    {
        "source": "Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.",
        "suggest": "将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。",
        "translate": ""
    },
    {
        "source": "Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.",
        "suggest": "使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results.",
        "suggest": "将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。",
        "translate": ""
    },
    {
        "source": "Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.",
        "suggest": "将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。",
        "translate": ""
    },
    {
        "source": "Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.",
        "suggest": "使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "x86-64 uses `rbx` as the base register, so preserve it.",
        "suggest": "x86-64 使用 `rbx` 作为基址寄存器，所以保留它。",
        "translate": ""
    },
    {
        "source": "128-bit wide set of eight 'u16' types, x86-specific",
        "suggest": "128 位宽的一组 8 个 `u16` 类型，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is representing a 128-bit SIMD register which internally is consisted of eight packed `u16` instances.",
        "suggest": "该类型代表一个 128 位的 SIMD 寄存器，内部由 8 个包装的 `u16` 实例组成。",
        "translate": ""
    },
    {
        "source": "It's purpose is for bf16 related intrinsic implementations.",
        "suggest": "它的目的是用于 bf16 相关的内在实现。",
        "translate": ""
    },
    {
        "source": "256-bit wide set of 16 'u16' types, x86-specific",
        "suggest": "256 位宽的 16 种 `u16` 类型集，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m128bh` type defined by Intel, representing a 256-bit SIMD register which internally is consisted of",
        "suggest": "该类型与 Intel 定义的 `__m128bh` 类型相同，代表一个 256 位的 SIMD 寄存器，内部由",
        "translate": ""
    },
    {
        "source": "16 packed `u16` instances.",
        "suggest": "16 个包装的 `u16` 实例。",
        "translate": ""
    },
    {
        "source": "512-bit wide set of 32 'u16' types, x86-specific",
        "suggest": "512 位宽的 32 种 `u16` 类型集，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m128bh` type defined by Intel, representing a 512-bit SIMD register which internally is consisted of",
        "suggest": "该类型与 Intel 定义的 `__m128bh` 类型相同，代表一个 512 位的 SIMD 寄存器，内部由",
        "translate": ""
    },
    {
        "source": "32 packed `u16` instances.",
        "suggest": "32 个包装的 `u16` 实例。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer, and store the result in dst.",
        "suggest": "将 a 中的低位双精度 (64-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer, and store the result in dst.",
        "suggest": "将 a 中的低位单精度 (32-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 64-bit integer, and store the result in dst.",
        "suggest": "将 a 中的低位单精度 (32-bit) 浮点元素转换为无符号 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 64-bit integer, and store the result in dst.",
        "suggest": "将 a 中的低位双精度 (64-bit) 浮点元素转换为无符号 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the signed 64-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将有符号的 64 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高 3 个包装元素从 a 复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Convert the signed 64-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将有符号的 64 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高位元素复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的低位双精度 (64-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 64-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的低位双精度 (64-bit) 浮点元素转换为带截断的无符号 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的低位单精度 (32-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 64-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的低位单精度 (32-bit) 浮点元素转换为带截断的无符号 64 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "The XML file names VBMI as \"avx512_vbmi\", while Rust calls it \"avx512vbmi\".",
        "suggest": "XML 文件将 VBMI 命名为 \"avx512_vbmi\"，而 Rust 将其命名为 \"avx512vbmi\"。",
        "translate": ""
    },
    {
        "source": "The XML file names VBMI2 as \"avx512_vbmi2\", while Rust calls it \"avx512vbmi2\".",
        "suggest": "XML 文件将 VBMI2 命名为 \"avx512_vbmi2\"，而 Rust 将其命名为 \"avx512vbmi2\"。",
        "translate": ""
    },
    {
        "source": "The XML file names VNNI as \"avx512_vnni\", while Rust calls it \"avx512vnni\".",
        "suggest": "XML 文件将 VNNI 命名为 \"avx512_vnni\"，而 Rust 将其命名为 \"avx512vnni\"。",
        "translate": ""
    },
    {
        "source": "The XML file names VNNI as \"avx512_bf16\", while Rust calls it \"avx512bf16\".",
        "suggest": "XML 文件将 VNNI 命名为 \"avx512_bf16\"，而 Rust 将其命名为 \"avx512bf16\"。",
        "translate": ""
    },
    {
        "source": "AVX-512 BITALG (Support for VPOPCNT\\[B,W\\] and VPSHUFBITQMB)",
        "suggest": "AVX-512 BITALG (支持 VPOPCNT\\[B,W\\] 和 VPSHUFBITQMB)",
        "translate": ""
    },
    {
        "source": "removing `extern crate` gives an error that `vec_spare_capacity` is unknown",
        "suggest": "删除 `extern crate` 会出现 `vec_spare_capacity` 未知的错误",
        "translate": ""
    },
    {
        "source": "<b>Outer-Open Gomoku</b> is a board game which is a enhanced version of connect5 (Gomoku).",
        "suggest": "<b>Outer-Open Gomoku</b> 是 connect5 (Gomoku) 的增强版棋盘游戏。</b>",
        "translate": ""
    },
    {
        "source": "The game is a two-player game which played on a 15x15 Go board.",
        "suggest": "该游戏是在 15x15 围棋棋盘上进行的两人游戏。",
        "translate": ""
    },
    {
        "source": "Two players take turns placing a move on an empty intersection in this board.",
        "suggest": "两名玩家轮流在此棋盘上的空交叉点上移动。",
        "translate": ""
    },
    {
        "source": "The winner is the first player to form an unbroken chain of five moves horizontally, vertically, or diagonally.",
        "suggest": "获胜者是第一个在水平、垂直或对角线上形成连续五个移动链的玩家。",
        "translate": ""
    },
    {
        "source": "Unlike Gomoku, the first move is required to be placed at the two outer rows or columns of this board.",
        "suggest": "与五子棋不同的是，第一步需要放在这个棋盘的两行或两列之外。",
        "translate": ""
    },
    {
        "source": "This program provides an AI playing with Minimax search with alpha-beta pruning which uses",
        "suggest": "该程序提供了一个 AI 玩 Minimax 搜索和 alpha-beta 剪枝，它使用",
        "translate": ""
    },
    {
        "source": "patterns on evaluation.",
        "suggest": "评估模式。",
        "translate": ""
    },
    {
        "source": "The avx512 intrinsic can do 32 pattern matching at one time.",
        "suggest": "avx512 内联函数一次可以进行 32 个模式匹配。",
        "translate": ""
    },
    {
        "source": "This avx512 is tested with non-avx512 code to verify its correctness.",
        "suggest": "此 avx512 使用非 avx512 代码进行测试以验证其正确性。",
        "translate": ""
    },
    {
        "source": "On Intel i7-7800x using single thread with fixed AVX-512 clock at 4.0GHz, the avx512 is speed up about 9x.",
        "suggest": "在英特尔 i7-7800x 上使用单线程，在 4.0GHz 上固定 AVX-512 时钟，avx512 的速度提高了大约 9 倍。",
        "translate": ""
    },
    {
        "source": "The average time for each move in the avx512 is around 14.00s <span>±</span> 1.31s and in the non-avx512",
        "suggest": "avx512 每次移动的平均时间约为 14.00s <span>±</span> 1.31s，非 avx512",
        "translate": ""
    },
    {
        "source": "is 129.02s <span>±</span> 4.96s.",
        "suggest": "是 129.02s <span>±</span> 4.96s。",
        "translate": ""
    },
    {
        "source": "On Intel Tiger Lake i7-1165G7, the avx512 is around 11.11s <span>±</span> 1.31s.",
        "suggest": "在 Intel Tiger Lake i7-1165G7 上，avx512 约为 11.11s <span>±</span> 1.31s。",
        "translate": ""
    },
    {
        "source": "Pattern Matching",
        "suggest": "模式匹配",
        "translate": ""
    },
    {
        "source": "Use 512-bit to present the board state.",
        "suggest": "使用 512 位来呈现板子状态。",
        "translate": ""
    },
    {
        "source": "The location 0 is top left.",
        "suggest": "位置 0 位于左上角。",
        "translate": ""
    },
    {
        "source": "Pattern \"OOOOO\" is matching through \"0 1 2 3 4\", \"1 2 3 4 5\", ...",
        "suggest": "模式 \"OOOOO\" 通过 \"0 1 2 3 4\"、\"1 2 3 4 5\"、...",
        "translate": ""
    },
    {
        "source": "Using avx512, \"0 1 2 3 4\", \"16 17 18 19 20\", ...",
        "suggest": "使用 avx512, \"0 1 2 3 4\", \"16 17 18 19 20\", ...",
        "translate": ""
    },
    {
        "source": "can be matched simultaneously.",
        "suggest": "可以同时匹配。",
        "translate": ""
    },
    {
        "source": "//! You can test out this program via:",
        "suggest": "//! 您可以通过以下方式测试此程序:",
        "translate": ""
    },
    {
        "source": "You should see a game self-playing.",
        "suggest": "您应该看一个自己玩的游戏。",
        "translate": ""
    },
    {
        "source": "In the end of the game, it shows the average time for each move.",
        "suggest": "在游戏结束时，它会显示每一步的平均时间。",
        "translate": ""
    },
    {
        "source": "DIRECTION 0: left to right",
        "suggest": "方向 0: 从左到右",
        "translate": ""
    },
    {
        "source": "DIRECTION 1: top to bottom",
        "suggest": "方向 1: 从上到下",
        "translate": ""
    },
    {
        "source": "DIRECTION 2: top left to bottom right",
        "suggest": "方向 2: 从左上到右下",
        "translate": ""
    },
    {
        "source": "DIRECTION 3: top right to bottom left",
        "suggest": "方向 3: 从右上到左下",
        "translate": ""
    },
    {
        "source": "A table to encode each location to a value in bit 31-0 in the bitboard for 4 direction",
        "suggest": "将每个位置编码为位板中位 31-0 中的值的表，用于 4 个方向",
        "translate": ""
    },
    {
        "source": "Direction 0",
        "suggest": "方向 0",
        "translate": ""
    },
    {
        "source": "Direction 1",
        "suggest": "方向 1",
        "translate": ""
    },
    {
        "source": "Direction 2",
        "suggest": "方向 2",
        "translate": ""
    },
    {
        "source": "Direction 3",
        "suggest": "方向 3",
        "translate": ""
    },
    {
        "source": "A table to encode each location to an index in the bitboard for 4 direction",
        "suggest": "将每个位置编码为位板中 4 个方向的索引的表",
        "translate": ""
    },
    {
        "source": "Use one-dimensional array to store the board state.",
        "suggest": "使用一维数组存储棋盘状态。",
        "translate": ""
    },
    {
        "source": "position 15, 31, ...",
        "suggest": "位置 15, 31, ...",
        "translate": ""
    },
    {
        "source": "are Borders.",
        "suggest": "是边界。",
        "translate": ""
    },
    {
        "source": "position 0 is file 0, rank 0.",
        "suggest": "位置 0 是文件 0，等级 0。",
        "translate": ""
    },
    {
        "source": "position 17 is file 1, rank 1.",
        "suggest": "位置 17 是文件 1，等级 1。",
        "translate": ""
    },
    {
        "source": "Use a three-dimensional array to store the bitboard.",
        "suggest": "使用三维数组来存储位板。",
        "translate": ""
    },
    {
        "source": "The first dimension is color: Black, White and Empty.",
        "suggest": "第一个维度是颜色: 黑色、白色和空。",
        "translate": ""
    },
    {
        "source": "The second and third one are 2 x 512-bit.",
        "suggest": "第二个和第三个是 2 x 512 位。",
        "translate": ""
    },
    {
        "source": "Direction 0 and 2 use the first 512-bit.",
        "suggest": "方向 0 和 2 使用第一个 512 位。",
        "translate": ""
    },
    {
        "source": "Direction 1 and",
        "suggest": "方向 1 和",
        "translate": ""
    },
    {
        "source": "3 use the second 512-bit.",
        "suggest": "3 使用第二个 512 位。",
        "translate": ""
    },
    {
        "source": "Each 512-bit is a 32-bit x 16 array.",
        "suggest": "每个 512 位是一个 32 位 x 16 阵列。",
        "translate": ""
    },
    {
        "source": "Direction 0 and 1 store at bit 31-16 and Direction 2 and 3 store at bit 15-0.",
        "suggest": "方向 0 和 1 存储在位 31-16，方向 2 和 3 存储在位 15-0。",
        "translate": ""
    },
    {
        "source": "starting position Set up the Border",
        "suggest": "起始位置 设置边框",
        "translate": ""
    },
    {
        "source": "In the beginning, all is Empty",
        "suggest": "一开始，一切都是空的",
        "translate": ""
    },
    {
        "source": "first move is Black",
        "suggest": "第一步是黑色",
        "translate": ""
    },
    {
        "source": "set up the corresponding bitboard",
        "suggest": "设置相应的位板",
        "translate": ""
    },
    {
        "source": "use bit 31-16 to store direction 0 and 1",
        "suggest": "使用位 31-16 来存储方向 0 和 1",
        "translate": ""
    },
    {
        "source": "use bit 15-0 to store direction 2 and 3.",
        "suggest": "使用位 15-0 来存储方向 2 和 3。",
        "translate": ""
    },
    {
        "source": "There are 21 for each one.",
        "suggest": "每个人有 21 个。",
        "translate": ""
    },
    {
        "source": "We combine row1 and row16, row2 and row17, row3 and row18, row4 and row19, and row 5 and row20",
        "suggest": "我们组合 row1 和 row16、row2 和 row17、row3 和 row18、row4 和 row19，row5 和 row20",
        "translate": ""
    },
    {
        "source": "row 0",
        "suggest": "第 0 行",
        "translate": ""
    },
    {
        "source": "update black move and remove empty move in bitboard",
        "suggest": "更新黑色移动并删除位板中的空移动",
        "translate": ""
    },
    {
        "source": "update white move and remove empty move in bitboard",
        "suggest": "更新空白移动并移除位板中的空白移动",
        "translate": ""
    },
    {
        "source": "legal move list",
        "suggest": "合法移动列表",
        "translate": ""
    },
    {
        "source": "Use List to store legal moves.",
        "suggest": "使用列表存储合法移动。",
        "translate": ""
    },
    {
        "source": "if all empty is 0, all board is filled.",
        "suggest": "如果所有空的都是 0，则所有板都已填满。",
        "translate": ""
    },
    {
        "source": "use Minimax search with alpha-beta pruning",
        "suggest": "使用极小极大搜索和 alpha-beta 剪枝",
        "translate": ""
    },
    {
        "source": "move loop",
        "suggest": "循环移动",
        "translate": ""
    },
    {
        "source": "best move at the root node, best score elsewhere",
        "suggest": "最好在根节点移动，在其他地方得分最高",
        "translate": ""
    },
    {
        "source": "Evaluation function: give different scores to different patterns after a fixed depth.",
        "suggest": "评价函数: 在固定深度后，给不同的图案赋予不同的分数。",
        "translate": ""
    },
    {
        "source": "check if opp has live4 which will win playing next move",
        "suggest": "检查 opp 是否有 live4 这将赢得下一步行动",
        "translate": ""
    },
    {
        "source": "check if self has live4 which will win playing next move",
        "suggest": "检查自己是否有 live4 这将赢得下一步行动",
        "translate": ""
    },
    {
        "source": "check if self has dead4 which will win playing next move",
        "suggest": "检查自己是否有 dead4 这将赢得下一步行动",
        "translate": ""
    },
    {
        "source": "check if opp has 2 dead4 which will win playing next move",
        "suggest": "检查 opp 是否有 2 dead4 这将赢得下一步行动",
        "translate": ""
    },
    {
        "source": "check if opp has a dead 4 and live 3 which will win playing the next two move",
        "suggest": "检查 opp 是否有死 4 和活 3，这将赢得接下来的两步",
        "translate": ""
    },
    {
        "source": "check if opp has 2 live3 which will win playing the next two move",
        "suggest": "检查 opp 是否有 2 live3 这将赢得接下来的两步",
        "translate": ""
    },
    {
        "source": "check if self has 2 live3 which will win playing the next two move",
        "suggest": "检查自己是否有 2 live3 这将赢得接下来的两步棋",
        "translate": ""
    },
    {
        "source": "Check <b>OOOOO</b>",
        "suggest": "检查 <b>OOOOO</b>",
        "translate": ""
    },
    {
        "source": "Check <b>-OOOO-</b>",
        "suggest": "检查 <b>-OOOO-</b>",
        "translate": ""
    },
    {
        "source": "Check <b>OOOO-, OOO-O, OO-OO, O-OOO, -OOOO</b>",
        "suggest": "检查 <b>OOOO-, OOO-O, OO-OO, O-OOO,-OOOO</b>",
        "translate": ""
    },
    {
        "source": "Check <b>-OOO-, -OO-O-, -O-OO-</br>",
        "suggest": "检查 <b>-OOO-、-OO-O-、-O-OO-</b></br>",
        "translate": ""
    },
    {
        "source": "load states from bitboard",
        "suggest": "从位板加载状态",
        "translate": ""
    },
    {
        "source": "an unbroken chain of five moves",
        "suggest": "连续的五个动作链",
        "translate": ""
    },
    {
        "source": "use Mask to filter out which data is not processed.",
        "suggest": "使用 Mask 过滤掉哪些数据没有被处理。",
        "translate": ""
    },
    {
        "source": "There is no data to match (x = black, o = white, _ = empty, 0 = no data).",
        "suggest": "没有要匹配的数据 (x = 黑色，o = 白色，_= 空，0 = 无数据)。",
        "translate": ""
    },
    {
        "source": "Then, shift one space left.",
        "suggest": "然后，左移一格。",
        "translate": ""
    },
    {
        "source": "There is no enough data to match (o x o x but we want to match o o o o o).",
        "suggest": "没有足够的数据来匹配 (o x o x 但我们想匹配 o o o o o)。",
        "translate": ""
    },
    {
        "source": "mix 2 data together (column 17-23 and column 24-32).",
        "suggest": "将 2 个数据混合在一起 (17-23 列和 24-32 列)。",
        "translate": ""
    },
    {
        "source": "Using Mask to make it match correctly.",
        "suggest": "使用 Mask 使其正确匹配。",
        "translate": ""
    },
    {
        "source": "For example, column 23,24,25,26,27 is not a pattern and 24,25,26,27,28 is a pattern.",
        "suggest": "例如，第 23,24,25,26,27 列不是模式，而 24,25,26,27,28 是模式。",
        "translate": ""
    },
    {
        "source": "That is why some mask bits are set to 0 from answer_mask[2] to answer_mask[10].",
        "suggest": "这就是为什么一些掩码位从 answer_mask[2] 到 answer_mask [10] 设置为 0 的原因。",
        "translate": ""
    },
    {
        "source": "direction 0 and 1",
        "suggest": "方向 0 和 1",
        "translate": ""
    },
    {
        "source": "OOOOOOOOOOO----, the last 4 \"-\" cannot make an unbroken chain of five.",
        "suggest": "OOOOOOOOOOO----，最后的 4 个 \"-\" 不能组成一个完整的 5 个链。",
        "translate": ""
    },
    {
        "source": "shift one space left",
        "suggest": "左移一格",
        "translate": ""
    },
    {
        "source": "focus on the pattern",
        "suggest": "专注于模式",
        "translate": ""
    },
    {
        "source": "see if it matches the pattern",
        "suggest": "看看它是否与模式匹配",
        "translate": ""
    },
    {
        "source": "set the first move is (1,7)",
        "suggest": "设置第一步是 (1,7)",
        "translate": ""
    },
    {
        "source": "search depth = 4",
        "suggest": "搜索深度 = 4",
        "translate": ""
    },
    {
        "source": "See [`std::hint::black_box`] for details.",
        "suggest": "有关详细信息，请参见 [`std::hint::black_box`]。",
        "translate": ""
    },
    {
        "source": "A unique integer associated with each test.",
        "suggest": "与每个测试关联的唯一整数。",
        "translate": ""
    },
    {
        "source": "Memory safety",
        "suggest": "内存安全",
        "translate": ""
    },
    {
        "source": "Fully qualified syntax",
        "suggest": "完全限定的语法",
        "translate": ""
    },
    {
        "source": "base case",
        "suggest": "基本情况",
        "translate": ""
    },
    {
        "source": "no-op when invoked with null",
        "suggest": "使用 null 调用时无操作",
        "translate": ""
    },
    {
        "source": "Converts a `T` into a `Box<T>`",
        "suggest": "将 `T` 转换为 `Box<T>`",
        "translate": ""
    },
    {
        "source": "Given a leaf edge handle into a dying tree, returns the next leaf edge on the right side, and the key-value pair in between, if they exist.",
        "suggest": "给定 dying 树的叶子 edge 句柄，返回右侧的下一个叶子 edge，以及中间的键值对 (如果它们存在)。",
        "translate": ""
    },
    {
        "source": "If the given edge is the last one in a leaf, this method deallocates the leaf, as well as any ancestor nodes whose last edge was reached.",
        "suggest": "如果给定的 edge 是叶子中的最后一个，则此方法将释放叶子以及到达最后一个 edge 的所有祖先节点。",
        "translate": ""
    },
    {
        "source": "This implies that if no more key-value pair follows, the entire tree will have been deallocated and there is nothing left to return.",
        "suggest": "这意味着如果没有更多的键值对跟随，整个树将被释放并且没有任何东西可以返回。",
        "translate": ""
    },
    {
        "source": "The returned KV handle is only valid to access the key and value, and only valid until the next call to this method or counterpart `deallocating_next_back`.",
        "suggest": "返回的 KV 句柄仅对访问键和值有效，并且仅在下一次调用此方法或对应的 `deallocating_next_back` 之前有效。",
        "translate": ""
    },
    {
        "source": "Given a leaf edge handle into a dying tree, returns the next leaf edge on the left side, and the key-value pair in between, if they exist.",
        "suggest": "给定 dying 树的叶子 edge 句柄，返回左侧的下一个叶子 edge，以及中间的键值对 (如果它们存在)。",
        "translate": ""
    },
    {
        "source": "If the given edge is the first one in a leaf, this method deallocates the leaf, as well as any ancestor nodes whose first edge was reached.",
        "suggest": "如果给定的 edge 是叶子中的第一个，则此方法释放叶子节点，以及到达第一个 edge 的任何祖先节点。",
        "translate": ""
    },
    {
        "source": "The returned KV handle is only valid to access the key and value, and only valid until the next call to this method or counterpart `deallocating_next`.",
        "suggest": "返回的 KV 句柄仅对访问键和值有效，并且仅在下一次调用此方法或对应方 `deallocating_next` 之前有效。",
        "translate": ""
    },
    {
        "source": "That KV was not previously returned by counterpart `deallocating_next_back_unchecked` on any copy of the handles being used to traverse the tree.",
        "suggest": "该 KV 之前没有由对应的 `deallocating_next_back_unchecked` 在用于遍历树的句柄的任何副本上返回。",
        "translate": ""
    },
    {
        "source": "The only safe way to proceed with the updated handle is to compare it, drop it, or call this method or counterpart `deallocating_next_back_unchecked` again.",
        "suggest": "处理更新后的句柄的唯一安全方法是比较它，丢弃它，或再次调用此方法或对应的 `deallocating_next_back_unchecked`。",
        "translate": ""
    },
    {
        "source": "That leaf edge was not previously returned by counterpart `deallocating_next_unchecked` on any copy of the handles being used to traverse the tree.",
        "suggest": "该叶子 edge 之前没有由对应的 `deallocating_next_unchecked` 在用于遍历树的句柄的任何副本上返回。",
        "translate": ""
    },
    {
        "source": "The only safe way to proceed with the updated handle is to compare it, drop it, or call this method or counterpart `deallocating_next_unchecked` again.",
        "suggest": "处理更新后的句柄的唯一安全方法是比较它，丢弃它，或再次调用此方法或对应的 `deallocating_next_unchecked`。",
        "translate": ""
    },
    {
        "source": "Borrows exclusive access to the leaf portion of a leaf or internal node.",
        "suggest": "借用对叶子或内部节点的叶子部分的独占访问权。",
        "translate": ""
    },
    {
        "source": "Offers exclusive access to the leaf portion of a leaf or internal node.",
        "suggest": "提供对叶子或内部节点的叶子部分的独占访问。",
        "translate": ""
    },
    {
        "source": "Borrows exclusive access to the leaf portion of a dying leaf or internal node.",
        "suggest": "借用对 dying 叶子或内部节点的叶子部分的独占访问。",
        "translate": ""
    },
    {
        "source": "Replaces the key and value that the KV handle refers to.",
        "suggest": "替换 KV 句柄引用的键和值。",
        "translate": ""
    },
    {
        "source": "Extracts the key and value that the KV handle refers to.",
        "suggest": "提取 KV 句柄引用的键和值。",
        "translate": ""
    },
    {
        "source": "Drops the key and value that the KV handle refers to.",
        "suggest": "丢弃 KV 句柄引用的键和值。",
        "translate": ""
    },
    {
        "source": "Converts a generic type `T` into a `Rc<T>`",
        "suggest": "将泛型 `T` 转换为 `Rc<T>`",
        "translate": ""
    },
    {
        "source": "Create a reference-counted pointer from a clone-on-write pointer by copying its content.",
        "suggest": "通过复制其内容，从写时克隆指针创建一个引用计数指针。",
        "translate": ""
    },
    {
        "source": "If the string is not owned...",
        "suggest": "如果该字符串不被拥有...",
        "translate": ""
    },
    {
        "source": "It will allocate on the heap and copy the string.",
        "suggest": "它将在堆上分配并复制字符串。",
        "translate": ""
    },
    {
        "source": "Copies elements from `src` range to the end of the string.",
        "suggest": "将 `src` 范围内的元素复制到字符串的末尾。",
        "translate": ""
    },
    {
        "source": "A Match result needs to contain the whole matched pattern, however Reject results may be split up into arbitrary many adjacent fragments.",
        "suggest": "Match 结果需要包含整个匹配的模式，而 Reject 结果可以被分割成任意多个相邻的片段。",
        "translate": ""
    },
    {
        "source": "In practice the implementation of Searcher::next_match tends to be more efficient, so we use it here and do some work to invert matches into rejections since that's what we want to copy below.",
        "suggest": "在实践中，Searcher::next_match 的实现往往更高效，所以我们在这里使用它并做一些工作将匹配转化为拒绝，因为这就是我们想要在下面复制的内容。",
        "translate": ""
    },
    {
        "source": "The stream of Match and Reject values up to a Done will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.",
        "suggest": "直到 Done 的 Match 和 Reject 值流将包含相邻、不重叠、覆盖整个 haystack 并位于 utf8 边界上的索引范围。",
        "translate": ""
    },
    {
        "source": "Bypass format_args!() to avoid write_str with zero-length strs",
        "suggest": "绕过 format_args!() 以避免使用零长度字符串 write_str",
        "translate": ""
    },
    {
        "source": "Converts a `&str` into a [`String`].",
        "suggest": "将 `&str` 转换为 [`String`]。",
        "translate": ""
    },
    {
        "source": "Converts a `&mut str` into a [`String`].",
        "suggest": "将 `&mut str` 转换为 [`String`]。",
        "translate": ""
    },
    {
        "source": "Converts a `&String` into a [`String`].",
        "suggest": "将 `&String` 转换为 [`String`]。",
        "translate": ""
    },
    {
        "source": "This clones `s` and returns the clone.",
        "suggest": "这将克隆 `s` 并返回该克隆。",
        "translate": ""
    },
    {
        "source": "Converts the given boxed `str` slice to a [`String`].",
        "suggest": "将给定的 boxed `str` 切片转换为 [`String`]。",
        "translate": ""
    },
    {
        "source": "Converts the given [`String`] to a boxed `str` slice that is owned.",
        "suggest": "将给定的 [`String`] 转换为拥有所有权的 boxed `str` 切片。",
        "translate": ""
    },
    {
        "source": "Converts a clone-on-write string to an owned instance of [`String`].",
        "suggest": "将写时克隆字符串转换为 [`String`] 的拥有实例。",
        "translate": ""
    },
    {
        "source": "This extracts the owned string, clones the string if it is not already owned.",
        "suggest": "这将提取拥有所有权的字符串，如果尚未拥有，则克隆该字符串。",
        "translate": ""
    },
    {
        "source": "Converts a string slice into a [`Borrowed`] variant.",
        "suggest": "将字符串切片转换为 [`Borrowed`] 变体。",
        "translate": ""
    },
    {
        "source": "Converts a [`String`] into an [`Owned`] variant.",
        "suggest": "将 [`String`] 转换为 [`Owned`] 变体。",
        "translate": ""
    },
    {
        "source": "Converts a [`String`] reference into a [`Borrowed`] variant.",
        "suggest": "将 [`String`] 引用转换为 [`Borrowed`] 变体。",
        "translate": ""
    },
    {
        "source": "Converts the given [`String`] to a vector [`Vec`] that holds values of type [`u8`].",
        "suggest": "将给定的 [`String`] 转换为包含 [`u8`] 类型值的 vector [`Vec`]。",
        "translate": ""
    },
    {
        "source": "Allocates an owned [`String`] from a single character.",
        "suggest": "从单个字符分配一个拥有所有权的 [`String`]。",
        "translate": ""
    },
    {
        "source": "Create an atomically reference-counted pointer from a clone-on-write pointer by copying its content.",
        "suggest": "通过复制其内容，从写时克隆指针创建一个原子引用计数指针。",
        "translate": ""
    },
    {
        "source": "Creates a [`Borrowed`] variant of [`Cow`] from a slice.",
        "suggest": "从一个切片创建一个 [`Cow`] 的 [`Borrowed`] 变体。",
        "translate": ""
    },
    {
        "source": "This conversion does not allocate or clone the data.",
        "suggest": "此转换不会分配或克隆数据。",
        "translate": ""
    },
    {
        "source": "Creates an [`Owned`] variant of [`Cow`] from an owned instance of [`Vec`].",
        "suggest": "从拥有所有权的 [`Vec`] 实例创建 [`Cow`] 的 [`Owned`] 变体。",
        "translate": ""
    },
    {
        "source": "Creates a [`Borrowed`] variant of [`Cow`] from a reference to [`Vec`].",
        "suggest": "从 [`Vec`] 的引用创建 [`Cow`] 的 [`Borrowed`] 变体。",
        "translate": ""
    },
    {
        "source": "and similar have a representation guarantee that they're the same size as the corresponding `u32` type, as well as a guarantee that transmuting between `NonZeroU32` and `Option<num::NonZeroU32>` works.",
        "suggest": "并且类似的具有表示保证它们与相应的 `u32` 类型具有相同的大小，以及保证 `NonZeroU32` 和 `Option<num::NonZeroU32>` 之间的转换有效。",
        "translate": ""
    },
    {
        "source": "While the documentation officially makes it UB to transmute from `None`, we're the standard library so we can make extra inferences, and we know that the only niche available to represent `None` is the one that's all zeros.",
        "suggest": "虽然正式的文档将 `None` 转换为 UB，但我们是标准库，因此我们可以进行额外的推断，我们知道唯一可用来表示 `None` 的利基是一个全是零的。",
        "translate": ""
    },
    {
        "source": "Increase `gap.read` now since the drop may panic.",
        "suggest": "现在增加 `gap.read` 因为丢弃可能 panic。",
        "translate": ""
    },
    {
        "source": "Without #[may_dangle] we get:",
        "suggest": "没有 #[may_dangle] 我们得到:",
        "translate": ""
    },
    {
        "source": "~~~~~~~~ borrowed value does not live long enough",
        "suggest": "~~~~~~~~ 借来的值活不长",
        "translate": ""
    },
    {
        "source": "dropped here while still borrowed borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::sync::Weak`",
        "suggest": "在此处删除时仍然借用的借用可能会在此处使用，当 `val` 被删除并运行 `std::sync::Weak` 类型的 `Drop` 代码时",
        "translate": ""
    },
    {
        "source": "dropped here while still borrowed borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::rc::Weak`",
        "suggest": "删除这里，而仍然借用的借用可能会在此处使用，当删除 `val` 并运行类型为 `std::rc::Weak` 的 `Drop` 代码时",
        "translate": ""
    },
    {
        "source": "here it panics while dropping the item with index==4",
        "suggest": "在这里，当删除 index==4 的项时，它会 panic",
        "translate": ""
    },
    {
        "source": "Helper functions and types for fixed-length arrays.",
        "suggest": "固定长度数组的辅助函数和类型。",
        "translate": ""
    },
    {
        "source": "Panics if `other` is currently mutably borrowed.",
        "suggest": "如果当前 `other` 是可变借用的，则会 panic。",
        "translate": ""
    },
    {
        "source": "Force the 6th bit to be set to ensure ascii is lower case.",
        "suggest": "强制设置第 6 位以确保 ascii 是小写的。",
        "translate": ""
    },
    {
        "source": "Creates a new formatter with default settings.",
        "suggest": "使用默认设置创建一个新的格式化程序。",
        "translate": ""
    },
    {
        "source": "This can be used as a micro-optimization in cases where a full `Arguments` structure (as created by `format_args!`) is not necessary;",
        "suggest": "在不需要完整的 `Arguments` 结构 (由 `format_args!` 创建) 的情况下，这可以用作微优化;",
        "translate": ""
    },
    {
        "source": "`Arguments` is a little more expensive to use in simple formatting scenarios.",
        "suggest": "在简单的格式化场景中使用 `Arguments` 的使用成本稍高一些。",
        "translate": ""
    },
    {
        "source": "Currently not intended for use outside of the standard library.",
        "suggest": "目前不打算在标准库之外使用。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::hint::unreachable_unchecked`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::size_of`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::mem::size_of`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::align_of`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::mem::align_of`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::align_of_val`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::mem::align_of_val`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::any::type_name`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::any::type_name`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::any::TypeId::of`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::any::TypeId::of`]。",
        "translate": ""
    },
    {
        "source": "Consider using [`core::panic::Location::caller`] instead.",
        "suggest": "可以考虑使用 [`core::panic::Location::caller`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::ptr::read_volatile`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::ptr::read_volatile`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::ptr::write_volatile`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::ptr::write_volatile`]。",
        "translate": ""
    },
    {
        "source": "The stabilized version of this intrinsic is [`core::mem::discriminant`].",
        "suggest": "这个 intrinsic 的稳定版本是 [`core::mem::discriminant`]。",
        "translate": ""
    },
    {
        "source": "Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`, the pointers must be non-null and properly aligned.",
        "suggest": "请注意，即使有效复制的大小 (`count * size_of::<T>()`) 是 `0`，指针也必须非空的并且正确对齐。",
        "translate": ""
    },
    {
        "source": "Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`, the pointer must be non-null and properly aligned.",
        "suggest": "请注意，即使有效复制的大小 (`count * size_of::<T>()`) 是 `0`，指针也必须非空的并且正确对齐。",
        "translate": ""
    },
    {
        "source": "Safety: All invariants are upheld.",
        "suggest": "安全性: 所有不可变变量均得到支持。",
        "translate": ""
    },
    {
        "source": "Specialization implementations for `Range`.",
        "suggest": "`Range` 的专业化实现。",
        "translate": ""
    },
    {
        "source": "The following invariants for `Step::steps_between` exist:",
        "suggest": "`Step::steps_between` 存在以下不可变变量:",
        "translate": ""
    },
    {
        "source": "this is the case when it would require more than `usize::MAX` steps to",
        "suggest": "当它需要比 `usize::MAX` 步骤更多的时候，就是这种情况",
        "translate": ""
    },
    {
        "source": "get to `b`",
        "suggest": "获取到 `b`",
        "translate": ""
    },
    {
        "source": "The first invariant is what is generally required for `TrustedLen` to be sound.",
        "suggest": "第一个不可变变量是 `TrustedLen` 正常运行所必需的。",
        "translate": ""
    },
    {
        "source": "The note addendum satisfies an additional `TrustedLen` invariant.",
        "suggest": "注释附录满足额外的 `TrustedLen` 不可变变量。",
        "translate": ""
    },
    {
        "source": "The upper bound must only be `None` if the actual iterator length is larger",
        "suggest": "如果实际迭代器长度更大，则上限只能是 `None`",
        "translate": ""
    },
    {
        "source": "than `usize::MAX`",
        "suggest": "比 `usize::MAX`",
        "translate": ""
    },
    {
        "source": "The second invariant logically follows the first so long as the `PartialOrd` implementation is correct;",
        "suggest": "只要 `PartialOrd` 实现是正确的，第二个不可变变量在逻辑上遵循第一个;",
        "translate": ""
    },
    {
        "source": "regardless it is explicitly stated.",
        "suggest": "不管它是否明确说明。",
        "translate": ""
    },
    {
        "source": "As such the second invariant is upheld.",
        "suggest": "因此，第二个不可变变量得到支持。",
        "translate": ""
    },
    {
        "source": "Safety: See above implementation for `ops::Range<A>`",
        "suggest": "安全性: 请参见上面的 `ops::Range<A>` 实现",
        "translate": ""
    },
    {
        "source": "Advancing an infinite iterator of a single element is a no-op.",
        "suggest": "推进单个元素的无限迭代器是不可行的。",
        "translate": ""
    },
    {
        "source": "The even numbers in the range of zero to nine.",
        "suggest": "介于 0 到 9 之间的偶数。",
        "translate": ""
    },
    {
        "source": "Current algorithms tries finding the first element for which the predicate evaluates to false, and the last element for which it evaluates to true and repeatedly swaps them.",
        "suggest": "当前的算法尝试找到谓词评估为 false 的第一个元素，以及它评估为 true 的最后一个元素，并反复交换它们。",
        "translate": ""
    },
    {
        "source": "Time Complexity: *O*(*N*)",
        "suggest": "时间复杂度: *O*(*N*)",
        "translate": ""
    },
    {
        "source": "This bound is rather strange, but means minimal breakage on nightly.",
        "suggest": "这个 bound 相当奇怪，但意味着 nightly 的破坏最小。",
        "translate": ""
    },
    {
        "source": "See #85115 for the issue tracking a holistic solution for this and try_map.",
        "suggest": "有关跟踪此问题和 try_map 的整体解决方案的问题，请参阅 #85115。",
        "translate": ""
    },
    {
        "source": "We're bootstrapping.",
        "suggest": "我们正在引导。",
        "translate": ""
    },
    {
        "source": "Note that [`f32`]/[`f64`] doesn't implement [`Ord`] due to NaN being incomparable.",
        "suggest": "请注意，由于 NaN 不可比较，[`f32`]/[`f64`] 没有实现 [`Ord`]。",
        "translate": ""
    },
    {
        "source": "You can work around this by using [`Iterator::reduce`]:",
        "suggest": "您可以使用 [`Iterator::reduce`] 解决此问题:",
        "translate": ""
    },
    {
        "source": "A type that upholds all invariants of [`Step`].",
        "suggest": "一种支持 [`Step`] 的所有不可变变量的类型。",
        "translate": ""
    },
    {
        "source": "The invariants of [`Step::steps_between()`] are a superset of the invariants of [`TrustedLen`].",
        "suggest": "[`Step::steps_between()`] 的不可变变量是 [`TrustedLen`] 的不可变变量的超集。",
        "translate": ""
    },
    {
        "source": "As such, [`TrustedLen`] is implemented for all range types with the same generic type argument.",
        "suggest": "因此，对于具有相同泛型参数的所有范围类型，都实现了 [`TrustedLen`]。",
        "translate": ""
    },
    {
        "source": "The implementation of [`Step`] for the given type must guarantee all invariants of all methods are upheld.",
        "suggest": "给定类型的 [`Step`] 的实现必须保证所有方法的所有不可变变量都得到维护。",
        "translate": ""
    },
    {
        "source": "See the [`Step`] trait's documentation for details.",
        "suggest": "有关详细信息，请参见 [`Step`] trait 的文档。",
        "translate": ""
    },
    {
        "source": "Consumers are free to rely on the invariants in unsafe code.",
        "suggest": "消费者可以自由地依赖不安全代码中的不可变变量。",
        "translate": ""
    },
    {
        "source": "allow using `core::` in intra-doc links",
        "suggest": "允许在文档内部链接中使用 `core::`",
        "translate": ""
    },
    {
        "source": "We don't export this through #[macro_export] for now, to avoid breakage.",
        "suggest": "我们暂时不通过 #[macro_export] 导出它，以避免损坏。",
        "translate": ""
    },
    {
        "source": "Unstable module containing the unstable `assert_matches` macro.",
        "suggest": "Unstable 模块包含不稳定的 `assert_matches` 宏。",
        "translate": ""
    },
    {
        "source": "Asserts that an expression matches any of the given patterns.",
        "suggest": "断言表达式匹配任何给定的模式。",
        "translate": ""
    },
    {
        "source": "On panic, this macro will print the value of the expression with its debug representation.",
        "suggest": "在 panic 时，这个宏将打印表达式的值及其调试表示。",
        "translate": ""
    },
    {
        "source": "Unlike [`assert_matches!`], `debug_assert_matches!` statements are only enabled in non optimized builds by default.",
        "suggest": "与 [`assert_matches!`] 不同，`debug_assert_matches!` 语句默认仅在非优化构建中启用。",
        "translate": ""
    },
    {
        "source": "An optimized build will not execute `debug_assert_matches!` statements unless `-C debug-assertions` is passed to the compiler.",
        "suggest": "除非将 `-C debug-assertions` 传递给编译器，否则优化的构建将不会执行 `debug_assert_matches!` 语句。",
        "translate": ""
    },
    {
        "source": "This makes `debug_assert_matches!` useful for checks that are too expensive to be present in a release build but may be helpful during development.",
        "suggest": "这使得 `debug_assert_matches!` 可用于在发布版本中出现的检查成本太高，但在开发过程中可能会有所帮助。",
        "translate": ""
    },
    {
        "source": "The result of expanding `debug_assert_matches!` is always type checked.",
        "suggest": "扩展 `debug_assert_matches!` 的结果总是经过类型检查。",
        "translate": ""
    },
    {
        "source": "This allows your code to type-check, which is useful if you are prototyping or implementing a trait that requires multiple methods which you don't plan to use all of.",
        "suggest": "这允许您的代码进行类型检查，如果您正在设计原型或实现需要多个您不打算使用所有方法的特征，这将非常有用。",
        "translate": ""
    },
    {
        "source": "For example, a variable of reference type must be aligned and non-null.",
        "suggest": "例如，引用类型的变量必须对齐且非空。",
        "translate": ""
    },
    {
        "source": "does not drop, so there are no double-frees And thus the conversion is safe",
        "suggest": "不丢弃就没有双重释放，因此转换是安全的",
        "translate": ""
    },
    {
        "source": "See [`from_bits`](Self::from_bits) for some discussion of the portability of this operation (there are almost no issues).",
        "suggest": "有关此操作的可移植性的一些讨论，请参见 [`from_bits`](Self::from_bits) (几乎没有问题)。",
        "translate": ""
    },
    {
        "source": "when [`checked_add`] would return `None`.",
        "suggest": "当 [`checked_add`] 返回 `None` 时。",
        "translate": ""
    },
    {
        "source": "when [`checked_sub`] would return `None`.",
        "suggest": "当 [`checked_sub`] 返回 `None` 时。",
        "translate": ""
    },
    {
        "source": "when [`checked_mul`] would return `None`.",
        "suggest": "当 [`checked_mul`] 返回 `None` 时。",
        "translate": ""
    },
    {
        "source": "Unchecked shift left.",
        "suggest": "未检查的左移。",
        "translate": ""
    },
    {
        "source": "Computes `self << rhs`, assuming that `rhs` is less than the number of bits in `self`.",
        "suggest": "计算 `self << rhs`，假设 `rhs` 小于 `self` 中的位数。",
        "translate": ""
    },
    {
        "source": "This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`, i.e.",
        "suggest": "如果 `rhs` 大于或等于 `self` 中的位数，则会导致未定义的行为，即",
        "translate": ""
    },
    {
        "source": "when [`checked_shl`] would return `None`.",
        "suggest": "当 [`checked_shl`] 返回 `None` 时。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `unchecked_shl`.",
        "suggest": "调用者必须遵守 `unchecked_shl` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Unchecked shift right.",
        "suggest": "未检查右移。",
        "translate": ""
    },
    {
        "source": "Computes `self >> rhs`, assuming that `rhs` is less than the number of bits in `self`.",
        "suggest": "计算 `self >> rhs`，假设 `rhs` 小于 `self` 中的位数。",
        "translate": ""
    },
    {
        "source": "when [`checked_shr`] would return `None`.",
        "suggest": "当 [`checked_shr`] 返回 `None` 时。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `unchecked_shr`.",
        "suggest": "调用者必须遵守 `unchecked_shr` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Returns the size of this integer type in bits.",
        "suggest": "以位为单位返回此整数类型的大小。",
        "translate": ""
    },
    {
        "source": "These are used only as part of implementing the iterator adapters.",
        "suggest": "这些仅用作实现迭代器适配器的一部分。",
        "translate": ""
    },
    {
        "source": "They have mediocre names and non-obvious semantics, so aren't currently on a path to potential stabilization.",
        "suggest": "它们具有普通的名称和不明显的语义，因此目前还没有走上潜在的稳定之路。",
        "translate": ""
    },
    {
        "source": "Converts from `&mut Bound<T>` to `Bound<&mut T>`.",
        "suggest": "从 `&mut Bound<T>` 转换为 `Bound<&mut T>`。",
        "translate": ""
    },
    {
        "source": "Maps a `Bound<T>` to a `Bound<U>` by applying a function to the contained value (including both `Included` and `Excluded`), returning a `Bound` of the same kind.",
        "suggest": "映射一个 `Bound` 通过将函数应用于包含的值 (包括 `Included` 和 `Excluded`)，返回相同类型的 `Bound`。",
        "translate": ""
    },
    {
        "source": "This no longer follows its RFC, but is only used in bootstrap.",
        "suggest": "这不再遵循它的 RFC，而仅用于引导程序。",
        "translate": ""
    },
    {
        "source": "Used to specify which residuals can be converted into which [`crate::ops::Try`] types.",
        "suggest": "用于指定哪些残差可以转换为哪些 [`crate::ops::Try`] 类型。",
        "translate": ""
    },
    {
        "source": "There's a special error message in the trait selection code for `From` in `?`, so this is not shown for result-in-result errors, and thus it can be phrased more strongly than `ControlFlow`'s.",
        "suggest": "在 `?` 中 `From` 的 trait 选择代码中有一条特殊的错误消息，因此对于结果中的错误没有显示，因此它可以比 `ControlFlow` 更强烈地表达。",
        "translate": ""
    },
    {
        "source": "always works, as there's only one possible residual, so this can also be phrased strongly.",
        "suggest": "总是有效，因为只有一种可能的残差，所以这也可以用强烈的措辞表达。",
        "translate": ""
    },
    {
        "source": "is not a `ControlFlow`, as that case was matched previously",
        "suggest": "不是 `ControlFlow`，正如前面匹配的那样",
        "translate": ""
    },
    {
        "source": "This is called the \"null pointer optimization\" or NPO.",
        "suggest": "这称为 \"空指针优化\" 或 NPO。",
        "translate": ""
    },
    {
        "source": "Internal function for `assert_match!`",
        "suggest": "`assert_match!` 的内联函数",
        "translate": ""
    },
    {
        "source": "Use the Display implementation to display the pattern.",
        "suggest": "使用 Display 实现来显示模式。",
        "translate": ""
    },
    {
        "source": "Non-generic version of the above functions, to avoid code bloat.",
        "suggest": "上述函数的非泛型版本，以避免代码膨胀。",
        "translate": ""
    },
    {
        "source": "When calling this method, you have to ensure that *either* the pointer is null *or* all of the following is true:",
        "suggest": "调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::",
        "translate": ""
    },
    {
        "source": "Take the address of a 32-bit integer which is not aligned.",
        "suggest": "取一个未对齐的 32 位整数的地址。",
        "translate": ""
    },
    {
        "source": "In contrast to `&packed.unaligned as *const _`, this has no undefined behavior.",
        "suggest": "与 `&packed.unaligned as *const _` 相比，它没有未定义的行为。",
        "translate": ""
    },
    {
        "source": "In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.",
        "suggest": "与 `&packed.unaligned as *mut _` 相比，它没有未定义的行为。",
        "translate": ""
    },
    {
        "source": "Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.",
        "suggest": "请注意，即使 `T` 的大小为 `0`，指针也必须非空且正确对齐。",
        "translate": ""
    },
    {
        "source": "Note that even if `T` has size `0`, the pointers must be non-null and properly aligned.",
        "suggest": "请注意，即使 `T` 的大小为 `0`，指针也必须非空且正确对齐。",
        "translate": ""
    },
    {
        "source": "Note that even if `T` has size `0`, the pointer must be non-null.",
        "suggest": "请注意，即使 `T` 的大小为 `0`，指针也必须非空。",
        "translate": ""
    },
    {
        "source": "Instead you must use the [`ptr::addr_of!`](addr_of) macro to create the pointer.",
        "suggest": "相反，您必须使用 [`ptr::addr_of!`](addr_of) 宏来创建指针。",
        "translate": ""
    },
    {
        "source": "You may use that returned pointer together with this function.",
        "suggest": "您可以将返回的指针与此函数一起使用。",
        "translate": ""
    },
    {
        "source": "Instead you must use the [`ptr::addr_of_mut!`](addr_of_mut) macro to create the pointer.",
        "suggest": "相反，您必须使用 [`ptr::addr_of_mut!`](addr_of_mut) 宏来创建指针。",
        "translate": ""
    },
    {
        "source": "An example of how to do it and how this relates to `write_unaligned` is:",
        "suggest": "如何做到这一点以及这与 `write_unaligned` 的关系的一个例子是:",
        "translate": ""
    },
    {
        "source": "Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however (as can be seen in the `assert_eq!` above).",
        "suggest": "然而，直接使用例如 `packed.unaligned` 访问未对齐的字段是安全的 (如上面的 `assert_eq!` 所示)。",
        "translate": ""
    },
    {
        "source": "In particular, `addr_of!(*ptr::null())` is Undefined Behavior because it dereferences a null pointer.",
        "suggest": "特别是，`addr_of!(*ptr::null())` 是未定义行为，因为它解引用空指针。",
        "translate": ""
    },
    {
        "source": "In particular, `addr_of_mut!(*ptr::null_mut())` is Undefined Behavior because it dereferences a null pointer.",
        "suggest": "特别是，`addr_of_mut!(*ptr::null_mut())` 是未定义行为，因为它解引用空指针。",
        "translate": ""
    },
    {
        "source": "As a consequence, the resulting pointer cannot be null.",
        "suggest": "因此，得到的指针不能为空。",
        "translate": ""
    },
    {
        "source": "If you do not have a `&T`, but some other value that you can compare with one (for example, `String` implements `PartialEq<str>`), you can use `iter().any`:",
        "suggest": "如果您没有 `&T`，但有其他一些可以与之比较的值 (例如，`String` 实现 `PartialEq<str>`)，则可以使用 `iter().any`:",
        "translate": ""
    },
    {
        "source": "The index is chosen deterministically, but is subject to change in future versions of Rust.",
        "suggest": "索引的选择是确定的，但在 Rust 的未来版本中可能会发生变化。",
        "translate": ""
    },
    {
        "source": "Derive both `src_ptr` and `dest_ptr` from the same loan",
        "suggest": "从同一个 loan 派生 `src_ptr` 和 `dest_ptr`",
        "translate": ""
    },
    {
        "source": "0 is always ok.",
        "suggest": "0 总是可以的。",
        "translate": ""
    },
    {
        "source": "Note that optimizing `self.get(..index)` relies on this.",
        "suggest": "请注意，优化 `self.get(..index)` 依赖于此。",
        "translate": ""
    },
    {
        "source": "For `None` we have two options:",
        "suggest": "对于 `None`，我们有两个选择:",
        "translate": ""
    },
    {
        "source": "index == self.len() Empty strings are valid, so return true",
        "suggest": "index == self.len() 空字符串是有效的，因此返回 true",
        "translate": ""
    },
    {
        "source": "index > self.len() In this case return false",
        "suggest": "index > self.len() 在这种情况下返回 false",
        "translate": ""
    },
    {
        "source": "The check is placed exactly here, because it improves generated code on higher opt-levels.",
        "suggest": "检查正好放在这里，因为它改进了更高 opt-level 上生成的代码。",
        "translate": ""
    },
    {
        "source": "See PR #84751 for more details.",
        "suggest": "有关更多详细信息，请参见 PR #84751。",
        "translate": ""
    },
    {
        "source": "Needs the V2 trait",
        "suggest": "需要 V2 trait",
        "translate": ""
    },
    {
        "source": "A null payload here means that we got here from the catch (...) of __rust_try.",
        "suggest": "这里的空负载意味着我们从 __rust_try 的 catch (...) 到达这里。",
        "translate": ""
    },
    {
        "source": "We have the array method separate from extending from a slice.",
        "suggest": "我们将数组方法与从切片扩展中分开。",
        "translate": ""
    },
    {
        "source": "This is because in the case of small arrays, codegen can be more efficient (avoiding a memmove call).",
        "suggest": "这是因为在小数组的情况下，codegen 可以更有效 (避免 memmove 调用)。",
        "translate": ""
    },
    {
        "source": "With extend_from_slice, LLVM at least currently is not able to make that optimization.",
        "suggest": "使用 extend_from_slice，LLVM 至少目前无法进行这种优化。",
        "translate": ""
    },
    {
        "source": "The code here is taken from Vec::push, and we know that reserve() will panic if we're exceeding isize::MAX bytes and so there's no need to check for overflow.",
        "suggest": "这里的代码取自 Vec::push，我们知道如果超过 isize::MAX 字节，reserve() 将 panic，所以没有必要检查溢出。",
        "translate": ""
    },
    {
        "source": "Used by the implementation of `Span::quote`",
        "suggest": "由 `Span::quote` 的实现使用",
        "translate": ""
    },
    {
        "source": "Parse a single literal from its stringified representation.",
        "suggest": "从字符串化表示中解析单个字面量。",
        "translate": ""
    },
    {
        "source": "In order to parse successfully, the input string must not contain anything but the literal token.",
        "suggest": "为了成功解析，输入字符串不能包含除字面量 token 之外的任何内容。",
        "translate": ""
    },
    {
        "source": "Specifically, it must not contain whitespace or comments in addition to the literal.",
        "suggest": "具体来说，它不能包含除字面量之外的空格或注释。",
        "translate": ""
    },
    {
        "source": "The resulting literal token will have a `Span::call_site()` span.",
        "suggest": "生成的字面量 token 将具有 `Span::call_site()` span。",
        "translate": ""
    },
    {
        "source": "The C side must **not** modify the length of the string (by writing a `null` somewhere inside the string or removing the final one) before it makes it back into Rust using [`CString::from_raw`].",
        "suggest": "C 端必须**不**修改字符串的长度 (通过在字符串内某处写入 `null` 或删除最后一个)，然后使用 [`CString::from_raw`] 将其返回到 Rust。",
        "translate": ""
    },
    {
        "source": "The buffer.",
        "suggest": "缓冲区。",
        "translate": ""
    },
    {
        "source": "Avoid using this like a normal `Vec` in common code paths.",
        "suggest": "避免在公共代码路径中像普通 `Vec` 一样使用它。",
        "translate": ""
    },
    {
        "source": "That is, don't use `buf.push`, `buf.extend_from_slice`, or any other methods that require bounds checking or the like.",
        "suggest": "也就是说，不要使用 `buf.push`、`buf.extend_from_slice` 或任何其他需要边界检查等的方法。",
        "translate": ""
    },
    {
        "source": "This makes an enormous difference to performance (we may want to stop using a `Vec` entirely).",
        "suggest": "这对性能产生了巨大的影响 (我们可能希望完全停止使用 `Vec`)。",
        "translate": ""
    },
    {
        "source": "`amt_to_buffer` is <= buffer's spare capacity by construction.",
        "suggest": "`amt_to_buffer` 是 <= 缓冲区的构造备用容量。",
        "translate": ""
    },
    {
        "source": "Ensure this function does not get inlined into `write`, so that it remains inlineable and its common path remains as short as possible.",
        "suggest": "确保这个函数不会被内联到 `write` 中，这样它就可以保持内联并且它的公共路径尽可能地短。",
        "translate": ""
    },
    {
        "source": "If this function ends up being called frequently relative to `write`, it's likely a sign that the client is using an improperly sized buffer or their write patterns are somewhat pathological.",
        "suggest": "如果这个函数最终相对于 `write` 被频繁调用，则可能表明客户端使用了大小不正确的缓冲区或他们的写入模式有点病态。",
        "translate": ""
    },
    {
        "source": "Why not len > capacity?",
        "suggest": "为什么不是 len > capacity?",
        "translate": ""
    },
    {
        "source": "To avoid a needless trip through the buffer when the input exactly fills it.",
        "suggest": "以避免在输入正好填满缓冲区时发生不必要的遍历。",
        "translate": ""
    },
    {
        "source": "We'd just need to flush it to the underlying writer anyway.",
        "suggest": "无论如何，我们只需要将其刷新到底层 writer 即可。",
        "translate": ""
    },
    {
        "source": "Write to the buffer.",
        "suggest": "写入缓冲区。",
        "translate": ""
    },
    {
        "source": "In this case, we write to the buffer even if it fills it exactly.",
        "suggest": "在这种情况下，即使缓冲区完全填满，我们也会写入缓冲区。",
        "translate": ""
    },
    {
        "source": "Doing otherwise would mean flushing the buffer, then writing this input to the inner writer, which in many cases would be a worse strategy.",
        "suggest": "否则将意味着刷新缓冲区，然后将此输入写入内部 writer，这在许多情况下将是更糟糕的策略。",
        "translate": ""
    },
    {
        "source": "There was either enough spare capacity already, or there wasn't and we flushed the buffer to ensure that there is.",
        "suggest": "要么已经有足够的空闲容量，要么没有，我们刷新了缓冲区以确保有。",
        "translate": ""
    },
    {
        "source": "In the latter case, we know that there is because flushing ensured that our entire buffer is spare capacity, and we entered this block because the input buffer length is less than that capacity.",
        "suggest": "在后一种情况下，我们知道是因为 flush 确保了我们整个缓冲区都是空闲容量，我们进入这个块是因为输入缓冲区长度小于那个容量。",
        "translate": ""
    },
    {
        "source": "In either case, it's safe to write the input buffer to our buffer.",
        "suggest": "无论哪种情况，将输入缓冲区写入我们的缓冲区都是安全的。",
        "translate": ""
    },
    {
        "source": "Ensure this function does not get inlined into `write_all`, so that it remains inlineable and its common path remains as short as possible.",
        "suggest": "确保这个函数不会被内联到 `write_all` 中，这样它就可以保持内联并且它的公共路径尽可能地短。",
        "translate": ""
    },
    {
        "source": "If this function ends up being called frequently relative to `write_all`, it's likely a sign that the client is using an improperly sized buffer or their write patterns are somewhat pathological.",
        "suggest": "如果这个函数最终相对于 `write_all` 被频繁调用，则可能表明客户端使用了大小不正确的缓冲区或他们的写入模式有点病态。",
        "translate": ""
    },
    {
        "source": "Requires `buf.len() <= self.buf.capacity() - self.buf.len()`, i.e., that input buffer length is less than or equal to spare capacity.",
        "suggest": "需要 `buf.len() <= self.buf.capacity() - self.buf.len()`，即输入缓冲区长度小于或等于备用容量。",
        "translate": ""
    },
    {
        "source": "Use < instead of <= to avoid a needless trip through the buffer in some cases.",
        "suggest": "使用 < 而不是 <= 以避免在某些情况下通过缓冲区进行不必要的缓冲行程。",
        "translate": ""
    },
    {
        "source": "See `write_cold` for details.",
        "suggest": "有关详细信息，请参见 `write_cold`。",
        "translate": ""
    },
    {
        "source": "safe by above conditional.",
        "suggest": "以上条件安全。",
        "translate": ""
    },
    {
        "source": "See `write_all_cold` for details.",
        "suggest": "有关详细信息，请参见 `write_all_cold`。",
        "translate": ""
    },
    {
        "source": "Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied to `write` and `write_all`.",
        "suggest": "考虑应用已应用于 `write` 和 `write_all` 的 `#[inline]`/`#[inline(never)]` 优化。",
        "translate": ""
    },
    {
        "source": "The performance benefits can be significant.",
        "suggest": "性能优势可能非常显着。",
        "translate": ""
    },
    {
        "source": "See #79930.",
        "suggest": "请参见 #79930。",
        "translate": ""
    },
    {
        "source": "We have to handle the possibility that the total length of the buffers overflows `usize` (even though this can only happen if multiple `IoSlice`s reference the same underlying buffer, as otherwise the buffers wouldn't fit in memory).",
        "suggest": "我们必须处理缓冲区总长度溢出 `usize` 的可能性 (即使只有在多个 IoSlice 引用同一个底层缓冲区时才会发生这种情况，否则缓冲区将无法放入内存中)。",
        "translate": ""
    },
    {
        "source": "If the computation overflows, then surely the input cannot fit in our buffer, so we forward to the inner writer's `write_vectored` method to let it handle it appropriately.",
        "suggest": "如果计算溢出，那么输入肯定无法放入我们的缓冲区，因此我们转发到内部 writer 的 `write_vectored` 方法让它适当地处理它。",
        "translate": ""
    },
    {
        "source": "Flush if the total length of the input exceeds our buffer's spare capacity.",
        "suggest": "如果输入的总长度超过缓冲区的空闲容量，则刷新。",
        "translate": ""
    },
    {
        "source": "If we would have overflowed, this condition also holds, and we need to flush.",
        "suggest": "如果我们已经溢出了，这种情况也成立，我们需要刷新。",
        "translate": ""
    },
    {
        "source": "Forward to our inner writer if the total length of the input is greater than or equal to our buffer capacity.",
        "suggest": "如果输入的总长度大于或等于我们的缓冲区容量，则转发到我们的内部 writer。",
        "translate": ""
    },
    {
        "source": "If we would have overflowed, this condition also holds, and we punt to the inner writer.",
        "suggest": "如果我们会溢出，则此条件也成立，我们将推送到内部 writer。",
        "translate": ""
    },
    {
        "source": "implies that we did not saturate.",
        "suggest": "意味着我们没有饱和。",
        "translate": ""
    },
    {
        "source": "We checked whether or not the spare capacity was large enough above.",
        "suggest": "我们在上面检查了备用容量是否足够大。",
        "translate": ""
    },
    {
        "source": "If it was, then we're safe already.",
        "suggest": "如果是这样，那么我们已经安全了。",
        "translate": ""
    },
    {
        "source": "If it wasn't, we flushed, making sufficient room for any input <= the buffer size, which includes this input.",
        "suggest": "如果不是，我们刷新，为任何输入 <= 缓冲区大小 (包括此输入) 留出足够的空间。",
        "translate": ""
    },
    {
        "source": "This cannot overflow `usize`.",
        "suggest": "这不能溢出 `usize`。",
        "translate": ""
    },
    {
        "source": "If we are here, we've written all of the bytes so far to our buffer, and we've ensured that we never exceed the buffer's capacity.",
        "suggest": "如果我们在这里，到目前为止我们已经将所有字节写入我们的缓冲区，并且我们确保我们永远不会超过缓冲区的容量。",
        "translate": ""
    },
    {
        "source": "Therefore, `total_written` <= `self.buf.capacity()` <= `usize::MAX`.",
        "suggest": "因此，`total_written` <= `self.buf.capacity()` <= `usize::MAX`。",
        "translate": ""
    },
    {
        "source": "An operation could not be completed, because it failed to allocate enough memory.",
        "suggest": "操作无法完成，因为它未能分配足够的内存。",
        "translate": ""
    },
    {
        "source": "As an example, on Linux, this method will call the `recv` syscall for a [`TcpStream`], where returning zero indicates the connection was shut down correctly.",
        "suggest": "例如，在 Linux 上，此方法将调用 [`TcpStream`] 的 `recv` 系统调用，其中返回零表示连接已正确关闭。",
        "translate": ""
    },
    {
        "source": "While for [`File`], it is possible to reach the end of file and get zero as result, but if more data is appended to the file, future calls to `read` will return more data.",
        "suggest": "而对于 [`File`]，有可能到达文件末尾并得到零结果，但如果将更多数据附加到文件中，future 对 `read` 的调用将返回更多数据。",
        "translate": ""
    },
    {
        "source": "Seeking can fail, for example because it might involve flushing a buffer.",
        "suggest": "查找可能会失败，例如因为它可能涉及刷新缓冲区。",
        "translate": ""
    },
    {
        "source": "Rewind to the beginning of a stream.",
        "suggest": "返回到流的开头。",
        "translate": ""
    },
    {
        "source": "This is a convenience method, equivalent to `seek(SeekFrom::Start(0))`.",
        "suggest": "这是一个方便的方法，相当于 `seek(SeekFrom::Start(0))`。",
        "translate": ""
    },
    {
        "source": "Rewinding can fail, for example because it might involve flushing a buffer.",
        "suggest": "返回可能会失败，例如因为它可能涉及刷新缓冲区。",
        "translate": ""
    },
    {
        "source": "data is no longer available, it is owned by the closure",
        "suggest": "数据不再可用，它由闭包拥有",
        "translate": ""
    },
    {
        "source": "data was moved to the spawned thread, so we cannot use it here",
        "suggest": "数据被移动到衍生线程，所以我们不能在这里使用它",
        "translate": ""
    },
    {
        "source": "converts any variables captured by reference or mutable reference to variables captured by value.",
        "suggest": "将任何通过引用捕获的变量转换为通过引用捕获的变量。",
        "translate": ""
    },
    {
        "source": "Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods (other than in tests and similar).",
        "suggest": "请注意，宏的目的是作为调试工具，因此您应该避免在版本控制中长时间使用它 (测试和类似的情况除外)。",
        "translate": ""
    },
    {
        "source": "Debug output from production code is better done with other facilities such as the [`debug!`] macro from the [`log`] crate.",
        "suggest": "使用其他工具 (例如 [`log`] crate 的 [`debug!`] 宏) 可以更好地完成生产代码的调试输出。",
        "translate": ""
    },
    {
        "source": "The unspecified and loopback addresses are unicast.",
        "suggest": "未指定地址和回环地址是单播的。",
        "translate": ""
    },
    {
        "source": "Any address that is not a multicast address (`ff00::/8`) is unicast.",
        "suggest": "任何不是多播地址 (`ff00::/8`) 的地址都是单播的。",
        "translate": ""
    },
    {
        "source": "The loopback address (`::1`) does not actually have link-local scope.",
        "suggest": "回环地址 (`::1`) 实际上并没有链接本地作用域。",
        "translate": ""
    },
    {
        "source": "Only addresses in `fe80::/10` have link-local scope.",
        "suggest": "只有 `fe80::/10` 中的地址具有本地链接作用域。",
        "translate": ""
    },
    {
        "source": "Addresses outside the stricter `fe80::/64` also have link-local scope.",
        "suggest": "更严格的 `fe80::/64` 之外的地址也具有链接本地作用域。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).",
        "suggest": "为特殊的 'unspecified' 地址 (`0.0.0.0`) 返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is a loopback address (`127.0.0.0/8`).",
        "suggest": "如果这是回环地址 (`127.0.0.0/8`)，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if the address is link-local (`169.254.0.0/16`).",
        "suggest": "如果地址是本地链接 (`169.254.0.0/16`)，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "the unspecified address (see [`Ipv4Addr::is_unspecified()`]), and the whole `0.0.0.0/8` block",
        "suggest": "未指定的地址 (请参见 [`Ipv4Addr::is_unspecified()`])，以及整个 `0.0.0.0/8` 块",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is a multicast address (`224.0.0.0/4`).",
        "suggest": "如果这是多播地址 (`224.0.0.0/4`)，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "Multicast addresses have a most significant octet between `224` and `239`, and is defined by [IETF RFC 5771].",
        "suggest": "多播地址在 `224` 和 `239` 之间有一个最重要的八位字节，由 [IETF RFC 5771] 定义。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is a broadcast address (`255.255.255.255`).",
        "suggest": "如果这是广播地址 (`255.255.255.255`)，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "A broadcast address has all octets set to `255` as defined in [IETF RFC 919].",
        "suggest": "广播地址的所有八位字节都设置为 `255`，如 [IETF RFC 919] 中所定义。",
        "translate": ""
    },
    {
        "source": "becomes `::a.b.c.d`",
        "suggest": "变成 `::a.b.c.d`",
        "translate": ""
    },
    {
        "source": "becomes `::ffff:a.b.c.d`",
        "suggest": "变成 `::ffff:a.b.c.d`",
        "translate": ""
    },
    {
        "source": "Returns [`true`] for the special 'unspecified' address (`::`).",
        "suggest": "为特殊的 'unspecified' 地址 (`::`) 返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is a unicast address, as defined by [IETF RFC 4291].",
        "suggest": "如果这是 [IETF RFC 4291] 定义的单播地址，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "Any address that is not a [multicast address] (`ff00::/8`) is unicast.",
        "suggest": "任何不是 [multicast address] (`ff00::/8`) 的地址都是单播的。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the address is a unicast address with link-local scope, as defined in [RFC 4291].",
        "suggest": "如果地址是具有链接本地作用域的单播地址，则返回 `true`，如 [RFC 4291] 中所定义。",
        "translate": ""
    },
    {
        "source": "A unicast address has link-local scope if it has the prefix `fe80::/10`, as per [RFC 4291 section 2.4].",
        "suggest": "如果单播地址具有前缀 `fe80::/10`，则它具有链路本地作用域，如 [RFC 4291 section 2.4]。",
        "translate": ""
    },
    {
        "source": "Note that this encompasses more addresses than those defined in [RFC 4291 section 2.5.6], which describes \"Link-Local IPv6 Unicast Addresses\" as having the following stricter format:",
        "suggest": "请注意，这包含比 [RFC 4291 section 2.5.6] 中定义的地址更多的地址，[RFC 4291 section 2.5.6] 将 \"Link-Local IPv6 Unicast Addresses\" 描述为具有以下更严格的格式:",
        "translate": ""
    },
    {
        "source": "So while currently the only addresses with link-local scope an application will encounter are all in `fe80::/64`, this might change in the future with the publication of new standards.",
        "suggest": "因此，虽然目前应用程序将遇到的唯一具有本地链接作用域的地址都在 `fe80::/64` 中，但随着新标准的发布，这可能会在 future 中发生变化。",
        "translate": ""
    },
    {
        "source": "More addresses in `fe80::/10` could be allocated, and those addresses will have link-local scope.",
        "suggest": "`fe80::/10` 中可以分配更多的地址，这些地址将具有本地链接作用域。",
        "translate": ""
    },
    {
        "source": "Also note that while [RFC 4291 section 2.5.3] mentions about the [loopback address] (`::1`) that \"it is treated as having Link-Local scope\", this does not mean that the loopback address actually has link-local scope and this method will return `false` on it.",
        "suggest": "另请注意，虽然 [RFC 4291 section 2.5.3] 提到 \"它被视为具有 Link-Local 作用域\" 的 [loopback address] (`::1`)，但这并不意味着回环地址实际上具有链接本地作用域，并且此方法将在其上返回 `false`。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is a deprecated unicast site-local address (`fec0::/10`).",
        "suggest": "如果这是已弃用的单播站点本地地址 (`fec0::/10`)，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "As per [RFC 3879], the whole `fec0::/10` prefix is deprecated.",
        "suggest": "根据 [RFC 3879]，不推荐使用整个 `fec0::/10` 前缀。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is a multicast address (`ff00::/8`).",
        "suggest": "如果这是多播地址 (`ff00::/8`)，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "and `::ffff:a.b.c.d` become `a.b.c.d`",
        "suggest": "`::ffff:a.b.c.d` 变成 `a.b.c.d`",
        "translate": ""
    },
    {
        "source": "See [Issue #34202] for more details.",
        "suggest": "有关更多详细信息，请参见 [Issue #34202]。",
        "translate": ""
    },
    {
        "source": "rbx is reserved by LLVM",
        "suggest": "rbx 由 LLVM 保留",
        "translate": ""
    },
    {
        "source": "The code below could be written clearer using `cfg_if!`.",
        "suggest": "下面的代码可以使用 `cfg_if!` 写得更清楚。",
        "translate": ""
    },
    {
        "source": "However, the items below are publicly exported by `std` and external tools can have trouble analysing them because of the use of a macro that is not vendored by Rust and included in the toolchain.",
        "suggest": "但是，下面的项是由 `std` 公开导出的，并且由于使用了不是由 Rust 提供并包含在工具链中的宏，因此外部工具可能无法分析它们。",
        "translate": ""
    },
    {
        "source": "When documenting std we want to show the `unix`, `windows`, `linux` and `wasi` modules as these are the \"main modules\" that are used across platforms, so these modules are enabled when `cfg(doc)` is set.",
        "suggest": "在记录 std 时，我们希望显示 `unix`、`windows`、`linux` 和 `wasi` 模块，因为它们是跨平台使用的 \"main modules\"，因此在设置 `cfg(doc)` 时启用这些模块。",
        "translate": ""
    },
    {
        "source": "On certain platforms right now the \"main modules\" modules that are documented don't compile (missing things in `libc` which is empty), so just omit them with an empty module.",
        "suggest": "现在在某些平台上，记录的 \"main modules\" 模块无法编译 (`libc` 中缺少空的内容)，因此只需使用空模块省略它们。",
        "translate": ""
    },
    {
        "source": "If we're not documenting std then we only expose modules appropriate for the current platform.",
        "suggest": "如果我们没有记录 std，那么我们只公开适合当前平台的模块。",
        "translate": ""
    },
    {
        "source": "requires that the control pointer is null when the len is 0.",
        "suggest": "当 len 为 0 时，要求控制指针为空。",
        "translate": ""
    },
    {
        "source": "Panicking in the closure is safe only if all the format arguments for the panic message can be safely formatted;",
        "suggest": "只有当 panic 消息的所有格式参数都可以安全格式化时，闭包中的 panic 才是安全的;",
        "translate": ""
    },
    {
        "source": "this is because although `Command` calls [`std::panic::always_abort`](crate::panic::always_abort) before calling the pre_exec hook, panic will still try to format the panic message.",
        "suggest": "这是因为尽管 `Command` 在调用 pre_exec hook 之前调用了 [`std::panic::always_abort`](crate::panic::always_abort)，但 panic 仍会尝试格式化 panic 消息。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to [`process::ExitStatus`] and [`ExitStatusError`](process::ExitStatusError).",
        "suggest": "[`process::ExitStatus`] 和 [`ExitStatusError`](process::ExitStatusError) 的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "It represents **any wait status** as returned by one of the `wait` family of system calls.",
        "suggest": "它表示由 `wait` 系列系统调用之一返回的**任何等待状态**。",
        "translate": ""
    },
    {
        "source": "A Unix wait status (a Rust `ExitStatus`) can represent a Unix exit status, but can also represent other kinds of process event.",
        "suggest": "Unix 等待状态 (Rust `ExitStatus`) 可以代表 Unix 退出状态，但也可以代表其他类型的进程事件。",
        "translate": ""
    },
    {
        "source": "Creates a new `ExitStatus` or `ExitStatusError` from the raw underlying integer status value from `wait`",
        "suggest": "从 `wait` 的原始底层整数状态值创建一个新的 `ExitStatus` 或 `ExitStatusError`",
        "translate": ""
    },
    {
        "source": "Panics on an attempt to make an `ExitStatusError` from a wait status of `0`.",
        "suggest": "尝试从 `0` 的等待状态生成 `ExitStatusError` 时出现 panic。",
        "translate": ""
    },
    {
        "source": "Making an `ExitStatus` always succeds and never panics.",
        "suggest": "使 `ExitStatus` 总是成功，并且永远不会 panics。",
        "translate": ""
    },
    {
        "source": "Platform-specific extensions to `std` for the WebAssembly System Interface (WASI).",
        "suggest": "用于 WebAssembly 系统接口 (WASI) 的 `std` 的平台特定扩展。",
        "translate": ""
    },
    {
        "source": "We will have aborted already, due to the panic.",
        "suggest": "由于 panic，我们已经中止了。",
        "translate": ""
    },
    {
        "source": "Make all future panics abort directly without running the panic hook or unwinding.",
        "suggest": "使所有 future panics 直接终止而不运行 panic hook 或展开。",
        "translate": ""
    },
    {
        "source": "There is no way to undo this;",
        "suggest": "没有办法撤销这个;",
        "translate": ""
    },
    {
        "source": "the effect lasts until the process exits or execs (or the equivalent).",
        "suggest": "效果持续到进程退出或执行 (或等效)。",
        "translate": ""
    },
    {
        "source": "Use after fork",
        "suggest": "fork 后使用",
        "translate": ""
    },
    {
        "source": "This function is particularly useful for calling after `libc::fork`.",
        "suggest": "这个函数在 `libc::fork` 之后调用特别有用。",
        "translate": ""
    },
    {
        "source": "After `fork`, in a multithreaded program it is (on many platforms) not safe to call the allocator.",
        "suggest": "在 `fork` 之后，在多线程程序中 (在许多平台上) 调用分配器是不安全的。",
        "translate": ""
    },
    {
        "source": "It is also generally highly undesirable for an unwind to unwind past the `fork`, because that results in the unwind propagating to code that was only ever expecting to run in the parent.",
        "suggest": "`fork` 之后的 unwind 到 unwind 通常也是非常不可取的，因为这会导致 unwind 传播到只希望在父级中运行的代码。",
        "translate": ""
    },
    {
        "source": "helps avoid both of these.",
        "suggest": "有助于避免这两种情况。",
        "translate": ""
    },
    {
        "source": "It directly avoids any further unwinding, and if there is a panic, the abort will occur without allocating provided that the arguments to panic can be formatted without allocating.",
        "suggest": "它直接避免了任何进一步的展开，如果存在 panic，则无需分配即可终止终止，前提是 panic 的参数可以在不分配的情况下进行格式化。",
        "translate": ""
    },
    {
        "source": "Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG) records whether panic::always_abort() has been called.",
        "suggest": "此外，GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG) 的最高位记录 panic::always_abort () 是否已被调用。",
        "translate": ""
    },
    {
        "source": "This can only be set, never cleared.",
        "suggest": "这只能设置，永远不会清除。",
        "translate": ""
    },
    {
        "source": "This could be viewed as a struct containing a single bit and an n-1-bit value, but if we wrote it like that it would be more than a single word, and even a newtype around usize would be clumsy because we need atomics.",
        "suggest": "这可以看作是一个包含一个位和一个 n-1 位值的结构体，但是如果我们这样写它就不仅仅是一个单词，甚至一个围绕 usize 的 newtype 也会很笨拙，因为我们需要原子.",
        "translate": ""
    },
    {
        "source": "But we use such a tuple for the return type of increase().",
        "suggest": "但是我们使用这样一个元组作为 increase() 的返回类型。",
        "translate": ""
    },
    {
        "source": "Stealing a bit is fine because it just amounts to assuming that each panicking thread consumes at least 2 bytes of address space.",
        "suggest": "窃取一点是可以的，因为它只是假设每个 panicking 线程至少消耗 2 字节的地址空间。",
        "translate": ""
    },
    {
        "source": "Disregards ALWAYS_ABORT_FLAG",
        "suggest": "忽略 ALWAYS_ABORT_FLAG",
        "translate": ""
    },
    {
        "source": "Don't try to print the message in this case",
        "suggest": "在这种情况下不要尝试打印消息",
        "translate": ""
    },
    {
        "source": "perhaps that is causing the recursive panics.",
        "suggest": "也许这导致了递归的 panics。",
        "translate": ""
    },
    {
        "source": "Unfortunately, this does not print a backtrace, because creating a `Backtrace` will allocate, which we must to avoid here.",
        "suggest": "不幸的是，这不会打印回溯，因为创建 `Backtrace` 将分配，我们必须在这里避免。",
        "translate": ""
    },
    {
        "source": "for most Windows prefixes, it may have a \"logical\" root separator for the purposes of normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.",
        "suggest": "对于大多数 Windows 前缀，为了规范化的目的，它可能有一个 \"logical\" 根分隔符，例如，\\\\server\\share == \\\\server\\share\\。",
        "translate": ""
    },
    {
        "source": "Creates a boxed [`Path`] from a reference.",
        "suggest": "从引用创建一个 boxed [`Path`]。",
        "translate": ""
    },
    {
        "source": "This will allocate and clone `path` to it.",
        "suggest": "这将为它分配和克隆 `path`。",
        "translate": ""
    },
    {
        "source": "Creates a boxed [`Path`] from a clone-on-write pointer.",
        "suggest": "从写时克隆指针创建一个 boxed [`Path`]。",
        "translate": ""
    },
    {
        "source": "Converting from a `Cow::Owned` does not clone or allocate.",
        "suggest": "从 `Cow::Owned` 转换不会克隆或分配。",
        "translate": ""
    },
    {
        "source": "Converts a borrowed `OsStr` to a `PathBuf`.",
        "suggest": "将借用的 `OsStr` 转换为 `PathBuf`。",
        "translate": ""
    },
    {
        "source": "Allocates a [`PathBuf`] and copies the data into it.",
        "suggest": "分配一个 [`PathBuf`] 并将数据复制到其中。",
        "translate": ""
    },
    {
        "source": "Creates a clone-on-write pointer from a reference to [`Path`].",
        "suggest": "创建一个从引用到 [`Path`] 的写时克隆指针。",
        "translate": ""
    },
    {
        "source": "This conversion does not clone or allocate.",
        "suggest": "此转换不会克隆或分配。",
        "translate": ""
    },
    {
        "source": "Creates a clone-on-write pointer from an owned instance of [`PathBuf`].",
        "suggest": "从 [`PathBuf`] 的拥有实例创建一个写时克隆指针。",
        "translate": ""
    },
    {
        "source": "Creates a clone-on-write pointer from a reference to [`PathBuf`].",
        "suggest": "创建一个从引用到 [`PathBuf`] 的写时克隆指针。",
        "translate": ""
    },
    {
        "source": "Converts a clone-on-write pointer to an owned path.",
        "suggest": "将写时克隆指针转换为拥有所有权的路径。",
        "translate": ""
    },
    {
        "source": "If you cannot access the metadata of the file, e.g.",
        "suggest": "如果您无法访问文件的元数据，例如",
        "translate": ""
    },
    {
        "source": "because of a permission error or broken symbolic links, this will return `false`.",
        "suggest": "由于权限错误或损坏的符号链接，这将返回 `false`。",
        "translate": ""
    },
    {
        "source": "If you cannot access the metadata of the file, e.g. because of a permission error or broken symbolic links, this will return `false`.",
        "suggest": "如果您无法访问文件的元数据，例如由于权限错误或损坏的符号链接，这将返回 `false`。",
        "translate": ""
    },
    {
        "source": "not allowed with coercion",
        "suggest": "不允许强制",
        "translate": ""
    },
    {
        "source": "Create it using `ptr::addr_of!`",
        "suggest": "使用 `ptr::addr_of!` 创建它",
        "translate": ""
    },
    {
        "source": "Instead of coercing a reference to a raw pointer, you can use the macros [`ptr::addr_of!`] (for `*const T`) and [`ptr::addr_of_mut!`] (for `*mut T`).",
        "suggest": "您可以使用宏 [`ptr::addr_of!`] (对于 `*const T`) 和 [`ptr::addr_of_mut!`] (对于 `*mut T`)，而不是强制引用到裸针疗法。",
        "translate": ""
    },
    {
        "source": "These macros allow you to create raw pointers to fields to which you cannot create a reference (without causing undefined behaviour), such as an unaligned field.",
        "suggest": "这些宏允许您创建裸指针指向您无法创建引用的字段 (不会导致未定义的行为)，例如未对齐的字段。",
        "translate": ""
    },
    {
        "source": "This might be necessary if packed structs or uninitialized memory is involved.",
        "suggest": "如果涉及包装的结构或未初始化的内存，这可能是必要的。",
        "translate": ""
    },
    {
        "source": "For proper error reporting of failed processes, print the value of `ExitStatus` or `ExitStatusError` using their implementations of [`Display`](crate::fmt::Display).",
        "suggest": "为了正确报告失败进程的错误，请使用 [`Display`](crate::fmt::Display) 的实现打印 `ExitStatus` 或 `ExitStatusError` 的值。",
        "translate": ""
    },
    {
        "source": "Returns a `Result`.",
        "suggest": "返回 `Result`。",
        "translate": ""
    },
    {
        "source": "Describes the result of a process after it has failed",
        "suggest": "描述进程失败后的结果",
        "translate": ""
    },
    {
        "source": "Produced by the [`.exit_ok`](ExitStatus::exit_ok) method on [`ExitStatus`].",
        "suggest": "通过 [`ExitStatus`] 上的 [`.exit_ok`](ExitStatus::exit_ok) 方法生成。",
        "translate": ""
    },
    {
        "source": "The definition of imp::ExitStatusError should ideally be such that Result<(), imp::ExitStatusError> has an identical representation to imp::ExitStatus.",
        "suggest": "理想情况下，imp::ExitStatusError 的定义应该是 Result<(), imp::ExitStatusError> 与 imp::ExitStatus 具有相同的表示。",
        "translate": ""
    },
    {
        "source": "Reports the exit code, if applicable, from an `ExitStatusError`.",
        "suggest": "从 `ExitStatusError` 报告退出代码 (如果适用)。",
        "translate": ""
    },
    {
        "source": "Note that on Unix the exit status is truncated to 8 bits, and that values that didn't come from a program's call to `exit` may be invented by the runtime system (often, for example, 255, 254, 127 or 126).",
        "suggest": "请注意，在 Unix 上，退出状态被截断为 8 位，并且不是来自程序调用到 `exit` 的值可能是由运行时系统发明的 (通常，例如，255、254、127 或 126)。",
        "translate": ""
    },
    {
        "source": "If you want to handle such situations specially, consider using methods from [`ExitStatusExt`](crate::os::unix::process::ExitStatusExt).",
        "suggest": "如果您想专门处理这种情况，请考虑使用 [`ExitStatusExt`](crate::os::unix::process::ExitStatusExt) 中的方法。",
        "translate": ""
    },
    {
        "source": "If the process finished by calling `exit` with a nonzero value, this will return that exit status.",
        "suggest": "如果进程通过使用非零值调用 `exit` 完成，这将返回该退出状态。",
        "translate": ""
    },
    {
        "source": "If the error was something else, it will return `None`.",
        "suggest": "如果错误是其他原因，它将返回 `None`。",
        "translate": ""
    },
    {
        "source": "If the process exited successfully (ie, by calling `exit(0)`), there is no `ExitStatusError`.",
        "suggest": "如果进程成功退出 (即通过调用 `exit(0)`)，则没有 `ExitStatusError`。",
        "translate": ""
    },
    {
        "source": "So the return value from `ExitStatusError::code()` is always nonzero.",
        "suggest": "所以 `ExitStatusError::code()` 的返回值总是非零。",
        "translate": ""
    },
    {
        "source": "Reports the exit code, if applicable, from an `ExitStatusError`, as a `NonZero`",
        "suggest": "将 `ExitStatusError` 的退出代码 (如果适用) 报告为 `NonZero`",
        "translate": ""
    },
    {
        "source": "This is exaclty like [`code()`](Self::code), except that it returns a `NonZeroI32`.",
        "suggest": "这与 [`code()`](Self::code) 类似，只是它返回 `NonZeroI32`。",
        "translate": ""
    },
    {
        "source": "Plain `code`, returning a plain integer, is provided because is is often more convenient.",
        "suggest": "提供普通 `code`，返回一个普通整数，因为它通常更方便。",
        "translate": ""
    },
    {
        "source": "The returned value from `code()` is indeed also nonzero;",
        "suggest": "`code()` 的返回值确实也是非零的;",
        "translate": ""
    },
    {
        "source": "use `code_nonzero()` when you want a type-level guarantee of nonzeroness.",
        "suggest": "当您想要非零的类型级别保证时，请使用 `code_nonzero()`。",
        "translate": ""
    },
    {
        "source": "Converts an `ExitStatusError` (back) to an `ExitStatus`.",
        "suggest": "将 `ExitStatusError` (back) 转换为 `ExitStatus`。",
        "translate": ""
    },
    {
        "source": "If another user of this mutex panicked while holding the mutex, then this call will return the [`Poisoned`] error if the mutex would otherwise be acquired.",
        "suggest": "如果该调用的另一个用户同时持有互斥锁，则该调用将返回 [`Poisoned`] 错误，否则将获得该调用的拒绝互锁。",
        "translate": ""
    },
    {
        "source": "If the mutex could not be acquired because it is already locked, then this call will return the [`WouldBlock`] error.",
        "suggest": "如果互斥锁已被锁定而无法获取，则该调用将返回 [`WouldBlock`] 错误。",
        "translate": ""
    },
    {
        "source": "This function will return the [`Poisoned`] error if the RwLock is poisoned.",
        "suggest": "如果 RwLock 中毒，此函数将返回 [`Poisoned`] 错误。",
        "translate": ""
    },
    {
        "source": "will only be returned if the lock would have otherwise been acquired.",
        "suggest": "仅当以其他方式获取锁时才会返回。",
        "translate": ""
    },
    {
        "source": "This function will return the [`WouldBlock`] error if the RwLock could not be acquired because it was already locked exclusively.",
        "suggest": "如果 RwLock 因为已经被独占锁定而无法获取，该函数将返回 [`WouldBlock`] 错误。",
        "translate": ""
    },
    {
        "source": "Import essential modules from platforms used in `std::os` when documenting.",
        "suggest": "记录时从 `std::os` 中使用的平台导入基本模块。",
        "translate": ""
    },
    {
        "source": "Note that on some platforms those modules don't compile (missing things in `libc` which is empty), so they are not included in `std::os` and can be omitted here as well.",
        "suggest": "请注意，在某些平台上，这些模块不会编译 (`libc` 中缺少内容，它是空的)，因此它们不包含在 `std::os` 中，也可以在此处省略。",
        "translate": ""
    },
    {
        "source": "On non-Windows platforms (aka linux/osx/etc) pull in a \"minimal\" amount of windows goop which ends up compiling",
        "suggest": "在非 Windows 平台 (也就是 linux/osx/etc) 上引入 \"minimal\" 数量的 windows goop，最终编译",
        "translate": ""
    },
    {
        "source": "It is a trick to call `statx` with null pointers to check if the syscall is available.",
        "suggest": "这是一个用空指针调用 `statx` 来检查系统调用是否可用的技巧。",
        "translate": ""
    },
    {
        "source": "null can mean either the end is reached or an error occurred.",
        "suggest": "null 可能意味着到达终点或发生错误。",
        "translate": ""
    },
    {
        "source": "Overwrite the trailing null pointer in `argv` and then add a new null pointer.",
        "suggest": "覆盖 `argv` 中的尾随空指针，然后添加一个新的空指针。",
        "translate": ""
    },
    {
        "source": "affected by the same bug as ExitStatus::code()",
        "suggest": "受与 ExitStatus::code () 相同的 bug 影响",
        "translate": ""
    },
    {
        "source": "Many of the other aspects of this situation, including heap alloc concurrency safety etc., are tested in src/test/ui/process/process-panic-after-fork.rs",
        "suggest": "这种情况的许多其他方面，包括堆 alloc 并发安全性等，都在 src/test/ui/process/process-panic-after-fork.rs 中进行了测试",
        "translate": ""
    },
    {
        "source": "This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.",
        "suggest": "这假设 WIFEXITED(status)&&WEXITSTATUS == 0 对应于 status == 0。",
        "translate": ""
    },
    {
        "source": "This is true on all actual versions of Unix, is widely assumed, and is specified in SuS https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html.IfitisnottrueforaplatformpretendingtobeUnix,thetests(our doctests, and also procsss_unix/tests.rs) will spot it.",
        "suggest": "这在 Unix 的所有实际版本上都是正确的，被广泛假设，并在 SuS https://pubs.opengroup.org/wait.html.IfitisnottrueforaplatformpretendingtobeUnix,thetests (我们的 doctests，还有 procsss_unix/tests.rs) 中指定会发现它。",
        "translate": ""
    },
    {
        "source": "assumes this too.",
        "suggest": "也假设这一点。",
        "translate": ""
    },
    {
        "source": "We currently just use our own thread-local to store our current thread's ID, and then we lazily initialize it to something allocated from a global counter.",
        "suggest": "我们目前只是使用我们自己的线程本地来存储我们当前线程的 ID，然后我们懒惰地将它初始化为从一个计数器分配的东西。",
        "translate": ""
    },
    {
        "source": "Desktop specific functions & types",
        "suggest": "桌面特定的函数和类型",
        "translate": ""
    },
    {
        "source": "Forbidden when targeting UWP",
        "suggest": "以 UWP 为目标时禁止",
        "translate": ""
    },
    {
        "source": "Try to see if a file exists but, unlike `exists`, report I/O errors.",
        "suggest": "尝试查看文件是否存在，但与 `exists` 不同，报告 I/O 错误。",
        "translate": ""
    },
    {
        "source": "Open the file to ensure any symlinks are followed to their target.",
        "suggest": "打开文件以确保任何符号链接都遵循其目标。",
        "translate": ""
    },
    {
        "source": "No read, write, etc access rights are needed.",
        "suggest": "不需要读、写等访问权限。",
        "translate": ""
    },
    {
        "source": "Backup semantics enables opening directories as well as files.",
        "suggest": "备份语义允许打开目录和文件。",
        "translate": ""
    },
    {
        "source": "The file definitely does not exist",
        "suggest": "该文件肯定不存在",
        "translate": ""
    },
    {
        "source": "means that the file has been locked by another process.",
        "suggest": "表示该文件已被另一个进程锁定。",
        "translate": ""
    },
    {
        "source": "This is often temporary so we simply report it as the file existing.",
        "suggest": "这通常是暂时的，因此我们只是将其报告为存在的文件。",
        "translate": ""
    },
    {
        "source": "Other errors such as `ERROR_ACCESS_DENIED` may indicate that the file exists.",
        "suggest": "其他错误 (如 `ERROR_ACCESS_DENIED`) 可能表明文件存在。",
        "translate": ""
    },
    {
        "source": "However, these types of errors are usually more permanent so we report them here.",
        "suggest": "但是，这些类型的错误通常更持久，因此我们在此处报告它们。",
        "translate": ""
    },
    {
        "source": "The file was opened successfully therefore it must exist,",
        "suggest": "该文件已成功打开，因此它必须存在，",
        "translate": ""
    },
    {
        "source": "Prints to the \"panic output\", depending on the platform this may be:",
        "suggest": "打印到 \"panic output\"，取决于平台，这可能是:",
        "translate": ""
    },
    {
        "source": "the standard error output",
        "suggest": "标准错误输出",
        "translate": ""
    },
    {
        "source": "some dedicated platform specific output",
        "suggest": "一些专用平台特定的输出",
        "translate": ""
    },
    {
        "source": "nothing (so this macro is a no-op)",
        "suggest": "什么都没有 (所以这个宏是一个空操作)",
        "translate": ""
    },
    {
        "source": "An OS-based reader-writer lock, meant for use in static variables.",
        "suggest": "基于操作系统的读写锁，用于静态变量。",
        "translate": ""
    },
    {
        "source": "This rwlock does not implement poisoning.",
        "suggest": "这个 rwlock 没有实现中毒。",
        "translate": ""
    },
    {
        "source": "This rwlock has a const constructor ([`StaticRWLock::new`]), does not implement `Drop` to cleanup resources.",
        "suggest": "这个 rwlock 有一个 const 构造函数 ([`StaticRWLock::new`])，没有实现 `Drop` 来清理资源。",
        "translate": ""
    },
    {
        "source": "Creates a new rwlock for use.",
        "suggest": "创建一个新的 rwlock 以供使用。",
        "translate": ""
    },
    {
        "source": "This rwlock does *not* have a const constructor, cleans up its resources in its `Drop` implementation and may safely be moved (when not borrowed).",
        "suggest": "这个 rwlock 没有 const 构造函数，在它的 `Drop` 实现中清理它的资源并且可以安全地移动 (当没有被借用时)。",
        "translate": ""
    },
    {
        "source": "This is either a wrapper around `Box<imp::RWLock>` or `imp::RWLock`, depending on the platform.",
        "suggest": "这是 `Box<imp::RWLock>` 或 `imp::RWLock` 的包装器，具体取决于平台。",
        "translate": ""
    },
    {
        "source": "It is boxed on platforms where `imp::RWLock` may not be moved.",
        "suggest": "在不能移动 `imp::RWLock` 的平台上，它是 boxed。",
        "translate": ""
    },
    {
        "source": "see comments below",
        "suggest": "请参见下面的注释",
        "translate": ""
    },
    {
        "source": "When reading this function you might ask \"why is this inlined everywhere other than Windows?\", and that's a very reasonable question to ask.",
        "suggest": "在阅读这个函数时，你可能会问 \"为什么除了 Windows 之外，其他地方都内联这个函数?\"，这是一个非常合理的问题。",
        "translate": ""
    },
    {
        "source": "The short story is that it segfaults rustc if this function is inlined.",
        "suggest": "简而言之，如果这个函数是内联的，它会导致 rustc 段错误。",
        "translate": ""
    },
    {
        "source": "The longer story is that Windows looks to not support `extern` references to thread locals across DLL boundaries.",
        "suggest": "更长的故事是 Windows 看起来不支持跨 DLL 边界的线程局部变量的 `extern` 引用。",
        "translate": ""
    },
    {
        "source": "This appears to at least not be supported in the ABI that LLVM implements.",
        "suggest": "这似乎至少在 LLVM 实现的 ABI 中不受支持。",
        "translate": ""
    },
    {
        "source": "Because of this we never inline on Windows, but we do inline on other platforms (where external references to thread locals across DLLs are supported).",
        "suggest": "正因为如此，我们从不在 Windows 上内联，但我们在其他平台上内联 (在这些平台上，跨 dll 的线程局部变量的外部引用是受支持的)。",
        "translate": ""
    },
    {
        "source": "A better fix for this would be to inline this function on Windows, but only for \"statically linked\" components.",
        "suggest": "一个更好的解决方法是在 Windows 上内联这个函数，但仅限于 \"静态链接\" 组件。",
        "translate": ""
    },
    {
        "source": "For example if two separately compiled rlibs end up getting linked into a DLL then it's fine to inline this function across that boundary.",
        "suggest": "例如，如果两个单独编译的 rlib 最终链接到一个 DLL 中，那么可以跨边界内联这个函数。",
        "translate": ""
    },
    {
        "source": "It's only not fine to inline this function across a DLL boundary.",
        "suggest": "跨 DLL 边界内联这个函数是不好的。",
        "translate": ""
    },
    {
        "source": "Unfortunately rustc doesn't currently have this sort of logic available in an attribute, and it's not clear that rustc is even equipped to answer this (it's more of a Cargo question kinda).",
        "suggest": "不幸的是，rustc 目前在属性中没有这种可用的逻辑，而且还不清楚 rustc 是否有能力回答这个问题 (这更像是 Cargo 问题)。",
        "translate": ""
    },
    {
        "source": "This means that, unfortunately, Windows gets the pessimistic path for now where it's never inlined.",
        "suggest": "这意味着，不幸的是，Windows 现在的路径很悲观，它从来没有内联。",
        "translate": ""
    },
    {
        "source": "The issue of \"should enable on Windows sometimes\" is #84933",
        "suggest": "\"有时应该在 Windows 上启用\" 的问题是 #84933",
        "translate": ""
    },
    {
        "source": "The OS TLS ensures that this key contains a null value when this destructor starts to run.",
        "suggest": "当这个析构函数开始运行时，OS TLS 确保这个键包含一个空值。",
        "translate": ""
    },
    {
        "source": "is a compile-time constant integer in range `[0, 65535]`.",
        "suggest": "是 `[0, 65535]` 范围内的编译时常量整数。",
        "translate": ""
    },
    {
        "source": "The breakpoint instruction inserted is `BRK` on A64.",
        "suggest": "插入的断点指令是 A64 上的 `BRK`。",
        "translate": ""
    },
    {
        "source": "Absolute difference between the arguments of Floating",
        "suggest": "浮动参数之间的绝对差异",
        "translate": ""
    },
    {
        "source": "Unsigned Absolute difference Long",
        "suggest": "无符号绝对差长",
        "translate": ""
    },
    {
        "source": "Signed Absolute difference Long",
        "suggest": "有符号绝对差长",
        "translate": ""
    },
    {
        "source": "Signed compare bitwise equal to zero",
        "suggest": "有符号比较按位等于零",
        "translate": ""
    },
    {
        "source": "Unsigned compare bitwise equal to zero",
        "suggest": "无符号比较按位等于零",
        "translate": ""
    },
    {
        "source": "Floating-point compare bitwise equal to zero",
        "suggest": "浮点比较按位等于零",
        "translate": ""
    },
    {
        "source": "Signed compare bitwise Test bits nonzero",
        "suggest": "有符号比较按位测试位非零",
        "translate": ""
    },
    {
        "source": "Unsigned compare bitwise Test bits nonzero",
        "suggest": "无符号比较按位测试位非零",
        "translate": ""
    },
    {
        "source": "Floating-point absolute value",
        "suggest": "浮点绝对值",
        "translate": ""
    },
    {
        "source": "Compare signed greater than or equal to zero",
        "suggest": "比较有符号大于或等于零",
        "translate": ""
    },
    {
        "source": "Floating-point compare greater than or equal to zero",
        "suggest": "浮点比较大于或等于零",
        "translate": ""
    },
    {
        "source": "Compare signed greater than zero",
        "suggest": "比较有符号大于零",
        "translate": ""
    },
    {
        "source": "Floating-point compare greater than zero",
        "suggest": "浮点比较大于零",
        "translate": ""
    },
    {
        "source": "Compare signed less than or equal to zero",
        "suggest": "比较有符号小于或等于零",
        "translate": ""
    },
    {
        "source": "Floating-point compare less than or equal to zero",
        "suggest": "浮点比较小于或等于零",
        "translate": ""
    },
    {
        "source": "Compare signed less than zero",
        "suggest": "比较有符号小于零",
        "translate": ""
    },
    {
        "source": "Floating-point compare less than zero",
        "suggest": "浮点比较小于零",
        "translate": ""
    },
    {
        "source": "Floating-point absolute compare greater than",
        "suggest": "浮点绝对值比较大于",
        "translate": ""
    },
    {
        "source": "Floating-point absolute compare greater than or equal",
        "suggest": "浮点绝对比较大于或等于",
        "translate": ""
    },
    {
        "source": "Floating-point absolute compare less than",
        "suggest": "浮点绝对比较小于",
        "translate": ""
    },
    {
        "source": "Floating-point absolute compare less than or equal",
        "suggest": "浮点绝对比较小于或等于",
        "translate": ""
    },
    {
        "source": "Insert vector element from another vector element",
        "suggest": "从另一个 vector 元素插入 vector 元素",
        "translate": ""
    },
    {
        "source": "Fixed-point convert to floating-point",
        "suggest": "定点转换为浮点",
        "translate": ""
    },
    {
        "source": "Floating-point convert to higher precision long",
        "suggest": "浮点数转换为更高精度的 long",
        "translate": ""
    },
    {
        "source": "Floating-point convert to lower precision narrow",
        "suggest": "浮点数转换为低精度 narrow",
        "translate": ""
    },
    {
        "source": "Floating-point convert to lower precision narrow, rounding to odd",
        "suggest": "浮点数转换为低精度 narrow，四舍五入为奇数",
        "translate": ""
    },
    {
        "source": "Floating-point convert to fixed-point, rounding toward zero",
        "suggest": "浮点数转换为定点数，四舍五入为零",
        "translate": ""
    },
    {
        "source": "Floating-point convert to signed fixed-point, rounding toward zero",
        "suggest": "浮点转换为有符号的定点，四舍五入为零",
        "translate": ""
    },
    {
        "source": "Floating-point convert to unsigned fixed-point, rounding toward zero",
        "suggest": "浮点转换为无符号定点，四舍五入为零",
        "translate": ""
    },
    {
        "source": "Floating-point convert to signed integer, rounding to nearest with ties to away",
        "suggest": "浮点转换为有符号整数，四舍五入到最接近的整数",
        "translate": ""
    },
    {
        "source": "Floating-point convert to integer, rounding to nearest with ties to away",
        "suggest": "浮点数转换为整数，四舍五入到最接近的整数",
        "translate": ""
    },
    {
        "source": "Floating-point convert to signed integer, rounding to nearest with ties to even",
        "suggest": "浮点数转换为有符号整数，四舍五入到最接近的与偶数的关系",
        "translate": ""
    },
    {
        "source": "Floating-point convert to signed integer, rounding toward minus infinity",
        "suggest": "浮点转换为有符号整数，向负无穷四舍五入",
        "translate": ""
    },
    {
        "source": "Floating-point convert to signed integer, rounding toward plus infinity",
        "suggest": "浮点转换为有符号整数，向正无穷大四舍五入",
        "translate": ""
    },
    {
        "source": "Floating-point convert to unsigned integer, rounding to nearest with ties to away",
        "suggest": "浮点数转换为无符号整数，四舍五入到最接近的整数",
        "translate": ""
    },
    {
        "source": "Floating-point convert to unsigned integer, rounding to nearest with ties to even",
        "suggest": "浮点转换为无符号整数，四舍五入到最接近的偶数",
        "translate": ""
    },
    {
        "source": "Floating-point convert to unsigned integer, rounding toward minus infinity",
        "suggest": "浮点数转换为无符号整数，向负无穷四舍五入",
        "translate": ""
    },
    {
        "source": "Floating-point convert to unsigned integer, rounding toward plus infinity",
        "suggest": "浮点数转换为无符号整数，向正无穷大四舍五入",
        "translate": ""
    },
    {
        "source": "Set all vector lanes to the same value",
        "suggest": "将所有 vector 通道设置为相同的值",
        "translate": ""
    },
    {
        "source": "Floating-point multiply-add to accumulator",
        "suggest": "浮点乘加累加器",
        "translate": ""
    },
    {
        "source": "Signed multiply-add long",
        "suggest": "有符号乘加长",
        "translate": ""
    },
    {
        "source": "Unsigned multiply-add long",
        "suggest": "无符号乘加长",
        "translate": ""
    },
    {
        "source": "Multiply-add long",
        "suggest": "乘加长",
        "translate": ""
    },
    {
        "source": "Floating-point multiply-subtract from accumulator",
        "suggest": "浮点乘减累加器",
        "translate": ""
    },
    {
        "source": "Signed multiply-subtract long",
        "suggest": "有符号乘减长",
        "translate": ""
    },
    {
        "source": "Unsigned multiply-subtract long",
        "suggest": "无符号乘减长",
        "translate": ""
    },
    {
        "source": "Multiply-subtract long",
        "suggest": "乘减长",
        "translate": ""
    },
    {
        "source": "Extract narrow",
        "suggest": "提取 narrow",
        "translate": ""
    },
    {
        "source": "Signed saturating negate",
        "suggest": "有符号饱和否定",
        "translate": ""
    },
    {
        "source": "Reverse bit order",
        "suggest": "反转位序",
        "translate": ""
    },
    {
        "source": "Floating-point round to integral exact, using current rounding mode",
        "suggest": "使用当前舍入模式将浮点舍入精确到整数",
        "translate": ""
    },
    {
        "source": "Floating-point round to integral, to nearest with ties to away",
        "suggest": "浮点数舍入到整数，到最近的与远离的关系",
        "translate": ""
    },
    {
        "source": "Floating-point round to integral, to nearest with ties to even",
        "suggest": "浮点数舍入到整数，最接近与偶数的关系",
        "translate": ""
    },
    {
        "source": "Floating-point round to integral, toward minus infinity",
        "suggest": "浮点舍入为整数，向负无穷大",
        "translate": ""
    },
    {
        "source": "Floating-point round to integral, toward plus infinity",
        "suggest": "浮点舍入为整数，朝向正无穷大",
        "translate": ""
    },
    {
        "source": "Floating-point round to integral, toward zero",
        "suggest": "浮点四舍五入为整数，接近零",
        "translate": ""
    },
    {
        "source": "Floating-point round to integral, using current rounding mode",
        "suggest": "浮点四舍五入到整数，使用当前舍入模式",
        "translate": ""
    },
    {
        "source": "Vector multiply by scalar",
        "suggest": "Vector 乘以标量",
        "translate": ""
    },
    {
        "source": "Floating-point multiply",
        "suggest": "浮点乘法",
        "translate": ""
    },
    {
        "source": "Signed multiply long",
        "suggest": "有符号乘长",
        "translate": ""
    },
    {
        "source": "Unsigned multiply long",
        "suggest": "无符号乘长",
        "translate": ""
    },
    {
        "source": "Multiply long",
        "suggest": "乘长",
        "translate": ""
    },
    {
        "source": "Floating-point multiply extended",
        "suggest": "浮点乘法扩展",
        "translate": ""
    },
    {
        "source": "Floating-point fused Multiply-Add to accumulator(vector)",
        "suggest": "浮点融合的乘加累加器 accumulator(vector)",
        "translate": ""
    },
    {
        "source": "Floating-point fused multiply-add to accumulator",
        "suggest": "浮点融合乘加累加器",
        "translate": ""
    },
    {
        "source": "Floating-point fused multiply-subtract from accumulator",
        "suggest": "从累加器中进行浮点相乘相减",
        "translate": ""
    },
    {
        "source": "Floating-point fused Multiply-subtract to accumulator(vector)",
        "suggest": "浮点相乘相减到累加器 accumulator(vector)",
        "translate": ""
    },
    {
        "source": "Floating-point fused multiply-subtract to accumulator",
        "suggest": "浮点融合乘减累加器",
        "translate": ""
    },
    {
        "source": "Signed Add Long across Vector",
        "suggest": "跨 Vector 签名加长",
        "translate": ""
    },
    {
        "source": "Unsigned Add Long across Vector",
        "suggest": "跨 Vector 的无符号加长",
        "translate": ""
    },
    {
        "source": "Signed Subtract Wide",
        "suggest": "有符号减宽",
        "translate": ""
    },
    {
        "source": "Unsigned Subtract Wide",
        "suggest": "无符号减宽",
        "translate": ""
    },
    {
        "source": "Signed Subtract Long",
        "suggest": "有符号减长",
        "translate": ""
    },
    {
        "source": "Unsigned Subtract Long",
        "suggest": "无符号减长",
        "translate": ""
    },
    {
        "source": "Floating-point Maximun Number (vector)",
        "suggest": "浮点最大值 (vector)",
        "translate": ""
    },
    {
        "source": "Floating-point Maximum Number Pairwise (vector).",
        "suggest": "浮点最大数成对 (vector)。",
        "translate": ""
    },
    {
        "source": "Floating-point Minimun Number (vector)",
        "suggest": "浮点最小数 (vector)",
        "translate": ""
    },
    {
        "source": "Floating-point Minimum Number Pairwise (vector).",
        "suggest": "浮点最小数成对 (vector)。",
        "translate": ""
    },
    {
        "source": "Signed saturating doubling multiply long",
        "suggest": "有符号饱和加倍乘以长",
        "translate": ""
    },
    {
        "source": "Vector saturating doubling long multiply by scalar",
        "suggest": "Vector 饱和加倍长乘以标量",
        "translate": ""
    },
    {
        "source": "Signed saturating doubling multiply-add long",
        "suggest": "有符号饱和加倍乘加长",
        "translate": ""
    },
    {
        "source": "Vector widening saturating doubling multiply accumulate with scalar",
        "suggest": "Vector 加宽饱和加倍乘积与标量",
        "translate": ""
    },
    {
        "source": "Signed saturating doubling multiply-subtract long",
        "suggest": "有符号饱和加倍乘减长",
        "translate": ""
    },
    {
        "source": "Vector widening saturating doubling multiply subtract with scalar",
        "suggest": "Vector 加宽饱和加倍乘减标量",
        "translate": ""
    },
    {
        "source": "Signed saturating doubling multiply returning high half",
        "suggest": "有符号饱和加倍乘法返回高半",
        "translate": ""
    },
    {
        "source": "Saturating extract narrow",
        "suggest": "饱和提取 narrow",
        "translate": ""
    },
    {
        "source": "Signed saturating extract narrow",
        "suggest": "带符号饱和提取 narrow",
        "translate": ""
    },
    {
        "source": "Signed saturating extract unsigned narrow",
        "suggest": "有符号饱和提取无符号 narrow",
        "translate": ""
    },
    {
        "source": "Signed saturating rounding doubling multiply returning high half",
        "suggest": "有符号饱和舍入加倍乘法返回高半",
        "translate": ""
    },
    {
        "source": "Signed saturating rounding doubling multiply accumulate returning high half",
        "suggest": "有符号饱和四舍五入加倍累加返回高半",
        "translate": ""
    },
    {
        "source": "Signed saturating rounding doubling multiply subtract returning high half",
        "suggest": "有符号饱和舍入加倍乘减返回高半",
        "translate": ""
    },
    {
        "source": "Signed saturating rounding shift left",
        "suggest": "有符号饱和舍入左移",
        "translate": ""
    },
    {
        "source": "Unsigned signed saturating rounding shift left",
        "suggest": "无符号有符号饱和舍入左移",
        "translate": ""
    },
    {
        "source": "Signed saturating rounded shift right narrow",
        "suggest": "有符号饱和圆角右移 narrow",
        "translate": ""
    },
    {
        "source": "Unsigned saturating rounded shift right narrow",
        "suggest": "无符号饱和圆角右移 narrow",
        "translate": ""
    },
    {
        "source": "Signed saturating rounded shift right unsigned narrow",
        "suggest": "有符号饱和四舍五入右移无符号 narrow",
        "translate": ""
    },
    {
        "source": "Signed saturating shift left",
        "suggest": "有符号饱和左移",
        "translate": ""
    },
    {
        "source": "Unsigned saturating shift left",
        "suggest": "无符号饱和左移",
        "translate": ""
    },
    {
        "source": "Signed saturating shift right narrow",
        "suggest": "有符号饱和右移 narrow",
        "translate": ""
    },
    {
        "source": "Unsigned saturating shift right narrow",
        "suggest": "无符号饱和右移 narrow",
        "translate": ""
    },
    {
        "source": "Signed saturating shift right unsigned narrow",
        "suggest": "有符号饱和右移无符号 narrow",
        "translate": ""
    },
    {
        "source": "Calculates the square root of each lane.",
        "suggest": "计算每条通道的平方根。",
        "translate": ""
    },
    {
        "source": "Reciprocal estimate.",
        "suggest": "相互估计。",
        "translate": ""
    },
    {
        "source": "Signed rounding shift left",
        "suggest": "有符号舍入左移",
        "translate": ""
    },
    {
        "source": "Unsigned rounding shift left",
        "suggest": "无符号舍入左移",
        "translate": ""
    },
    {
        "source": "Signed rounding shift right",
        "suggest": "有符号舍入右移",
        "translate": ""
    },
    {
        "source": "Unsigned rounding shift right",
        "suggest": "无符号舍入右移",
        "translate": ""
    },
    {
        "source": "Rounding shift right narrow",
        "suggest": "舍入右移变 narrow",
        "translate": ""
    },
    {
        "source": "Signed rounding shift right and accumulate.",
        "suggest": "有符号舍入右移并累加。",
        "translate": ""
    },
    {
        "source": "Ungisned rounding shift right and accumulate.",
        "suggest": "未定义的舍入右移并累加。",
        "translate": ""
    },
    {
        "source": "Signed Shift left",
        "suggest": "有符号左移",
        "translate": ""
    },
    {
        "source": "Unsigned Shift left",
        "suggest": "无符号左移",
        "translate": ""
    },
    {
        "source": "Signed shift left long",
        "suggest": "有符号左移长",
        "translate": ""
    },
    {
        "source": "Shift right narrow",
        "suggest": "右移 narrow",
        "translate": ""
    },
    {
        "source": "Transpose vectors",
        "suggest": "转置向量",
        "translate": ""
    },
    {
        "source": "Unzip vectors",
        "suggest": "解压缩 vectors",
        "translate": ""
    },
    {
        "source": "Unsigned Absolute difference and Accumulate Long",
        "suggest": "无符号绝对差和累积长",
        "translate": ""
    },
    {
        "source": "Signed Absolute difference and Accumulate Long",
        "suggest": "有符号绝对差和累积长",
        "translate": ""
    },
    {
        "source": "Singned saturating Absolute value",
        "suggest": "饱和绝对值",
        "translate": ""
    },
    {
        "source": "Store multiple single-element structures from one, two, three, or four registers.",
        "suggest": "从一个、两个、三个或四个寄存器中存储多个单一元素结构。",
        "translate": ""
    },
    {
        "source": "Bitwise Select instructions.",
        "suggest": "按位选择指令。",
        "translate": ""
    },
    {
        "source": "This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.",
        "suggest": "当原始目标位为 1 时，该指令将目标 SIMD&FP 寄存器中的每一位设置为来自第一个源 SIMD&FP 寄存器的相应位，否则来自第二个源 SIMD&FP 寄存器。",
        "translate": ""
    },
    {
        "source": "Bitwise Select.",
        "suggest": "按位选择。",
        "translate": ""
    },
    {
        "source": "Shift left",
        "suggest": "左移",
        "translate": ""
    },
    {
        "source": "Signed shift right",
        "suggest": "有符号右移",
        "translate": ""
    },
    {
        "source": "Signed shift right and accumulate",
        "suggest": "有符号右移并累加",
        "translate": ""
    },
    {
        "source": "Unsigned shift right and accumulate",
        "suggest": "无符号右移并累加",
        "translate": ""
    },
    {
        "source": "Fetch the cache line that contains address `p` using the given `RW` and `LOCALITY`.",
        "suggest": "使用给定的 `RW` 和 `LOCALITY` 获取包含地址 `p` 的缓存行。",
        "translate": ""
    },
    {
        "source": "The `RW` must be one of:",
        "suggest": "`RW` 必须是以下之一:",
        "translate": ""
    },
    {
        "source": "The `LOCALITY` must be one of:",
        "suggest": "`LOCALITY` 必须是以下之一:",
        "translate": ""
    },
    {
        "source": "Replace this with the standard ACLE __pld/__pldx/__pli/__plix intrinsics",
        "suggest": "将其替换为标准的 ACLE __pld/__pldx/__pli/__plix 内联函数",
        "translate": ""
    },
    {
        "source": "The breakpoint instruction inserted is `BKPT` on A32/T32.",
        "suggest": "插入的断点指令是 A32/T32 上的 `BKPT`。",
        "translate": ""
    },
    {
        "source": "defines that `__breakpoint` accepts the following values for `VAL`:",
        "suggest": "定义 `__breakpoint` 接受 `VAL` 的以下值:",
        "translate": ""
    },
    {
        "source": "when compiling as A32,",
        "suggest": "编译为 A32 时，",
        "translate": ""
    },
    {
        "source": "The current implementation only accepts values in range `[0, 255]`.",
        "suggest": "当前的实现只接受 `[0, 255]` 范围内的值。",
        "translate": ""
    },
    {
        "source": "Rust compilers without 8a57820bca64a252489790a57cb5ea23db6f9198 need crypto (hence the bootstrap check) LLVM builds without b8baa2a9132498ea286dbb0d03f005760ecc6fdb need crypto for arm (hence the target_arch check)",
        "suggest": "没有 8a57820bca64a252489790a57cb5ea23db6f9198 的 Rust 编译器需要加密 (因此引导程序检查) LLVM 构建没有 b8baa2a9132498ea286dbb0d03f005760f 的目标需要 cryptoarchecc0fx",
        "translate": ""
    },
    {
        "source": "Only for 'neon' submodule",
        "suggest": "仅适用于 'neon' 子模块",
        "translate": ""
    },
    {
        "source": "Absolute difference between the arguments",
        "suggest": "参数之间的绝对差异",
        "translate": ""
    },
    {
        "source": "Count leading sign bits",
        "suggest": "计数前导符号位",
        "translate": ""
    },
    {
        "source": "Signed count leading sign bits",
        "suggest": "有符号计数前导符号位",
        "translate": ""
    },
    {
        "source": "Unsigned count leading sign bits",
        "suggest": "无符号计数前导符号位",
        "translate": ""
    },
    {
        "source": "Multiply-add to accumulator",
        "suggest": "乘加到累加器",
        "translate": ""
    },
    {
        "source": "Vector multiply accumulate with scalar",
        "suggest": "向量与标量相乘累加",
        "translate": ""
    },
    {
        "source": "Vector widening multiply accumulate with scalar",
        "suggest": "向量加宽乘积与标量",
        "translate": ""
    },
    {
        "source": "Multiply-subtract from accumulator",
        "suggest": "累加器的乘减",
        "translate": ""
    },
    {
        "source": "Vector multiply subtract with scalar",
        "suggest": "向量乘减标量",
        "translate": ""
    },
    {
        "source": "Vector widening multiply subtract with scalar",
        "suggest": "向量加宽乘减标量",
        "translate": ""
    },
    {
        "source": "Polynomial multiply",
        "suggest": "多项式乘法",
        "translate": ""
    },
    {
        "source": "Vector long multiply with scalar",
        "suggest": "向量长乘以标量",
        "translate": ""
    },
    {
        "source": "Vector long multiply by scalar",
        "suggest": "向量长乘以标量",
        "translate": ""
    },
    {
        "source": "Subtract returning high narrow",
        "suggest": "减去返回 high narrow",
        "translate": ""
    },
    {
        "source": "Vector saturating doubling long multiply with scalar",
        "suggest": "向量饱和加倍长乘以标量",
        "translate": ""
    },
    {
        "source": "Vector saturating doubling multiply high with scalar",
        "suggest": "向量饱和加倍乘以标量",
        "translate": ""
    },
    {
        "source": "Unsigned saturating extract narrow",
        "suggest": "无符号饱和提取 narrow",
        "translate": ""
    },
    {
        "source": "Vector saturating rounding doubling multiply high with scalar",
        "suggest": "向量饱和舍入加倍乘以标量高",
        "translate": ""
    },
    {
        "source": "Vector rounding saturating doubling multiply high by scalar",
        "suggest": "向量舍入饱和加倍乘以标量高",
        "translate": ""
    },
    {
        "source": "Unsigned signed saturating rounded shift right narrow",
        "suggest": "无符号符号饱和圆角右移 narrow",
        "translate": ""
    },
    {
        "source": "Signed rounding shift right and accumulate",
        "suggest": "有符号四舍入移并累加",
        "translate": ""
    },
    {
        "source": "Unsigned rounding shift right and accumulate",
        "suggest": "无符号舍入右移并累加",
        "translate": ""
    },
    {
        "source": "signed absolute difference and accumulate (64-bit)",
        "suggest": "有符号绝对差和累加 (64-bit)",
        "translate": ""
    },
    {
        "source": "signed absolute difference and accumulate (128-bit)",
        "suggest": "有符号绝对差和累加 (128-bit)",
        "translate": ""
    },
    {
        "source": "Vector bitwise bit clear",
        "suggest": "矢量按位清除",
        "translate": ""
    },
    {
        "source": "Vector bitwise inclusive OR NOT",
        "suggest": "向量按位包含或不包含",
        "translate": ""
    },
    {
        "source": "Tests for ARM+v7+neon store (vst1) intrinsics.",
        "suggest": "ARM+v7+neon 存储 (vst1) 内联函数测试。",
        "translate": ""
    },
    {
        "source": "Helper struct used to trigger const eval errors when the const generic immediate value `IMM` is out of `[MIN-MAX]` range.",
        "suggest": "Helper 结构用于当 const 泛型 immediate 值 `IMM` 超出 `[MIN-MAX]` 范围时触发 const eval 错误。",
        "translate": ""
    },
    {
        "source": "Here you'll find intrinsics specific to WebAssembly that aren't otherwise surfaced somewhere in a cross-platform abstraction of `std`, and you'll also find functions for leveraging WebAssembly proposals such as [atomics] and [simd].",
        "suggest": "在这里，您会发现特定于 WebAssembly 的内联函数，它们不会在 `std` 的跨平台抽象中以其他方式出现，您还会发现利用 WebAssembly 提案 (如 [atomics] 和 [simd]) 的函数。",
        "translate": ""
    },
    {
        "source": "Intrinsics in the `wasm32` module are modeled after the WebAssembly instructions that they represent.",
        "suggest": "`wasm32` 模块中的内联函数是根据它们所代表的 WebAssembly 指令建模的。",
        "translate": ""
    },
    {
        "source": "Most functions are named after the instruction they intend to correspond to, and the arguments/results correspond to the type signature of the instruction itself.",
        "suggest": "大多数函数都以它们想要对应的指令命名，arguments/results 对应指令本身的类型签名。",
        "translate": ""
    },
    {
        "source": "Stable WebAssembly instructions are [documented online][instrdoc].",
        "suggest": "稳定的 WebAssembly 指令是 [documented online][instrdoc]。",
        "translate": ""
    },
    {
        "source": "If a proposal is not yet stable in WebAssembly itself then the functions within this function may be unstable and require the nightly channel of Rust to use.",
        "suggest": "如果一个提案在 WebAssembly 本身中还不稳定，那么这个函数中的函数可能是不稳定的，需要使用 Rust 的 nightly 通道。",
        "translate": ""
    },
    {
        "source": "As the proposal itself stabilizes the intrinsics in this module should stabilize as well.",
        "suggest": "由于提案本身稳定，该模块中的内联函数也应该稳定。",
        "translate": ""
    },
    {
        "source": "Most instructions added in the [atomics] proposal are exposed in Rust through the `std::sync::atomic` module.",
        "suggest": "[atomics] 提案中添加的大多数指令都通过 `std::sync::atomic` 模块在 Rust 中公开。",
        "translate": ""
    },
    {
        "source": "Some instructions, however, don't have direct equivalents in Rust so they're exposed here instead.",
        "suggest": "但是，某些指令在 Rust 中没有直接等效项，因此它们在此处公开。",
        "translate": ""
    },
    {
        "source": "Note that the instructions added in the [atomics] proposal can work in either a context with a shared wasm memory and without.",
        "suggest": "请注意，在 [atomics] 提案中添加的指令可以在具有共享 wasm 内存和不具有共享 wasm 内存的上下文中工作。",
        "translate": ""
    },
    {
        "source": "These intrinsics are always available in the standard library, but you likely won't be able to use them too productively unless you recompile the standard library (and all your code) with `-Ctarget-feature=+atomics`.",
        "suggest": "这些内联函数始终在标准库中可用，但除非您使用 `-Ctarget-feature=+atomics` 重新编译标准库 (和所有代码)，否则您可能无法高效地使用它们。",
        "translate": ""
    },
    {
        "source": "It's also worth pointing out that multi-threaded WebAssembly and its story in Rust is still in a somewhat \"early days\" phase as of the time of this writing.",
        "suggest": "还值得指出的是，截至撰写本文时，多线程 WebAssembly 及其在 Rust 中的描述仍处于 \"早期\" 阶段。",
        "translate": ""
    },
    {
        "source": "Pieces should mostly work but it generally requires a good deal of manual setup.",
        "suggest": "件基本上可以工作，但它通常需要大量的手动设置。",
        "translate": ""
    },
    {
        "source": "At this time it's not as simple as \"just call `std::thread::spawn`\", but it will hopefully get there one day!",
        "suggest": "这个时候它不像 \"只需调用 `std::thread::spawn`\" 那么简单，但希望有一天它能被实现!",
        "translate": ""
    },
    {
        "source": "The [simd proposal][simd] for WebAssembly added a new `v128` type for a",
        "suggest": "WebAssembly 的 [simd proposal][simd] 添加了一个新的 `v128` 类型，用于",
        "translate": ""
    },
    {
        "source": "It also added a large array of instructions to operate on the `v128` type to perform data processing.",
        "suggest": "它还添加了大量指令以对 `v128` 类型进行操作以执行数据处理。",
        "translate": ""
    },
    {
        "source": "Using SIMD on wasm is intended to be similar to as you would on `x86_64`, for example.",
        "suggest": "例如，在 wasm 上使用 SIMD 与在 `x86_64` 上使用类似。",
        "translate": ""
    },
    {
        "source": "Unlike `x86_64`, however, WebAssembly does not currently have dynamic detection at runtime as to whether SIMD is supported (this is one of the motivators for the [conditional sections][condsections] and [feature detection] proposals, but that is still pretty early days).",
        "suggest": "然而，与 `x86_64` 不同的是，WebAssembly 目前没有在运行时动态检测是否支持 SIMD (这是 [conditional sections][condsections] 和 [feature detection] 提案的动机之一，但这还处于早期阶段)。",
        "translate": ""
    },
    {
        "source": "Note that this does not include the standard library unless you [recompile the standard library][buildstd].",
        "suggest": "请注意，除非您使用 [recompile the standard library][buildstd]，否则这不包括标准库。",
        "translate": ""
    },
    {
        "source": "The argument `MEM` is the numerical index of which memory to return the size of.",
        "suggest": "参数 `MEM` 是返回内存大小的数字索引。",
        "translate": ""
    },
    {
        "source": "This type corresponds to the `v128` type in the [WebAssembly SIMD proposal](https://github.com/webassembly/simd).",
        "suggest": "此类型对应于 [WebAssembly SIMD proposal](https://github.com/webassembly/simd) 中的 `v128` 类型。",
        "translate": ""
    },
    {
        "source": "This type is 128-bits large and the meaning of all the bits is defined within the context of how this value is used.",
        "suggest": "此类型为 128 位大，所有位的含义在如何使用此值的上下文中定义。",
        "translate": ""
    },
    {
        "source": "This same type is used simultaneously for all 128-bit-wide SIMD types, for example:",
        "suggest": "该相同类型同时用于所有 128 位宽的 SIMD 类型，例如:",
        "translate": ""
    },
    {
        "source": "sixteen 8-bit integers (both `i8` and `u8`)",
        "suggest": "十六个 8 位整数 (`i8` 和 `u8`)",
        "translate": ""
    },
    {
        "source": "eight 16-bit integers (both `i16` and `u16`)",
        "suggest": "八个 16 位整数 (`i16` 和 `u16`)",
        "translate": ""
    },
    {
        "source": "four 32-bit integers (both `i32` and `u32`)",
        "suggest": "四个 32 位整数 (`i32` 和 `u32`)",
        "translate": ""
    },
    {
        "source": "two 64-bit integers (both `i64` and `u64`)",
        "suggest": "两个 64 位整数 (`i64` 和 `u64`)",
        "translate": ""
    },
    {
        "source": "four 32-bit floats (`f32`)",
        "suggest": "四个 32 位浮点数 (`f32`)",
        "translate": ""
    },
    {
        "source": "two 64-bit floats (`f64`)",
        "suggest": "两个 64 位浮点数 (`f64`)",
        "translate": ""
    },
    {
        "source": "The `v128` type in Rust is intended to be quite analagous to the `v128` type in WebAssembly.",
        "suggest": "Rust 中的 `v128` 类型旨在与 WebAssembly 中的 `v128` 类型非常相似。",
        "translate": ""
    },
    {
        "source": "Operations on `v128` can only be performed with the functions in this module.",
        "suggest": "`v128` 的操作只能通过本模块的函数进行。",
        "translate": ""
    },
    {
        "source": "Load a 32-bit element into the low bits of the vector and sets all other bits to zero.",
        "suggest": "将 32 位元素加载到 vector 的低位并将所有其他位设置为零。",
        "translate": ""
    },
    {
        "source": "Load a 64-bit element into the low bits of the vector and sets all other bits to zero.",
        "suggest": "将 64 位元素加载到 vector 的低位并将所有其他位设置为零。",
        "translate": ""
    },
    {
        "source": "Loads an 8-bit value from `m` and sets lane `L` of `v` to that value.",
        "suggest": "从 `m` 加载一个 8 位值并将 `v` 的通道 `L` 设置为该值。",
        "translate": ""
    },
    {
        "source": "Loads a 16-bit value from `m` and sets lane `L` of `v` to that value.",
        "suggest": "从 `m` 加载 16 位值并将 `v` 的通道 `L` 设置为该值。",
        "translate": ""
    },
    {
        "source": "Loads a 32-bit value from `m` and sets lane `L` of `v` to that value.",
        "suggest": "从 `m` 加载 32 位值并将 `v` 的通道 `L` 设置为该值。",
        "translate": ""
    },
    {
        "source": "Loads a 64-bit value from `m` and sets lane `L` of `v` to that value.",
        "suggest": "从 `m` 加载 64 位值并将 `v` 的通道 `L` 设置为该值。",
        "translate": ""
    },
    {
        "source": "Stores the 8-bit value from lane `L` of `v` into `m`",
        "suggest": "将来自 `v` 的 `L` 通道的 8 位值存储到 `m`",
        "translate": ""
    },
    {
        "source": "Stores the 16-bit value from lane `L` of `v` into `m`",
        "suggest": "将 `v` 的通道 `L` 的 16 位值存储到 `m`",
        "translate": ""
    },
    {
        "source": "Stores the 32-bit value from lane `L` of `v` into `m`",
        "suggest": "将来自 `v` 的 `L` 通道的 32 位值存储到 `m`",
        "translate": ""
    },
    {
        "source": "Stores the 64-bit value from lane `L` of `v` into `m`",
        "suggest": "将来自 `v` 的 `L` 通道的 64 位值存储到 `m`",
        "translate": ""
    },
    {
        "source": "Materializes a SIMD value from the provided operands.",
        "suggest": "从提供的操作数实现 SIMD 值。",
        "translate": ""
    },
    {
        "source": "If possible this will generate a `v128.const` instruction, otherwise it may be lowered to a sequence of instructions to materialize the vector value.",
        "suggest": "如果可能，这将生成一条 `v128.const` 指令，否则它可能会降低为一系列指令以实现向量值。",
        "translate": ""
    },
    {
        "source": "The `$a` and `$b` expressions must have type `v128`, and this function generates a wasm instruction that is encoded with 16 bytes providing the indices of the elements to return.",
        "suggest": "`$a` 和 `$b` 表达式必须具有 `v128` 类型，该函数生成一个 wasm 指令，该指令用 16 个字节编码，提供要返回的元素的索引。",
        "translate": ""
    },
    {
        "source": "Same as [`i8x16_shuffle`], except operates as if the inputs were eight",
        "suggest": "与 [`i8x16_shuffle`] 相同，只是操作起来好像输入是八个",
        "translate": ""
    },
    {
        "source": "Note that this will generate the `i8x16.shuffle` instruction, since there is no native `i16x8.shuffle` instruction (there is no need for one since `i8x16.shuffle` suffices).",
        "suggest": "请注意，这将生成 `i8x16.shuffle` 指令，因为没有原生 `i16x8.shuffle` 指令 (不需要一个，因为 `i8x16.shuffle` 就足够了)。",
        "translate": ""
    },
    {
        "source": "Same as [`i8x16_shuffle`], except operates as if the inputs were four",
        "suggest": "与 [`i8x16_shuffle`] 相同，但操作时如同输入为 4",
        "translate": ""
    },
    {
        "source": "Note that this will generate the `i8x16.shuffle` instruction, since there is no native `i32x4.shuffle` instruction (there is no need for one since `i8x16.shuffle` suffices).",
        "suggest": "请注意，这将生成 `i8x16.shuffle` 指令，因为没有原生 `i32x4.shuffle` 指令 (不需要一个，因为 `i8x16.shuffle` 就足够了)。",
        "translate": ""
    },
    {
        "source": "Same as [`i8x16_shuffle`], except operates as if the inputs were two",
        "suggest": "与 [`i8x16_shuffle`] 相同，但操作时就像输入是两个",
        "translate": ""
    },
    {
        "source": "Note that this will generate the `v8x16.shuffle` instruction, since there is no native `i64x2.shuffle` instruction (there is no need for one since `i8x16.shuffle` suffices).",
        "suggest": "请注意，这将生成 `v8x16.shuffle` 指令，因为没有原生 `i64x2.shuffle` 指令 (不需要一个，因为 `i8x16.shuffle` 就足够了)。",
        "translate": ""
    },
    {
        "source": "Extracts a lane from a 128-bit vector interpreted as 16 packed u8 numbers.",
        "suggest": "从解释为 16 个包装的 u8 数字的 128 位 vector 中提取一个通道。",
        "translate": ""
    }
]
