[
    {
        "source": "Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise OR of 512 bits (representing integer data) in a and b, and store the result in dst.",
        "suggest": "计算 a 和 b 中 512 位 (代表整数数据) 的按位或，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of 512 bits (representing integer data) in a and b, and store the result in dst.",
        "suggest": "计算 a 和 b 中 512 位 (代表整数数据) 的按位 XOR，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst.",
        "suggest": "计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "should be vpandnd",
        "suggest": "应该是 vpandnd",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of 512 bits (composed of packed 64-bit integers) in a and then AND with b, and store the results in dst.",
        "suggest": "计算 a 中的 512 位 (由包装的 64 位整数组成) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of 512 bits (representing integer data) in a and then AND with b, and store the result in dst.",
        "suggest": "计算 a 中的 512 位 (代表整数数据) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise AND of 16-bit masks a and b, and store the result in k.",
        "suggest": "计算 16 位掩码 a 和 b 的按位与，并将结果存储在 k 中。",
        "translate": ""
    },
    {
        "source": "generate normal and code instead of kandw",
        "suggest": "生成 normal 和 code 而不是 kandw",
        "translate": ""
    },
    {
        "source": "Compute the bitwise OR of 16-bit masks a and b, and store the result in k.",
        "suggest": "计算 16 位掩码 a 和 b 的按位或，并将结果存储在 k 中。",
        "translate": ""
    },
    {
        "source": "generate normal or code instead of korw",
        "suggest": "生成 normal 或 code 而不是 korw",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.",
        "suggest": "计算 16 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。",
        "translate": ""
    },
    {
        "source": "generate normal xor code instead of kxorw",
        "suggest": "生成普通的 xor 代码而不是 kxorw",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of 16-bit mask a, and store the result in k.",
        "suggest": "计算 16 位掩码 a 的按位非，并将结果存储在 k 中。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.",
        "suggest": "计算 16 位掩码 a 的按位非，然后与 b 计算 AND，并将结果存储在 k 中。",
        "translate": ""
    },
    {
        "source": "generate normal and, not code instead of kandnw",
        "suggest": "生成普通代码，而不是代码，而不是 kandnw",
        "translate": ""
    },
    {
        "source": "Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.",
        "suggest": "计算 16 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。",
        "translate": ""
    },
    {
        "source": "generate normal xor, not code instead of kxnorw",
        "suggest": "生成普通的 xor，而不是代码而不是 kxnorw",
        "translate": ""
    },
    {
        "source": "Copy 16-bit mask a to k.",
        "suggest": "将 16 位掩码 a 复制到 k。",
        "translate": ""
    },
    {
        "source": "generate normal and code instead of kmovw",
        "suggest": "生成 normal 和 code 而不是 kmovw",
        "translate": ""
    },
    {
        "source": "Converts integer mask into bitmask, storing the result in dst.",
        "suggest": "将整数掩码转换为位掩码，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Converts bit mask k1 into an integer value, storing the results in dst.",
        "suggest": "将位掩码 k1 转换为整数值，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Unpack and interleave 8 bits from masks a and b, and store the 16-bit result in k.",
        "suggest": "从掩码 a 和 b 解包并交织 8 位，并将 16 位结果存储在 k 中。",
        "translate": ""
    },
    {
        "source": "generate normal and code instead of kunpckbw",
        "suggest": "生成 normal 和 code 而不是 kunpckbw",
        "translate": ""
    },
    {
        "source": "Performs bitwise OR between k1 and k2, storing the result in dst.",
        "suggest": "在 k1 和 k2 之间执行按位或运算，将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "CF flag is set if dst consists of all 1's.",
        "suggest": "如果 dst 全为 1，则设置 CF 标志。",
        "translate": ""
    },
    {
        "source": "generate normal and code instead of kortestw",
        "suggest": "生成 normal 和 code 而不是 kortestw",
        "translate": ""
    },
    {
        "source": "Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.",
        "suggest": "计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.",
        "suggest": "计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。",
        "translate": ""
    },
    {
        "source": "Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from a into memory using a non-temporal memory hint.",
        "suggest": "使用非临时内存提示将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.",
        "suggest": "mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。",
        "translate": ""
    },
    {
        "source": "Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint.",
        "suggest": "使用非临时内存提示将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "should be vmovntpd",
        "suggest": "应该是 vmovntpd",
        "translate": ""
    },
    {
        "source": "Store 512-bits of integer data from a into memory using a non-temporal memory hint.",
        "suggest": "使用非临时内存提示将 512 位整数数据从 a 存储到内存中。",
        "translate": ""
    },
    {
        "source": "should be vmovntdq",
        "suggest": "应该是 vmovntdq",
        "translate": ""
    },
    {
        "source": "Sets packed 32-bit integers in `dst` with the supplied values.",
        "suggest": "使用提供的值在 `dst` 中设置包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Broadcast 64-bit float `a` to all elements of `dst`.",
        "suggest": "向 `dst` 的所有元素广播 64 位浮点数 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcast 32-bit float `a` to all elements of `dst`.",
        "suggest": "向 `dst` 的所有元素广播 32 位浮点数 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcast 8-bit integer a to all elements of dst.",
        "suggest": "向 dst 的所有元素广播 8 位整数 a。",
        "translate": ""
    },
    {
        "source": "Broadcast the low packed 16-bit integer from a to all all elements of dst.",
        "suggest": "将低包装的 16 位整数从 a 广播到 dst 的所有所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcast 32-bit integer `a` to all elements of `dst`.",
        "suggest": "向 `dst` 的所有元素广播 32 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。",
        "translate": ""
    },
    {
        "source": "Broadcast 64-bit integer `a` to all elements of `dst`.",
        "suggest": "向 `dst` 的所有元素广播 64 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。",
        "translate": ""
    },
    {
        "source": "Set packed 64-bit integers in dst with the repeated 4 element sequence.",
        "suggest": "使用重复的 4 个元素序列在 dst 中设置包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Set packed 64-bit integers in dst with the repeated 4 element sequence in reverse order.",
        "suggest": "在 dst 中设置包装的 64 位整数，并以相反的顺序重复 4 个元素序列。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素的小于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素不小于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否等于或小于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否不相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否都不是 NaN，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，以查看是否为 NaN，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否为 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装后的双精度 (64-bit) 浮点元素的小于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素的小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素不小于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否小于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否等于或小于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，看是否都不是 NaN，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，以查看其中一个是否为 NaN，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的双精度 (64-bit) 浮点元素以查看是否为 NaN，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not seti).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否小于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否大于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否不相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 32 位整数 (小于)，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 32 位整数 (小于等于)，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的 32 位整数是否相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的 32 位整数是否不相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装有符号 32 位整数，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否小于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否大于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否不相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 64 位整数，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数小于零，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数是否大于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的 64 位整数是否相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并将结果存储在掩码 vector k 中。",
        "translate": ""
    },
    {
        "source": "Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by addition.",
        "suggest": "通过加法减少包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the sum of all elements in a.",
        "suggest": "返回 a 中所有元素的总和。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by addition using mask k.",
        "suggest": "使用掩码 k 通过加法来减少 a 中包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the sum of all active elements in a.",
        "suggest": "返回 a 中所有活动元素的总和。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 64-bit integers in a by addition.",
        "suggest": "通过加法减少包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 64-bit integers in a by addition using mask k.",
        "suggest": "使用掩码 k 通过加法来减少 a 中包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed single-precision (32-bit) floating-point elements in a by addition.",
        "suggest": "此外，还减少了包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed single-precision (32-bit) floating-point elements in a by addition using mask k.",
        "suggest": "通过使用掩码 k 加法来减少包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed double-precision (64-bit) floating-point elements in a by addition.",
        "suggest": "另外，还减少了包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed double-precision (64-bit) floating-point elements in a by addition using mask k.",
        "suggest": "通过使用掩膜 k 加法来减少包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by multiplication.",
        "suggest": "通过乘法减少包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the product of all elements in a.",
        "suggest": "返回 a 中所有元素的乘积。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by multiplication using mask k.",
        "suggest": "使用掩码 k 通过乘以减少 a 中包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the product of all active elements in a.",
        "suggest": "返回 a 中所有活动元素的乘积。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 64-bit integers in a by multiplication.",
        "suggest": "通过乘法减少包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 64-bit integers in a by multiplication using mask k.",
        "suggest": "使用掩码 k 通过乘以减少 a 中包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication.",
        "suggest": "通过乘法减少包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication using mask k.",
        "suggest": "使用掩码 k 通过乘以减少 a 中包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication.",
        "suggest": "通过乘法减少包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication using mask k.",
        "suggest": "使用掩码 k 通过乘以减少 a 中包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed signed 32-bit integers in a by maximum.",
        "suggest": "最多减少包装的带符号 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the maximum of all elements in a.",
        "suggest": "返回 a 中所有元素的最大值。",
        "translate": ""
    },
    {
        "source": "Reduce the packed signed 32-bit integers in a by maximum using mask k.",
        "suggest": "使用掩码 k 最多减少 a 中的包装有符号 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the maximum of all active elements in a.",
        "suggest": "返回 a 中所有活动元素的最大值。",
        "translate": ""
    },
    {
        "source": "Reduce the packed signed 64-bit integers in a by maximum.",
        "suggest": "最大减少包装的带符号的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed signed 64-bit integers in a by maximum using mask k.",
        "suggest": "使用掩码 k 最大减少包装的带符号的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed unsigned 32-bit integers in a by maximum.",
        "suggest": "最多减少包装的无符号 32 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed unsigned 32-bit integers in a by maximum using mask k.",
        "suggest": "使用掩码 k 最大减少包装的无符号 32 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed unsigned 64-bit integers in a by maximum.",
        "suggest": "最多减少包装的无符号 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed unsigned 64-bit integers in a by maximum using mask k.",
        "suggest": "使用掩码 k 最大减少包装的无符号 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed single-precision (32-bit) floating-point elements in a by maximum.",
        "suggest": "最大减少包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k.",
        "suggest": "最多使用掩码 k 减少包装后的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed double-precision (64-bit) floating-point elements in a by maximum.",
        "suggest": "最大减少包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k.",
        "suggest": "使用掩码 k 最多减少 a 中包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Reduce the packed signed 32-bit integers in a by minimum.",
        "suggest": "将包装的有符号的 32 位整数减少到最小值。",
        "translate": ""
    },
    {
        "source": "Returns the minimum of all elements in a.",
        "suggest": "返回 a 中所有元素的最小值。",
        "translate": ""
    },
    {
        "source": "Reduce the packed signed 64-bit integers in a by minimum.",
        "suggest": "将一个包装的有符号 64 位整数减少到最小值。",
        "translate": ""
    },
    {
        "source": "Reduce the packed unsigned 32-bit integers in a by minimum.",
        "suggest": "将一个包装的无符号 32 位整数减少到最小值。",
        "translate": ""
    },
    {
        "source": "Reduce the packed unsigned 64-bit integers in a by minimum.",
        "suggest": "将一个包装的无符号 64 位整数减少到最小。",
        "translate": ""
    },
    {
        "source": "Reduce the packed single-precision (32-bit) floating-point elements in a by minimum.",
        "suggest": "将一个包装的单精度（32位）浮点元素减少到最小。",
        "translate": ""
    },
    {
        "source": "Reduce the packed double-precision (64-bit) floating-point elements in a by minimum.",
        "suggest": "将一个包装的双精度（64位）浮点元素减少到最小。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by bitwise AND.",
        "suggest": "通过按位 AND 减少包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the bitwise AND of all elements in a.",
        "suggest": "返回 a 中所有元素的按位与。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by bitwise AND using mask k.",
        "suggest": "使用掩码 k 按位与减少包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the bitwise AND of all active elements in a.",
        "suggest": "返回 a 中所有活动元素的按位与。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 64-bit integers in a by bitwise AND.",
        "suggest": "通过按位 AND 减少包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by bitwise OR.",
        "suggest": "通过按位 OR 减少包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the bitwise OR of all elements in a.",
        "suggest": "返回 a 中所有元素的按位或。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 32-bit integers in a by bitwise OR using mask k.",
        "suggest": "使用掩码 k 按位或减少包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Returns the bitwise OR of all active elements in a.",
        "suggest": "返回 a 中所有活动元素的按位或。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 64-bit integers in a by bitwise OR.",
        "suggest": "通过按位 OR 减少包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Reduce the packed 64-bit integers in a by bitwise OR using mask k.",
        "suggest": "使用掩码 k 按位或减少包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Returns vector of type `__m512d` with undefined elements.",
        "suggest": "返回带有未定义元素的 `__m512d` 类型的 vector。",
        "translate": ""
    },
    {
        "source": "Returns vector of type `__m512` with undefined elements.",
        "suggest": "返回带有未定义元素的 `__m512` 类型的 vector。",
        "translate": ""
    },
    {
        "source": "Return vector of type __m512i with undefined elements.",
        "suggest": "返回类型为 __m512i 的 vector，其中包含未定义的元素。",
        "translate": ""
    },
    {
        "source": "Return vector of type __m512 with undefined elements.",
        "suggest": "返回类型为 __m512 的 vector，其中包含未定义的元素。",
        "translate": ""
    },
    {
        "source": "Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst.",
        "suggest": "将 512 位 (由 16 个包装的 32 位整数组成) 从 dst 加载。",
        "translate": ""
    },
    {
        "source": "Store 512-bits (composed of 16 packed 32-bit integers) from a into memory.",
        "suggest": "将 a 中的 512 位 (由 16 个包装的 32 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst.",
        "suggest": "将 512 位 (由 8 个包装的 64 位整数组成) 从 dst 加载。",
        "translate": ""
    },
    {
        "source": "should be vmovdqu64",
        "suggest": "应该是 vmovdqu64",
        "translate": ""
    },
    {
        "source": "Store 512-bits (composed of 8 packed 64-bit integers) from a into memory.",
        "suggest": "将 a 中的 512 位 (由 8 个包装的 64 位整数组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Load 512-bits of integer data from memory into dst.",
        "suggest": "将 512 位整数数据从内存加载到 dst 中。",
        "translate": ""
    },
    {
        "source": "Store 512-bits of integer data from a into memory.",
        "suggest": "将 a 中的 512 位整数数据存储到内存中。",
        "translate": ""
    },
    {
        "source": "Loads 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into result.",
        "suggest": "从内存中加载 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 到结果中。",
        "translate": ""
    },
    {
        "source": "Stores 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from `a` into memory.",
        "suggest": "将来自 `a` 的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Loads 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into result.",
        "suggest": "从内存中将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。",
        "translate": ""
    },
    {
        "source": "Stores 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from `a` into memory.",
        "suggest": "将来自 `a` 的 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "should be vmovdqa32",
        "suggest": "应该是 vmovdqa32",
        "translate": ""
    },
    {
        "source": "should be vmovdqa64",
        "suggest": "应该是 vmovdqa64",
        "translate": ""
    },
    {
        "source": "Load 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into dst.",
        "suggest": "将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 从 dst 加载。",
        "translate": ""
    },
    {
        "source": "Load 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into dst.",
        "suggest": "将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 从 dst 加载。",
        "translate": ""
    },
    {
        "source": "should be vmovapd",
        "suggest": "应该是 vmovapd",
        "translate": ""
    },
    {
        "source": "Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory.",
        "suggest": "将 a 中的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Set packed double-precision (64-bit) floating-point elements in dst with the supplied values in reverse order.",
        "suggest": "在 dst 中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序提供所提供的值。",
        "translate": ""
    },
    {
        "source": "Set packed double-precision (64-bit) floating-point elements in dst with the supplied values.",
        "suggest": "使用提供的值在 dst 中设置包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用写掩码 k 将低位单精度 (32-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高 3 个包装的元素从 a 复制到高位 dst 的元素。",
        "translate": ""
    },
    {
        "source": "Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用零掩码 k 将较低的单精度 (32-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的 3 个包装的元素从 a 复制到较高的元素 dst。",
        "translate": ""
    },
    {
        "source": "Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用写掩码 k 将低位双精度 (64-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高位元素从 a 复制到 a 的高位元素 dst。",
        "translate": ""
    },
    {
        "source": "Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用零掩码 k 将较低的双精度 (64-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时，该元素是从 src 复制的)，并复制高位 3 从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素归零)，并复制较高的 3 个包装的元素从 a 到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并从中复制较高的元素。a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从 a 中复制较高的元素到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "从 a 中的较低单精度 (32-bit) 浮点元素减去 b 中的较低单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "从 a 中的较低单精度 (32-bit) 浮点元素中减去 b 中的较低单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时，该元素是从 src 复制的 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制包装后的高 3 位元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 个包装的元素从 a 到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并从中复制上部元素。a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的低位双精度 (64-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时该元素归零)，然后从 a 中复制高位元素到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 时，该元素从 src 复制 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 为 0 时，该元素清零) (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 为 0 时，该元素归零 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制较高的元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中下部单精度 (32-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。",
        "translate": ""
    },
    {
        "source": "Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制高 3 从 a 到 dst 的上层元素的包装的元素。",
        "translate": ""
    },
    {
        "source": "Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的高位元素的前 3 个包装的元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上层元素的上 3 个包装的元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中较低的双精度 (64-bit) 浮点元素的近似平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的上元素的上元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上元素的上元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中下部单精度 (32-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 x 元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制较高元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，将结果存储在 dst 的较低元素中，并从 a 中复制较高的 3 个包装的元素到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "This intrinsic essentially calculates floor(log2(x)) for the lower element.",
        "suggest": "本质上，此内联函数计算下部元素的 floor(log2(x))。",
        "translate": ""
    },
    {
        "source": "Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置掩码位 0 时)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，将结果存储在 dst 的低位元素中，并将高位元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置屏蔽位 0 时)，然后将 a 的高位元素复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，然后将较高的元素从 a 复制到 dst 的较高的元素。",
        "translate": ""
    },
    {
        "source": "Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制高 3 从 a 到 dst 的上层元素的包装的元素。",
        "translate": ""
    },
    {
        "source": "Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后复制高位 3 从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "标准化 b 中下部双精度 (64-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后从中复制较高元素。a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中的下部单精度 (32-bit) 浮点元素四舍五入为 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上面的 3 个包装的元素从 a 复制到 dst 的上面的元素。",
        "translate": ""
    },
    {
        "source": "Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中的下部双精度 (64-bit) 浮点元素四舍五入为 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上一个元素从 a 复制到 dst 的上一个元素。",
        "translate": ""
    },
    {
        "source": "Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用 b 中的值缩放 a 中的包装的单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素 (未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。",
        "translate": ""
    },
    {
        "source": "Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 从 a 到 dst 的上层元素的包装的元素。",
        "translate": ""
    },
    {
        "source": "Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果添加到 dst 较低元素中 (当未使用 mask bit 0 时从 a 复制该元素设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的中间结果相加到 dst 较低元素中 (未设置掩码位 0 时该元素归零) )，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果存储到 dst 较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并使用 writemask k 将中间结果添加到 dst 较低元素中的较低元素 in c. Store 的结果 (当未使用掩码位 0 时从 a 复制该元素) set)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的结果加到 dst 较低元素中 (当未设置掩码位 0 时该元素归零) )，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与较低的元素 in c. Store 的结果相加，使用 writemask k 在 dst 的较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的上部元素复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result.",
        "suggest": "将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 a 复制该元素)，然后将 a 的上部元素复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时，该元素是从 a 复制的 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将取反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 a 复制 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的上部元素复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result.",
        "suggest": "将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高位元素从 a 复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "从 a 中的下部单精度 (32-bit) 浮点元素中减去 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。",
        "translate": ""
    },
    {
        "source": "Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。",
        "translate": ""
    },
    {
        "source": "Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 中的下部双精度 (64-bit) 浮点元素除以 b 中的下部双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最大值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最大值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最小值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst , and copy the upper element from a to the upper element of dst.",
        "suggest": "比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最小值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "计算 b 中较低的双精度 (64-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后将取反的中间结果与较低元素 in c. Store 相加，将结果与 dst 的较低元素相乘，然后将较高的 3 个包装的元素从 a 复制到 dst。",
        "translate": ""
    },
    {
        "source": "Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后将求和的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素中。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的下部元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到上部 dst 的元素。",
        "translate": ""
    },
    {
        "source": "Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result.",
        "suggest": "将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.",
        "suggest": "使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用 c 中的低 32 位整数修复 a 和 b 中的低位单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 a 的高位元素 dst。",
        "translate": ""
    },
    {
        "source": "Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用 c 中的较低 32 位整数修复 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用 c 中的较低 32 位整数固定 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当未使用掩码 bit 0 时该元素被清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 c 中的较低 64 位整数修复 a 和 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。",
        "translate": ""
    },
    {
        "source": "Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当不使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将上层元素从 a 复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将上部的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.",
        "suggest": "将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.",
        "suggest": "将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.",
        "suggest": "将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.",
        "suggest": "将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将无符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Convert the signed 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将带符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.",
        "suggest": "将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Convert the unsigned 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将无符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的低位元素中，然后将 a 的高位元素复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Convert the unsigned 64-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "将无符号的 64 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "should be vcvtusi2ss",
        "suggest": "应该是 vcvtusi2ss",
        "translate": ""
    },
    {
        "source": "Convert the unsigned 64-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将无符号的 64 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。",
        "translate": ""
    },
    {
        "source": "should be vcvtusi2sd",
        "suggest": "应该是 vcvtusi2sd",
        "translate": ""
    },
    {
        "source": "Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并返回布尔结果 (0 或 1)。",
        "translate": ""
    },
    {
        "source": "should be vcomiss",
        "suggest": "应该是 vcomiss",
        "translate": ""
    },
    {
        "source": "Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).",
        "suggest": "根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并返回布尔结果 (0 或 1)。",
        "translate": ""
    },
    {
        "source": "should be vcomisd",
        "suggest": "应该是 vcomisd",
        "translate": ""
    },
    {
        "source": "Not less-than",
        "suggest": "不小于",
        "translate": ""
    },
    {
        "source": "Not less-than-or-equal",
        "suggest": "不小于等于",
        "translate": ""
    },
    {
        "source": "interval [1, 2)",
        "suggest": "间隔 [1，2)",
        "translate": ""
    },
    {
        "source": "interval [0.5, 2)",
        "suggest": "间隔 [0.5，2)",
        "translate": ""
    },
    {
        "source": "interval [0.5, 1)",
        "suggest": "间隔 [0.5，1)",
        "translate": ""
    },
    {
        "source": "interval [0.75, 1.5)",
        "suggest": "间隔 [0.75，1.5)",
        "translate": ""
    },
    {
        "source": "DEST = NaN if sign(SRC) = 1",
        "suggest": "如果 sign(SRC) =1，则 DEST=NaN",
        "translate": ""
    },
    {
        "source": "from clang",
        "suggest": "来自于 clang",
        "translate": ""
    },
    {
        "source": "64 bytes",
        "suggest": "64 字节",
        "translate": ""
    },
    {
        "source": "Galois Field New Instructions (GFNI)",
        "suggest": "Galois Field 新说明 (GFNI)",
        "translate": ""
    },
    {
        "source": "LLVM requires AVX512BW for a lot of these instructions, see",
        "suggest": "LLVM 需要 AVX512BW 来获取许多这些指令，请参见",
        "translate": ""
    },
    {
        "source": "however our tests also require the target feature list to match Intel's which *doesn't* require AVX512BW but only AVX512F, so we added the redundant AVX512F requirement (for now) also see",
        "suggest": "但是，我们的测试还要求目标功能列表与英特尔的功能列表相匹配，而 *不需要* 要求 AVX512BW 但仅要求 AVX512F，因此我们添加了冗余的 AVX512F 要求 (目前) 也请参见",
        "translate": ""
    },
    {
        "source": "for forcing GFNI, BW and optionally VL extension",
        "suggest": "用于强制 GFNI，BW 和可选的 VL 扩展",
        "translate": ""
    },
    {
        "source": "Performs a multiplication in GF(2^8) on the packed bytes.",
        "suggest": "在包装的字节上执行 GF(2^8) 乘法。",
        "translate": ""
    },
    {
        "source": "The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.",
        "suggest": "该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。",
        "translate": ""
    },
    {
        "source": "Performs an affine transformation on the packed bytes in x.",
        "suggest": "对 x 中的包装字节执行仿射变换。",
        "translate": ""
    },
    {
        "source": "That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value.",
        "suggest": "也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。",
        "translate": ""
    },
    {
        "source": "Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.",
        "suggest": "x 中每 8 字节的包在 a 中的相同位置与 64 位字配对。",
        "translate": ""
    },
    {
        "source": "Performs an affine transformation on the inverted packed bytes in x.",
        "suggest": "对 x 中的反向包装的字节执行仿射变换。",
        "translate": ""
    },
    {
        "source": "That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value.",
        "suggest": "也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。",
        "translate": ""
    },
    {
        "source": "The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.",
        "suggest": "相对于简化多项式 x^8+x^4+x^3+x+1 定义字节的倒数。",
        "translate": ""
    },
    {
        "source": "The inverse of 0 is 0.",
        "suggest": "0 的倒数是 0。",
        "translate": ""
    },
    {
        "source": "this implementation follows the description in",
        "suggest": "此实现遵循",
        "translate": ""
    },
    {
        "source": "Carryless multiplication",
        "suggest": "无进位乘法",
        "translate": ""
    },
    {
        "source": "reduction, adding in \"0\" where appropriate to clear out high bits note that REDUCTION_POLYNOMIAL is zero in this context",
        "suggest": "减少，在适当的地方添加 \"0\" 来清除高位，请注意，在这种情况下 REDUCTION_POLYNOMIAL 为零",
        "translate": ""
    },
    {
        "source": "validate inversion",
        "suggest": "验证反演",
        "translate": ""
    },
    {
        "source": "validate subsequent affine operation",
        "suggest": "验证后续的仿射操作",
        "translate": ""
    },
    {
        "source": "validate everything by virtue of checking against the AES SBox",
        "suggest": "通过检查 AES SBox 来验证所有内容",
        "translate": ""
    },
    {
        "source": "Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result.",
        "suggest": "将 `b` 和 `c` 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。",
        "translate": ""
    },
    {
        "source": "Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.",
        "suggest": "将中间结果的高 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。",
        "translate": ""
    },
    {
        "source": "Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.",
        "suggest": "将中间结果的低 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。",
        "translate": ""
    },
    {
        "source": "Vectorized AES Instructions (VAES)",
        "suggest": "向量化 AES 指令 (VAES)",
        "translate": ""
    },
    {
        "source": "Performs one round of an AES encryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.",
        "suggest": "使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行一轮 AES 加密流程。",
        "translate": ""
    },
    {
        "source": "Performs the last round of an AES encryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.",
        "suggest": "使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行最后一轮 AES 加密流程。",
        "translate": ""
    },
    {
        "source": "Performs one round of an AES decryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.",
        "suggest": "使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行一轮 AES 解密流程。",
        "translate": ""
    },
    {
        "source": "Performs the last round of an AES decryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.",
        "suggest": "使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行最后一轮 AES 解密流程。",
        "translate": ""
    },
    {
        "source": "the first parts of these tests are straight ports from the AES-NI tests the second parts directly compare the two, for inputs that are different across lanes and \"more random\" than the standard test vectors ideally we'd be using quickcheck here instead",
        "suggest": "这些测试的第一部分是 AES-NI 测试的直接端口，第二部分直接比较两者，对于跨通道和 \"more random\" 的输入与标准测试 vectors 不同的输入，理想情况下，我们将在此处使用 quickcheck",
        "translate": ""
    },
    {
        "source": "they are repeated appropriately",
        "suggest": "适当地重复它们",
        "translate": ""
    },
    {
        "source": "Vectorized Carry-less Multiplication (VCLMUL)",
        "suggest": "向量化的无进位乘法 (VCLMUL)",
        "translate": ""
    },
    {
        "source": "The reference is [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2: Instruction Set Reference, A-Z][intel64_ref] (p. 4-241).",
        "suggest": "引用的是 [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2: Instruction Set Reference, A-Z][intel64_ref] (第 4-241 页)。",
        "translate": ""
    },
    {
        "source": "for some odd reason on x86_64 we generate the correct long name instructions but on i686 we generate the short name + imm8 so we need to special-case on that...",
        "suggest": "出于某些奇怪的原因，我们在 x86_64 上生成了正确的长名称指令，但在 i686 上，我们生成了短名称 + imm8，因此我们需要对此进行特殊处理...",
        "translate": ""
    },
    {
        "source": "Performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2^k) - in each of the 4 128-bit lanes.",
        "suggest": "在 4 个 128 位通道中的每一个中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。",
        "translate": ""
    },
    {
        "source": "The immediate byte is used for determining which halves of each lane `a` and `b` should be used.",
        "suggest": "immediate 字节用于确定应使用每个通道 `a` 和 `b` 的哪一半。",
        "translate": ""
    },
    {
        "source": "Immediate bits other than 0 and 4 are ignored.",
        "suggest": "0 和 4 以外的 immediate 位将被忽略。",
        "translate": ""
    },
    {
        "source": "All lanes share immediate byte.",
        "suggest": "所有通道共享 immediate 字节。",
        "translate": ""
    },
    {
        "source": "technically according to Intel's documentation we don't need avx512f here, however LLVM gets confused otherwise",
        "suggest": "从技术上讲，根据英特尔的文档，在这里我们不需要 avx512f，但是 LLVM 会引起混淆",
        "translate": ""
    },
    {
        "source": "Performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2^k) - in each of the 2 128-bit lanes.",
        "suggest": "在 2 个 128 位通道中的每个通道中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。",
        "translate": ""
    },
    {
        "source": "this function tests one of the possible 4 instances with different inputs across lanes",
        "suggest": "此函数使用跨通道的不同输入测试可能的 4 个实例之一",
        "translate": ""
    },
    {
        "source": "this function tests one of the possible 4 instances with different inputs across lanes for the VL version",
        "suggest": "对于 VL 版本，此函数使用跨通道的不同输入测试可能的 4 个实例之一",
        "translate": ""
    },
    {
        "source": "Vectorized Population Count Instructions for Double- and Quadwords (VPOPCNTDQ)",
        "suggest": "Double 和 Quadwords (VPOPCNTDQ) 的矢量化人口计数说明",
        "translate": ""
    },
    {
        "source": "For each packed 32-bit integer maps the value to the number of logical 1 bits.",
        "suggest": "对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。",
        "translate": ""
    },
    {
        "source": "For each packed 64-bit integer maps the value to the number of logical 1 bits.",
        "suggest": "对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。",
        "translate": ""
    },
    {
        "source": "Bit Manipulation Instruction (BMI) Set 1.0.",
        "suggest": "位操作指令 (BMI) 设置 1.0。",
        "translate": ""
    },
    {
        "source": "Extracts bits in range [`start`, `start` + `length`) from `a` into the least significant bits of the result.",
        "suggest": "从 `a` 提取范围为 [start，`start` + `length`) 的位到结果的最低有效位。",
        "translate": ""
    },
    {
        "source": "Extracts bits of `a` specified by `control` into the least significant bits of the result.",
        "suggest": "将 `control` 指定的 `a` 的位提取到结果的最低有效位中。",
        "translate": ""
    },
    {
        "source": "Bits `[7,0]` of `control` specify the index to the first bit in the range to be extracted, and bits `[15,8]` specify the length of the range.",
        "suggest": "`control` 的位 `[7,0]` 指定要提取的范围中第一位的索引，而 `[15,8]` 的位指定范围的长度。",
        "translate": ""
    },
    {
        "source": "Bitwise logical `AND` of inverted `a` with `b`.",
        "suggest": "`a` 和 `b` 的按位逻辑 `AND`。",
        "translate": ""
    },
    {
        "source": "Extracts lowest set isolated bit.",
        "suggest": "提取最低位隔离位。",
        "translate": ""
    },
    {
        "source": "Gets mask up to lowest set bit.",
        "suggest": "将掩码提高到最低设置位。",
        "translate": ""
    },
    {
        "source": "Resets the lowest set bit of `x`.",
        "suggest": "复位 `x` 的最低位。",
        "translate": ""
    },
    {
        "source": "If `x` is sets CF.",
        "suggest": "如果 `x` 设置为 CF。",
        "translate": ""
    },
    {
        "source": "Counts the number of trailing least significant zero bits.",
        "suggest": "计算尾随的最低有效零位的数量。",
        "translate": ""
    },
    {
        "source": "When the source operand is `0`, it returns its size in bits.",
        "suggest": "当源操作数为 `0` 时，它将返回其大小 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "test the behavior when the input is `0`.",
        "suggest": "测试输入为 `0` 时的行为。",
        "translate": ""
    },
    {
        "source": "Bit Manipulation Instruction (BMI) Set 2.0.",
        "suggest": "位操作指令 (BMI) 设置 2.0。",
        "translate": ""
    },
    {
        "source": "Unsigned multiply without affecting flags.",
        "suggest": "无符号乘法，且不影响标志。",
        "translate": ""
    },
    {
        "source": "Unsigned multiplication of `a` with `b` returning a pair `(lo, hi)` with the low half and the high half of the result.",
        "suggest": "`a` 与 `b` 的无符号乘法返回一对 `(lo, hi)`，其结果的下半部分和上半部分。",
        "translate": ""
    },
    {
        "source": "LLVM BUG (should be mulxl):",
        "suggest": "LLVM 错误 (应为 mulxl) :",
        "translate": ""
    },
    {
        "source": "Zeroes higher bits of `a` >= `index`.",
        "suggest": "将 `a` >= `index` 的高位清零。",
        "translate": ""
    },
    {
        "source": "Scatter contiguous low order bits of `a` to the result at the positions specified by the `mask`.",
        "suggest": "将 `a` 的连续低阶位分散到 `mask` 指定的位置处的结果中。",
        "translate": ""
    },
    {
        "source": "Gathers the bits of `x` specified by the `mask` into the contiguous low order bit positions of the result.",
        "suggest": "将 `mask` 指定的 `x` 的位收集到结果的连续低阶位位置。",
        "translate": ""
    },
    {
        "source": "Byte swap intrinsics.",
        "suggest": "字节交换内联函数。",
        "translate": ""
    },
    {
        "source": "Returns an integer with the reversed byte order of x",
        "suggest": "返回整数，其字节顺序为 x",
        "translate": ""
    },
    {
        "source": "Returns the bit in position `b` of the memory addressed by `p`.",
        "suggest": "返回由 `p` 寻址的存储器的位置 `b` 中的位。",
        "translate": ""
    },
    {
        "source": "Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`.",
        "suggest": "返回由 `p` 寻址的存储器的位置 `b` 中的位，然后将该位设置为 `1`。",
        "translate": ""
    },
    {
        "source": "Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`.",
        "suggest": "返回由 `p` 寻址的存储器的位置 `b` 中的位，然后将该位重置为 `0`。",
        "translate": ""
    },
    {
        "source": "Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit.",
        "suggest": "返回由 `p` 寻址的存储器的位置 `b` 中的位，然后将该位取反。",
        "translate": ""
    },
    {
        "source": "Result of the `cpuid` instruction.",
        "suggest": "`cpuid` 指令的结果。",
        "translate": ""
    },
    {
        "source": "the derived impl of Debug for CpuidResult is not #[inline] and that's OK.",
        "suggest": "CpuidResult 的 Debug 派生的暗示不是 #[inline]，这没关系。",
        "translate": ""
    },
    {
        "source": "EAX register.",
        "suggest": "EAX 寄存器。",
        "translate": ""
    },
    {
        "source": "EBX register.",
        "suggest": "EBX 寄存器。",
        "translate": ""
    },
    {
        "source": "ECX register.",
        "suggest": "ECX 寄存器。",
        "translate": ""
    },
    {
        "source": "EDX register.",
        "suggest": "EDX 寄存器。",
        "translate": ""
    },
    {
        "source": "Returns the result of the `cpuid` instruction for a given `leaf` (`EAX`) and `sub_leaf` (`ECX`).",
        "suggest": "返回给定 `leaf` (`EAX`) 和 `sub_leaf` (`ECX`) 的 `cpuid` 指令的结果。",
        "translate": ""
    },
    {
        "source": "The highest-supported leaf value is returned by the first tuple argument of [`__get_cpuid_max(0)`](fn.__get_cpuid_max.html).",
        "suggest": "[`__get_cpuid_max(0)`](fn.__get_cpuid_max.html) 的第一个元组参数返回支持的最高叶子值。",
        "translate": ""
    },
    {
        "source": "For leaves containung sub-leaves, the second tuple argument returns the highest-supported sub-leaf value.",
        "suggest": "对于叶子包含子叶，第二个元组参数返回支持的最高子叶值。",
        "translate": ""
    },
    {
        "source": "The [CPUID Wikipedia page][wiki_cpuid] contains how to query which information using the `EAX` and `ECX` registers, and the interpretation of the results returned in `EAX`, `EBX`, `ECX`, and `EDX`.",
        "suggest": "[CPUID Wikipedia page][wiki_cpuid] 包含如何使用 `EAX` 和 `ECX` 寄存器查询哪些信息，以及如何解释 `EAX`，`EBX`，`ECX` 和 `EDX` 返回的结果。",
        "translate": ""
    },
    {
        "source": "x86-64 uses %rbx as the base register, so preserve it.",
        "suggest": "x86-64 使用 %rbx 作为基址寄存器，因此保留它。",
        "translate": ""
    },
    {
        "source": "This works around a bug in LLVM with ASAN enabled:",
        "suggest": "这可以解决启用 ASAN 的 LLVM 中的错误:",
        "translate": ""
    },
    {
        "source": "See [`__cpuid_count`](fn.__cpuid_count.html).",
        "suggest": "请参见 [`__cpuid_count`](fn.__cpuid_count.html)。",
        "translate": ""
    },
    {
        "source": "Does the host support the `cpuid` instruction?",
        "suggest": "主机是否支持 `cpuid` 指令?",
        "translate": ""
    },
    {
        "source": "Optimization for i586 and i686 Rust targets which SSE enabled and support cpuid:",
        "suggest": "对 i586 和 i686 Rust 的优化目标是启用了 SSE 并支持 cpuid 的目标:",
        "translate": ""
    },
    {
        "source": "If SSE is not enabled, detect whether cpuid is available:",
        "suggest": "如果未启用 SSE，请检测 cpuid 是否可用:",
        "translate": ""
    },
    {
        "source": "On `x86` the `cpuid` instruction is not always available.",
        "suggest": "在 `x86` 上，`cpuid` 指令并非始终可用。",
        "translate": ""
    },
    {
        "source": "This follows the approach indicated in:",
        "suggest": "这遵循以下指示的方法:",
        "translate": ""
    },
    {
        "source": "which detects whether `cpuid` is available by checking whether the 21st bit of the EFLAGS register is modifiable or not.",
        "suggest": "它通过检查 EFLAGS 寄存器的第 21 位是否可修改来检测 `cpuid` 是否可用。",
        "translate": ""
    },
    {
        "source": "If it is, then `cpuid` is available.",
        "suggest": "如果是，则 `cpuid` 可用。",
        "translate": ""
    },
    {
        "source": "There is a race between popfd (A) and pushfd (B) where other bits beyond 21st may have been modified due to interrupts, a debugger stepping through the asm, etc.",
        "suggest": "popfd (A) 和 pushfd (B) 之间存在竞争，由于中断，调试器逐步通过 asm 等原因，可能已修改了 21st 之后的其他位。",
        "translate": ""
    },
    {
        "source": "Therefore, explicitly check whether the 21st bit was modified or not.",
        "suggest": "因此，明确检查第 21 位是否被修改。",
        "translate": ""
    },
    {
        "source": "If the result is zero, the cpuid bit was not modified.",
        "suggest": "如果结果为零，则未修改 cpuid 位。",
        "translate": ""
    },
    {
        "source": "If the result is `0x200000` (non-zero), then the cpuid was correctly modified and the CPU supports the cpuid instruction:",
        "suggest": "如果结果为 `0x200000` (non-zero)，则说明 cpuid 已正确修改，并且 CPU 支持 cpuid 指令:",
        "translate": ""
    },
    {
        "source": "Returns the highest-supported `leaf` (`EAX`) and sub-leaf (`ECX`) `cpuid` values.",
        "suggest": "返回最高支持的 `leaf` (`EAX`) 和子叶 (`ECX`) `cpuid` 值。",
        "translate": ""
    },
    {
        "source": "If `cpuid` is supported, and `leaf` is zero, then the first tuple argument contains the highest `leaf` value that `cpuid` supports.",
        "suggest": "如果支持 `cpuid`，并且 `leaf` 为零，则第一个元组参数包含 `cpuid` 支持的最高 `leaf` 值。",
        "translate": ""
    },
    {
        "source": "For `leaf`s containing sub-leafs, the second tuple argument contains the highest-supported sub-leaf value.",
        "suggest": "对于包含子叶的 `leaf'，第二个元组参数包含支持的最高子叶值。",
        "translate": ""
    },
    {
        "source": "See also [`__cpuid`](fn.__cpuid.html) and [`__cpuid_count`](fn.__cpuid_count.html).",
        "suggest": "另请参见 [`__cpuid`](fn.__cpuid.html) 和 [`__cpuid_count`](fn.__cpuid_count.html)。",
        "translate": ""
    },
    {
        "source": "all currently-tested targets have the instruction",
        "suggest": "所有当前测试过的目标都有说明",
        "translate": ""
    },
    {
        "source": "add targets without `cpuid` to CI",
        "suggest": "将没有 `cpuid` 的目标添加到 CI",
        "translate": ""
    },
    {
        "source": "Reads EFLAGS.",
        "suggest": "读取 EFLAGS。",
        "translate": ""
    },
    {
        "source": "Write EFLAGS.",
        "suggest": "写 EFLAGS。",
        "translate": ""
    },
    {
        "source": "reads eflags, writes them back, reads them again, and compare for equality:",
        "suggest": "读取 eflag，将其写回，再次读取，并进行相等性比较:",
        "translate": ""
    },
    {
        "source": "Converts the 4 x 16-bit half-precision float values in the lowest 64-bit of the 128-bit vector `a` into 4 x 32-bit float values stored in a 128-bit wide vector.",
        "suggest": "将 128 位 vector `a` 的最低 64 位中的 4 x 16 位半精度浮点值转换为存储在 128 位宽的 vector 中的 4 x 32 位浮点值。",
        "translate": ""
    },
    {
        "source": "Converts the 8 x 16-bit half-precision float values in the 128-bit vector `a` into 8 x 32-bit float values stored in a 256-bit wide vector.",
        "suggest": "将 128 位 vector `a` 中的 8 x 16 位半精度浮点值转换为存储在 256 位宽 vector 中的 8 x 32 位浮点值。",
        "translate": ""
    },
    {
        "source": "Converts the 4 x 32-bit float values in the 128-bit vector `a` into 4 x",
        "suggest": "将 128 位 vector `a` 中的 4 x 32 位浮点值转换为 4 x",
        "translate": ""
    },
    {
        "source": "16-bit half-precision float values stored in the lowest 64-bit of a 128-bit vector.",
        "suggest": "16 位半精度浮点值存储在 128 位 vector 的最低 64 位中。",
        "translate": ""
    },
    {
        "source": "Rounding is done according to the `imm_rounding` parameter, which can be one of:",
        "suggest": "根据 `imm_rounding` 参数进行舍入，该参数可以是以下之一:",
        "translate": ""
    },
    {
        "source": "round to nearest and suppress exceptions,",
        "suggest": "四舍五入并排除异常，",
        "translate": ""
    },
    {
        "source": "round down and suppress exceptions,",
        "suggest": "四舍五入并排除异常，",
        "translate": ""
    },
    {
        "source": "round up and suppress exceptions,",
        "suggest": "汇总并排除异常，",
        "translate": ""
    },
    {
        "source": "truncate and suppress exceptions,",
        "suggest": "截断并抑制异常，",
        "translate": ""
    },
    {
        "source": "use `MXCSR.RC` - see [`_MM_SET_ROUNDING_MODE`].",
        "suggest": "使用 `MXCSR.RC` - 请参见 [`_MM_SET_ROUNDING_MODE`]。",
        "translate": ""
    },
    {
        "source": "Converts the 8 x 32-bit float values in the 256-bit vector `a` into 8 x",
        "suggest": "将 256 位 vector `a` 中的 8 x 32 位浮点值转换为 8 x",
        "translate": ""
    },
    {
        "source": "16-bit half-precision float values stored in a 128-bit wide vector.",
        "suggest": "16 位半精度浮点值存储在 128 位宽的 vector 中。",
        "translate": ""
    },
    {
        "source": "Fused Multiply-Add instruction set (FMA)",
        "suggest": "融合乘加指令集 (FMA)",
        "translate": ""
    },
    {
        "source": "The FMA instruction set is an extension to the 128 and 256-bit SSE instructions in the x86 microprocessor instruction set to perform fused multiply–add (FMA) operations.",
        "suggest": "FMA 指令集是 x86 微处理器指令集中 128 位和 256 位 SSE 指令的扩展，用于执行融合的乘加 (FMA) 操作。",
        "translate": ""
    },
    {
        "source": "Wikipedia's [FMA][wiki_fma] page provides a quick overview of the instructions available.",
        "suggest": "Wikipedia 的 [FMA][wiki_fma] 页面提供了对可用说明的快速概述。",
        "translate": ""
    },
    {
        "source": "Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`.",
        "suggest": "将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并将中间结果与 `c` 中的包装的元素相加。",
        "translate": ""
    },
    {
        "source": "Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`.",
        "suggest": "将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，并将中间结果添加到 `c` 中的包装元素中。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to the lower element in `c`.",
        "suggest": "将 `a` 和 `b` 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与 `c` 中的较低的元素相加。",
        "translate": ""
    },
    {
        "source": "Stores the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result.",
        "suggest": "将结果存储在返回值的低位元素中，并将高位元素从 `a` 复制到结果的高位元素。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to the lower element in `c`.",
        "suggest": "将 `a` 和 `b` 中较低的单精度 (32-bit) 浮点元素相乘，并将中间结果与 `c` 中的较低元素相加。",
        "translate": ""
    },
    {
        "source": "Stores the result in the lower element of the returned value, and copy the",
        "suggest": "将结果存储在返回值的下部元素中，然后复制",
        "translate": ""
    },
    {
        "source": "3 upper elements from `a` to the upper elements of the result.",
        "suggest": "从 `a` 到结果的高位元素的 3 个高位元素。",
        "translate": ""
    },
    {
        "source": "Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result.",
        "suggest": "将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，或者在 `c` to/from 中将包装的元素相加或减去中间结果。",
        "translate": ""
    },
    {
        "source": "Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result.",
        "suggest": "将 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素相乘，或者将 `c` 中包装的元素加/减到中间结果中。",
        "translate": ""
    },
    {
        "source": "Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result.",
        "suggest": "将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的包装的双精度元素。",
        "translate": ""
    },
    {
        "source": "Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result.",
        "suggest": "将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的包装元素。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and subtract the lower element in `c` from the intermediate result.",
        "suggest": "将 `a` 和 `b` 中的较低的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的较低的元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result.",
        "suggest": "将结果存储在返回值的低位元素中，并将高位元素从 `a` 复制到结果的高位元素。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`,  and subtract the lower element in `c` from the intermediate result.",
        "suggest": "将 `a` 和 `b` 中的较低单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的较低元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result.",
        "suggest": "将结果存储在返回值的低位元素中，并将 3 个高位元素从 `a` 复制到结果的高位元素。",
        "translate": ""
    },
    {
        "source": "Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result.",
        "suggest": "将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，也可以从中间结果中减去或加上 `c` 中的包装元素。",
        "translate": ""
    },
    {
        "source": "Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result.",
        "suggest": "将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，或者将 `c` 中的包装元素从中间结果中减去或加上。",
        "translate": ""
    },
    {
        "source": "Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`.",
        "suggest": "将 `a` 和 `b` 中的包装双精度 (64-bit) 浮点元素相乘，然后将取反的中间结果添加到 `c` 中的包装元素中。",
        "translate": ""
    },
    {
        "source": "Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`.",
        "suggest": "将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，并将取反的中间结果添加到 `c` 中的包装元素中。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to the lower element in `c`.",
        "suggest": "将 `a` 和 `b` 中较低的双精度 (64-bit) 浮点元素相乘，并将取反的中间结果添加到 `c` 中的较低元素。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to the lower element in `c`.",
        "suggest": "将 `a` 和 `b` 中较低的单精度 (32-bit) 浮点元素相乘，并将取反的中间结果与 `c` 中的较低元素相加。",
        "translate": ""
    },
    {
        "source": "Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.",
        "suggest": "将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并从取反的中间结果中减去 `c` 中的包装的元素。",
        "translate": ""
    },
    {
        "source": "Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.",
        "suggest": "将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，并从取反的中间结果中减去 `c` 中的包装的元素。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.",
        "suggest": "将 `a` 和 `b` 中较低的双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 `c` 中的包装的元素。",
        "translate": ""
    },
    {
        "source": "Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.",
        "suggest": "将 `a` 和 `b` 中较低的单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 `c` 中的包装元素。",
        "translate": ""
    },
    {
        "source": "FXSR floating-point context fast save and restor.",
        "suggest": "FXSR 浮点上下文快速保存和恢复。",
        "translate": ""
    },
    {
        "source": "Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the",
        "suggest": "将 `x87` FPU，`MMX` 技术，`XMM` 和 `MXCSR` 寄存器保存到",
        "translate": ""
    },
    {
        "source": "512-byte-long 16-byte-aligned memory region `mem_addr`.",
        "suggest": "512 字节长，16 字节对齐的内存区域 `mem_addr`。",
        "translate": ""
    },
    {
        "source": "A misaligned destination operand raises a general-protection (#GP) or an alignment check exception (#AC).",
        "suggest": "目标操作数未对齐将引发通用保护 (#GP) 或对齐检查异常 (#AC)。",
        "translate": ""
    },
    {
        "source": "See [`FXSAVE`][fxsave] and [`FXRSTOR`][fxrstor].",
        "suggest": "请参见 [`FXSAVE`][fxsave] 和 [`FXRSTOR`][fxrstor]。",
        "translate": ""
    },
    {
        "source": "Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the",
        "suggest": "从以下位置恢复 `XMM`，`MMX`，`MXCSR` 和 `x87` FPU 寄存器",
        "translate": ""
    },
    {
        "source": "The contents of this memory region should have been written to by a previous `_fxsave` or `_fxsave64` intrinsic.",
        "suggest": "该存储区的内容应该已经由以前的 `_fxsave` 或 `_fxsave64` 内联函数写入。",
        "translate": ""
    },
    {
        "source": "512 bytes",
        "suggest": "512 字节",
        "translate": ""
    },
    {
        "source": "Constifies 5 bits along with an sae option without rounding control.",
        "suggest": "在没有舍入控制的情况下，包含 5 位以及 sae 选项。",
        "translate": ""
    },
    {
        "source": "For gather instructions, the only valid values for scale are 1, 2, 4 and 8.",
        "suggest": "对于收集指令，标度的唯一有效值为 1、2、4 和 8。",
        "translate": ""
    },
    {
        "source": "This macro enforces that.",
        "suggest": "此宏强制执行该操作。",
        "translate": ""
    },
    {
        "source": "For round instructions, the only valid values for rounding are 4, 8, 9, 10 and 11.",
        "suggest": "对于舍入指令，舍入的唯一有效值为 4、8、9、10 和 11。",
        "translate": ""
    },
    {
        "source": "For sae instructions, the only valid values for sae are 4 and 8.",
        "suggest": "对于 sae 指令，sae 的唯一有效值为 4 和 8。",
        "translate": ""
    },
    {
        "source": "Two mantissas parameters.",
        "suggest": "两个尾数参数。",
        "translate": ""
    },
    {
        "source": "Include mantissas parameters.",
        "suggest": "包括尾数参数。",
        "translate": ""
    },
    {
        "source": "Constifies 8 bits along with an sae option without rounding control.",
        "suggest": "在没有舍入控制的情况下，包含 8 位以及 sae 选项。",
        "translate": ""
    },
    {
        "source": "The only valid values are 0 to 255.",
        "suggest": "唯一有效的值为 0 到 255。",
        "translate": ""
    },
    {
        "source": "Two sae parameters.",
        "suggest": "两个 sae 参数。",
        "translate": ""
    },
    {
        "source": "and `x86_64` intrinsics.",
        "suggest": "和 `x86_64` 内联函数。",
        "translate": ""
    },
    {
        "source": "128-bit wide integer vector type, x86-specific",
        "suggest": "128 位宽的整数 vector 类型，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m128i` type defined by Intel, representing a 128-bit SIMD register.",
        "suggest": "此类型与 Intel 定义的 `__m128i` 类型相同，代表一个 128 位 SIMD 寄存器。",
        "translate": ""
    },
    {
        "source": "Usage of this type typically corresponds to the `sse` and up target features for x86/x86_64.",
        "suggest": "这种类型的用法通常对应于 `sse` 和 x86/x86_64 的向上目标功能。",
        "translate": ""
    },
    {
        "source": "Internally this type may be viewed as:",
        "suggest": "在内部，此类型可以被视为:",
        "translate": ""
    },
    {
        "source": "sixteen `i8` variables packed together",
        "suggest": "十六个 `i8` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "eight `i16` variables packed together",
        "suggest": "八个 `i16` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "four `i32` variables packed together",
        "suggest": "四个 `i32` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "two `i64` variables packed together",
        "suggest": "两个 `i64` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "(as well as unsigned versions).",
        "suggest": "(以及未签名的版本)。",
        "translate": ""
    },
    {
        "source": "Each intrinsic may interpret the internal bits differently, check the documentation of the intrinsic to see how it's being used.",
        "suggest": "每个内联函数可能对内部位的解释不同，请查看内联函数的文档以了解其用法。",
        "translate": ""
    },
    {
        "source": "Note that this means that an instance of `__m128i` typically just means a \"bag of bits\" which is left up to interpretation at the point of use.",
        "suggest": "请注意，这意味着 `__m128i` 的实例通常仅表示 \"bag of bits\"，该 \"bag of bits\" 留待使用时进行解释。",
        "translate": ""
    },
    {
        "source": "Most intrinsics using `__m128i` are prefixed with `_mm_` and the integer types tend to correspond to suffixes like \"epi8\" or \"epi32\".",
        "suggest": "使用 `__m128i` 的大多数内联函数都以 `_mm_` 作为前缀，并且整数类型往往对应于后缀，例如 \"epi8\" 或 \"epi32\"。",
        "translate": ""
    },
    {
        "source": "128-bit wide set of four `f32` types, x86-specific",
        "suggest": "四种 `f32` 类型的 128 位宽集，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m128` type defined by Intel, representing a 128-bit SIMD register which internally is consisted of four packed `f32` instances.",
        "suggest": "此类型与 Intel 定义的 `__m128` 类型相同，代表一个 128 位 SIMD 寄存器，该寄存器内部由四个包装的 `f32` 实例组成。",
        "translate": ""
    },
    {
        "source": "Note that unlike `__m128i`, the integer version of the 128-bit registers, this `__m128` type has *one* interpretation.",
        "suggest": "请注意，与 `__m128i` (128 位寄存器的整数版本) 不同，此 `__m128` 类型具有 *one* 解释。",
        "translate": ""
    },
    {
        "source": "Each instance of `__m128` always corresponds to `f32x4`, or four `f32` types packed together.",
        "suggest": "`__m128` 的每个实例始终与 `f32x4` 或包装在一起的四种 `f32` 类型相对应。",
        "translate": ""
    },
    {
        "source": "Most intrinsics using `__m128` are prefixed with `_mm_` and are suffixed with \"ps\" (or otherwise contain \"ps\").",
        "suggest": "使用 `__m128` 的大多数内联函数都以 `_mm_` 为前缀，并以 \"ps\" 为后缀 (或另外包含 \"ps\")。",
        "translate": ""
    },
    {
        "source": "Not to be confused with \"pd\" which is used for `__m128d`.",
        "suggest": "不要与用于 `__m128d` 的 \"pd\" 混淆。",
        "translate": ""
    },
    {
        "source": "128-bit wide set of two `f64` types, x86-specific",
        "suggest": "两种 `f64` 类型的 128 位宽集，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m128d` type defined by Intel, representing a 128-bit SIMD register which internally is consisted of two packed `f64` instances.",
        "suggest": "此类型与 Intel 定义的 `__m128d` 类型相同，代表一个 128 位 SIMD 寄存器，该寄存器内部由两个包装的 `f64` 实例组成。",
        "translate": ""
    },
    {
        "source": "Note that unlike `__m128i`, the integer version of the 128-bit registers, this `__m128d` type has *one* interpretation.",
        "suggest": "请注意，与 `__m128i` (128 位寄存器的整数版本) 不同，此 `__m128d` 类型具有 *one* 解释。",
        "translate": ""
    },
    {
        "source": "Each instance of `__m128d` always corresponds to `f64x2`, or two `f64` types packed together.",
        "suggest": "`__m128d` 的每个实例始终对应于 `f64x2` 或包装在一起的两种 `f64` 类型。",
        "translate": ""
    },
    {
        "source": "Most intrinsics using `__m128d` are prefixed with `_mm_` and are suffixed with \"pd\" (or otherwise contain \"pd\").",
        "suggest": "使用 `__m128d` 的大多数内联函数都以 `_mm_` 为前缀，并以 \"pd\" 为后缀 (或另外包含 \"pd\")。",
        "translate": ""
    },
    {
        "source": "Not to be confused with \"ps\" which is used for `__m128`.",
        "suggest": "不要与用于 `__m128` 的 \"ps\" 混淆。",
        "translate": ""
    },
    {
        "source": "256-bit wide integer vector type, x86-specific",
        "suggest": "256 位宽的整数 vector 类型，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m256i` type defined by Intel, representing a 256-bit SIMD register.",
        "suggest": "此类型与 Intel 定义的 `__m256i` 类型相同，代表 256 位 SIMD 寄存器。",
        "translate": ""
    },
    {
        "source": "Usage of this type typically corresponds to the `avx` and up target features for x86/x86_64.",
        "suggest": "这种类型的用法通常对应于 `avx` 和 x86/x86_64 的向上目标功能。",
        "translate": ""
    },
    {
        "source": "thirty two `i8` variables packed together",
        "suggest": "三十二个 `i8` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "sixteen `i16` variables packed together",
        "suggest": "十六个 `i16` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "eight `i32` variables packed together",
        "suggest": "八个 `i32` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "four `i64` variables packed together",
        "suggest": "四个 `i64` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "Note that this means that an instance of `__m256i` typically just means a \"bag of bits\" which is left up to interpretation at the point of use.",
        "suggest": "请注意，这意味着 `__m256i` 的实例通常仅表示 \"bag of bits\"，该 \"bag of bits\" 留待使用时进行解释。",
        "translate": ""
    },
    {
        "source": "256-bit wide set of eight `f32` types, x86-specific",
        "suggest": "256 位宽的八种 `f32` 类型的集合，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m256` type defined by Intel, representing a 256-bit SIMD register which internally is consisted of eight packed `f32` instances.",
        "suggest": "此类型与 Intel 定义的 `__m256` 类型相同，代表一个 256 位 SIMD 寄存器，该寄存器内部由八个包装的 `f32` 实例组成。",
        "translate": ""
    },
    {
        "source": "Note that unlike `__m256i`, the integer version of the 256-bit registers, this `__m256` type has *one* interpretation.",
        "suggest": "请注意，与 `__m256i` (256 位寄存器的整数版本) 不同，此 `__m256` 类型具有 *one* 解释。",
        "translate": ""
    },
    {
        "source": "Each instance of `__m256` always corresponds to `f32x8`, or eight `f32` types packed together.",
        "suggest": "`__m256` 的每个实例始终对应于 `f32x8` 或包装在一起的八种 `f32` 类型。",
        "translate": ""
    },
    {
        "source": "Most intrinsics using `__m256` are prefixed with `_mm256_` and are suffixed with \"ps\" (or otherwise contain \"ps\").",
        "suggest": "使用 `__m256` 的大多数内联函数都以 `_mm256_` 为前缀，并以 \"ps\" 为后缀 (或另外包含 \"ps\")。",
        "translate": ""
    },
    {
        "source": "Not to be confused with \"pd\" which is used for `__m256d`.",
        "suggest": "不要与用于 `__m256d` 的 \"pd\" 混淆。",
        "translate": ""
    },
    {
        "source": "256-bit wide set of four `f64` types, x86-specific",
        "suggest": "256 位宽的四种 `f64` 类型的集合，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m256d` type defined by Intel, representing a 256-bit SIMD register which internally is consisted of four packed `f64` instances.",
        "suggest": "此类型与 Intel 定义的 `__m256d` 类型相同，代表一个 256 位 SIMD 寄存器，该寄存器内部由四个包装的 `f64` 实例组成。",
        "translate": ""
    },
    {
        "source": "Note that unlike `__m256i`, the integer version of the 256-bit registers, this `__m256d` type has *one* interpretation.",
        "suggest": "请注意，与 `__m256i` (256 位寄存器的整数版本) 不同，此 `__m256d` 类型具有 *one* 解释。",
        "translate": ""
    },
    {
        "source": "Each instance of `__m256d` always corresponds to `f64x4`, or four `f64` types packed together.",
        "suggest": "`__m256d` 的每个实例始终与 `f64x4` 或包装在一起的四种 `f64` 类型相对应。",
        "translate": ""
    },
    {
        "source": "Most intrinsics using `__m256d` are prefixed with `_mm256_` and are suffixed with \"pd\" (or otherwise contain \"pd\").",
        "suggest": "使用 `__m256d` 的大多数内联函数都以 `_mm256_` 为前缀，并以 \"pd\" 为后缀 (或另外包含 \"pd\")。",
        "translate": ""
    },
    {
        "source": "Not to be confused with \"ps\" which is used for `__m256`.",
        "suggest": "不要与用于 `__m256` 的 \"ps\" 混淆。",
        "translate": ""
    },
    {
        "source": "512-bit wide integer vector type, x86-specific",
        "suggest": "512 位宽的整数 vector 类型，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m512i` type defined by Intel, representing a 512-bit SIMD register.",
        "suggest": "此类型与 Intel 定义的 `__m512i` 类型相同，代表 512 位 SIMD 寄存器。",
        "translate": ""
    },
    {
        "source": "Usage of this type typically corresponds to the `avx512*` and up target features for x86/x86_64.",
        "suggest": "这种类型的用法通常对应于 `avx512*` 和 x86/x86_64 的向上目标功能。",
        "translate": ""
    },
    {
        "source": "sixty-four `i8` variables packed together",
        "suggest": "六十四个 `i8` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "thirty-two `i16` variables packed together",
        "suggest": "三十二个 `i16` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "sixteen `i32` variables packed together",
        "suggest": "十六个 `i32` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "eight `i64` variables packed together",
        "suggest": "八个 `i64` 变量包装在一起",
        "translate": ""
    },
    {
        "source": "Note that this means that an instance of `__m512i` typically just means a \"bag of bits\" which is left up to interpretation at the point of use.",
        "suggest": "请注意，这意味着 `__m512i` 的实例通常仅表示 \"bag of bits\"，该 \"bag of bits\" 留待使用时进行解释。",
        "translate": ""
    },
    {
        "source": "512-bit wide set of sixteen `f32` types, x86-specific",
        "suggest": "512 位宽的十六种 `f32` 类型集，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m512` type defined by Intel, representing a 512-bit SIMD register which internally is consisted of eight packed `f32` instances.",
        "suggest": "此类型与 Intel 定义的 `__m512` 类型相同，代表一个 512 位 SIMD 寄存器，该寄存器内部由八个包装的 `f32` 实例组成。",
        "translate": ""
    },
    {
        "source": "Note that unlike `__m512i`, the integer version of the 512-bit registers, this `__m512` type has *one* interpretation.",
        "suggest": "请注意，与 `__m512i` (512 位寄存器的整数版本) 不同，此 `__m512` 类型具有 *one* 解释。",
        "translate": ""
    },
    {
        "source": "Each instance of `__m512` always corresponds to `f32x16`, or sixteen `f32` types packed together.",
        "suggest": "`__m512` 的每个实例始终对应于 `f32x16` 或包装在一起的十六种 `f32` 类型。",
        "translate": ""
    },
    {
        "source": "Most intrinsics using `__m512` are prefixed with `_mm512_` and are suffixed with \"ps\" (or otherwise contain \"ps\").",
        "suggest": "使用 `__m512` 的大多数内联函数都以 `_mm512_` 为前缀，并以 \"ps\" 为后缀 (或另外包含 \"ps\")。",
        "translate": ""
    },
    {
        "source": "Not to be confused with \"pd\" which is used for `__m512d`.",
        "suggest": "不要与用于 `__m512d` 的 \"pd\" 混淆。",
        "translate": ""
    },
    {
        "source": "512-bit wide set of eight `f64` types, x86-specific",
        "suggest": "八种 `f64` 类型的 512 位宽集，特定于 x86",
        "translate": ""
    },
    {
        "source": "This type is the same as the `__m512d` type defined by Intel, representing a 512-bit SIMD register which internally is consisted of eight packed `f64` instances.",
        "suggest": "此类型与 Intel 定义的 `__m512d` 类型相同，代表一个 512 位 SIMD 寄存器，该寄存器内部由八个包装的 `f64` 实例组成。",
        "translate": ""
    },
    {
        "source": "Note that unlike `__m512i`, the integer version of the 512-bit registers, this `__m512d` type has *one* interpretation.",
        "suggest": "请注意，与 `__m512i` (512 位寄存器的整数版本) 不同，此 `__m512d` 类型具有 *one* 解释。",
        "translate": ""
    },
    {
        "source": "Each instance of `__m512d` always corresponds to `f64x4`, or eight `f64` types packed together.",
        "suggest": "`__m512d` 的每个实例始终对应于 `f64x4` 或包装在一起的八种 `f64` 类型。",
        "translate": ""
    },
    {
        "source": "Most intrinsics using `__m512d` are prefixed with `_mm512_` and are suffixed with \"pd\" (or otherwise contain \"pd\").",
        "suggest": "使用 `__m512d` 的大多数内联函数都以 `_mm512_` 为前缀，并以 \"pd\" 为后缀 (或另外包含 \"pd\")。",
        "translate": ""
    },
    {
        "source": "Not to be confused with \"ps\" which is used for `__m512`.",
        "suggest": "不要与用于 `__m512` 的 \"ps\" 混淆。",
        "translate": ""
    },
    {
        "source": "The `__mmask64` type used in AVX-512 intrinsics, a 64-bit integer",
        "suggest": "AVX-512 内联函数中使用的 `__mmask64` 类型，一个 64 位整数",
        "translate": ""
    },
    {
        "source": "The `__mmask32` type used in AVX-512 intrinsics, a 32-bit integer",
        "suggest": "AVX-512 内联函数中使用的 `__mmask32` 类型，一个 32 位整数",
        "translate": ""
    },
    {
        "source": "The `__mmask16` type used in AVX-512 intrinsics, a 16-bit integer",
        "suggest": "AVX-512 内联函数中使用的 `__mmask16` 类型，一个 16 位整数",
        "translate": ""
    },
    {
        "source": "The `__mmask8` type used in AVX-512 intrinsics, a 8-bit integer",
        "suggest": "AVX-512 内联函数中使用的 `__mmask8` 类型，一个 8 位整数",
        "translate": ""
    },
    {
        "source": "The `_MM_CMPINT_ENUM` type used to specify comparison operations in AVX-512 intrinsics.",
        "suggest": "`_MM_CMPINT_ENUM` 类型用于在 AVX-512 内联函数中指定比较操作。",
        "translate": ""
    },
    {
        "source": "The `MM_MANTISSA_NORM_ENUM` type used to specify mantissa normalized operations in AVX-512 intrinsics.",
        "suggest": "`MM_MANTISSA_NORM_ENUM` 类型用于指定 AVX-512 内联函数中的尾数归一化操作。",
        "translate": ""
    },
    {
        "source": "The `MM_MANTISSA_SIGN_ENUM` type used to specify mantissa signed operations in AVX-512 intrinsics.",
        "suggest": "`MM_MANTISSA_SIGN_ENUM` 类型用于指定 AVX-512 内联函数中的尾数签名操作。",
        "translate": ""
    },
    {
        "source": "The `MM_PERM_ENUM` type used to specify shuffle operations in AVX-512 intrinsics.",
        "suggest": "`MM_PERM_ENUM` 类型用于在 AVX-512 内联函数中指定重排操作。",
        "translate": ""
    },
    {
        "source": "Generates the trap instruction `UD2`",
        "suggest": "生成陷阱指令 `UD2`",
        "translate": ""
    },
    {
        "source": "Carry-less Multiplication (CLMUL)",
        "suggest": "无进位乘法 (CLMUL)",
        "translate": ""
    },
    {
        "source": "Performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2^k).",
        "suggest": "在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。",
        "translate": ""
    },
    {
        "source": "The immediate byte is used for determining which halves of `a` and `b` should be used.",
        "suggest": "immediate 字节用于确定应使用 `a` 和 `b` 的哪一半。",
        "translate": ""
    },
    {
        "source": "RDRAND and RDSEED instructions for returning random numbers from an Intel on-chip hardware random number generator which has been seeded by an on-chip entropy source.",
        "suggest": "RDRAND 和 RDSEED 指令，用于从 Intel 片上硬件随机数生成器返回随机数，该随机数发生器已由片上熵源播种。",
        "translate": ""
    },
    {
        "source": "Read a hardware generated 16-bit random value and store the result in val.",
        "suggest": "读取硬件生成的 16 位随机值，并将结果存储在 val 中。",
        "translate": ""
    },
    {
        "source": "Returns 1 if a random value was generated, and 0 otherwise.",
        "suggest": "如果生成随机值，则返回 1，否则返回 0。",
        "translate": ""
    },
    {
        "source": "Read a hardware generated 32-bit random value and store the result in val.",
        "suggest": "读取硬件生成的 32 位随机值，并将结果存储在 val 中。",
        "translate": ""
    },
    {
        "source": "Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store in val.",
        "suggest": "读取符合 NIST SP800-90B 和 SP800-90C 的 16 位随机值，并存储在 val 中。",
        "translate": ""
    },
    {
        "source": "Return 1 if a random value was generated, and 0 otherwise.",
        "suggest": "如果生成随机值，则返回 1，否则返回 0。",
        "translate": ""
    },
    {
        "source": "Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store in val.",
        "suggest": "读取符合 NIST SP800-90B 和 SP800-90C 的 32 位随机值，并存储在 val 中。",
        "translate": ""
    },
    {
        "source": "RDTSC instructions.",
        "suggest": "RDTSC 指令。",
        "translate": ""
    },
    {
        "source": "Reads the current value of the processor’s time-stamp counter.",
        "suggest": "读取处理器时间戳计数器的当前值。",
        "translate": ""
    },
    {
        "source": "The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset.",
        "suggest": "处理器在每个时钟周期单调递增时间戳计数器 MSR，并在每次重置处理器时将其重置为 0。",
        "translate": ""
    },
    {
        "source": "The RDTSC instruction is not a serializing instruction.",
        "suggest": "RDTSC 指令不是序列化指令。",
        "translate": ""
    },
    {
        "source": "It does not necessarily wait until all previous instructions have been executed before reading the counter.",
        "suggest": "它不一定要等到所有先前的指令已执行才读取计数器。",
        "translate": ""
    },
    {
        "source": "Similarly, subsequent instructions may begin execution before the read operation is performed.",
        "suggest": "类似地，后续指令可以在执行读取操作之前开始执行。",
        "translate": ""
    },
    {
        "source": "On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.",
        "suggest": "在支持 Intel 64 架构的处理器上，将清除 RAX 和 RDX 的每个高阶 32 位。",
        "translate": ""
    },
    {
        "source": "Reads the current value of the processor’s time-stamp counter and the `IA32_TSC_AUX MSR`.",
        "suggest": "读取处理器时间戳计数器和 `IA32_TSC_AUX MSR` 的当前值。",
        "translate": ""
    },
    {
        "source": "The RDTSCP instruction waits until all previous instructions have been executed before reading the counter.",
        "suggest": "RDTSCP 指令等待，直到所有先前的指令都已执行，然后再读取计数器。",
        "translate": ""
    },
    {
        "source": "However, subsequent instructions may begin execution before the read operation is performed.",
        "suggest": "但是，后续指令可能会在执行读取操作之前开始执行。",
        "translate": ""
    },
    {
        "source": "On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.",
        "suggest": "在支持 Intel 64 架构的处理器上，将清除 RAX，RDX 和 RCX 的每个高阶 32 位。",
        "translate": ""
    },
    {
        "source": "The chances of this being 0 are infinitesimal",
        "suggest": "此为 0 的机会是无穷的",
        "translate": ""
    },
    {
        "source": "Intel's Restricted Transactional Memory (RTM).",
        "suggest": "英特尔受限事物内存 (RTM)。",
        "translate": ""
    },
    {
        "source": "This CPU feature is available on Intel Broadwell or later CPUs (and some Haswell).",
        "suggest": "此 CPU 功能在 Intel Broadwell 或更高版本的 CPU (和某些 Haswell) 上可用。",
        "translate": ""
    },
    {
        "source": "provides a quick overview of the assembly instructions, and Intel's [programming considerations][intel_consid] details what sorts of instructions within a transaction are likely to cause an abort.",
        "suggest": "提供了汇编指令的快速概述，而 Intel 的 [编程注意事项][intel_consid] 中详细说明了事务中哪种指令可能导致终止。",
        "translate": ""
    },
    {
        "source": "Transaction explicitly aborted with xabort.",
        "suggest": "使用 xabort 显式中止了事务。",
        "translate": ""
    },
    {
        "source": "The parameter passed to xabort is available with `_xabort_code(status)`.",
        "suggest": "传递给 xabort 的参数可用于 `_xabort_code(status)`。",
        "translate": ""
    },
    {
        "source": "Transaction abort due to a memory conflict with another thread.",
        "suggest": "由于与另一个线程发生内存冲突而导致事务终止。",
        "translate": ""
    },
    {
        "source": "Transaction abort due to the transaction using too much memory.",
        "suggest": "事务终止，因为事务使用了过多的内存。",
        "translate": ""
    },
    {
        "source": "Transaction abort due to a debug trap.",
        "suggest": "事务由于调试陷阱而终止。",
        "translate": ""
    },
    {
        "source": "Transaction abort in a inner nested transaction.",
        "suggest": "内部嵌套事务中的事务终止。",
        "translate": ""
    },
    {
        "source": "Specifies the start of a restricted transactional memory (RTM) code region and returns a value indicating status.",
        "suggest": "指定受限制的事务性存储器 (RTM) 代码区域的开始，并返回一个指示状态的值。",
        "translate": ""
    },
    {
        "source": "Specifies the end of a restricted transactional memory (RTM) code region.",
        "suggest": "指定受限制的事务性存储器 (RTM) 代码区域的结尾。",
        "translate": ""
    },
    {
        "source": "Forces a restricted transactional memory (RTM) region to abort.",
        "suggest": "强制将受限制的事务内存 (RTM) 区域终止。",
        "translate": ""
    },
    {
        "source": "Queries whether the processor is executing in a transactional region identified by restricted transactional memory (RTM) or hardware lock elision (HLE).",
        "suggest": "查询处理器是在由受限事务存储器 (RTM) 还是硬件锁定扩展 (HLE) 标识的事务区域中执行。",
        "translate": ""
    },
    {
        "source": "Retrieves the parameter passed to [`_xabort`] when [`_xbegin`]'s status has the `_XABORT_EXPLICIT` flag set.",
        "suggest": "当 [`_xbegin`] 的状态设置为 `_XABORT_EXPLICIT` 标志时，检索传递给 [`_xabort`] 的参数。",
        "translate": ""
    },
    {
        "source": "aborting outside a transactional region does nothing",
        "suggest": "在事务区域外终止不执行任何操作",
        "translate": ""
    },
    {
        "source": "putting the assert inside the transaction would abort the transaction on fail without any output/panic/etc",
        "suggest": "将断言放入事务中将在没有任何 output/panic/etc 的情况下终止事务失败",
        "translate": ""
    },
    {
        "source": "Performs an intermediate calculation for the next four SHA1 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and returning the result.",
        "suggest": "使用来自 `a` 和 `b` 的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。",
        "translate": ""
    },
    {
        "source": "Performs the final calculation for the next four SHA1 message values (unsigned 32-bit integers) using the intermediate result in `a` and the previous message values in `b`, and returns the result.",
        "suggest": "使用 `a` 中的中间结果和 `b` 中的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。",
        "translate": ""
    },
    {
        "source": "Calculate SHA1 state variable E after four rounds of operation from the current SHA1 state variable `a`, add that value to the scheduled values (unsigned 32-bit integers) in `b`, and returns the result.",
        "suggest": "经过四轮运算后，从当前 SHA1 状态变量 `a` 计算 SHA1 状态变量 E，将该值添加到 `b` 中的计划值 (无符号 32 位整数)，然后返回结果。",
        "translate": ""
    },
    {
        "source": "Performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from `a` and some pre-computed sum of the next 4 round message values (unsigned 32-bit integers), and state variable E from `b`, and return the updated SHA1 state (A,B,C,D).",
        "suggest": "使用来自 `a` 的初始 SHA1 状态 (A,B,C,D) 以及接下来的 4 个回合消息值 (一些无符号的 32 位整数) 和来自 `b` 的状态变量 E 的一些预先计算的总和，执行四轮 SHA1 操作，并返回更新的 SHA1 状态 (A,B,C,D)。",
        "translate": ""
    },
    {
        "source": "contains the logic functions and round constants.",
        "suggest": "包含逻辑函数和舍入常量。",
        "translate": ""
    },
    {
        "source": "Performs an intermediate calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and return the result.",
        "suggest": "使用来自 `a` 和 `b` 的先前消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。",
        "translate": ""
    },
    {
        "source": "Performs the final calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and return the result.",
        "suggest": "使用以前的 `a` 和 `b` 的消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。",
        "translate": ""
    },
    {
        "source": "Performs 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from `a`, an initial SHA256 state (A,B,E,F) from `b`, and a pre-computed sum of the next 2 round message values (unsigned 32-bit integers) and the corresponding round constants from `k`, and store the updated SHA256 state (A,B,E,F) in dst.",
        "suggest": "使用来自 `a` 的初始 SHA256 状态 (C,D,G,H)，来自 `b` 的初始 SHA256 状态 (A,B,E,F) 以及接下来的 2 个回合消息值 (无符号的 32 位整数) 和来自 `k` 的相应回合常量的预先计算的总和，执行 2 轮 SHA256 操作。，并将更新的 SHA256 状态 (A,B,E,F) 存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "clear all exception flags",
        "suggest": "清除所有异常标志",
        "translate": ""
    },
    {
        "source": "perform calculations",
        "suggest": "执行计算",
        "translate": ""
    },
    {
        "source": "handle overflow",
        "suggest": "处理上溢",
        "translate": ""
    },
    {
        "source": "unmask underflow",
        "suggest": "暴露下溢",
        "translate": ""
    },
    {
        "source": "turn off (default)",
        "suggest": "关闭 (default)",
        "translate": ""
    },
    {
        "source": "turn on",
        "suggest": "打开",
        "translate": ""
    },
    {
        "source": "Streaming SIMD Extensions (SSE)",
        "suggest": "流式 SIMD 扩展 (SSE)",
        "translate": ""
    },
    {
        "source": "Adds the first component of `a` and `b`, the other components are copied from `a`.",
        "suggest": "添加 `a` 和 `b` 的第一个组件，其他组件从 `a` 复制。",
        "translate": ""
    },
    {
        "source": "Adds __m128 vectors.",
        "suggest": "添加 __m128 vectors。",
        "translate": ""
    },
    {
        "source": "Subtracts the first component of `b` from `a`, the other components are copied from `a`.",
        "suggest": "从 `a` 减去 `b` 的第一个组件，从 `a` 复制其他组件。",
        "translate": ""
    },
    {
        "source": "Subtracts __m128 vectors.",
        "suggest": "减去 __m128 vectors。",
        "translate": ""
    },
    {
        "source": "Multiplies the first component of `a` and `b`, the other components are copied from `a`.",
        "suggest": "将 `a` 和 `b` 的第一个组件相乘，然后从 `a` 复制其他组件。",
        "translate": ""
    },
    {
        "source": "Multiplies __m128 vectors.",
        "suggest": "乘以 __m128 vectors。",
        "translate": ""
    },
    {
        "source": "Divides the first component of `b` by `a`, the other components are copied from `a`.",
        "suggest": "将 `b` 的第一个组件除以 `a`，其他组件则从 `a` 复制。",
        "translate": ""
    },
    {
        "source": "Divides __m128 vectors.",
        "suggest": "除 __m128 vectors。",
        "translate": ""
    },
    {
        "source": "Returns the square root of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged.",
        "suggest": "返回 `a` 中第一个单精度 (32-bit) 浮点元素的平方根，其他元素保持不变。",
        "translate": ""
    },
    {
        "source": "Returns the square root of packed single-precision (32-bit) floating-point elements in `a`.",
        "suggest": "返回 `a` 中包装的单精度 (32-bit) 浮点元素的平方根。",
        "translate": ""
    },
    {
        "source": "Returns the approximate reciprocal of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged.",
        "suggest": "返回 `a` 中第一个单精度 (32-bit) 浮点元素的近似倒数，其他元素不变。",
        "translate": ""
    },
    {
        "source": "Returns the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`.",
        "suggest": "返回 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数。",
        "translate": ""
    },
    {
        "source": "Returns the approximate reciprocal square root of the fist single-precision (32-bit) floating-point elements in `a`, the other elements are unchanged.",
        "suggest": "返回 `a` 中的第一个单精度 (32-bit) 浮点元素的近似倒数平方根，其他元素不变。",
        "translate": ""
    },
    {
        "source": "Returns the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`.",
        "suggest": "返回 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根。",
        "translate": ""
    },
    {
        "source": "Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the minimum value in the first element of the return value, the other elements are copied from `a`.",
        "suggest": "比较 `a` 和 `b` 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最小值，从 `a` 复制其他元素。",
        "translate": ""
    },
    {
        "source": "Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding minimum values.",
        "suggest": "比较 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素，并返回相应的最小值。",
        "translate": ""
    },
    {
        "source": "See the `test_mm_min_ps` test why this can't be implemented using `simd_fmin`.",
        "suggest": "请参见 `test_mm_min_ps` 测试，为什么不能使用 `simd_fmin` 来实现。",
        "translate": ""
    },
    {
        "source": "Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the maximum value in the first element of the return value, the other elements are copied from `a`.",
        "suggest": "比较 `a` 和 `b` 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最大值，从 `a` 复制其他元素。",
        "translate": ""
    },
    {
        "source": "Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding maximum values.",
        "suggest": "比较 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素，并返回相应的最大值。",
        "translate": ""
    },
    {
        "source": "See the `test_mm_min_ps` test why this can't be implemented using `simd_fmax`.",
        "suggest": "请参见 `test_mm_min_ps` 测试，为什么不能使用 `simd_fmax` 来实现。",
        "translate": ""
    },
    {
        "source": "Bitwise AND of packed single-precision (32-bit) floating-point elements.",
        "suggest": "包装的单精度 (32-bit) 浮点元素的按位与。",
        "translate": ""
    },
    {
        "source": "i586 only seems to generate plain `and` instructions, so ignore it.",
        "suggest": "i586 似乎只生成普通的 `and` 指令，因此请忽略它。",
        "translate": ""
    },
    {
        "source": "Bitwise AND-NOT of packed single-precision (32-bit) floating-point elements.",
        "suggest": "包装的单精度 (32-bit) 浮点元素的按位与非运算。",
        "translate": ""
    },
    {
        "source": "Computes `!a & b` for each bit in `a` and `b`.",
        "suggest": "为 `a` 和 `b` 中的每个位计算 `!a & b`。",
        "translate": ""
    },
    {
        "source": "i586 only seems to generate plain `not` and `and` instructions, so ignore it.",
        "suggest": "i586 似乎只生成普通的 `not` 和 `and` 指令，因此请忽略它。",
        "translate": ""
    },
    {
        "source": "Bitwise OR of packed single-precision (32-bit) floating-point elements.",
        "suggest": "包装的单精度 (32-bit) 浮点元素的按位或。",
        "translate": ""
    },
    {
        "source": "i586 only seems to generate plain `or` instructions, so we ignore it.",
        "suggest": "i586 似乎只生成普通的 `or` 指令，因此我们将其忽略。",
        "translate": ""
    },
    {
        "source": "Bitwise exclusive OR of packed single-precision (32-bit) floating-point elements.",
        "suggest": "包装的单精度 (32-bit) 浮点元素的按位异或。",
        "translate": ""
    },
    {
        "source": "i586 only seems to generate plain `xor` instructions, so we ignore it.",
        "suggest": "i586 似乎只生成普通的 `xor` 指令，因此我们将其忽略。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for equality.",
        "suggest": "比较两个输入中的最低 `f32` 是否相等。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if the two inputs are equal, or `0` otherwise.",
        "suggest": "如果两个输入相等，结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The upper 96 bits of the result are the upper 96 bits of `a`.",
        "suggest": "结果的高 96 位是 `a` 的高 96 位。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for less than.",
        "suggest": "比较两个输入的最低 `f32` 小于。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 小于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for less than or equal.",
        "suggest": "比较两个输入中的最低 `f32` 小于或等于。",
        "translate": ""
    },
    {
        "source": "The lowest",
        "suggest": "最低的",
        "translate": ""
    },
    {
        "source": "32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than or equal `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 小于或等于 `b.extract(0)`，则结果的 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for greater than.",
        "suggest": "比较两个输入的最低 `f32` 大于。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 大于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for greater than or equal.",
        "suggest": "比较两个输入的最低 `f32` 大于或等于。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than or equal `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 大于或等于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for inequality.",
        "suggest": "比较两个输入中最低的 `f32` 是否不相等。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not equal to `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 不等于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for not-less-than.",
        "suggest": "比较两个输入中的最低 `f32` 不少于。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 不小于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for not-less-than-or-equal.",
        "suggest": "比较两个输入的最低 `f32` 等于或小于等于。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than or equal to `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 不小于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for not-greater-than.",
        "suggest": "比较两个输入的最低 `f32`，以得出不大于。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 不大于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares the lowest `f32` of both inputs for not-greater-than-or-equal.",
        "suggest": "比较两个输入中的最低 `f32`，以得出不大于等于。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than or equal to `b.extract(0)`, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 不大于或等于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Checks if the lowest `f32` of both inputs are ordered.",
        "suggest": "检查两个输入中最低的 `f32` 是否已订购。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if neither of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 或 `b.extract(0)` 都不是 NaN，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Checks if the lowest `f32` of both inputs are unordered.",
        "suggest": "检查两个输入中最低的 `f32` 是否无序。",
        "translate": ""
    },
    {
        "source": "The lowest 32 bits of the result will be `0xffffffff` if any of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise.",
        "suggest": "如果 `a.extract(0)` 或 `b.extract(0)` 中的任何一个为 NaN，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Compares each of the four floats in `a` to the corresponding element in `b`.",
        "suggest": "将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input elements were equal, or `0` otherwise.",
        "suggest": "如果输入元素相等，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is less than the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素小于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is less than or equal to the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素小于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is greater than the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素大于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is greater than or equal to the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素大于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input elements are **not** equal, or `0` otherwise.",
        "suggest": "如果输入元素不相等，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is **not** less than the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素不小于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is **not** less than or equal to the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素不小于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is **not** greater than the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素不大于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "The result in the output vector will be `0xffffffff` if the input element in `a` is **not** greater than or equal to the corresponding element in `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的输入元素不大于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。",
        "translate": ""
    },
    {
        "source": "Returns four floats that have one of two possible bit patterns.",
        "suggest": "返回具有两个可能的位模式之一的四个浮点数。",
        "translate": ""
    },
    {
        "source": "The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are ordered (i.e., neither of them is a NaN), or 0 otherwise.",
        "suggest": "如果 `a` 和 `b` 中的输入元素是有序的 (即，它们都不是 NaN)，则输出 vector 中的元素将为 `0xffffffff`，否则为 0。",
        "translate": ""
    },
    {
        "source": "The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are unordered (i.e., at least on of them is a NaN), or 0 otherwise.",
        "suggest": "如果 `a` 和 `b` 中的输入元素无序 (即，至少其中一个是 NaN)，则输出 vector 中的元素将为 `0xffffffff`，否则为 0。",
        "translate": ""
    },
    {
        "source": "Compares two 32-bit floats from the low-order bits of `a` and `b`.",
        "suggest": "比较 `a` 和 `b` 的低位的两个 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "Returns `1` if they are equal, or `0` otherwise.",
        "suggest": "如果相等则返回 `1`，否则返回 `0`。",
        "translate": ""
    },
    {
        "source": "Returns `1` if the value from `a` is less than the one from `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的值小于 `b` 中的值，则返回 `1`，否则返回 `0`。",
        "translate": ""
    },
    {
        "source": "Returns `1` if the value from `a` is less than or equal to the one from `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的值小于或等于 `b` 中的值，则返回 `1`，否则返回 `0`。",
        "translate": ""
    },
    {
        "source": "Returns `1` if the value from `a` is greater than the one from `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的值大于 `b` 中的值，则返回 `1`，否则返回 `0`。",
        "translate": ""
    },
    {
        "source": "Returns `1` if the value from `a` is greater than or equal to the one from `b`, or `0` otherwise.",
        "suggest": "如果 `a` 中的值大于或等于 `b` 中的值，则返回 `1`，否则返回 `0`。",
        "translate": ""
    },
    {
        "source": "Returns `1` if they are **not** equal, or `0` otherwise.",
        "suggest": "如果它们不相等，则返回 `1`，否则返回 `0`。",
        "translate": ""
    },
    {
        "source": "This instruction will not signal an exception if either argument is a quiet NaN.",
        "suggest": "如果任一参数是安静的 NaN，则该指令不会发出异常信号。",
        "translate": ""
    },
    {
        "source": "Converts the lowest 32 bit float in the input vector to a 32 bit integer.",
        "suggest": "将输入 vector 中的最低 32 位浮点型转换为 32 位整数。",
        "translate": ""
    },
    {
        "source": "The result is rounded according to the current rounding mode.",
        "suggest": "根据当前舍入模式对结果进行舍入。",
        "translate": ""
    },
    {
        "source": "If the result cannot be represented as a 32 bit integer the result will be `0x8000_0000` (`i32::MIN`) or an invalid operation floating point exception if unmasked (see [`_mm_setcsr`](fn._mm_setcsr.html)).",
        "suggest": "如果结果不能表示为 32 位整数，则结果将为 `0x8000_0000` (`i32::MIN`) 或无效的操作浮点异常 (如果未屏蔽) (请参见 [`_mm_setcsr`](fn._mm_setcsr.html))。)。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `CVTSS2SI` instruction (with 32 bit output).",
        "suggest": "这对应于 `CVTSS2SI` 指令 (具有 32 位输出)。",
        "translate": ""
    },
    {
        "source": "Alias for [`_mm_cvtss_si32`](fn._mm_cvtss_si32.html).",
        "suggest": "[`_mm_cvtss_si32`](fn._mm_cvtss_si32.html) 的别名。",
        "translate": ""
    },
    {
        "source": "Converts the lowest 32 bit float in the input vector to a 32 bit integer with truncation.",
        "suggest": "将输入 vector 中的最低 32 位浮点型转换为带有截断的 32 位整数。",
        "translate": ""
    },
    {
        "source": "The result is rounded always using truncation (round towards zero).",
        "suggest": "始终使用截断将结果四舍五入 (趋向于零)。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `CVTTSS2SI` instruction (with 32 bit output).",
        "suggest": "这对应于 `CVTTSS2SI` 指令 (具有 32 位输出)。",
        "translate": ""
    },
    {
        "source": "Alias for [`_mm_cvttss_si32`](fn._mm_cvttss_si32.html).",
        "suggest": "[`_mm_cvttss_si32`](fn._mm_cvttss_si32.html) 的别名。",
        "translate": ""
    },
    {
        "source": "Extracts the lowest 32 bit float from the input vector.",
        "suggest": "从输入 vector 中提取最低的 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "No point in using assert_instrs.",
        "suggest": "使用 assert_instrs 没有意义。",
        "translate": ""
    },
    {
        "source": "In Unix x86_64 calling convention this is a no-op, and on Windows it's just a `mov`.",
        "suggest": "在 Unix 和 x86_64 调用约定中，这是一个空操作，而在 Windows 上，它只是一个 `mov`。",
        "translate": ""
    },
    {
        "source": "Converts a 32 bit integer to a 32 bit float.",
        "suggest": "将 32 位整数转换为 32 位浮点型。",
        "translate": ""
    },
    {
        "source": "The result vector is the input vector `a` with the lowest 32 bit float replaced by the converted integer.",
        "suggest": "结果 vector 是输入 vector `a`，其最低 32 位浮点数已由转换后的整数替换。",
        "translate": ""
    },
    {
        "source": "This intrinsic corresponds to the `CVTSI2SS` instruction (with 32 bit input).",
        "suggest": "此内联函数对应于 `CVTSI2SS` 指令 (具有 32 位输入)。",
        "translate": ""
    },
    {
        "source": "Alias for [`_mm_cvtsi32_ss`](fn._mm_cvtsi32_ss.html).",
        "suggest": "[`_mm_cvtsi32_ss`](fn._mm_cvtsi32_ss.html) 的别名。",
        "translate": ""
    },
    {
        "source": "Construct a `__m128` with the lowest element set to `a` and the rest set to zero.",
        "suggest": "创建一个 `__m128`，将最低元素设置为 `a`，将剩余部分设置为零。",
        "translate": ""
    },
    {
        "source": "Construct a `__m128` with all element set to `a`.",
        "suggest": "创建一个 `__m128`，并将所有元素设置为 `a`。",
        "translate": ""
    },
    {
        "source": "Alias for [`_mm_set1_ps`](fn._mm_set1_ps.html)",
        "suggest": "[`_mm_set1_ps`](fn._mm_set1_ps.html) 的别名",
        "translate": ""
    },
    {
        "source": "Construct a `__m128` from four floating point values highest to lowest.",
        "suggest": "从最高到最低的四个浮点值构造 `__m128`。",
        "translate": ""
    },
    {
        "source": "Note that `a` will be the highest 32 bits of the result, and `d` the lowest.",
        "suggest": "请注意，`a` 将是结果的最高 32 位，而 `d` 则是最低的 32 位。",
        "translate": ""
    },
    {
        "source": "This matches the standard way of writing bit patterns on x86:",
        "suggest": "这与在 x86 上写入位模式的标准方式匹配:",
        "translate": ""
    },
    {
        "source": "Construct a `__m128` from four floating point values lowest to highest.",
        "suggest": "从四个最低到最高的浮点值构造 `__m128`。",
        "translate": ""
    },
    {
        "source": "This matches the memory order of `__m128`, i.e., `a` will be the lowest 32 bits of the result, and `d` the highest.",
        "suggest": "这与 `__m128` 的存储顺序匹配，即 `a` 将是结果的最低 32 位，而 `d` 是结果的最高 32 位。",
        "translate": ""
    },
    {
        "source": "On a 32-bit architecture on non-Windows it just copies the operands from the stack.",
        "suggest": "在非 Windows 上的 32 位体系结构上，它仅从栈中复制操作数。",
        "translate": ""
    },
    {
        "source": "Construct a `__m128` with all elements initialized to zero.",
        "suggest": "创建一个 `__m128`，并将所有元素初始化为零。",
        "translate": ""
    },
    {
        "source": "A utility function for creating masks to use with Intel shuffle and permute intrinsics.",
        "suggest": "一个实用程序函数，用于创建与 Intel 重排和置换内联函数一起使用的掩码。",
        "translate": ""
    },
    {
        "source": "Shuffles packed single-precision (32-bit) floating-point elements in `a` and `b` using `mask`.",
        "suggest": "使用 `mask` 对 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "The lower half of result takes values from `a` and the higher half from `b`.",
        "suggest": "结果的下半部分取自 `a` 的值，而上半部分取自 `b` 的值。",
        "translate": ""
    },
    {
        "source": "Mask is split to 2 control bits each to index the element from inputs.",
        "suggest": "掩码被分成 2 个控制位，每个控制位用于索引输入中的元素。",
        "translate": ""
    },
    {
        "source": "Note that there appears to be a mistake within Intel's Intrinsics Guide.",
        "suggest": "请注意，<英特尔内部技术指南> 中似乎存在一个错误。",
        "translate": ""
    },
    {
        "source": "is supposed to take an `i32` instead of an `u32` as is the case for [other shuffle intrinsics](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_shuffle_).",
        "suggest": "应该像 [other shuffle intrinsics](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_shuffle_) 那样使用 `i32` 而不是 `u32`。",
        "translate": ""
    },
    {
        "source": "Performing an implicit type conversion between an unsigned integer and a signed integer does not cause a problem in C, however Rust's commitment to strong typing does not allow this.",
        "suggest": "在无符号整数和有符号整数之间执行隐式类型转换不会在 C 中引起问题，但是 Rust 对强类型化的承诺不允许这样做。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave single-precision (32-bit) floating-point elements from the higher half of `a` and `b`.",
        "suggest": "从 `a` 和 `b` 的上半部分解包并交织单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave single-precision (32-bit) floating-point elements from the lower half of `a` and `b`.",
        "suggest": "从 `a` 和 `b` 的下半部分解包并交织单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Combine higher half of `a` and `b`.",
        "suggest": "合并 `a` 和 `b` 的上半部分。",
        "translate": ""
    },
    {
        "source": "The highwe half of `b` occupies the lower half of result.",
        "suggest": "`b` 的上半部分占据结果的下半部分。",
        "translate": ""
    },
    {
        "source": "TODO; figure why this is a different instruction on Windows?",
        "suggest": "TODO; 为何在 Windows 上这是一条不同的指令?",
        "translate": ""
    },
    {
        "source": "Combine lower half of `a` and `b`.",
        "suggest": "合并 `a` 和 `b` 的下半部分。",
        "translate": ""
    },
    {
        "source": "The lower half of `b` occupies the higher half of result.",
        "suggest": "`b` 的下半部分占据结果的上半部分。",
        "translate": ""
    },
    {
        "source": "Returns a mask of the most significant bit of each element in `a`.",
        "suggest": "返回 `a` 中每个元素的最高有效位的掩码。",
        "translate": ""
    },
    {
        "source": "The mask is stored in the 4 least significant bits of the return value.",
        "suggest": "掩码存储在返回值的 4 个最低有效位中。",
        "translate": ""
    },
    {
        "source": "All other bits are set to `0`.",
        "suggest": "所有其他位设置为 `0`。",
        "translate": ""
    },
    {
        "source": "LLVM9 trunk has the following bug:",
        "suggest": "LLVM9 中继具有以下错误:",
        "translate": ""
    },
    {
        "source": "so we only temporarily test this on i686 and x86_64 but not on i586:",
        "suggest": "因此，我们仅在 i686 和 x86_64 上临时测试，而在 i586 上不测试:",
        "translate": ""
    },
    {
        "source": "Construct a `__m128` with the lowest element read from `p` and the other elements set to zero.",
        "suggest": "使用从 `p` 读取的最低元素并将其他元素设置为零来构造 `__m128`。",
        "translate": ""
    },
    {
        "source": "This corresponds to instructions `VMOVSS` / `MOVSS`.",
        "suggest": "这对应于指令 `VMOVSS`/`MOVSS`。",
        "translate": ""
    },
    {
        "source": "Construct a `__m128` by duplicating the value read from `p` into all elements.",
        "suggest": "通过将从 `p` 读取的值复制到所有元素中来构造 `__m128`。",
        "translate": ""
    },
    {
        "source": "This corresponds to instructions `VMOVSS` / `MOVSS` followed by some shuffling.",
        "suggest": "这对应于指令 `VMOVSS`/`MOVSS`，然后进行一些改组。",
        "translate": ""
    },
    {
        "source": "Alias for [`_mm_load1_ps`](fn._mm_load1_ps.html)",
        "suggest": "[`_mm_load1_ps`](fn._mm_load1_ps.html) 的别名",
        "translate": ""
    },
    {
        "source": "Loads four `f32` values from *aligned* memory into a `__m128`.",
        "suggest": "将 *aligned* 内存中的四个 `f32` 值加载到 `__m128` 中。",
        "translate": ""
    },
    {
        "source": "If the pointer is not aligned to a 128-bit boundary (16 bytes) a general protection fault will be triggered (fatal program crash).",
        "suggest": "如果指针未与 128 位边界 (16 个字节) 对齐，则将触发一般保护错误 (致命程序崩溃)。",
        "translate": ""
    },
    {
        "source": "Use [`_mm_loadu_ps`](fn._mm_loadu_ps.html) for potentially unaligned memory.",
        "suggest": "[`_mm_loadu_ps`](fn._mm_loadu_ps.html) 用于可能未对齐的内存。",
        "translate": ""
    },
    {
        "source": "This corresponds to instructions `VMOVAPS` / `MOVAPS`.",
        "suggest": "这对应于指令 `VMOVAPS`/`MOVAPS`。",
        "translate": ""
    },
    {
        "source": "Loads four `f32` values from memory into a `__m128`.",
        "suggest": "从内存中将四个 `f32` 值加载到 `__m128` 中。",
        "translate": ""
    },
    {
        "source": "There are no restrictions on memory alignment.",
        "suggest": "内存对齐没有任何限制。",
        "translate": ""
    },
    {
        "source": "For aligned memory",
        "suggest": "对于对齐的内存",
        "translate": ""
    },
    {
        "source": "may be faster.",
        "suggest": "可能更快。",
        "translate": ""
    },
    {
        "source": "This corresponds to instructions `VMOVUPS` / `MOVUPS`.",
        "suggest": "这对应于指令 `VMOVUPS`/`MOVUPS`。",
        "translate": ""
    },
    {
        "source": "Using `*p` would require `f32` alignment, but `movups` has no alignment restrictions.",
        "suggest": "使用 `*p` 需要 `f32` 对齐，但是 `movups` 没有对齐限制。",
        "translate": ""
    },
    {
        "source": "Loads four `f32` values from aligned memory into a `__m128` in reverse order.",
        "suggest": "从对齐的内存中以相反的顺序将四个 `f32` 值加载到 `__m128` 中。",
        "translate": ""
    },
    {
        "source": "Functionally equivalent to the following code sequence (assuming `p` satisfies the alignment restrictions):",
        "suggest": "在功能上等效于以下代码序列 (假设 `p` 满足对齐限制) :",
        "translate": ""
    },
    {
        "source": "This corresponds to instructions `VMOVAPS` / `MOVAPS` followed by some shuffling.",
        "suggest": "这对应于指令 `VMOVAPS`/`MOVAPS`，然后进行一些改组。",
        "translate": ""
    },
    {
        "source": "Loads unaligned 64-bits of integer data from memory into new vector.",
        "suggest": "将未对齐的 64 位整数数据从内存加载到新的 vector 中。",
        "translate": ""
    },
    {
        "source": "Stores the lowest 32 bit float of `a` into memory.",
        "suggest": "将 `a` 的最低 32 位浮点数存储到内存中。",
        "translate": ""
    },
    {
        "source": "This intrinsic corresponds to the `MOVSS` instruction.",
        "suggest": "此内联函数对应于 `MOVSS` 指令。",
        "translate": ""
    },
    {
        "source": "Stores the lowest 32 bit float of `a` repeated four times into *aligned* memory.",
        "suggest": "将 `a` 的最低 32 位浮点数重复存储四次到 *aligned* 存储器中。",
        "translate": ""
    },
    {
        "source": "Alias for [`_mm_store1_ps`](fn._mm_store1_ps.html)",
        "suggest": "[`_mm_store1_ps`](fn._mm_store1_ps.html) 的别名",
        "translate": ""
    },
    {
        "source": "Stores four 32-bit floats into *aligned* memory.",
        "suggest": "将四个 32 位浮点数存储到 *aligned* 存储器中。",
        "translate": ""
    },
    {
        "source": "Use [`_mm_storeu_ps`](fn._mm_storeu_ps.html) for potentially unaligned memory.",
        "suggest": "[`_mm_storeu_ps`](fn._mm_storeu_ps.html) 用于可能未对齐的内存。",
        "translate": ""
    },
    {
        "source": "Stores four 32-bit floats into memory.",
        "suggest": "将四个 32 位浮点数存储到内存中。",
        "translate": ""
    },
    {
        "source": "For aligned memory [`_mm_store_ps`](fn._mm_store_ps.html) may be faster.",
        "suggest": "对于对齐的内存，[`_mm_store_ps`](fn._mm_store_ps.html) 可能更快。",
        "translate": ""
    },
    {
        "source": "Stores four 32-bit floats into *aligned* memory in reverse order.",
        "suggest": "以相反的顺序将四个 32 位浮点数存储到 *aligned* 存储器中。",
        "translate": ""
    },
    {
        "source": "Returns a `__m128` with the first component from `b` and the remaining components from `a`.",
        "suggest": "返回 `__m128`，其中第一个组件来自 `b`，其余组件来自 `a`。",
        "translate": ""
    },
    {
        "source": "In other words for any `a` and `b`:",
        "suggest": "换句话说，对于任何 `a` 和 `b`:",
        "translate": ""
    },
    {
        "source": "Performs a serializing operation on all store-to-memory instructions that were issued prior to this instruction.",
        "suggest": "对在此指令之前发出的所有存储到内存指令执行序列化操作。",
        "translate": ""
    },
    {
        "source": "Guarantees that every store instruction that precedes, in program order, is globally visible before any store instruction which follows the fence in program order.",
        "suggest": "确保按程序顺序在先的每个存储指令在程序顺序中位于篱笆后面的任何存储指令之前都是全局可见的。",
        "translate": ""
    },
    {
        "source": "Gets the unsigned 32-bit value of the MXCSR control and status register.",
        "suggest": "获取 MXCSR 控制和状态寄存器的无符号 32 位值。",
        "translate": ""
    },
    {
        "source": "For more info see [`_mm_setcsr`](fn._mm_setcsr.html)",
        "suggest": "有关更多信息，请参见 [`_mm_setcsr`](fn._mm_setcsr.html)。",
        "translate": ""
    },
    {
        "source": "Sets the MXCSR register with the 32-bit unsigned integer value.",
        "suggest": "用 32 位无符号整数值设置 MXCSR 寄存器。",
        "translate": ""
    },
    {
        "source": "This register constrols how SIMD instructions handle floating point operations.",
        "suggest": "该寄存器控制 SIMD 指令如何处理浮点运算。",
        "translate": ""
    },
    {
        "source": "Modifying this register only affects the current thread.",
        "suggest": "修改该寄存器只会影响当前线程。",
        "translate": ""
    },
    {
        "source": "It contains several groups of flags:",
        "suggest": "它包含几组标志:",
        "translate": ""
    },
    {
        "source": "flags* report which exceptions occurred since last they were reset.",
        "suggest": "标志 * 报告自上次重置以来发生了哪些异常。",
        "translate": ""
    },
    {
        "source": "flags* can be used to mask (ignore) certain exceptions.",
        "suggest": "`flags*` 可用于屏蔽 (ignore) 某些异常。",
        "translate": ""
    },
    {
        "source": "By default these flags are all set to 1, so all exceptions are masked.",
        "suggest": "默认情况下，这些标志都设置为 1，因此所有异常都被屏蔽。",
        "translate": ""
    },
    {
        "source": "When an an exception is masked, the processor simply sets the exception flag and continues the operation.",
        "suggest": "屏蔽了异常后，处理器将简单地设置异常标志并继续操作。",
        "translate": ""
    },
    {
        "source": "If the exception is unmasked, the flag is also set but additionally an exception handler is invoked.",
        "suggest": "如果未屏蔽该异常，则还会设置该标志，但是还会调用一个异常处理程序。",
        "translate": ""
    },
    {
        "source": "flags* control the rounding mode of floating point instructions.",
        "suggest": "`flags*` 控制浮点指令的舍入模式。",
        "translate": ""
    },
    {
        "source": "The *denormals-are-zero mode flag* turns all numbers which would be denormalized (exponent bits are all zeros) into zeros.",
        "suggest": "非规范化为零模式 `flags*` 将所有将要归一化 (指数位全为零) 的数字转换为零。",
        "translate": ""
    },
    {
        "source": "Exception Flags",
        "suggest": "异常标志",
        "translate": ""
    },
    {
        "source": "An invalid operation was performed (e.g., dividing Infinity by Infinity).",
        "suggest": "执行了无效的操作 (例如，将 Infinity 除以 Infinity)。",
        "translate": ""
    },
    {
        "source": "An operation attempted to operate on a denormalized number.",
        "suggest": "一项操作尝试对非正规数进行操作。",
        "translate": ""
    },
    {
        "source": "Mainly this can cause loss of precision.",
        "suggest": "这主要会导致精度降低。",
        "translate": ""
    },
    {
        "source": "Division by zero occured.",
        "suggest": "被零除的情况发生了。",
        "translate": ""
    },
    {
        "source": "A numeric overflow exception occured, i.e., a result was too large to be represented (e.g., an `f32` with absolute value greater than `2^128`).",
        "suggest": "发生数字溢出异常，即结果太大而无法表示 (例如，绝对值大于 `2^128` 的 `f32`)。",
        "translate": ""
    },
    {
        "source": "A numeric underflow exception occured, i.e., a result was too small to be represented in a normalized way (e.g., an",
        "suggest": "发生数字下溢异常，即结果太小而无法以标准化方式表示 (例如，",
        "translate": ""
    },
    {
        "source": "with absulte value smaller than `2^-126`.)",
        "suggest": "绝对值小于 `2 ^-126`。)",
        "translate": ""
    },
    {
        "source": "An inexact-result exception occured (a.k.a.",
        "suggest": "发生了不精确的结果异常 (又名",
        "translate": ""
    },
    {
        "source": "precision exception).",
        "suggest": "精度异常)。",
        "translate": ""
    },
    {
        "source": "This means some precision was lost due to rounding.",
        "suggest": "这意味着由于舍入而损失了一些精度。",
        "translate": ""
    },
    {
        "source": "For example, the fraction `1/3` cannot be represented accurately in a",
        "suggest": "例如，分数 `1/3` 无法在",
        "translate": ""
    },
    {
        "source": "32 or 64 bit float and computing it would cause this exception to be raised.",
        "suggest": "32 位或 64 位浮点数并对其进行计算将导致引发此异常。",
        "translate": ""
    },
    {
        "source": "Precision exceptions are very common, so they are usually masked.",
        "suggest": "精度异常非常常见，因此通常会被屏蔽。",
        "translate": ""
    },
    {
        "source": "Exception flags can be read and set using the convenience functions `_MM_GET_EXCEPTION_STATE` and `_MM_SET_EXCEPTION_STATE`.",
        "suggest": "可以使用便捷函数 `_MM_GET_EXCEPTION_STATE` 和 `_MM_SET_EXCEPTION_STATE` 读取和设置异常标志。",
        "translate": ""
    },
    {
        "source": "For example, to check if an operation caused some overflow:",
        "suggest": "例如，要检查某个操作是否引起一些溢出:",
        "translate": ""
    },
    {
        "source": "Masking Flags",
        "suggest": "掩蔽标志",
        "translate": ""
    },
    {
        "source": "There is one masking flag for each exception flag: `_MM_MASK_INVALID`, `_MM_MASK_DENORM`, `_MM_MASK_DIV_ZERO`, `_MM_MASK_OVERFLOW`, `_MM_MASK_UNDERFLOW`,",
        "suggest": "每个异常标志都有一个屏蔽标志: `_MM_MASK_INVALID`，`_MM_MASK_DENORM`，`_MM_MASK_DIV_ZERO`，`_MM_MASK_OVERFLOW`，`_MM_MASK_UNDERFLOW`，",
        "translate": ""
    },
    {
        "source": "A single masking bit can be set via",
        "suggest": "可以通过设置单个屏蔽位",
        "translate": ""
    },
    {
        "source": "However, since mask bits are by default all set to 1, it is more common to want to *disable* certain bits.",
        "suggest": "但是，由于默认情况下所有掩码位都设置为 1，因此更常见的是要 *禁用* 某些位。",
        "translate": ""
    },
    {
        "source": "For example, to unmask the underflow exception, use:",
        "suggest": "例如，要掩盖下溢异常，请使用:",
        "translate": ""
    },
    {
        "source": "Warning: an unmasked exception will cause an exception handler to be called.",
        "suggest": "警告: 未屏蔽的异常将导致调用异常处理程序。",
        "translate": ""
    },
    {
        "source": "The standard handler will simply terminate the process.",
        "suggest": "标准处理程序将简单地终止该进程。",
        "translate": ""
    },
    {
        "source": "So, in this case any underflow exception would terminate the current process with something like `signal: 8, SIGFPE: erroneous arithmetic operation`.",
        "suggest": "因此，在这种情况下，任何下溢异常都将使用诸如 `signal: 8, SIGFPE: erroneous arithmetic operation` 之类的内容终止当前进程。",
        "translate": ""
    },
    {
        "source": "Rounding Mode",
        "suggest": "舍入模式",
        "translate": ""
    },
    {
        "source": "The rounding mode is describe using two bits.",
        "suggest": "使用两位描述舍入模式。",
        "translate": ""
    },
    {
        "source": "It can be read and set using the convenience wrappers `_MM_GET_ROUNDING_MODE()` and `_MM_SET_ROUNDING_MODE(mode)`.",
        "suggest": "可以使用便捷包装 `_MM_GET_ROUNDING_MODE()` 和 `_MM_SET_ROUNDING_MODE(mode)` 进行读取和设置。",
        "translate": ""
    },
    {
        "source": "The rounding modes are:",
        "suggest": "舍入模式为:",
        "translate": ""
    },
    {
        "source": "(default) Round to closest to the infinite precision value.",
        "suggest": "(default) 四舍五入到最接近无限精度值。",
        "translate": ""
    },
    {
        "source": "If two values are equally close, round to even (i.e., least significant bit will be zero).",
        "suggest": "如果两个值相等接近，则四舍五入为偶数 (即，最低有效位将为零)。",
        "translate": ""
    },
    {
        "source": "Round toward negative Infinity.",
        "suggest": "向负无穷大舍入。",
        "translate": ""
    },
    {
        "source": "Round toward positive Infinity.",
        "suggest": "向正无穷大方向舍入。",
        "translate": ""
    },
    {
        "source": "Round towards zero (truncate).",
        "suggest": "向零 (truncate) 舍入。",
        "translate": ""
    },
    {
        "source": "If this bit is set, values that would be denormalized will be set to zero instead.",
        "suggest": "如果设置了此位，则将要反规范化的值将设置为零。",
        "translate": ""
    },
    {
        "source": "This is turned off by default.",
        "suggest": "默认情况下是关闭的。",
        "translate": ""
    },
    {
        "source": "You can read and enable/disable this mode via the helper functions `_MM_GET_FLUSH_ZERO_MODE()` and `_MM_SET_FLUSH_ZERO_MODE()`:",
        "suggest": "您可以通过辅助函数 `_MM_GET_FLUSH_ZERO_MODE()` 和 `_MM_SET_FLUSH_ZERO_MODE()` 读取和 enable/disable 此模式:",
        "translate": ""
    },
    {
        "source": "See [`_mm_setcsr`](fn._mm_setcsr.html)",
        "suggest": "请参见 [`_mm_setcsr`](fn._mm_setcsr.html)",
        "translate": ""
    },
    {
        "source": "See [`_MM_GET_EXCEPTION_STATE`](fn._MM_GET_EXCEPTION_STATE.html)",
        "suggest": "请参见 [`_MM_GET_EXCEPTION_STATE`](fn._MM_GET_EXCEPTION_STATE.html)",
        "translate": ""
    },
    {
        "source": "See [`_MM_GET_EXCEPTION_MASK`](fn._MM_GET_EXCEPTION_MASK.html)",
        "suggest": "请参见 [`_MM_GET_EXCEPTION_MASK`](fn._MM_GET_EXCEPTION_MASK.html)",
        "translate": ""
    },
    {
        "source": "See [`_MM_GET_ROUNDING_MODE`](fn._MM_GET_ROUNDING_MODE.html)",
        "suggest": "请参见 [`_MM_GET_ROUNDING_MODE`](fn._MM_GET_ROUNDING_MODE.html)",
        "translate": ""
    },
    {
        "source": "See [`_MM_GET_FLUSH_ZERO_MODE`](fn._MM_GET_FLUSH_ZERO_MODE.html)",
        "suggest": "请参见 [`_MM_GET_FLUSH_ZERO_MODE`](fn._MM_GET_FLUSH_ZERO_MODE.html)",
        "translate": ""
    },
    {
        "source": "See [`_mm_prefetch`](fn._mm_prefetch.html).",
        "suggest": "请参见 [`_mm_prefetch`](fn._mm_prefetch.html)。",
        "translate": ""
    },
    {
        "source": "Fetch the cache line that contains address `p` using the given `strategy`.",
        "suggest": "使用给定的 `strategy` 获取包含地址 `p` 的缓存行。",
        "translate": ""
    },
    {
        "source": "The `strategy` must be one of:",
        "suggest": "`strategy` 必须是以下之一:",
        "translate": ""
    },
    {
        "source": "Fetch into all levels of the cache hierarchy.",
        "suggest": "提取到缓存层次结构的所有级别。",
        "translate": ""
    },
    {
        "source": "Fetch into L2 and higher.",
        "suggest": "提取到 L2 及更高版本中。",
        "translate": ""
    },
    {
        "source": "Fetch into L3 and higher or an   implementation-specific choice (e.g., L2 if there is no L3).",
        "suggest": "获取 L3 及更高版本或特定于实现的选择 (例如，如果没有 L3，则获取 L2)。",
        "translate": ""
    },
    {
        "source": "Fetch data using the non-temporal access (NTA) hint.",
        "suggest": "使用非临时访问 (NTA) 提示获取数据。",
        "translate": ""
    },
    {
        "source": "It may be a place closer than main memory but outside of the cache hierarchy.",
        "suggest": "它可能比主存储器更近，但不在高速缓存层次结构之外。",
        "translate": ""
    },
    {
        "source": "This is used to reduce access latency without polluting the cache.",
        "suggest": "这用于减少访问延迟而不污染高速缓存。",
        "translate": ""
    },
    {
        "source": "The actual implementation depends on the particular CPU.",
        "suggest": "实际的实现取决于特定的 CPU。",
        "translate": ""
    },
    {
        "source": "This instruction is considered a hint, so the CPU is also free to simply ignore the request.",
        "suggest": "该指令被认为是提示，因此 CPU 也可以随意忽略该请求。",
        "translate": ""
    },
    {
        "source": "The amount of prefetched data depends on the cache line size of the specific CPU, but it will be at least 32 bytes.",
        "suggest": "预取的数据量取决于特定 CPU 的高速缓存行大小，但至少为 32 个字节。",
        "translate": ""
    },
    {
        "source": "Common caveats:",
        "suggest": "常见警告:",
        "translate": ""
    },
    {
        "source": "Most modern CPUs already automatically prefetch data based on predicted access patterns.",
        "suggest": "大多数现代 CPU 已经根据预测的访问模式自动预取数据。",
        "translate": ""
    },
    {
        "source": "Data is usually not fetched if this would cause a TLB miss or a page fault.",
        "suggest": "如果这会导致 TLB 丢失或页面错误，通常不会提取数据。",
        "translate": ""
    },
    {
        "source": "Too much prefetching can cause unnecessary cache evictions.",
        "suggest": "过多的预取会导致不必要的缓存逐出。",
        "translate": ""
    },
    {
        "source": "Prefetching may also fail if there are not enough memory-subsystem resources (e.g., request buffers).",
        "suggest": "如果没有足够的内存子系统资源 (例如，请求缓冲区)，则预取也可能会失败。",
        "translate": ""
    },
    {
        "source": "The `strategy` must be a compile-time constant, so we use a short form of `constify_imm8!` for now.",
        "suggest": "`strategy` 必须是编译时常量，因此我们现在使用 `constify_imm8!` 的简写形式。",
        "translate": ""
    },
    {
        "source": "We use the `llvm.prefetch` instrinsic with `rw` = 0 (read), and `cache type` = 1 (data cache).",
        "suggest": "我们使用 `llvm.prefetch` 内联函数，其中 `rw` =0 (read)，并且 `cache type` =1 (数据缓存)。",
        "translate": ""
    },
    {
        "source": "is based on our `strategy`.",
        "suggest": "基于我们的 `strategy`。",
        "translate": ""
    },
    {
        "source": "Returns vector of type __m128 with undefined elements.",
        "suggest": "返回类型为 __m128 的 vector，其中包含未定义的元素。",
        "translate": ""
    },
    {
        "source": "Transpose the 4x4 matrix formed by 4 rows of __m128 in place.",
        "suggest": "将由 4 行 __m128 组成的 4x4 矩阵转置到位。",
        "translate": ""
    },
    {
        "source": "Stores `a` into the memory at `mem_addr` using a non-temporal memory hint.",
        "suggest": "使用非临时内存提示将 `a` 存储到 `mem_addr` 的内存中。",
        "translate": ""
    },
    {
        "source": "must be aligned on a 16-byte boundary or a general-protection exception _may_ be generated.",
        "suggest": "必须在 16 字节边界上对齐，否则将生成常规保护异常 _may_。",
        "translate": ""
    },
    {
        "source": "can **not** be implemented using the `simd_min` rust intrinsic.",
        "suggest": "不能使用 `simd_min` rust 内联函数实现。",
        "translate": ""
    },
    {
        "source": "is lowered by the llvm codegen backend to `llvm.minnum.v*` llvm intrinsic.",
        "suggest": "由 llvm 代码生成后端降低为 `llvm.minnum.v*` llvm 固有。",
        "translate": ""
    },
    {
        "source": "This intrinsic doesn't specify how -0.0 is handled.",
        "suggest": "此内联函数未指定如何处理 -0.0。",
        "translate": ""
    },
    {
        "source": "Unfortunately it happens to behave different from the `minps` x86 instruction on x86.",
        "suggest": "不幸的是，它的行为与 x86 上的 `minps` x86 指令不同。",
        "translate": ""
    },
    {
        "source": "The `llvm.minnum.v*` llvm intrinsic equals `r1` to `a` and `r2` to `b`.",
        "suggest": "`llvm.minnum.v*` llvm 内联函数等于 `r1` 到 `a`，并且 `r2` 到 `b`。",
        "translate": ""
    },
    {
        "source": "sanity check that -0.0 is actually present",
        "suggest": "实际检查是否存在 - 0.0",
        "translate": ""
    },
    {
        "source": "this test is exactly the same as for `_mm_cmpge_ss`, but there must be a difference.",
        "suggest": "此测试与 `_mm_cmpge_ss` 完全相同，但必须有所不同。",
        "translate": ""
    },
    {
        "source": "It may have to do with behavior in the presence of NaNs (signaling or quiet).",
        "suggest": "它可能与存在 NaN 时的行为有关 (信号或静默)。",
        "translate": ""
    },
    {
        "source": "If so, we should add tests for those.",
        "suggest": "如果是这样，我们应该为这些添加测试。",
        "translate": ""
    },
    {
        "source": "this test is exactly the same as for `_mm_cmpgt_ss`, but there must be a difference.",
        "suggest": "此测试与 `_mm_cmpgt_ss` 完全相同，但必须有所不同。",
        "translate": ""
    },
    {
        "source": "this test is exactly the same as for `_mm_cmple_ss`, but there must be a difference.",
        "suggest": "此测试与 `_mm_cmple_ss` 完全相同，但必须有所不同。",
        "translate": ""
    },
    {
        "source": "this test is exactly the same as for `_mm_cmplt_ss`, but there must be a difference.",
        "suggest": "此测试与 `_mm_cmplt_ss` 完全相同，但必须有所不同。",
        "translate": ""
    },
    {
        "source": "If one of the arguments is a quiet NaN `comieq_ss` should signal an Invalid Operation Exception while `ucomieq_ss` should not.",
        "suggest": "如果参数之一是安静的 NaN，则 `comieq_ss` 应发出无效操作异常信号，而 `ucomieq_ss` 则不应。",
        "translate": ""
    },
    {
        "source": "Should comieq_ss signal an exception?",
        "suggest": "comieq_ss 是否应该发出异常信号?",
        "translate": ""
    },
    {
        "source": "ucomieq_ss should not signal an exception",
        "suggest": "ucomieq_ss 不应发出异常信号",
        "translate": ""
    },
    {
        "source": "Make sure p is aligned, otherwise we might get a (signal: 11, SIGSEGV: invalid memory reference)",
        "suggest": "确保 p 对齐，否则我们可能会得到一个 (信号: 11，SIGSEGV: 无效的内存引用)",
        "translate": ""
    },
    {
        "source": "Align p to 16-byte boundary",
        "suggest": "将 p 对齐到 16 字节边界",
        "translate": ""
    },
    {
        "source": "Make sure p is **not** aligned to 16-byte boundary",
        "suggest": "确保 p 不与 16 字节边界对齐",
        "translate": ""
    },
    {
        "source": "first component is a denormalized f32",
        "suggest": "第一个组件是非规范化的 f32",
        "translate": ""
    },
    {
        "source": "Same as _mm_setcsr_1 test, but with opposite flag value.",
        "suggest": "与 _mm_setcsr_1 测试相同，但标志值相反。",
        "translate": ""
    },
    {
        "source": "just to be sure",
        "suggest": "只是要确定",
        "translate": ""
    },
    {
        "source": "Streaming SIMD Extensions 2 (SSE2)",
        "suggest": "流式 SIMD 扩展 2 (SSE2)",
        "translate": ""
    },
    {
        "source": "Provides a hint to the processor that the code sequence is a spin-wait loop.",
        "suggest": "向处理器提示代码序列是自旋等待循环。",
        "translate": ""
    },
    {
        "source": "This can help improve the performance and power consumption of spin-wait loops.",
        "suggest": "这可以帮助改善自旋等待循环的性能和功耗。",
        "translate": ""
    },
    {
        "source": "`pause` is guaranteed to be interpreted as a `nop` by CPUs without the SSE2 target-feature - therefore it does not require any target features",
        "suggest": "保证 `pause` 被没有 SSE2 目标功能的 CPU 解释为 `nop` - 因此它不需要任何目标功能",
        "translate": ""
    },
    {
        "source": "Invalidates and flushes the cache line that contains `p` from all levels of the cache hierarchy.",
        "suggest": "使高速缓存层次结构中所有级别的包含 `p` 的高速缓存行失效并刷新。",
        "translate": ""
    },
    {
        "source": "Performs a serializing operation on all load-from-memory instructions that were issued prior to this instruction.",
        "suggest": "对在此指令之前发布的所有内存加载指令执行序列化操作。",
        "translate": ""
    },
    {
        "source": "Guarantees that every load instruction that precedes, in program order, is globally visible before any load instruction which follows the fence in program order.",
        "suggest": "确保按程序顺序在前面的每个装入指令在按程序顺序在篱笆后面的任何装入指令之前都是全局可见的。",
        "translate": ""
    },
    {
        "source": "Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to this instruction.",
        "suggest": "对在此指令之前发布的所有从内存加载和存储到内存指令执行序列化操作。",
        "translate": ""
    },
    {
        "source": "Guarantees that every memory access that precedes, in program order, the memory fence instruction is globally visible before any memory instruction which follows the fence in program order.",
        "suggest": "确保按照程序顺序在内存围墙指令之前的每个内存访问在程序顺序后在围墙之后的任何内存指令之前都是全局可见的。",
        "translate": ""
    },
    {
        "source": "Multiplies and then horizontally add signed 16 bit integers in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中相乘，然后水平相加带符号的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Multiplies the packed 16-bit integers in `a` and `b`.",
        "suggest": "将 `a` 和 `b` 中的包装的 16 位整数相乘。",
        "translate": ""
    },
    {
        "source": "The multiplication produces intermediate 32-bit integers, and returns the high 16 bits of the intermediate integers.",
        "suggest": "乘法产生中间的 32 位整数，并返回中间整数的高 16 位。",
        "translate": ""
    },
    {
        "source": "Multiplies the packed unsigned 16-bit integers in `a` and `b`.",
        "suggest": "将 `a` 和 `b` 中包装的无符号 16 位整数相乘。",
        "translate": ""
    },
    {
        "source": "The multiplication produces intermediate 32-bit integers, and returns the low 16 bits of the intermediate integers.",
        "suggest": "乘法产生中间的 32 位整数，并返回中间整数的低 16 位。",
        "translate": ""
    },
    {
        "source": "Multiplies the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`.",
        "suggest": "将 `a` 和 `b` 中每个包装的 64 位元素中的低 32 位无符号整数相乘。",
        "translate": ""
    },
    {
        "source": "Sum the absolute differences of packed unsigned 8-bit integers.",
        "suggest": "包装无符号 8 位整数的绝对差之和。",
        "translate": ""
    },
    {
        "source": "Computes the absolute differences of packed unsigned 8-bit integers in `a` and `b`, then horizontally sum each consecutive 8 differences to produce two unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements returned.",
        "suggest": "计算 `a` 和 `b` 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差异水平求和以生成两个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位元素的低 16 位中回。",
        "translate": ""
    },
    {
        "source": "Subtracts packed 8-bit integers in `b` from packed 8-bit integers in `a`.",
        "suggest": "从 `a` 中的包装的 8 位整数中减去 `b` 中的包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Subtracts packed 16-bit integers in `b` from packed 16-bit integers in `a`.",
        "suggest": "从 `a` 中的包装的 16 位整数减去 `b` 中的包装的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.",
        "suggest": "从 `a` 中的包装的 32 位整数中减去 `b` 中的包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`.",
        "suggest": "从 `a` 中的包装的 64 位整数中减去 `b` 中的包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit integers in `a` using saturation.",
        "suggest": "使用饱和度从 `a` 中的包装无符号 8 位整数减去 `b` 中的包装无符号 8 位整数。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit integers in `a` using saturation.",
        "suggest": "使用饱和度从 `a` 中的包装的无符号 16 位整数减去 `b` 中的包装的无符号 16 位整数。",
        "translate": ""
    },
    {
        "source": "Shifts `a` left by `imm8` bytes while shifting in zeros.",
        "suggest": "将 `a` 向左移 `imm8` 字节，同时向零移动。",
        "translate": ""
    },
    {
        "source": "Implementation detail: converts the immediate argument of the `_mm_slli_si128` intrinsic into a compile-time constant.",
        "suggest": "实现细节: 将 `_mm_slli_si128` 内联函数的立即参数转换为编译时常量。",
        "translate": ""
    },
    {
        "source": "Shifts `a` right by `imm8` bytes while shifting in zeros.",
        "suggest": "将 `a` 向右移 `imm8` 字节，同时向零移动。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` left by `imm8` while shifting in zeros.",
        "suggest": "将 `imm8` 左移的 `a` 中的包装的 16 位整数移位，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` left by `count` while shifting in zeros.",
        "suggest": "将 `count` 左移的 `a` 中的包装的 16 位整数移位，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` left by `imm8` while shifting in zeros.",
        "suggest": "将 `imm8` 左移的 `a` 中的包装的 32 位整数移位，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` left by `count` while shifting in zeros.",
        "suggest": "将 `count` 左移的 `a` 中的包装的 32 位整数移位，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` left by `imm8` while shifting in zeros.",
        "suggest": "将 `imm8` 左移的 `a` 中的包装的 64 位整数移位，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` left by `count` while shifting in zeros.",
        "suggest": "将 `count` 左移的 `a` 中的包装的 64 位整数移位，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Implementation detail: converts the immediate argument of the `_mm_srli_si128` intrinsic into a compile-time constant.",
        "suggest": "实现细节: 将 `_mm_srli_si128` 内联函数的立即参数转换为编译时常量。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` right by `imm8` while shifting in zeros.",
        "suggest": "将 `a` 中的包装的 16 位整数右移 `imm8`，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` right by `imm8` while shifting in zeros.",
        "suggest": "将 `a` 中的包装的 32 位整数右移 `imm8`，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` right by `imm8` while shifting in zeros.",
        "suggest": "将 `a` 中的包装的 64 位整数右移 `imm8`，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of 128 bits (representing integer data) in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中 128 位 (表示整数数据) 的按位与。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise NOT of 128 bits (representing integer data) in `a` and then AND with `b`.",
        "suggest": "计算 `a` 中 128 位 (代表整数数据) 的按位非，然后计算 `b` 的与。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise OR of 128 bits (representing integer data) in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中 128 位 (表示整数数据) 的按位或。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise XOR of 128 bits (representing integer data) in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中 128 位 (表示整数数据) 的按位 XOR。",
        "translate": ""
    },
    {
        "source": "Compares packed 8-bit integers in `a` and `b` for less-than.",
        "suggest": "比较 `a` 和 `b` 中小于 8 的包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Compares packed 16-bit integers in `a` and `b` for less-than.",
        "suggest": "比较 `a` 和 `b` 中的包装的 16 位整数小于。",
        "translate": ""
    },
    {
        "source": "Compares packed 32-bit integers in `a` and `b` for less-than.",
        "suggest": "比较 `a` 和 `b` 中的包装的 32 位整数是否小于。",
        "translate": ""
    },
    {
        "source": "Converts the lower two packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements.",
        "suggest": "将 `a` 中的低位两个包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Returns `a` with its lower element replaced by `b` after converting it to an `f64`.",
        "suggest": "将 `a` 的下位元素转换为 `f64` 后，返回其下位元素为 `b` 的 `a`。",
        "translate": ""
    },
    {
        "source": "Returns a vector whose lowest element is `a` and all higher elements are `0`.",
        "suggest": "返回 vector，其最低元素为 `a`，所有更高元素为 `0`。",
        "translate": ""
    },
    {
        "source": "Returns the lowest element of `a`.",
        "suggest": "返回 `a` 的最低元素。",
        "translate": ""
    },
    {
        "source": "Sets packed 64-bit integers with the supplied values, from highest to lowest.",
        "suggest": "使用提供的值 (从最高到最低) 设置包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "no particular instruction to test",
        "suggest": "没有特定的测试指令",
        "translate": ""
    },
    {
        "source": "Sets packed 32-bit integers with the supplied values.",
        "suggest": "使用提供的值设置包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Sets packed 16-bit integers with the supplied values.",
        "suggest": "使用提供的值设置包装的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Sets packed 8-bit integers with the supplied values.",
        "suggest": "使用提供的值设置包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Broadcasts 64-bit integer `a` to all elements.",
        "suggest": "向所有元素广播 64 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 32-bit integer `a` to all elements.",
        "suggest": "向所有元素广播 32 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 16-bit integer `a` to all elements.",
        "suggest": "向所有元素广播 16 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 8-bit integer `a` to all elements.",
        "suggest": "向所有元素广播 8 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "Sets packed 32-bit integers with the supplied values in reverse order.",
        "suggest": "以相反的顺序设置提供的值的包装 32 位整数。",
        "translate": ""
    },
    {
        "source": "Sets packed 16-bit integers with the supplied values in reverse order.",
        "suggest": "以相反的顺序设置提供的值的包装 16 位整数。",
        "translate": ""
    },
    {
        "source": "Sets packed 8-bit integers with the supplied values in reverse order.",
        "suggest": "以相反的顺序设置提供的值的包装 8 位整数。",
        "translate": ""
    },
    {
        "source": "Returns a vector with all elements set to zero.",
        "suggest": "返回所有元素均设置为零的 vector。",
        "translate": ""
    },
    {
        "source": "Loads 64-bit integer from memory into first element of returned vector.",
        "suggest": "将内存中的 64 位整数加载到返回的 vector 的第一个元素中。",
        "translate": ""
    },
    {
        "source": "FIXME movsd on windows",
        "suggest": "FIXME windows 上的 movsd",
        "translate": ""
    },
    {
        "source": "Loads 128-bits of integer data from memory into a new vector.",
        "suggest": "从内存中将 128 位整数数据加载到新的 vector 中。",
        "translate": ""
    },
    {
        "source": "must be aligned on a 16-byte boundary.",
        "suggest": "必须在 16 字节边界上对齐。",
        "translate": ""
    },
    {
        "source": "Conditionally store 8-bit integer elements from `a` into memory using `mask`.",
        "suggest": "使用 `mask` 有条件地将 `a` 中的 8 位整数元素存储到内存中。",
        "translate": ""
    },
    {
        "source": "Elements are not stored when the highest bit is not set in the corresponding element.",
        "suggest": "如果在相应元素中未设置最高位，则不会存储元素。",
        "translate": ""
    },
    {
        "source": "should correspond to a 128-bit memory location and does not need to be aligned on any particular boundary.",
        "suggest": "应与 128 位存储器位置相对应，并且不需要在任何特定边界上对齐。",
        "translate": ""
    },
    {
        "source": "Stores 128-bits of integer data from `a` into memory.",
        "suggest": "将来自 `a` 的 128 位整数数据存储到内存中。",
        "translate": ""
    },
    {
        "source": "FIXME movdqu expected",
        "suggest": "FIXME movdqu 预期",
        "translate": ""
    },
    {
        "source": "Stores the lower 64-bit integer `a` to a memory location.",
        "suggest": "将低 64 位整数 `a` 存储到内存位置。",
        "translate": ""
    }
]
