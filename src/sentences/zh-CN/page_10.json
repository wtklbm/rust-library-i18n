[
    {
        "source": "In immutable contexts, `*x` (where `T` is neither a reference nor a raw pointer) is equivalent to `*Deref::deref(&x)`.",
        "suggest": "在不可变的上下文中，`*x` (其中 `T` 既不是引用也不是裸指针) 等效于 `* Deref::deref(&x)`。",
        "translate": ""
    },
    {
        "source": "Values of type `&T` are coerced to values of type `&U`",
        "suggest": "`&T` 类型的值被强制为 `&U` 类型的值",
        "translate": ""
    },
    {
        "source": "implicitly implements all the (immutable) methods of the type `U`.",
        "suggest": "隐式实现 `U` 类型的所有 (不可变) 方法。",
        "translate": ""
    },
    {
        "source": "For more details, visit [the chapter in *The Rust Programming Language*][book] as well as the reference sections on [the dereference operator][ref-deref-op], [method resolution] and [type coercions].",
        "suggest": "有关更多详细信息，请访问 [Rust 编程语言中的章节][book] 以及 [解引用运算符][ref-deref-op]，[method resolution] 和 [type coercions] 上的引用部分。",
        "translate": ""
    },
    {
        "source": "A struct with a single field which is accessible by dereferencing the struct.",
        "suggest": "具有解引用的结构体可访问的具有单个字段的结构体。",
        "translate": ""
    },
    {
        "source": "The resulting type after dereferencing.",
        "suggest": "解引用后的结果类型。",
        "translate": ""
    },
    {
        "source": "Dereferences the value.",
        "suggest": "解引用值。",
        "translate": ""
    },
    {
        "source": "Used for mutable dereferencing operations, like in `*v = 1;`.",
        "suggest": "用于可变解引用操作，例如在 `*v = 1;` 中。",
        "translate": ""
    },
    {
        "source": "In addition to being used for explicit dereferencing operations with the (unary) `*` operator in mutable contexts, `DerefMut` is also used implicitly by the compiler in many circumstances.",
        "suggest": "`DerefMut` 除了可用于 (一元) `*` 运算符在可变上下文中的显式解引用操作外，还可以在许多情况下被编译器隐式使用。",
        "translate": ""
    },
    {
        "source": "In immutable contexts, [`Deref`] is used.",
        "suggest": "在不可变的上下文中，使用 [`Deref`]。",
        "translate": ""
    },
    {
        "source": "Implementing `DerefMut` for smart pointers makes mutating the data behind them convenient, which is why they implement `DerefMut`.",
        "suggest": "为智能指针实现 `DerefMut` 可以方便地对其背后的数据进行可变的，这就是为什么它们实现 `DerefMut` 的原因。",
        "translate": ""
    },
    {
        "source": "On the other hand, the rules regarding [`Deref`] and `DerefMut` were designed specifically to accommodate smart pointers.",
        "suggest": "另一方面，有关 [`Deref`] 和 `DerefMut` 的规则是专门为容纳智能指针而设计的。",
        "translate": ""
    },
    {
        "source": "Because of this, **`DerefMut` should only be implemented for smart pointers** to avoid confusion.",
        "suggest": "因此，`DerefMut` 仅应针对智能指针实现，以免造成混淆。",
        "translate": ""
    },
    {
        "source": "If `T` implements `DerefMut<Target = U>`, and `x` is a value of type `T`, then:",
        "suggest": "如果 `T` 实现 `DerefMut<Target = U>`，并且 `x` 是 `T` 类型的值，则:",
        "translate": ""
    },
    {
        "source": "In mutable contexts, `*x` (where `T` is neither a reference nor a raw pointer) is equivalent to `*DerefMut::deref_mut(&mut x)`.",
        "suggest": "在可变上下文中，`*x` (其中 `T` 既不是引用也不是裸指针) 等效于 `* DerefMut::deref_mut(&mut x)`。",
        "translate": ""
    },
    {
        "source": "Values of type `&mut T` are coerced to values of type `&mut U`",
        "suggest": "`&mut T` 类型的值被强制为 `&mut U` 类型的值",
        "translate": ""
    },
    {
        "source": "implicitly implements all the (mutable) methods of the type `U`.",
        "suggest": "隐式实现 `U` 类型的所有 (可变) 方法。",
        "translate": ""
    },
    {
        "source": "A struct with a single field which is modifiable by dereferencing the struct.",
        "suggest": "具有单个字段的结构体，可以通过解引用该结构体进行修改。",
        "translate": ""
    },
    {
        "source": "Mutably dereferences the value.",
        "suggest": "可变地解引用该值。",
        "translate": ""
    },
    {
        "source": "Indicates that a struct can be used as a method receiver, without the `arbitrary_self_types` feature.",
        "suggest": "表示可以将结构体用作方法接收器，而无需使用 `arbitrary_self_types` 特性。",
        "translate": ""
    },
    {
        "source": "This is implemented by stdlib pointer types like `Box<T>`, `Rc<T>`, `&T`, and `Pin<P>`.",
        "suggest": "这是由 stdlib 指针类型实现的 (例如 `Box<T>`，`Rc<T>`，`&T` 和 `Pin<P>`)。",
        "translate": ""
    },
    {
        "source": "Custom code within the destructor.",
        "suggest": "析构函数中的自定义代码。",
        "translate": ""
    },
    {
        "source": "When a value is no longer needed, Rust will run a \"destructor\" on that value.",
        "suggest": "当不再需要某个值时，Rust 将对该值运行 \"析构函数\"。",
        "translate": ""
    },
    {
        "source": "The most common way that a value is no longer needed is when it goes out of scope.",
        "suggest": "不再需要值的最常见方法是离开作用域。",
        "translate": ""
    },
    {
        "source": "Destructors may still run in other circumstances, but we're going to focus on scope for the examples here.",
        "suggest": "析构函数可能仍在其他情况下运行，但是在这里的示例中，我们将重点关注作用域。",
        "translate": ""
    },
    {
        "source": "To learn about some of those other cases, please see [the reference] section on destructors.",
        "suggest": "要了解其他一些情况，请参见析构函数的 [the reference] 部分。",
        "translate": ""
    },
    {
        "source": "This destructor consists of two components:",
        "suggest": "此析构函数由两个组件组成:",
        "translate": ""
    },
    {
        "source": "A call to `Drop::drop` for that value, if this special `Drop` trait is implemented for its type.",
        "suggest": "如果为此类型实现了特殊的 `Drop` trait，则对该值调用 `Drop::drop`。",
        "translate": ""
    },
    {
        "source": "The automatically generated \"drop glue\" which recursively calls the destructors of the all fields of this value.",
        "suggest": "自动生成的 \"drop glue\" 递归调用此值所有字段的析构函数。",
        "translate": ""
    },
    {
        "source": "As Rust automatically calls the destructors of all contained fields, you don't have to implement `Drop` in most cases.",
        "suggest": "由于 Rust 自动调用所有包含字段的析构函数，因此在大多数情况下，您无需实现 `Drop`。",
        "translate": ""
    },
    {
        "source": "But there are some cases where it is useful, for example for types which directly manage a resource.",
        "suggest": "但是在某些情况下它很有用，例如对于直接管理资源的类型。",
        "translate": ""
    },
    {
        "source": "That resource may be memory, it may be a file descriptor, it may be a network socket.",
        "suggest": "该资源可能是内存，可能是文件描述符，可能是网络套接字。",
        "translate": ""
    },
    {
        "source": "Once a value of that type is no longer going to be used, it should \"clean up\" its resource by freeing the memory or closing the file or socket.",
        "suggest": "一旦不再使用该类型的值，则应通过释放内存或关闭文件或套接字 \"clean up\" 资源。",
        "translate": ""
    },
    {
        "source": "This is the job of a destructor, and therefore the job of `Drop::drop`.",
        "suggest": "这是析构函数的工作，因此也是 `Drop::drop` 的工作。",
        "translate": ""
    },
    {
        "source": "To see destructors in action, let's take a look at the following program:",
        "suggest": "要查看析构函数的作用，让我们看一下以下程序:",
        "translate": ""
    },
    {
        "source": "Rust will first call `Drop::drop` for `_x` and then for both `_x.one` and `_x.two`, meaning that running this will print",
        "suggest": "Rust 将首先为 `_x` 调用 `Drop::drop`，然后为 `_x.one` 和 `_x.two` 调用，这意味着运行此命令将打印",
        "translate": ""
    },
    {
        "source": "Even if we remove the implementation of `Drop` for `HasTwoDrop`, the destructors of its fields are still called.",
        "suggest": "即使我们删除了针对 `HasTwoDrop` 的 `Drop` 的实现，其字段的析构函数仍然会被调用。",
        "translate": ""
    },
    {
        "source": "This would result in",
        "suggest": "这将导致",
        "translate": ""
    },
    {
        "source": "You cannot call `Drop::drop` yourself",
        "suggest": "您不能自己调用 `Drop::drop`",
        "translate": ""
    },
    {
        "source": "Because `Drop::drop` is used to clean up a value, it may be dangerous to use this value after the method has been called.",
        "suggest": "因为 `Drop::drop` 是用来清理一个值的，所以在调用方法后使用该值可能很危险。",
        "translate": ""
    },
    {
        "source": "As `Drop::drop` does not take ownership of its input, Rust prevents misuse by not allowing you to call `Drop::drop` directly.",
        "suggest": "由于 `Drop::drop` 不拥有其输入的所有权，因此 Rust 通过不允许您直接调用 `Drop::drop` 来防止误用。",
        "translate": ""
    },
    {
        "source": "In other words, if you tried to explicitly call `Drop::drop` in the above example, you'd get a compiler error.",
        "suggest": "换句话说，如果您在上面的示例中尝试显式调用 `Drop::drop`，则会出现编译器错误。",
        "translate": ""
    },
    {
        "source": "If you'd like explicitly call the destructor of a value, [`mem::drop`] can be used instead.",
        "suggest": "如果您想显式调用一个值的析构函数，则可以使用 [`mem::drop`] 代替。",
        "translate": ""
    },
    {
        "source": "Drop order",
        "suggest": "Drop 指令",
        "translate": ""
    },
    {
        "source": "Which of our two `HasDrop` drops first, though?",
        "suggest": "但是，我们的两个 `HasDrop` 哪个先丢弃掉?",
        "translate": ""
    },
    {
        "source": "For structs, it's the same order that they're declared: first `one`, then `two`.",
        "suggest": "对于结构体，其声明顺序相同: 首先是 `one`，然后是 `two`。",
        "translate": ""
    },
    {
        "source": "If you'd like to try this yourself, you can modify `HasDrop` above to contain some data, like an integer, and then use it in the `println!` inside of `Drop`.",
        "suggest": "如果您想自己尝试一下，可以修改上面的 `HasDrop` 以包含一些数据 (例如整数)，然后在 `Drop` 内部的 `println!` 中使用它。",
        "translate": ""
    },
    {
        "source": "This behavior is guaranteed by the language.",
        "suggest": "此行为由语言保证。",
        "translate": ""
    },
    {
        "source": "Unlike for structs, local variables are dropped in reverse order:",
        "suggest": "与结构体不同，局部变量以相反的顺序丢弃:",
        "translate": ""
    },
    {
        "source": "This will print",
        "suggest": "这将打印",
        "translate": ""
    },
    {
        "source": "Please see [the reference] for the full rules.",
        "suggest": "有关完整规则，请参见 [the reference]。",
        "translate": ""
    },
    {
        "source": "and `Drop` are exclusive",
        "suggest": "和 `Drop` 是互斥的",
        "translate": ""
    },
    {
        "source": "You cannot implement both [`Copy`] and `Drop` on the same type.",
        "suggest": "您不能在同一类型上同时实现 [`Copy`] 和 `Drop`。",
        "translate": ""
    },
    {
        "source": "Types that are `Copy` get implicitly duplicated by the compiler, making it very hard to predict when, and how often destructors will be executed.",
        "suggest": "`Copy` 类型被编译器隐式复制，这使得很难预测何时以及将执行析构函数的频率。",
        "translate": ""
    },
    {
        "source": "As such, these types cannot have destructors.",
        "suggest": "因此，这些类型不能有析构函数。",
        "translate": ""
    },
    {
        "source": "Executes the destructor for this type.",
        "suggest": "执行此类型的析构函数。",
        "translate": ""
    },
    {
        "source": "This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error [E0040]).",
        "suggest": "当值离开作用域时隐式调用此方法，并且不能显式调用此方法 (会得到编译器 [E0040] 错误)。",
        "translate": ""
    },
    {
        "source": "However, the [`mem::drop`] function in the prelude can be used to call the argument's `Drop` implementation.",
        "suggest": "但是，prelude 中的 [`mem::drop`] 函数可用于调用参数的 `Drop` 实现。",
        "translate": ""
    },
    {
        "source": "When this method has been called, `self` has not yet been deallocated.",
        "suggest": "当这个方法被调用时，`self` 还没有被释放。",
        "translate": ""
    },
    {
        "source": "That only happens after the method is over.",
        "suggest": "只有在方法结束后才会发生这种情况。",
        "translate": ""
    },
    {
        "source": "If this wasn't the case, `self` would be a dangling reference.",
        "suggest": "如果不是这种情况，那么 `self` 将是悬垂引用。",
        "translate": ""
    },
    {
        "source": "Given that a [`panic!`] will call `drop` as it unwinds, any [`panic!`] in a `drop` implementation will likely abort.",
        "suggest": "考虑到 [`panic!`] 在展开时将调用 `drop`，因此 `drop` 实现中的任何 [`panic!`] 都可能会终止。",
        "translate": ""
    },
    {
        "source": "Note that even if this panics, the value is considered to be dropped;",
        "suggest": "请注意，即使此 panics，该值也被视为已丢弃;",
        "translate": ""
    },
    {
        "source": "you must not cause `drop` to be called again.",
        "suggest": "您不得再次调用 `drop`。",
        "translate": ""
    },
    {
        "source": "This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using [`ptr::drop_in_place`].",
        "suggest": "这通常由编译器自动处理，但是在使用不安全的代码时，有时可能会无意间发生，尤其是在使用 [`ptr::drop_in_place`] 时。",
        "translate": ""
    },
    {
        "source": "consumes its captured variables, so it cannot be run more than once.",
        "suggest": "使用其捕获的变量，因此不能多次运行。",
        "translate": ""
    },
    {
        "source": "Attempting to invoke `func()` again will throw a `use of moved value` error for `func`.",
        "suggest": "再次尝试调用 `func()` 将为 `func` 引发 `use of moved value` 错误。",
        "translate": ""
    },
    {
        "source": "can no longer be invoked at this point",
        "suggest": "现在不能再被调用",
        "translate": ""
    },
    {
        "source": "The version of the call operator that takes an immutable receiver.",
        "suggest": "采用不可变接收者的调用运算符的版本。",
        "translate": ""
    },
    {
        "source": "Instances of `Fn` can be called repeatedly without mutating state.",
        "suggest": "`Fn` 的实例可以在不改变状态的情况下重复调用。",
        "translate": ""
    },
    {
        "source": "This trait (`Fn`) is not to be confused with [function pointers] (`fn`).",
        "suggest": "请勿将此 trait (`Fn`) 与 [function pointers] (`fn`) 混淆。",
        "translate": ""
    },
    {
        "source": "is implemented automatically by closures which only take immutable references to captured variables or don't capture anything at all, as well as (safe) [function pointers] (with some caveats, see their documentation for more details).",
        "suggest": "由闭包自动实现，闭包只对捕获的变量进行不可变引用或根本不捕获任何内容，还有 (安全) [function pointers] (有一些警告，请参见其文档以获取更多详细信息)。",
        "translate": ""
    },
    {
        "source": "Additionally, for any type `F` that implements `Fn`, `&F` implements `Fn`, too.",
        "suggest": "此外，对于实现 `Fn` 的任何类型 `F`，`&F` 也实现了 `Fn`。",
        "translate": ""
    },
    {
        "source": "Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`] is expected.",
        "suggest": "由于 [`FnMut`] 和 [`FnOnce`] 都是 `Fn` 的 supertraits，因此 `Fn` 的任何实例都可以用作参数，其中需要 [`FnMut`] 或 [`FnOnce`]。",
        "translate": ""
    },
    {
        "source": "Use `Fn` as a bound when you want to accept a parameter of function-like type and need to call it repeatedly and without mutating state (e.g., when calling it concurrently).",
        "suggest": "当您要接受类似函数类型的参数并且需要反复调用且不改变状态 (例如，同时调用它) 时，请使用 `Fn` 作为绑定。",
        "translate": ""
    },
    {
        "source": "If you do not need such strict requirements, use [`FnMut`] or [`FnOnce`] as bounds.",
        "suggest": "如果不需要严格的要求，请使用 [`FnMut`] 或 [`FnOnce`] 作为界限。",
        "translate": ""
    },
    {
        "source": "See the [chapter on closures in *The Rust Programming Language*][book] for some more information on this topic.",
        "suggest": "有关此主题的更多信息，请参见 [Rust 编程语言中关于闭包的章节][book]。",
        "translate": ""
    },
    {
        "source": "Also of note is the special syntax for `Fn` traits (e.g.",
        "suggest": "还要注意的是 `Fn` traits 的特殊语法 (例如",
        "translate": ""
    },
    {
        "source": "`Fn(usize, bool) -> usize`). Those interested in the technical details of this can refer to [the relevant section in the *Rustonomicon*][nomicon].",
        "suggest": "`Fn(usize, bool) -> usize`)。对此技术细节感兴趣的人可以参考 [Rustonomicon 中的相关部分][nomicon]。",
        "translate": ""
    },
    {
        "source": "Calling a closure",
        "suggest": "调用一个闭包",
        "translate": ""
    },
    {
        "source": "Using a `Fn` parameter",
        "suggest": "使用 `Fn` 参数",
        "translate": ""
    },
    {
        "source": "so that regex can rely that `&str: !FnMut`",
        "suggest": "这样 regex 可以依靠 `&str: !FnMut`",
        "translate": ""
    },
    {
        "source": "Performs the call operation.",
        "suggest": "执行调用操作。",
        "translate": ""
    },
    {
        "source": "The version of the call operator that takes a mutable receiver.",
        "suggest": "采用可变接收者的调用运算符的版本。",
        "translate": ""
    },
    {
        "source": "Instances of `FnMut` can be called repeatedly and may mutate state.",
        "suggest": "`FnMut` 的实例可以重复调用，并且可以改变状态。",
        "translate": ""
    },
    {
        "source": "is implemented automatically by closures which take mutable references to captured variables, as well as all types that implement [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of [`Fn`]).",
        "suggest": "由闭包自动实现，闭包将可变引用引用到捕获的变量，以及实现 [`Fn`] 的所有类型，例如 (safe) [function pointers] (因为 `FnMut` 是 [`Fn`] 的特征)。",
        "translate": ""
    },
    {
        "source": "Additionally, for any type `F` that implements `FnMut`, `&mut F` implements `FnMut`, too.",
        "suggest": "另外，对于任何实现 `FnMut` 的 `F` 类型，`&mut F` 也实现 `FnMut`。",
        "translate": ""
    },
    {
        "source": "Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.",
        "suggest": "由于 [`FnOnce`] 是 `FnMut` 的 super trait，因此可以在期望 [`FnOnce`] 的地方使用 `FnMut` 的任何实例，并且由于 [`Fn`] 是 `FnMut` 的子特性，因此可以在预期 `FnMut` 的地方使用 [`Fn`] 的任何实例。",
        "translate": ""
    },
    {
        "source": "Use `FnMut` as a bound when you want to accept a parameter of function-like type and need to call it repeatedly, while allowing it to mutate state.",
        "suggest": "当您想接受类似函数类型的参数并需要反复调用它，同时允许其改变状态时，请使用 `FnMut` 作为绑定。",
        "translate": ""
    },
    {
        "source": "If you don't want the parameter to mutate state, use [`Fn`] as a bound;",
        "suggest": "如果您不希望参数改变状态，请使用 [`Fn`] 作为绑定;",
        "translate": ""
    },
    {
        "source": "if you don't need to call it repeatedly, use [`FnOnce`].",
        "suggest": "如果不需要重复调用，请使用 [`FnOnce`]。",
        "translate": ""
    },
    {
        "source": "Calling a mutably capturing closure",
        "suggest": "调用可变捕获闭包",
        "translate": ""
    },
    {
        "source": "Using a `FnMut` parameter",
        "suggest": "使用 `FnMut` 参数",
        "translate": ""
    },
    {
        "source": "The version of the call operator that takes a by-value receiver.",
        "suggest": "具有按值接收者的调用运算符的版本。",
        "translate": ""
    },
    {
        "source": "Instances of `FnOnce` can be called, but might not be callable multiple times.",
        "suggest": "可以调用 `FnOnce` 的实例，但可能无法多次调用。",
        "translate": ""
    },
    {
        "source": "Because of this, if the only thing known about a type is that it implements `FnOnce`, it can only be called once.",
        "suggest": "因此，如果唯一知道类型的是它实现 `FnOnce`，则只能调用一次。",
        "translate": ""
    },
    {
        "source": "is implemented automatically by closures that might consume captured variables, as well as all types that implement [`FnMut`], e.g., (safe) [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).",
        "suggest": "由可能消耗捕获变量的闭包以及实现 [`FnMut`] 的所有类型 (例如 (safe) [function pointers] (因为 `FnOnce` 是 [`FnMut`] 的特征) ) 自动实现。",
        "translate": ""
    },
    {
        "source": "Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.",
        "suggest": "由于 [`Fn`] 和 [`FnMut`] 都是 `FnOnce` 的子特性，因此可以在期望使用 `FnOnce` 的情况下使用 [`Fn`] 或 [`FnMut`] 的任何实例。",
        "translate": ""
    },
    {
        "source": "Use `FnOnce` as a bound when you want to accept a parameter of function-like type and only need to call it once.",
        "suggest": "当您想接受类似函数类型的参数并且只需要调用一次时，可以使用 `FnOnce` 作为绑定。",
        "translate": ""
    },
    {
        "source": "If you need to call the parameter repeatedly, use [`FnMut`] as a bound;",
        "suggest": "如果需要重复调用该参数，请使用 [`FnMut`] 作为界限;",
        "translate": ""
    },
    {
        "source": "if you also need it to not mutate state, use [`Fn`].",
        "suggest": "如果还需要它不改变状态，请使用 [`Fn`]。",
        "translate": ""
    },
    {
        "source": "Using a `FnOnce` parameter",
        "suggest": "使用 `FnOnce` 参数",
        "translate": ""
    },
    {
        "source": "The returned type after the call operator is used.",
        "suggest": "使用调用运算符后的返回类型。",
        "translate": ""
    },
    {
        "source": "The result of a generator resumption.",
        "suggest": "恢复生成器的结果。",
        "translate": ""
    },
    {
        "source": "This enum is returned from the `Generator::resume` method and indicates the possible return values of a generator.",
        "suggest": "该枚举从 `Generator::resume` 方法返回，并指示生成器的可能返回值。",
        "translate": ""
    },
    {
        "source": "Currently this corresponds to either a suspension point (`Yielded`) or a termination point (`Complete`).",
        "suggest": "当前，这对应于悬挂点 (`Yielded`) 或终止点 (`Complete`)。",
        "translate": ""
    },
    {
        "source": "The generator suspended with a value.",
        "suggest": "生成器挂起了一个值。",
        "translate": ""
    },
    {
        "source": "This state indicates that a generator has been suspended, and typically corresponds to a `yield` statement.",
        "suggest": "此状态表明生成器已被挂起，并且通常对应于 `yield` 语句。",
        "translate": ""
    },
    {
        "source": "The value provided in this variant corresponds to the expression passed to `yield` and allows generators to provide a value each time they yield.",
        "suggest": "该成员中提供的值对应于传递给 `yield` 的表达式，并允许生成器在每次产生时提供一个值。",
        "translate": ""
    },
    {
        "source": "The generator completed with a return value.",
        "suggest": "生成器完成并返回一个值。",
        "translate": ""
    },
    {
        "source": "This state indicates that a generator has finished execution with the provided value.",
        "suggest": "此状态表明生成器已使用提供的值完成了执行。",
        "translate": ""
    },
    {
        "source": "Once a generator has returned `Complete` it is considered a programmer error to call `resume` again.",
        "suggest": "生成器返回 `Complete` 后，再次调用 `resume` 将被视为程序员错误。",
        "translate": ""
    },
    {
        "source": "The trait implemented by builtin generator types.",
        "suggest": "由内置生成器类型实现的 trait。",
        "translate": ""
    },
    {
        "source": "Generators, also commonly referred to as coroutines, are currently an experimental language feature in Rust.",
        "suggest": "生成器 (通常也称为协程) 是 Rust 中的一种实验语言功能。",
        "translate": ""
    },
    {
        "source": "Added in [RFC 2033] generators are currently intended to primarily provide a building block for async/await syntax but will likely extend to also providing an ergonomic definition for iterators and other primitives.",
        "suggest": "[RFC 2033] 中添加的生成器目前主要用于为 async/await 语法提供构建块，但可能会扩展为还为迭代器和其他原语提供符合人体工程学的定义。",
        "translate": ""
    },
    {
        "source": "The syntax and semantics for generators is unstable and will require a further RFC for stabilization.",
        "suggest": "生成器的语法和语义不稳定，将需要进一步的 RFC 来稳定。",
        "translate": ""
    },
    {
        "source": "At this time, though, the syntax is closure-like:",
        "suggest": "但是，此时的语法类似于闭包:",
        "translate": ""
    },
    {
        "source": "More documentation of generators can be found in the unstable book.",
        "suggest": "在不稳定的书中可以找到有关生成器的更多文档。",
        "translate": ""
    },
    {
        "source": "The type of value this generator yields.",
        "suggest": "此生成器产生的值的类型。",
        "translate": ""
    },
    {
        "source": "This associated type corresponds to the `yield` expression and the values which are allowed to be returned each time a generator yields.",
        "suggest": "此关联类型对应于 `yield` 表达式以及每次生成器产生时都允许返回的值。",
        "translate": ""
    },
    {
        "source": "For example an iterator-as-a-generator would likely have this type as `T`, the type being iterated over.",
        "suggest": "例如，作为一个迭代器的迭代器可能将这种类型作为 `T` 进行迭代。",
        "translate": ""
    },
    {
        "source": "The type of value this generator returns.",
        "suggest": "此生成器返回的值的类型。",
        "translate": ""
    },
    {
        "source": "This corresponds to the type returned from a generator either with a `return` statement or implicitly as the last expression of a generator literal.",
        "suggest": "这对应于使用 `return` 语句从生成器返回的类型，或隐式作为生成器字面量的最后一个表达式返回的类型。",
        "translate": ""
    },
    {
        "source": "For example futures would use this as `Result<T, E>` as it represents a completed future.",
        "suggest": "例如，futures 将其用作 `Result<T, E>`，因为它代表完整的 future。",
        "translate": ""
    },
    {
        "source": "Resumes the execution of this generator.",
        "suggest": "恢复此生成器的执行。",
        "translate": ""
    },
    {
        "source": "This function will resume execution of the generator or start execution if it hasn't already.",
        "suggest": "此函数将恢复生成器的执行，如果尚未生成，则开始执行。",
        "translate": ""
    },
    {
        "source": "This call will return back into the generator's last suspension point, resuming execution from the latest `yield`.",
        "suggest": "该调用将返回到生成器的最后一个暂停点，从最新的 `yield` 恢复执行。",
        "translate": ""
    },
    {
        "source": "The generator will continue executing until it either yields or returns, at which point this function will return.",
        "suggest": "生成器将继续执行，直到它屈服或返回为止，此时该函数将返回。",
        "translate": ""
    },
    {
        "source": "The `GeneratorState` enum returned from this function indicates what state the generator is in upon returning.",
        "suggest": "从此函数返回的 `GeneratorState` 枚举指示生成器在返回时处于什么状态。",
        "translate": ""
    },
    {
        "source": "If the `Yielded` variant is returned then the generator has reached a suspension point and a value has been yielded out.",
        "suggest": "如果返回了 `Yielded` 成员，则生成器已达到暂停点，并且已产生一个值。",
        "translate": ""
    },
    {
        "source": "Generators in this state are available for resumption at a later point.",
        "suggest": "此状态下的生成器可在稍后恢复。",
        "translate": ""
    },
    {
        "source": "If `Complete` is returned then the generator has completely finished with the value provided.",
        "suggest": "如果返回 `Complete`，则生成器将完全完成所提供的值。",
        "translate": ""
    },
    {
        "source": "It is invalid for the generator to be resumed again.",
        "suggest": "再次恢复生成器是无效的。",
        "translate": ""
    },
    {
        "source": "This function may panic if it is called after the `Complete` variant has been returned previously.",
        "suggest": "如果先前已返回 `Complete` 成员后调用此函数，则它可能为 panic。",
        "translate": ""
    },
    {
        "source": "While generator literals in the language are guaranteed to panic on resuming after `Complete`, this is not guaranteed for all implementations of the `Generator` trait.",
        "suggest": "尽管在 `Complete` 之后恢复时，将语言中的生成器字面量保证为 panic，但对于 `Generator` trait 的所有实现均不能保证。",
        "translate": ""
    },
    {
        "source": "In this case, `balance[Side::Right]` is sugar for `*balance.index(Side::Right)`, since we are only *reading* `balance[Side::Right]`, not writing it.",
        "suggest": "在这种情况下，`balance[Side::Right]` 是 `*balance.index(Side::Right)` 的糖，因为我们只是* 读*`balance[Side::Right]`，而不是写 `balance[Side::Right]`。",
        "translate": ""
    },
    {
        "source": "However, in this case `balance[Side::Left]` is sugar for `*balance.index_mut(Side::Left)`, since we are writing `balance[Side::Left]`.",
        "suggest": "但是，在这种情况下，`balance[Side::Left]` 是 `*balance.index_mut(Side::Left)` 的糖，因为我们正在编写 `balance[Side::Left]`。",
        "translate": ""
    },
    {
        "source": "Used for indexing operations (`container[index]`) in immutable contexts.",
        "suggest": "用于在不可变上下文中索引操作 (`container[index]`)。",
        "translate": ""
    },
    {
        "source": "is actually syntactic sugar for `*container.index(index)`, but only when used as an immutable value.",
        "suggest": "实际上是 `*container.index(index)` 的语法糖，但仅当用作不可变值时才使用。",
        "translate": ""
    },
    {
        "source": "If a mutable value is requested, [`IndexMut`] is used instead.",
        "suggest": "如果请求一个可变值，则使用 [`IndexMut`]。",
        "translate": ""
    },
    {
        "source": "This allows nice things such as `let value = v[index]` if the type of `value` implements [`Copy`].",
        "suggest": "如果 `value` 的类型实现 [`Copy`]，则这允许使用诸如 `let value = v[index]` 之类的好东西。",
        "translate": ""
    },
    {
        "source": "The following example implements `Index` on a read-only `NucleotideCount` container, enabling individual counts to be retrieved with index syntax.",
        "suggest": "下面的示例在只读 `NucleotideCount` 容器上实现 `Index`，从而可以使用索引语法检索单个计数。",
        "translate": ""
    },
    {
        "source": "The returned type after indexing.",
        "suggest": "索引后返回的类型。",
        "translate": ""
    },
    {
        "source": "Performs the indexing (`container[index]`) operation.",
        "suggest": "执行索引 (`container[index]`) 操作。",
        "translate": ""
    },
    {
        "source": "Used for indexing operations (`container[index]`) in mutable contexts.",
        "suggest": "用于可变上下文中的索引操作 (`container[index]`)。",
        "translate": ""
    },
    {
        "source": "is actually syntactic sugar for `*container.index_mut(index)`, but only when used as a mutable value.",
        "suggest": "实际上是 `*container.index_mut(index)` 的语法糖，但仅当用作变量值时。",
        "translate": ""
    },
    {
        "source": "If an immutable value is requested, the [`Index`] trait is used instead.",
        "suggest": "如果请求一个不可变值，则使用 [`Index`] trait。",
        "translate": ""
    },
    {
        "source": "This allows nice things such as `v[index] = value`.",
        "suggest": "这允许使用诸如 `v[index] = value` 之类的好东西。",
        "translate": ""
    },
    {
        "source": "A very simple implementation of a `Balance` struct that has two sides, where each can be indexed mutably and immutably.",
        "suggest": "`Balance` 结构体的非常简单的实现，它具有两个面，每个面都可以可变和不可变地进行索引。",
        "translate": ""
    },
    {
        "source": "Performs the mutable indexing (`container[index]`) operation.",
        "suggest": "执行可变索引 (`container[index]`) 操作。",
        "translate": ""
    },
    {
        "source": "consumes its captured variables, so it cannot be run more than once",
        "suggest": "使用其捕获的变量，因此不能多次运行",
        "translate": ""
    },
    {
        "source": "Attempting to invoke `func()` again will throw a `use of moved value` error for `func`",
        "suggest": "再次尝试调用 `func()` 将为 `func` 引发 `use of moved value` 错误",
        "translate": ""
    },
    {
        "source": "Overloadable operators.",
        "suggest": "可重载的运算符。",
        "translate": ""
    },
    {
        "source": "Implementing these traits allows you to overload certain operators.",
        "suggest": "实现这些 traits 可使您重载某些运算符。",
        "translate": ""
    },
    {
        "source": "Some of these traits are imported by the prelude, so they are available in every Rust program.",
        "suggest": "其中的某些 traits 由 prelude 导入，因此在每个 Rust 程序中都可用。",
        "translate": ""
    },
    {
        "source": "Only operators backed by traits can be overloaded.",
        "suggest": "只能重载由 traits 支持的运算符。",
        "translate": ""
    },
    {
        "source": "For example, the addition operator (`+`) can be overloaded through the [`Add`] trait, but since the assignment operator (`=`) has no backing trait, there is no way of overloading its semantics.",
        "suggest": "例如，可以通过 [`Add`] trait 重载加法运算符 (`+`)，但是由于赋值运算符 (`=`) 没有后备 trait，因此无法重载其语义。",
        "translate": ""
    },
    {
        "source": "Additionally, this module does not provide any mechanism to create new operators.",
        "suggest": "此外，此模块不提供任何机制来创建新的运算符。",
        "translate": ""
    },
    {
        "source": "If traitless overloading or custom operators are required, you should look toward macros or compiler plugins to extend Rust's syntax.",
        "suggest": "如果需要无特征重载或自定义运算符，则应使用宏或编译器插件来扩展 Rust 的语法。",
        "translate": ""
    },
    {
        "source": "Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and [operator precedence].",
        "suggest": "考虑到它们的通常含义和 [operator precedence]，运算符 traits 的实现在它们各自的上下文中应该不足为奇。",
        "translate": ""
    },
    {
        "source": "For example, when implementing [`Mul`], the operation should have some resemblance to multiplication (and share expected properties like associativity).",
        "suggest": "例如，当实现 [`Mul`] 时，该操作应与乘法有些相似 (并共享期望的属性，如关联性)。",
        "translate": ""
    },
    {
        "source": "Note that the `&&` and `||` operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result.",
        "suggest": "请注意，`&&` 和 `||` 运算符发生短路，即，它们仅在第二操作数对结果有贡献的情况下才对其求值。",
        "translate": ""
    },
    {
        "source": "Since this behavior is not enforceable by traits, `&&` and `||` are not supported as overloadable operators.",
        "suggest": "由于 traits 无法强制执行此行为，因此不支持 `&&` 和 `||` 作为可重载的运算符。",
        "translate": ""
    },
    {
        "source": "Many of the operators take their operands by value.",
        "suggest": "许多运算符都按值取其操作数。",
        "translate": ""
    },
    {
        "source": "In non-generic contexts involving built-in types, this is usually not a problem.",
        "suggest": "在涉及内置类型的非泛型上下文中，这通常不是问题。",
        "translate": ""
    },
    {
        "source": "However, using these operators in generic code, requires some attention if values have to be reused as opposed to letting the operators consume them.",
        "suggest": "但是，如果必须重用值而不是让运算符使用它们，那么在泛型代码中使用这些运算符就需要引起注意。",
        "translate": ""
    },
    {
        "source": "One option is to occasionally use [`clone`].",
        "suggest": "一种选择是偶尔使用 [`clone`]。",
        "translate": ""
    },
    {
        "source": "Another option is to rely on the types involved providing additional operator implementations for references.",
        "suggest": "另一个选择是依靠所涉及的类型，为引用提供其他运算符实现。",
        "translate": ""
    },
    {
        "source": "For example, for a user-defined type `T` which is supposed to support addition, it is probably a good idea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and [`Add<&T>`][`Add`] so that generic code can be written without unnecessary cloning.",
        "suggest": "例如，对于应该支持加法的用户定义类型 `T`，将 `T` 和 `&T` 都实现 traits [`Add<T>`][`Add`] 和 [`Add<&T>`][`Add`] 可能是一个好主意，这样就可以编写泛型代码而不必进行不必要的克隆。",
        "translate": ""
    },
    {
        "source": "This example creates a `Point` struct that implements [`Add`] and [`Sub`], and then demonstrates adding and subtracting two `Point`s.",
        "suggest": "本示例创建一个实现 [`Add`] 和 [`Sub`] 的 `Point` 结构体，然后演示加减两个 Point。",
        "translate": ""
    },
    {
        "source": "See the documentation for each trait for an example implementation.",
        "suggest": "有关示例实现，请参见每个 trait 的文档。",
        "translate": ""
    },
    {
        "source": "The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be invoked like functions.",
        "suggest": "[`Fn`]，[`FnMut`] 和 [`FnOnce`] traits 由可以像函数一样调用的类型实现。",
        "translate": ""
    },
    {
        "source": "Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut self` and [`FnOnce`] takes `self`.",
        "suggest": "请注意，[`Fn`] 占用 `&self`，[`FnMut`] 占用 `&mut self`，[`FnOnce`] 占用 `self`。",
        "translate": ""
    },
    {
        "source": "These correspond to the three kinds of methods that can be invoked on an instance: call-by-reference, call-by-mutable-reference, and call-by-value.",
        "suggest": "这些对应于可以在实例上调用的三种方法: 引用调用、可变引用调用和值调用。",
        "translate": ""
    },
    {
        "source": "The most common use of these traits is to act as bounds to higher-level functions that take functions or closures as arguments.",
        "suggest": "这些 traits 的最常见用法是充当以函数或闭包为参数的高级函数的界限。",
        "translate": ""
    },
    {
        "source": "Taking a [`Fn`] as a parameter:",
        "suggest": "以 [`Fn`] 作为参数:",
        "translate": ""
    },
    {
        "source": "Taking a [`FnMut`] as a parameter:",
        "suggest": "以 [`FnMut`] 作为参数:",
        "translate": ""
    },
    {
        "source": "Taking a [`FnOnce`] as a parameter:",
        "suggest": "以 [`FnOnce`] 作为参数:",
        "translate": ""
    },
    {
        "source": "This is the `RangeFull`",
        "suggest": "这是 `RangeFull`",
        "translate": ""
    },
    {
        "source": "This is a `Range`",
        "suggest": "这是 `Range`",
        "translate": ""
    },
    {
        "source": "This is a `RangeFrom`",
        "suggest": "这是 `RangeFrom`",
        "translate": ""
    },
    {
        "source": "error[E0277]: the trait bound `std::ops::RangeTo<{integer}>:",
        "suggest": "错误 [E0277]: trait bound`std::RangeTo <{integer}>:",
        "translate": ""
    },
    {
        "source": "std::iter::Iterator` is not satisfied",
        "suggest": "std::Iterator` 不满足",
        "translate": ""
    },
    {
        "source": "This is a `RangeTo`",
        "suggest": "这是 `RangeTo`",
        "translate": ""
    },
    {
        "source": "This is a `RangeInclusive`",
        "suggest": "这是 `RangeInclusive`",
        "translate": ""
    },
    {
        "source": "Precise field values are unspecified here",
        "suggest": "此处未指定精确的字段值",
        "translate": ""
    },
    {
        "source": "error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:",
        "suggest": "错误 [E0277]: trait bound`std::RangeToInclusive <{integer}>:",
        "translate": ""
    },
    {
        "source": "This is a `RangeToInclusive`",
        "suggest": "这是 `RangeToInclusive`",
        "translate": ""
    },
    {
        "source": "An unbounded range (`..`).",
        "suggest": "无限制范围 (`..`)。",
        "translate": ""
    },
    {
        "source": "is primarily used as a [slicing index], its shorthand is `..`.",
        "suggest": "主要用作 [slicing index]，其简写为 `..`。",
        "translate": ""
    },
    {
        "source": "It cannot serve as an [`Iterator`] because it doesn't have a starting point.",
        "suggest": "它不能用作 [`Iterator`]，因为它没有起点。",
        "translate": ""
    },
    {
        "source": "The `..` syntax is a `RangeFull`:",
        "suggest": "`..` 语法是 `RangeFull`:",
        "translate": ""
    },
    {
        "source": "It does not have an [`IntoIterator`] implementation, so you can't use it in a `for` loop directly.",
        "suggest": "它没有 [`IntoIterator`] 实现，因此不能直接在 `for` 循环中使用它。",
        "translate": ""
    },
    {
        "source": "This won't compile:",
        "suggest": "这不会编译:",
        "translate": ""
    },
    {
        "source": "Used as a [slicing index], `RangeFull` produces the full array as a slice.",
        "suggest": "用作 [slicing index] 时，`RangeFull` 产生完整的阵列作为切片。",
        "translate": ""
    },
    {
        "source": "A (half-open) range bounded inclusively below and exclusively above (`start..end`).",
        "suggest": "(half-open) 范围包括在 (`start..end`) 之下和仅在 (`start..end`) 之上。",
        "translate": ""
    },
    {
        "source": "The range `start..end` contains all values with `start <= x < end`.",
        "suggest": "范围 `start..end` 包含 `start <= x < end` 的所有值。",
        "translate": ""
    },
    {
        "source": "It is empty if `start >= end`.",
        "suggest": "如果为 `start >= end`，则为空。",
        "translate": ""
    },
    {
        "source": "The `start..end` syntax is a `Range`:",
        "suggest": "`start..end` 语法是 `Range`:",
        "translate": ""
    },
    {
        "source": "not Copy -- see #27186",
        "suggest": "没有 Copy - 请参见 #27186",
        "translate": ""
    },
    {
        "source": "The lower bound of the range (inclusive).",
        "suggest": "(inclusive) 范围的下限。",
        "translate": ""
    },
    {
        "source": "The upper bound of the range (exclusive).",
        "suggest": "范围 (exclusive) 的上限。",
        "translate": ""
    },
    {
        "source": "Returns `true` if `item` is contained in the range.",
        "suggest": "如果范围中包含 `item`，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the range contains no items.",
        "suggest": "如果范围不包含任何项，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "The range is empty if either side is incomparable:",
        "suggest": "如果任何一方都无法比拟，则范围为空:",
        "translate": ""
    },
    {
        "source": "A range only bounded inclusively below (`start..`).",
        "suggest": "范围仅包括 (`start..`) 以下的范围。",
        "translate": ""
    },
    {
        "source": "The `RangeFrom` `start..` contains all values with `x >= start`.",
        "suggest": "`RangeFrom` `start..` 包含 `x >= start` 的所有值。",
        "translate": ""
    },
    {
        "source": "Overflow in the [`Iterator`] implementation (when the contained data type reaches its numerical limit) is allowed to panic, wrap, or saturate.",
        "suggest": "[`Iterator`] 实现中的溢出 (当所包含的数据类型达到其数值限制时) 允许 panic，自动换行或饱和。",
        "translate": ""
    },
    {
        "source": "This behavior is defined by the implementation of the [`Step`] trait.",
        "suggest": "此行为由 [`Step`] trait 的实现定义。",
        "translate": ""
    },
    {
        "source": "For primitive integers, this follows the normal rules, and respects the overflow checks profile (panic in debug, wrap in release).",
        "suggest": "对于原始整数，这遵循正常规则，并遵守溢出检查配置文件 (调试中为 panic，释放中为包装)。",
        "translate": ""
    },
    {
        "source": "Note also that overflow happens earlier than you might assume: the overflow happens in the call to `next` that yields the maximum value, as the range must be set to a state to yield the next value.",
        "suggest": "还要注意，溢出发生的时间比您想像的要早: 溢出发生在 `next` 的调用中，该调用会产生最大值，因为必须将范围设置为产生下一个值的状态。",
        "translate": ""
    },
    {
        "source": "The `start..` syntax is a `RangeFrom`:",
        "suggest": "`start..` 语法是 `RangeFrom`:",
        "translate": ""
    },
    {
        "source": "A range only bounded exclusively above (`..end`).",
        "suggest": "范围仅排在 (`..end`) 之上。",
        "translate": ""
    },
    {
        "source": "The `RangeTo` `..end` contains all values with `x < end`.",
        "suggest": "`RangeTo` `..end` 包含 `x < end` 的所有值。",
        "translate": ""
    },
    {
        "source": "The `..end` syntax is a `RangeTo`:",
        "suggest": "`..end` 语法是 `RangeTo`:",
        "translate": ""
    },
    {
        "source": "When used as a [slicing index], `RangeTo` produces a slice of all array elements before the index indicated by `end`.",
        "suggest": "当用作 [slicing index] 时，`RangeTo` 会在 `end` 所指示的索引之前生成所有数组元素的切片。",
        "translate": ""
    },
    {
        "source": "A range bounded inclusively below and above (`start..=end`).",
        "suggest": "范围包括 (`start..=end`) 的上下边界。",
        "translate": ""
    },
    {
        "source": "The `RangeInclusive` `start..=end` contains all values with `x >= start` and `x <= end`.",
        "suggest": "`RangeInclusive` `start..=end` 包含 `x >= start` 和 `x <= end` 的所有值。",
        "translate": ""
    },
    {
        "source": "It is empty unless `start <= end`.",
        "suggest": "除非 `start <= end`，否则为空。",
        "translate": ""
    },
    {
        "source": "This iterator is [fused], but the specific values of `start` and `end` after iteration has finished are **unspecified** other than that [`.is_empty()`] will return `true` once no more values will be produced.",
        "suggest": "这个迭代器是 [fused]，但是迭代完成后 `start` 和 `end` 的特定值是未指定的，除了 [`.is_empty()`]之外，一旦不再产生值，就会返回 `true`。",
        "translate": ""
    },
    {
        "source": "The `start..=end` syntax is a `RangeInclusive`:",
        "suggest": "`start..=end` 语法是 `RangeInclusive`:",
        "translate": ""
    },
    {
        "source": "Note that the fields here are not public to allow changing the representation in the future;",
        "suggest": "请注意，此处的字段不是公开的，以允许更改 future 中的表示形式。",
        "translate": ""
    },
    {
        "source": "in particular, while we could plausibly expose start/end, modifying them without changing (future/current) private fields may lead to incorrect behavior, so we don't want to support that mode.",
        "suggest": "尤其是，尽管我们可能公开 start/end，但在不更改 (future/current) 私有字段的情况下对其进行修改可能会导致错误的行为，因此我们不希望支持该模式。",
        "translate": ""
    },
    {
        "source": "This field is:",
        "suggest": "该字段是:",
        "translate": ""
    },
    {
        "source": "upon construction",
        "suggest": "创建时",
        "translate": ""
    },
    {
        "source": "when iteration has yielded an element and the iterator is not exhausted",
        "suggest": "当迭代产生一个元素并且迭代器没有耗尽时",
        "translate": ""
    },
    {
        "source": "when iteration has been used to exhaust the iterator",
        "suggest": "当迭代已用于耗尽迭代器时",
        "translate": ""
    },
    {
        "source": "This is required to support PartialEq and Hash without a PartialOrd bound or specialization.",
        "suggest": "这是支持 PartialEq 和 Hash 而没有 PartialOrd 绑定或特殊化所必需的。",
        "translate": ""
    },
    {
        "source": "Creates a new inclusive range.",
        "suggest": "创建一个新的包含范围。",
        "translate": ""
    },
    {
        "source": "Equivalent to writing `start..=end`.",
        "suggest": "等同于编写 `start..=end`。",
        "translate": ""
    },
    {
        "source": "Returns the lower bound of the range (inclusive).",
        "suggest": "返回范围 (inclusive) 的下限。",
        "translate": ""
    },
    {
        "source": "When using an inclusive range for iteration, the values of `start()` and [`end()`] are unspecified after the iteration ended.",
        "suggest": "当使用包含范围进行迭代时，在迭代结束后未指定 `start()` 和 [`end()`] 的值。",
        "translate": ""
    },
    {
        "source": "To determine whether the inclusive range is empty, use the [`is_empty()`] method instead of comparing `start() > end()`.",
        "suggest": "若要确定包含范围是否为空，请使用 [`is_empty()`] 方法而不是比较 `start() > end()`。",
        "translate": ""
    },
    {
        "source": "the value returned by this method is unspecified after the range has been iterated to exhaustion.",
        "suggest": "范围迭代到穷竭之后，此方法返回的值是不确定的。",
        "translate": ""
    },
    {
        "source": "Returns the upper bound of the range (inclusive).",
        "suggest": "返回范围 (inclusive) 的上限。",
        "translate": ""
    },
    {
        "source": "When using an inclusive range for iteration, the values of [`start()`] and `end()` are unspecified after the iteration ended.",
        "suggest": "当使用包含范围进行迭代时，在迭代结束后未指定 [`start()`] 和 `end()` 的值。",
        "translate": ""
    },
    {
        "source": "Destructures the `RangeInclusive` into (lower bound, upper (inclusive) bound).",
        "suggest": "将 `RangeInclusive` 分解为 (下限 (inclusive) 上限)。",
        "translate": ""
    },
    {
        "source": "Converts to an exclusive `Range` for `SliceIndex` implementations.",
        "suggest": "转换为 `SliceIndex` 实现的专用 `Range`。",
        "translate": ""
    },
    {
        "source": "The caller is responsible for dealing with `end == usize::MAX`.",
        "suggest": "调用者负责处理 `end == usize::MAX`。",
        "translate": ""
    },
    {
        "source": "If we're not exhausted, we want to simply slice `start..end + 1`.",
        "suggest": "如果我们不筋疲力尽，我们只想切片 `start..end + 1`。",
        "translate": ""
    },
    {
        "source": "If we are exhausted, then slicing with `end + 1..end + 1` gives us an empty range that is still subject to bounds-checks for that endpoint.",
        "suggest": "如果我们筋疲力尽，则使用 `end + 1..end + 1` 切片会为我们提供一个空范围，该范围仍受该端点的边界检查的影响。",
        "translate": ""
    },
    {
        "source": "This method always returns `false` after iteration has finished:",
        "suggest": "迭代完成后，此方法总是返回 `false`:",
        "translate": ""
    },
    {
        "source": "This method returns `true` after iteration has finished:",
        "suggest": "迭代完成后，此方法返回 `true`:",
        "translate": ""
    },
    {
        "source": "A range only bounded inclusively above (`..=end`).",
        "suggest": "范围仅包括 (`..=end`) 以上的范围。",
        "translate": ""
    },
    {
        "source": "The `RangeToInclusive` `..=end` contains all values with `x <= end`.",
        "suggest": "`RangeToInclusive` `..=end` 包含 `x <= end` 的所有值。",
        "translate": ""
    },
    {
        "source": "The `..=end` syntax is a `RangeToInclusive`:",
        "suggest": "`..=end` 语法是 `RangeToInclusive`:",
        "translate": ""
    },
    {
        "source": "When used as a [slicing index], `RangeToInclusive` produces a slice of all array elements up to and including the index indicated by `end`.",
        "suggest": "当用作 [slicing index] 时，`RangeToInclusive` 会生成所有数组元素的切片，直到并包括 `end` 指示的索引。",
        "translate": ""
    },
    {
        "source": "The upper bound of the range (inclusive)",
        "suggest": "范围 (inclusive) 的上限",
        "translate": ""
    },
    {
        "source": "cannot impl From<RangeTo<Idx>> because underflow would be possible with (..0).into()",
        "suggest": "无法暗示 From<RangeTo<Idx>>，因为 (..0) .into () 可能会发生下溢",
        "translate": ""
    },
    {
        "source": "An endpoint of a range of keys.",
        "suggest": "一系列键的端点。",
        "translate": ""
    },
    {
        "source": "`Bound`s are range endpoints:",
        "suggest": "边界是范围端点:",
        "translate": ""
    },
    {
        "source": "Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].",
        "suggest": "使用 `Bound`s 的元组作为 [`BTreeMap::range`] 的参数。",
        "translate": ""
    },
    {
        "source": "Note that in most cases, it's better to use range syntax (`1..5`) instead.",
        "suggest": "请注意，在大多数情况下，最好改用范围语法 (`1..5`)。",
        "translate": ""
    },
    {
        "source": "An inclusive bound.",
        "suggest": "包容性范围。",
        "translate": ""
    },
    {
        "source": "An exclusive bound.",
        "suggest": "排他性约束。",
        "translate": ""
    },
    {
        "source": "An infinite endpoint.",
        "suggest": "无限端点。",
        "translate": ""
    },
    {
        "source": "Indicates that there is no bound in this direction.",
        "suggest": "指示此方向没有界限。",
        "translate": ""
    },
    {
        "source": "Converts from `&Bound<T>` to `Bound<&T>`.",
        "suggest": "从 `&Bound<T>` 转换为 `Bound<&T>`。",
        "translate": ""
    },
    {
        "source": "Converts from `&mut Bound<T>` to `Bound<&T>`.",
        "suggest": "从 `&mut Bound<T>` 转换为 `Bound<&T>`。",
        "translate": ""
    },
    {
        "source": "Map a `Bound<&T>` to a `Bound<T>` by cloning the contents of the bound.",
        "suggest": "Map 通过克隆绑定的内容将 `Bound<&T>` 更改为 `Bound<T>`。",
        "translate": ""
    },
    {
        "source": "is implemented by Rust's built-in range types, produced by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.",
        "suggest": "由 Rust 的内置范围类型实现，该范围类型由范围语法 (例如 `..`，`a..`，`..b`，`..=c`，`d..e` 或 `f..=g`) 产生。",
        "translate": ""
    },
    {
        "source": "Start index bound.",
        "suggest": "开始索引绑定。",
        "translate": ""
    },
    {
        "source": "Returns the start value as a `Bound`.",
        "suggest": "以 `Bound` 形式返回起始值。",
        "translate": ""
    },
    {
        "source": "End index bound.",
        "suggest": "结束索引绑定。",
        "translate": ""
    },
    {
        "source": "Returns the end value as a `Bound`.",
        "suggest": "将结束值返回为 `Bound`。",
        "translate": ""
    },
    {
        "source": "When the iterator is exhausted, we usually have start == end, but we want the range to appear empty, containing nothing.",
        "suggest": "当迭代器用尽时，我们通常有 start == end，但我们希望范围显示为空，不包含任何内容。",
        "translate": ""
    },
    {
        "source": "A trait for customizing the behavior of the `?` operator.",
        "suggest": "trait，用于自定义 `?` 运算符的行为。",
        "translate": ""
    },
    {
        "source": "A type implementing `Try` is one that has a canonical way to view it in terms of a success/failure dichotomy.",
        "suggest": "实现 `Try` 的类型是一种具有规范性的 success/failure 二分法来查看它的类型。",
        "translate": ""
    },
    {
        "source": "This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.",
        "suggest": "trait 允许从现有实例中提取成功或失败值，也可以从成功或失败值创建新实例。",
        "translate": ""
    },
    {
        "source": "The type of this value when viewed as successful.",
        "suggest": "视为成功时，此值的类型。",
        "translate": ""
    },
    {
        "source": "The type of this value when viewed as failed.",
        "suggest": "视为失败时，此值的类型。",
        "translate": ""
    },
    {
        "source": "Applies the \"?\" operator.",
        "suggest": "应用 \"?\" 运算符。",
        "translate": ""
    },
    {
        "source": "A return of `Ok(t)` means that the execution should continue normally, and the result of `?` is the value `t`.",
        "suggest": "返回 `Ok(t)` 意味着执行应正常继续，并且 `?` 的结果为值 `t`。",
        "translate": ""
    },
    {
        "source": "A return of `Err(e)` means that execution should branch to the innermost enclosing `catch`, or return from the function.",
        "suggest": "返回 `Err(e)` 意味着执行应该分支到最里面的 `catch`，或者从函数返回。",
        "translate": ""
    },
    {
        "source": "If an `Err(e)` result is returned, the value `e` will be \"wrapped\" in the return type of the enclosing scope (which must itself implement `Try`).",
        "suggest": "如果返回 `Err(e)` 结果，则在封闭的作用域 (必须自己实现 `Try`) 的返回类型中，值 `e` 将为 \"wrapped\"。",
        "translate": ""
    },
    {
        "source": "Specifically, the value `X::from_error(From::from(e))` is returned, where `X` is the return type of the enclosing function.",
        "suggest": "具体来说，将返回值 `X::from_error(From::from(e))`，其中 `X` 是封闭函数的返回类型。",
        "translate": ""
    },
    {
        "source": "Wrap an error value to construct the composite result.",
        "suggest": "包装错误值以构造复合结果。",
        "translate": ""
    },
    {
        "source": "For example, `Result::Err(x)` and `Result::from_error(x)` are equivalent.",
        "suggest": "例如，`Result::Err(x)` 和 `Result::from_error(x)` 是等效的。",
        "translate": ""
    },
    {
        "source": "Wrap an OK value to construct the composite result.",
        "suggest": "包装一个 OK 值以构造复合结果。",
        "translate": ""
    },
    {
        "source": "For example, `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.",
        "suggest": "例如，`Result::Ok(x)` 和 `Result::from_ok(x)` 是等效的。",
        "translate": ""
    },
    {
        "source": "Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee.",
        "suggest": "Trait，指示这是一个指针或一个包装器，其中可以在指针上执行大小调整。",
        "translate": ""
    },
    {
        "source": "See the [DST coercion RFC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce] for more details.",
        "suggest": "有关更多详细信息，请参见 [DST 强制 RFC][dst-coerce] 和 [关于强制的 nomicon 入口][nomicon-coerce]。",
        "translate": ""
    },
    {
        "source": "For builtin pointer types, pointers to `T` will coerce to pointers to `U` if `T: Unsize<U>` by converting from a thin pointer to a fat pointer.",
        "suggest": "对于内置指针类型，如果 `T: Unsize<U>` 通过从精简指针转换为胖指针，则指向 `T` 的指针将强制指向指向 `U` 的指针。",
        "translate": ""
    },
    {
        "source": "For custom types, the coercion here works by coercing `Foo<T>` to `Foo<U>` provided an impl of `CoerceUnsized<Foo<U>> for Foo<T>` exists.",
        "suggest": "对于自定义类型，这里的强制通过将 `Foo<T>` 强制为 `Foo<U>` 来工作 (如果存在 `CoerceUnsized<Foo<U>> for Foo<T>` 的实现)。",
        "translate": ""
    },
    {
        "source": "Such an impl can only be written if `Foo<T>` has only a single non-phantomdata field involving `T`.",
        "suggest": "仅当 `Foo<T>` 仅具有涉及 `T` 的单个非虚拟数据字段时，才可以写这样的 impl。",
        "translate": ""
    },
    {
        "source": "If the type of that field is `Bar<T>`, an implementation of `CoerceUnsized<Bar<U>> for Bar<T>` must exist.",
        "suggest": "如果该字段的类型为 `Bar<T>`，则必须存在 `CoerceUnsized<Bar<U>> for Bar<T>` 的实现。",
        "translate": ""
    },
    {
        "source": "The coercion will work by coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields from `Foo<T>` to create a `Foo<U>`.",
        "suggest": "强制将通过将 `Bar<T>` 字段强制转换为 `Bar<U>` 并填充 `Foo<T>` 的其余字段以创建 `Foo<U>` 来起作用。",
        "translate": ""
    },
    {
        "source": "This will effectively drill down to a pointer field and coerce that.",
        "suggest": "这将有效地向下钻取指针字段并将其强制。",
        "translate": ""
    },
    {
        "source": "Generally, for smart pointers you will implement `CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized`, with an optional `?Sized` bound on `T` itself.",
        "suggest": "通常，对于智能指针，您将实现 `CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized`，并在 `T` 本身上绑定了可选的 `?Sized`。",
        "translate": ""
    },
    {
        "source": "For wrapper types that directly embed `T` like `Cell<T>` and `RefCell<T>`, you can directly implement `CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>`.",
        "suggest": "对于直接嵌入 `T` 的包装器类型 (例如 `Cell<T>` 和 `RefCell<T>`)，您可以直接实现 `CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>`。",
        "translate": ""
    },
    {
        "source": "This will let coercions of types like `Cell<Box<T>>` work.",
        "suggest": "这将使像 `Cell<Box<T>>` 这样的强制类型起作用。",
        "translate": ""
    },
    {
        "source": "is used to mark types which can be coerced to DSTs if behind pointers.",
        "suggest": "用于标记在指针后面可以强制转换为 DST 的类型。",
        "translate": ""
    },
    {
        "source": "It is implemented automatically by the compiler.",
        "suggest": "它由编译器自动实现。",
        "translate": ""
    },
    {
        "source": "This is used for object safety, to check that a method's receiver type can be dispatched on.",
        "suggest": "这用于对象安全，以检查是否可以分派方法的接收者类型。",
        "translate": ""
    },
    {
        "source": "An example implementation of the trait:",
        "suggest": "trait 的示例实现:",
        "translate": ""
    },
    {
        "source": "The return value of the function is an option",
        "suggest": "函数的返回值是一个选项",
        "translate": ""
    },
    {
        "source": "Pattern match to retrieve the value",
        "suggest": "模式匹配以获取值",
        "translate": ""
    },
    {
        "source": "The division was valid",
        "suggest": "该划分有效",
        "translate": ""
    },
    {
        "source": "The division was invalid",
        "suggest": "划分无效",
        "translate": ""
    },
    {
        "source": "Take a reference to the contained string",
        "suggest": "对包含的字符串加上引号",
        "translate": ""
    },
    {
        "source": "Remove the contained string, destroying the Option",
        "suggest": "删除包含的字符串，销毁 Option",
        "translate": ""
    },
    {
        "source": "A list of data to search through.",
        "suggest": "要搜索的数据列表。",
        "translate": ""
    },
    {
        "source": "We're going to search for the name of the biggest animal, but to start with we've just got `None`.",
        "suggest": "我们将搜索最大的动物的名称，但首先要获取 `None`。",
        "translate": ""
    },
    {
        "source": "Now we've found the name of some big animal",
        "suggest": "现在我们找到了一些大动物的名字",
        "translate": ""
    },
    {
        "source": "First, cast `Option<String>` to `Option<&String>` with `as_ref`, then consume *that* with `map`, leaving `text` on the stack.",
        "suggest": "首先，使用 `as_ref` 将 `Option<String>` 转换为 `Option<&String>`，然后使用 `map` 消耗 *that*，将 `text` 保留在栈中。",
        "translate": ""
    },
    {
        "source": "panics with `fruits are healthy`",
        "suggest": "`fruits are healthy` 的 panics",
        "translate": ""
    },
    {
        "source": "takes self *by value*, consuming `maybe_some_string`",
        "suggest": "需要 self 按照值消耗 `maybe_some_string`",
        "translate": ""
    },
    {
        "source": "This will not panic, since all keys are unique.",
        "suggest": "这不会 panic，因为所有键都是唯一的。",
        "translate": ""
    },
    {
        "source": "This will panic, since both negative and positive `i` will insert the same `i * i` key, returning the old `Some(i)`.",
        "suggest": "这将是 panic，因为负 `i` 和正 `i` 都将插入相同的 `i * i` 键，并返回旧的 `Some(i)`。",
        "translate": ""
    },
    {
        "source": "Optional values.",
        "suggest": "可选值。",
        "translate": ""
    },
    {
        "source": "Type [`Option`] represents an optional value: every [`Option`] is either [`Some`] and contains a value, or [`None`], and does not.",
        "suggest": "类型 [`Option`] 表示一个可选值: 每个 [`Option`] 均为 [`Some`] 并包含一个值，或者为 [`None`]，但不包含。",
        "translate": ""
    },
    {
        "source": "types are very common in Rust code, as they have a number of uses:",
        "suggest": "类型在 Rust 代码中非常常见，因为它们有许多用途:",
        "translate": ""
    },
    {
        "source": "Initial values",
        "suggest": "初始值",
        "translate": ""
    },
    {
        "source": "Return values for functions that are not defined over their entire input range (partial functions)",
        "suggest": "未在整个输入范围内定义的函数的返回值 (部分函数)",
        "translate": ""
    },
    {
        "source": "Return value for otherwise reporting simple errors, where [`None`] is returned on error",
        "suggest": "返回值，用于报告否则将报告简单错误的错误，其中错误返回 [`None`]",
        "translate": ""
    },
    {
        "source": "Optional struct fields",
        "suggest": "可选的结构体字段",
        "translate": ""
    },
    {
        "source": "Struct fields that can be loaned or \"taken\"",
        "suggest": "可借用或 \"taken\" 的结构体字段",
        "translate": ""
    },
    {
        "source": "Optional function arguments",
        "suggest": "可选函数参数",
        "translate": ""
    },
    {
        "source": "Nullable pointers",
        "suggest": "可空指针",
        "translate": ""
    },
    {
        "source": "Swapping things out of difficult situations",
        "suggest": "从困难的情况中交换东西",
        "translate": ""
    },
    {
        "source": "[`Option`]s are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the [`None`] case.",
        "suggest": "通常将 [`Option`] 与模式匹配配对，以查询值的存在并采取措施，始终考虑 [`None`] 的情况。",
        "translate": ""
    },
    {
        "source": "Show how `Option` is used in practice, with lots of methods",
        "suggest": "通过多种方法展示 `Option` 在实践中的使用方式",
        "translate": ""
    },
    {
        "source": "Options and pointers (\"nullable\" pointers)",
        "suggest": "选项和指针 (\"nullable\" 指针)",
        "translate": ""
    },
    {
        "source": "Rust's pointer types must always point to a valid location;",
        "suggest": "Rust 的指针类型必须始终指向有效位置。",
        "translate": ""
    },
    {
        "source": "there are no \"null\" references.",
        "suggest": "没有 \"null\" 引用。",
        "translate": ""
    },
    {
        "source": "Instead, Rust has *optional* pointers, like the optional owned box,",
        "suggest": "相反， Rust 有可选指针，例如可选的拥有所有权的 box，",
        "translate": ""
    },
    {
        "source": "The following example uses [`Option`] to create an optional box of [`i32`].",
        "suggest": "以下示例使用 [`Option`] 创建 [`i32`] 的可选 box。",
        "translate": ""
    },
    {
        "source": "Notice that in order to use the inner [`i32`] value first, the `check_optional` function needs to use pattern matching to determine whether the box has a value (i.e., it is [`Some(...)`][`Some`]) or not ([`None`]).",
        "suggest": "注意，为了首先使用内部 [`i32`] 值，`check_optional` 函数需要使用模式匹配来确定 box 是否具有值 (即 [`Some(...)`][`Some`]) 或 ([`None`])。",
        "translate": ""
    },
    {
        "source": "Rust guarantees to optimize the following types `T` such that [`Option<T>`] has the same size as `T`:",
        "suggest": "Rust 保证优化以下 `T` 类型，以使 [`Option<T>`] 具有与 `T` 相同的大小:",
        "translate": ""
    },
    {
        "source": "struct around one of the types in this list.",
        "suggest": "结构体围绕此列表中的一种。",
        "translate": ""
    },
    {
        "source": "It is further guaranteed that, for the cases above, one can [`mem::transmute`] from all valid values of `T` to `Option<T>` and from `Some::<T>(_)` to `T` (but transmuting `None::<T>` to `T` is undefined behaviour).",
        "suggest": "对于上述情况，可以进一步保证，可以从 `T` 到 `Option<T>` 的所有有效值以及从 `Some::<T>(_)` 到 `T` 的所有有效值 [`mem::transmute`] (但是将 `None::<T>` 转换为 `T` 是未定义的行为)。",
        "translate": ""
    },
    {
        "source": "Basic pattern matching on [`Option`]:",
        "suggest": "[`Option`] 上的基本模式匹配:",
        "translate": ""
    },
    {
        "source": "Initialize a result to [`None`] before a loop:",
        "suggest": "循环前将结果初始化为 [`None`]:",
        "translate": ""
    },
    {
        "source": "The `Option` type.",
        "suggest": "`Option` 类型。",
        "translate": ""
    },
    {
        "source": "See [the module level documentation](self) for more.",
        "suggest": "有关更多信息，请参见 [模块级文档](self)。",
        "translate": ""
    },
    {
        "source": "No value",
        "suggest": "没有值",
        "translate": ""
    },
    {
        "source": "Some value `T`",
        "suggest": "一些值 `T`",
        "translate": ""
    },
    {
        "source": "Type implementation",
        "suggest": "类型实现",
        "translate": ""
    },
    {
        "source": "Querying the contained values",
        "suggest": "查询包含的值",
        "translate": ""
    },
    {
        "source": "Returns `true` if the option is a [`Some`] value.",
        "suggest": "如果选项是 [`Some`] 值，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the option is a [`None`] value.",
        "suggest": "如果选项是 [`None`] 值，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the option is a [`Some`] value containing the given value.",
        "suggest": "如果选项是包含给定值的 [`Some`] 值，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Adapter for working with references",
        "suggest": "用于引用的适配器",
        "translate": ""
    },
    {
        "source": "Converts from `&Option<T>` to `Option<&T>`.",
        "suggest": "从 `&Option<T>` 转换为 `Option<&T>`。",
        "translate": ""
    },
    {
        "source": "Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.",
        "suggest": "将 `Option<`[`String`]`>` 转换为 `Option<`[`usize`]`>`，并保留原始格式。",
        "translate": ""
    },
    {
        "source": "The [`map`] method takes the `self` argument by value, consuming the original, so this technique uses `as_ref` to first take an `Option` to a reference to the value inside the original.",
        "suggest": "[`map`] 方法按值使用 `self` 参数，从而消耗了原始文件，因此该技术使用 `as_ref` 首先将 `Option` 引用给原始文件中的值。",
        "translate": ""
    },
    {
        "source": "Converts from `&mut Option<T>` to `Option<&mut T>`.",
        "suggest": "从 `&mut Option<T>` 转换为 `Option<&mut T>`。",
        "translate": ""
    },
    {
        "source": "Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.",
        "suggest": "从 [`Pin`]`<&Option<T>>` 转换为 `Option<`[`Pin`]`<&T>>`。",
        "translate": ""
    },
    {
        "source": "`x` is guaranteed to be pinned because it comes from `self` which is pinned.",
        "suggest": "`x` 被固定，因为它来自被固定的 `self`。",
        "translate": ""
    },
    {
        "source": "Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.",
        "suggest": "从 [`Pin`]`<&mut Option<T>>` 转换为 `Option <`[`Pin`]`<&mut T>>`。",
        "translate": ""
    },
    {
        "source": "`get_unchecked_mut` is never used to move the `Option` inside `self`.",
        "suggest": "`get_unchecked_mut` 从未用于在 `self` 内部移动 `Option`。",
        "translate": ""
    },
    {
        "source": "is guaranteed to be pinned because it comes from `self` which is pinned.",
        "suggest": "由于它来自固定的 `self`，因此可以确保将其固定。",
        "translate": ""
    },
    {
        "source": "Getting to contained values",
        "suggest": "获取包含的值",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value, consuming the `self` value.",
        "suggest": "返回包含 `self` 值的包含的 [`Some`] 值。",
        "translate": ""
    },
    {
        "source": "Panics if the value is a [`None`] with a custom panic message provided by `msg`.",
        "suggest": "Panics (如果值是具有 `msg` 提供的自定义 panic 消息的 [`None`])。",
        "translate": ""
    },
    {
        "source": "Because this function may panic, its use is generally discouraged.",
        "suggest": "由于此函数可能为 panic，因此通常不建议使用该函数。",
        "translate": ""
    },
    {
        "source": "Instead, prefer to use pattern matching and handle the [`None`] case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or [`unwrap_or_default`].",
        "suggest": "相反，更喜欢使用模式匹配并显式处理 [`None`] 大小写，或者调用 [`unwrap_or`]，[`unwrap_or_else`] 或 [`unwrap_or_default`]。",
        "translate": ""
    },
    {
        "source": "Panics if the self value equals [`None`].",
        "suggest": "如果自身值等于 [`None`]，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value or a provided default.",
        "suggest": "返回包含的 [`Some`] 值或提供的默认值。",
        "translate": ""
    },
    {
        "source": "Arguments passed to `unwrap_or` are eagerly evaluated;",
        "suggest": "急切地评估传递给 `unwrap_or` 的参数;",
        "translate": ""
    },
    {
        "source": "if you are passing the result of a function call, it is recommended to use [`unwrap_or_else`], which is lazily evaluated.",
        "suggest": "如果要传递函数调用的结果，建议使用 [`unwrap_or_else`]，它是惰性求值的。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value or computes it from a closure.",
        "suggest": "返回包含的 [`Some`] 值或从闭包中计算得出。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value, consuming the `self` value, without checking that the value is not [`None`].",
        "suggest": "返回包含 `self` 值的包含的 [`Some`] 值，而不检查该值是否不是 [`None`]。",
        "translate": ""
    },
    {
        "source": "Calling this method on [`None`] is *[undefined behavior]*.",
        "suggest": "在 [`None`] 上调用此方法是 *[undefined behavior]*。",
        "translate": ""
    },
    {
        "source": "Transforming contained values",
        "suggest": "转换包含的值",
        "translate": ""
    },
    {
        "source": "Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.",
        "suggest": "通过将函数应用于包含的值，Maps 将 `Option<T>` 转换为 `Option<U>`。",
        "translate": ""
    },
    {
        "source": "Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:",
        "suggest": "使用原始文件将 `Option<`[`String`]`>` 转换为 `Option<`[`usize`]`>`:",
        "translate": ""
    },
    {
        "source": "Applies a function to the contained value (if any), or returns the provided default (if not).",
        "suggest": "将函数应用于所包含的值 (如果有)，或者返回提供的默认值 (如果没有)。",
        "translate": ""
    },
    {
        "source": "Arguments passed to `map_or` are eagerly evaluated;",
        "suggest": "急切地评估传递给 `map_or` 的参数;",
        "translate": ""
    },
    {
        "source": "if you are passing the result of a function call, it is recommended to use [`map_or_else`], which is lazily evaluated.",
        "suggest": "如果要传递函数调用的结果，建议使用 [`map_or_else`]，它是延迟计算的。",
        "translate": ""
    },
    {
        "source": "Applies a function to the contained value (if any), or computes a default (if not).",
        "suggest": "将函数应用于所包含的值 (如果有)，或者计算默认值 (如果没有)。",
        "translate": ""
    },
    {
        "source": "Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err)`].",
        "suggest": "将 `Option<T>` 转换为 [`Result<T, E>`]，将 [`Some(v)`] 映射到 [`Ok(v)`]，将 [`None`] 映射到 [`Err(err)`]。",
        "translate": ""
    },
    {
        "source": "Arguments passed to `ok_or` are eagerly evaluated;",
        "suggest": "急切地评估传递给 `ok_or` 的参数;",
        "translate": ""
    },
    {
        "source": "if you are passing the result of a function call, it is recommended to use [`ok_or_else`], which is lazily evaluated.",
        "suggest": "如果要传递函数调用的结果，建议使用 [`ok_or_else`]，它是延迟计算的。",
        "translate": ""
    },
    {
        "source": "Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err())`].",
        "suggest": "将 `Option<T>` 转换为 [`Result<T, E>`]，将 [`Some(v)`] 映射到 [`Ok(v)`]，将 [`None`] 映射到 [`Err(err())`]。",
        "translate": ""
    },
    {
        "source": "Inserts `value` into the option then returns a mutable reference to it.",
        "suggest": "将 `value` 插入选项，然后向其返回变量引用。",
        "translate": ""
    },
    {
        "source": "If the option already contains a value, the old value is dropped.",
        "suggest": "如果该选项已包含值，则将丢弃旧值。",
        "translate": ""
    },
    {
        "source": "the code above just filled the option",
        "suggest": "上面的代码刚刚填满了该选项",
        "translate": ""
    },
    {
        "source": "Iterator constructors",
        "suggest": "迭代器构造函数",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the possibly contained value.",
        "suggest": "返回可能包含的值的迭代器。",
        "translate": ""
    },
    {
        "source": "Returns a mutable iterator over the possibly contained value.",
        "suggest": "返回可能包含的值的可变迭代器。",
        "translate": ""
    },
    {
        "source": "Boolean operations on the values, eager and lazy",
        "suggest": "对值的布尔运算，渴望和懒惰",
        "translate": ""
    },
    {
        "source": "Returns [`None`] if the option is [`None`], otherwise returns `optb`.",
        "suggest": "如果选项为 [`None`]，则返回 [`None`]; 否则，返回 `optb`。",
        "translate": ""
    },
    {
        "source": "Returns [`None`] if the option is [`None`], otherwise calls `f` with the wrapped value and returns the result.",
        "suggest": "如果选项为 [`None`]，则返回 [`None`]; 否则，使用包装的值调用 `f`，并返回结果。",
        "translate": ""
    },
    {
        "source": "Some languages call this operation flatmap.",
        "suggest": "一些语言调用此操作平面图。",
        "translate": ""
    },
    {
        "source": "Returns [`None`] if the option is [`None`], otherwise calls `predicate` with the wrapped value and returns:",
        "suggest": "如果选项为 [`None`]，则返回 [`None`]; 否则，使用包装的值调用 `predicate` 并返回:",
        "translate": ""
    },
    {
        "source": "if `predicate` returns `true` (where `t` is the wrapped value), and",
        "suggest": "如果 `predicate` 返回 `true` (其中 `t` 是包装的值)，并且",
        "translate": ""
    },
    {
        "source": "if `predicate` returns `false`.",
        "suggest": "如果 `predicate` 返回 `false`。",
        "translate": ""
    },
    {
        "source": "This function works similar to [`Iterator::filter()`].",
        "suggest": "该函数的工作方式类似于 [`Iterator::filter()`]。",
        "translate": ""
    },
    {
        "source": "You can imagine the `Option<T>` being an iterator over one or zero elements.",
        "suggest": "您可以想象 `Option<T>` 是一个或零个元素上的迭代器。",
        "translate": ""
    },
    {
        "source": "lets you decide which elements to keep.",
        "suggest": "让您决定要保留哪些元素。",
        "translate": ""
    },
    {
        "source": "Returns the option if it contains a value, otherwise returns `optb`.",
        "suggest": "如果包含值，则返回选项，否则返回 `optb`。",
        "translate": ""
    },
    {
        "source": "Arguments passed to `or` are eagerly evaluated;",
        "suggest": "急切地评估传递给 `or` 的参数;",
        "translate": ""
    },
    {
        "source": "if you are passing the result of a function call, it is recommended to use [`or_else`], which is lazily evaluated.",
        "suggest": "如果要传递函数调用的结果，建议使用 [`or_else`]，它是延迟计算的。",
        "translate": ""
    },
    {
        "source": "Returns the option if it contains a value, otherwise calls `f` and returns the result.",
        "suggest": "如果选项包含值，则返回该选项，否则调用 `f` 并返回结果。",
        "translate": ""
    },
    {
        "source": "Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns [`None`].",
        "suggest": "如果 `self`，`optb` 之一恰好是 [`Some`]，则返回 [`Some`]，否则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Entry-like operations to insert if None and return a reference",
        "suggest": "如果没有则插入类似条目的操作，并返回一个引用",
        "translate": ""
    },
    {
        "source": "Inserts `value` into the option if it is [`None`], then returns a mutable reference to the contained value.",
        "suggest": "如果为 [`None`]，则将 `value` 插入到选项中，然后返回所包含的值的变量引用。",
        "translate": ""
    },
    {
        "source": "Inserts the default value into the option if it is [`None`], then returns a mutable reference to the contained value.",
        "suggest": "如果默认值为 [`None`]，则将其插入选项中，然后将所包含的值返回变量引用。",
        "translate": ""
    },
    {
        "source": "Inserts a value computed from `f` into the option if it is [`None`], then returns a mutable reference to the contained value.",
        "suggest": "如果从 `f` 计算得出的值是 [`None`]，则将其插入选项中，然后将所包含的值返回可变引用。",
        "translate": ""
    },
    {
        "source": "a `None` variant for `self` would have been replaced by a `Some` variant in the code above.",
        "suggest": "在上面的代码中，用于 `self` 的 `None` 成员将被替换为 `Some` 成员。",
        "translate": ""
    },
    {
        "source": "Takes the value out of the option, leaving a [`None`] in its place.",
        "suggest": "从选项中取出值，将 [`None`] 留在其位置。",
        "translate": ""
    },
    {
        "source": "Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a [`Some`] in its place without deinitializing either one.",
        "suggest": "用参数中给定的值替换选项中的实际值，如果存在则返回旧值，将 [`Some`] 保留在其位置，而不用对其中一个进行初始化。",
        "translate": ""
    },
    {
        "source": "Zips `self` with another `Option`.",
        "suggest": "用另一个 `Option` 压缩 `self`。",
        "translate": ""
    },
    {
        "source": "If `self` is `Some(s)` and `other` is `Some(o)`, this method returns `Some((s, o))`.",
        "suggest": "如果 `self` 是 `Some(s)`，而 `other` 是 `Some(o)`，则此方法返回 `Some((s, o))`。",
        "translate": ""
    },
    {
        "source": "Otherwise, `None` is returned.",
        "suggest": "否则，返回 `None`。",
        "translate": ""
    },
    {
        "source": "Zips `self` and another `Option` with function `f`.",
        "suggest": "使用函数 `f` 压缩 `self` 和另一个 `Option`。",
        "translate": ""
    },
    {
        "source": "If `self` is `Some(s)` and `other` is `Some(o)`, this method returns `Some(f(s, o))`.",
        "suggest": "如果 `self` 是 `Some(s)`，而 `other` 是 `Some(o)`，则此方法返回 `Some(f(s, o))`。",
        "translate": ""
    },
    {
        "source": "Maps an `Option<&T>` to an `Option<T>` by copying the contents of the option.",
        "suggest": "通过复制选项的内容将 `Option<&T>` 的 Maps 转换为 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the option.",
        "suggest": "通过复制选项的内容将 `Option<&mut T>` 的 Maps 转换为 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the option.",
        "suggest": "通过克隆选项的内容将 `Option<&T>` Maps 转换为 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the option.",
        "suggest": "通过克隆选项的内容将 `Option<&mut T>` Maps 转换为 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "Consumes `self` while expecting [`None`] and returning nothing.",
        "suggest": "消耗 `self`，而期望 [`None`] 却什么也不返回。",
        "translate": ""
    },
    {
        "source": "Panics if the value is a [`Some`], with a panic message including the passed message, and the content of the [`Some`].",
        "suggest": "Panics (如果值为 [`Some`])，其中 panic 消息包括传递的消息和 [`Some`] 的内容。",
        "translate": ""
    },
    {
        "source": "Panics if the value is a [`Some`], with a custom panic message provided by the [`Some`]'s value.",
        "suggest": "Panics，如果该值为 [`Some`]，则由 [`Some`] 的值提供自定义 panic 消息。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value or a default",
        "suggest": "返回包含的 [`Some`] 值或默认值",
        "translate": ""
    },
    {
        "source": "Consumes the `self` argument then, if [`Some`], returns the contained value, otherwise if [`None`], returns the [default value] for that type.",
        "suggest": "消费 `self` 参数，如果 [`Some`]，则返回所包含的值，否则，如果 [`None`]，则返回该类型的 [default value]。",
        "translate": ""
    },
    {
        "source": "Converts a string to an integer, turning poorly-formed strings into 0 (the default value for integers).",
        "suggest": "将字符串转换为整数，将格式不正确的字符串转换为 0 (整数的默认值)。",
        "translate": ""
    },
    {
        "source": "converts a string to any other type that implements [`FromStr`], returning [`None`] on error.",
        "suggest": "将字符串转换为实现 [`FromStr`] 的任何其他类型，并在错误时返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.",
        "suggest": "从 `Option<T>` (或 `&Option<T>`) 转换为 `Option<&T::Target>`。",
        "translate": ""
    },
    {
        "source": "Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via [`Deref`].",
        "suggest": "将原始 Option 保留在原位，创建一个带有对原始 Option 的引用的新 Option，并通过 [`Deref`] 强制执行其内容。",
        "translate": ""
    },
    {
        "source": "Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.",
        "suggest": "从 `Option<T>` (或 `&mut Option<T>`) 转换为 `Option<&mut T::Target>`。",
        "translate": ""
    },
    {
        "source": "Leaves the original `Option` in-place, creating a new one containing a mutable reference to the inner type's `Deref::Target` type.",
        "suggest": "将原始 `Option` 保留在原位，创建一个新的 `Option`，其中包含对内部类型的 `Deref::Target` 类型的引用。",
        "translate": ""
    },
    {
        "source": "Transposes an `Option` of a [`Result`] into a [`Result`] of an `Option`.",
        "suggest": "将 [`Result`] 的 `Option` 转换为 `Option` 的 [`Result`]。",
        "translate": ""
    },
    {
        "source": "will be mapped to [`Ok`]`(`[`None`]`)`.",
        "suggest": "将被映射到 [`Ok`]`(`[`None`]`)`。",
        "translate": ""
    },
    {
        "source": "and [`Some`]`(`[`Err`]`(_))` will be mapped to [`Ok`]`(`[`Some`]`(_))` and [`Err`]`(_)`.",
        "suggest": "[`Some`]`(`[`Err`]`(_))` 将被映射到 [`Ok`]`(`[`Some`]`(_))` 和 [`Err`]`(_)`。",
        "translate": ""
    },
    {
        "source": "This is a separate function to reduce the code size of .expect() itself.",
        "suggest": "这是一个单独的函数，可以减少 .expect() 本身的代码大小。",
        "translate": ""
    },
    {
        "source": "This is a separate function to reduce the code size of .expect_none() itself.",
        "suggest": "这是一个单独的函数，可以减少 .expect_none() 本身的代码大小。",
        "translate": ""
    },
    {
        "source": "Trait implementations",
        "suggest": "Trait 实现",
        "translate": ""
    },
    {
        "source": "Returns [`None`][Option::None].",
        "suggest": "返回 [`None`][Option::None]。",
        "translate": ""
    },
    {
        "source": "Returns a consuming iterator over the possibly contained value.",
        "suggest": "返回可能包含的值上的消耗迭代器。",
        "translate": ""
    },
    {
        "source": "Copies `val` into a new `Some`.",
        "suggest": "将 `val` 复制到新的 `Some` 中。",
        "translate": ""
    },
    {
        "source": "Converts from `&mut Option<T>` to `Option<&mut T>`",
        "suggest": "从 `&mut Option<T>` 转换为 `Option<&mut T>`",
        "translate": ""
    },
    {
        "source": "The Option Iterators",
        "suggest": "选项迭代器",
        "translate": ""
    },
    {
        "source": "An iterator over a reference to the [`Some`] variant of an [`Option`].",
        "suggest": "[`Option`] 的 [`Some`] 成员的引用上的迭代器。",
        "translate": ""
    },
    {
        "source": "The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.",
        "suggest": "如果 [`Option`] 为 [`Some`]，则迭代器产生一个值，否则为 0。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`Option::iter`] function.",
        "suggest": "该 `struct` 由 [`Option::iter`] 函数创建。",
        "translate": ""
    },
    {
        "source": "An iterator over a mutable reference to the [`Some`] variant of an [`Option`].",
        "suggest": "[`Option`] 的 [`Some`] 成员的可变引用上的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`Option::iter_mut`] function.",
        "suggest": "该 `struct` 由 [`Option::iter_mut`] 函数创建。",
        "translate": ""
    },
    {
        "source": "An iterator over the value in [`Some`] variant of an [`Option`].",
        "suggest": "[`Option`] 的 [`Some`] 成员中的值的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`Option::into_iter`] function.",
        "suggest": "该 `struct` 由 [`Option::into_iter`] 函数创建。",
        "translate": ""
    },
    {
        "source": "Takes each element in the [`Iterator`]: if it is [`None`][Option::None], no further elements are taken, and the [`None`][Option::None] is returned.",
        "suggest": "接受 [`Iterator`] 中的每个元素: 如果为 [`None`][Option::None]，则不再获取其他元素，并返回 [`None`][Option::None]。",
        "translate": ""
    },
    {
        "source": "Should no [`None`][Option::None] occur, a container with the values of each [`Option`] is returned.",
        "suggest": "如果没有发生 [`None`][Option::None]，则返回包含每个 [`Option`] 值的容器。",
        "translate": ""
    },
    {
        "source": "Here is an example which increments every integer in a vector.",
        "suggest": "这是一个使 vector 中的每个整数递增的示例。",
        "translate": ""
    },
    {
        "source": "We use the checked variant of `add` that returns `None` when the calculation would result in an overflow.",
        "suggest": "当计算将导致溢出时，我们使用 `add` 的检查成员返回 `None`。",
        "translate": ""
    },
    {
        "source": "As you can see, this will return the expected, valid items.",
        "suggest": "如您所见，这将返回预期的有效项。",
        "translate": ""
    },
    {
        "source": "Here is another example that tries to subtract one from another list of integers, this time checking for underflow:",
        "suggest": "这是另一个示例，尝试从另一个整数列表中减去一个，这次检查下溢:",
        "translate": ""
    },
    {
        "source": "Since the last element is zero, it would underflow.",
        "suggest": "由于最后一个元素为零，因此会下溢。",
        "translate": ""
    },
    {
        "source": "Thus, the resulting value is `None`.",
        "suggest": "因此，结果值为 `None`。",
        "translate": ""
    },
    {
        "source": "Here is a variation on the previous example, showing that no further elements are taken from `iter` after the first `None`.",
        "suggest": "这是前一个示例的变体，显示在第一个 `None` 之后不再从 `iter` 提取其他元素。",
        "translate": ""
    },
    {
        "source": "Since the third element caused an underflow, no further elements were taken, so the final value of `shared` is 6 (= `3 + 2 + 1`), not 16.",
        "suggest": "由于第三个元素引起下溢，因此不再使用其他元素，因此 `shared` 的最终值为 6 (= `3 + 2 + 1`)，而不是 16。",
        "translate": ""
    },
    {
        "source": "This could be replaced with Iterator::scan when this performance bug is closed.",
        "suggest": "该性能错误已关闭时，可以将其替换为 Iterator::scan。",
        "translate": ""
    },
    {
        "source": "The error type that results from applying the try operator (`?`) to a `None` value.",
        "suggest": "将 try 运算符 (`?`) 应用于 `None` 值所导致的错误类型。",
        "translate": ""
    },
    {
        "source": "If you wish to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can implement `impl From<NoneError>` for `YourErrorType`.",
        "suggest": "如果希望允许将 `x?` (其中 `x` 是 `Option<T>`) 转换为错误类型，则可以为 `YourErrorType` 实现 `impl From<NoneError>`。",
        "translate": ""
    },
    {
        "source": "In that case, `x?` within a function that returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.",
        "suggest": "在这种情况下，返回 `Result<_, YourErrorType>` 的函数中的 `x?` 会将 `None` 的值转换为 `Err` 的结果。",
        "translate": ""
    },
    {
        "source": "Converts from `Option<Option<T>>` to `Option<T>`",
        "suggest": "从 `Option<Option<T>>` 转换为 `Option<T>`",
        "translate": ""
    },
    {
        "source": "Returns the [`Location`] at which it is called.",
        "suggest": "返回调用它的 [`Location`]。",
        "translate": ""
    },
    {
        "source": "Returns a [`Location`] from within this function's definition.",
        "suggest": "从此函数的定义中返回 [`Location`]。",
        "translate": ""
    },
    {
        "source": "running the same untracked function in a different location gives us the same result",
        "suggest": "在不同的位置运行相同的未跟踪函数会得到相同的结果",
        "translate": ""
    },
    {
        "source": "running the tracked function in a different location produces a different value",
        "suggest": "在其他位置运行跟踪的函数会产生不同的值",
        "translate": ""
    },
    {
        "source": "Panic support in the standard library.",
        "suggest": "标准库中的 Panic 支持。",
        "translate": ""
    },
    {
        "source": "A struct providing information about a panic.",
        "suggest": "提供有关 panic 的信息的结构体。",
        "translate": ""
    },
    {
        "source": "structure is passed to a panic hook set by the [`set_hook`] function.",
        "suggest": "结构体传递给 [`set_hook`] 函数设置的 panic hook。",
        "translate": ""
    },
    {
        "source": "Returns the payload associated with the panic.",
        "suggest": "返回与 panic 关联的有效负载。",
        "translate": ""
    },
    {
        "source": "This will commonly, but not always, be a `&'static str` or [`String`].",
        "suggest": "通常但并非总是 `&'static str` 或 [`String`]。",
        "translate": ""
    },
    {
        "source": "If the `panic!` macro from the `core` crate (not from `std`) was used with a formatting string and some additional arguments, returns that message ready to be used for example with [`fmt::write`]",
        "suggest": "如果 `core` crate 中的 `panic!` 宏 (不是 `std` 中的) 与格式化字符串和一些其他参数一起使用，则返回该消息准备好与 [`fmt::write`] 一起使用",
        "translate": ""
    },
    {
        "source": "Returns information about the location from which the panic originated, if available.",
        "suggest": "返回有关 panic 起源的位置的信息 (如果有)。",
        "translate": ""
    },
    {
        "source": "This method will currently always return [`Some`], but this may change in future versions.",
        "suggest": "该方法当前将始终返回 [`Some`]，但是在 future 版本中可能会更改。",
        "translate": ""
    },
    {
        "source": "If this is changed to sometimes return None, deal with that case in std::panicking::default_hook and std::panicking::begin_panic_fmt.",
        "suggest": "如果更改为有时返回 None，则在 std::panicking::default_hook 和 std::panicking::begin_panic_fmt 中处理该情况。",
        "translate": ""
    },
    {
        "source": "we cannot use downcast_ref::<String>() here since String is not available in libcore!",
        "suggest": "我们不能使用 downcast_ref::<String> () 在这里，因为 String 在 libcore 中不可用!",
        "translate": ""
    },
    {
        "source": "The payload is a String when `std::panic!` is called with multiple arguments, but in that case the message is also available.",
        "suggest": "当使用多个参数调用 `std::panic!` 时，有效负载为字符串，但是在这种情况下，该消息也可用。",
        "translate": ""
    },
    {
        "source": "A struct containing information about the location of a panic.",
        "suggest": "包含有关 panic 位置信息的结构体。",
        "translate": ""
    },
    {
        "source": "This structure is created by [`PanicInfo::location()`].",
        "suggest": "该结构体由 [`PanicInfo::location()`] 创建。",
        "translate": ""
    },
    {
        "source": "Comparisons for equality and ordering are made in file, line, then column priority.",
        "suggest": "在文件，行和列优先级中进行相等性和顺序的比较。",
        "translate": ""
    },
    {
        "source": "Files are compared as strings, not `Path`, which could be unexpected.",
        "suggest": "文件被比较为字符串，而不是 `Path`，这可能是意外的。",
        "translate": ""
    },
    {
        "source": "See [`Location::file`]'s documentation for more discussion.",
        "suggest": "有关更多讨论，请参见 [`Location::file`] 的文档。",
        "translate": ""
    },
    {
        "source": "Returns the source location of the caller of this function.",
        "suggest": "返回此函数的调用者的源位置。",
        "translate": ""
    },
    {
        "source": "If that function's caller is annotated then its call location will be returned, and so on up the stack to the first call within a non-tracked function body.",
        "suggest": "如果该函数的调用方被注释，那么它的调用位置将被返回，以此类推，直到堆栈中第一个未被跟踪的函数体中的调用。",
        "translate": ""
    },
    {
        "source": "Returns the name of the source file from which the panic originated.",
        "suggest": "返回 panic 源自的源文件的名称。",
        "translate": ""
    },
    {
        "source": "not `&Path`",
        "suggest": "不是 `&Path`",
        "translate": ""
    },
    {
        "source": "The returned name refers to a source path on the compiling system, but it isn't valid to represent this directly as a `&Path`.",
        "suggest": "返回的名称指向编译系统上的源路径，但是将其直接表示为 `&Path` 是无效的。",
        "translate": ""
    },
    {
        "source": "The compiled code may run on a different system with a different `Path` implementation than the system providing the contents and this library does not currently have a different \"host path\" type.",
        "suggest": "与提供内容的系统相比，编译后的代码可以在具有不同 `Path` 实现的不同系统上运行，并且此库当前没有不同的 \"host path\" 类型。",
        "translate": ""
    },
    {
        "source": "The most surprising behavior occurs when \"the same\" file is reachable via multiple paths in the module system (usually using the `#[path = \"...\"]` attribute or similar), which can cause what appears to be identical code to return differing values from this function.",
        "suggest": "当通过模块系统中的多个路径可访问 \"the same\" 文件时 (通常使用 `#[path = \"...\"]` 属性或类似属性)，会发生最令人惊讶的行为，这可能导致看似相同的代码返回与此函数不同的值。",
        "translate": ""
    },
    {
        "source": "This value is not suitable for passing to `Path::new` or similar constructors when the host platform and target platform differ.",
        "suggest": "当主机平台和目标平台不同时，此值不适合传递给 `Path::new` 或类似的构造函数。",
        "translate": ""
    },
    {
        "source": "Returns the line number from which the panic originated.",
        "suggest": "返回 panic 起源的行号。",
        "translate": ""
    },
    {
        "source": "Returns the column from which the panic originated.",
        "suggest": "返回 panic 起源的列。",
        "translate": ""
    },
    {
        "source": "An internal trait used by libstd to pass data from libstd to `panic_unwind` and other panic runtimes.",
        "suggest": "libstd 使用的内部 trait 将数据从 libstd 传递到 `panic_unwind` 和其他 panic 运行时。",
        "translate": ""
    },
    {
        "source": "Not intended to be stabilized any time soon, do not use.",
        "suggest": "不打算在任何时候稳定下来，请勿使用。",
        "translate": ""
    },
    {
        "source": "Take full ownership of the contents.",
        "suggest": "拥有内容的全部所有权。",
        "translate": ""
    },
    {
        "source": "The return type is actually `Box<dyn Any + Send>`, but we cannot use `Box` in libcore.",
        "suggest": "返回类型实际上是 `Box<dyn Any + Send>`，但是我们不能在 libcore 中使用 `Box`。",
        "translate": ""
    },
    {
        "source": "After this method got called, only some dummy default value is left in `self`.",
        "suggest": "调用此方法后，`self` 中仅保留一些虚拟默认值。",
        "translate": ""
    },
    {
        "source": "Calling this method twice, or calling `get` after calling this method, is an error.",
        "suggest": "两次调用此方法，或在调用此方法后调用 `get`，都是错误的。",
        "translate": ""
    },
    {
        "source": "The argument is borrowed because the panic runtime (`__rust_start_panic`) only gets a borrowed `dyn BoxMeUp`.",
        "suggest": "之所以借用该参数是因为 panic 运行时 (`__rust_start_panic`) 仅得到借用的 `dyn BoxMeUp`。",
        "translate": ""
    },
    {
        "source": "Just borrow the contents.",
        "suggest": "只是借用内容。",
        "translate": ""
    },
    {
        "source": "Panic support for libcore",
        "suggest": "Panic 对 libcore 的支持",
        "translate": ""
    },
    {
        "source": "The core library cannot define panicking, but it does *declare* panicking.",
        "suggest": "核心库无法定义 panic，但可以声明 panic。",
        "translate": ""
    },
    {
        "source": "This means that the functions inside of libcore are allowed to panic, but to be useful an upstream crate must define panicking for libcore to use.",
        "suggest": "这意味着 libcore 内部的函数被允许用于 panic，但上游 crate 有用时必须定义恐慌以供 libcore 使用。",
        "translate": ""
    },
    {
        "source": "The current interface for panicking is:",
        "suggest": "当前的 panic 接口是:",
        "translate": ""
    },
    {
        "source": "This definition allows for panicking with any general message, but it does not allow for failing with a `Box<Any>` value.",
        "suggest": "此定义允许对任何常规消息进行 panic，但不允许 `Box<Any>` 值失败。",
        "translate": ""
    },
    {
        "source": "(`PanicInfo` just contains a `&(dyn Any + Send)`, for which we fill in a dummy value in `PanicInfo::internal_constructor`.) The reason for this is that libcore is not allowed to allocate.",
        "suggest": "(`PanicInfo` 仅包含一个 `&(dyn Any + Send)`，我们在其中将其填充为 `PanicInfo::internal_constructor` 中的虚拟值。) 其原因是不允许 libcore 进行分配。",
        "translate": ""
    },
    {
        "source": "This module contains a few other panicking functions, but these are just the necessary lang items for the compiler.",
        "suggest": "该模块还包含其他一些紧急函数，但这只是编译器必需的 lang 项。",
        "translate": ""
    },
    {
        "source": "All panics are funneled through this one function.",
        "suggest": "所有 panics 都通过此函数进行了分配。",
        "translate": ""
    },
    {
        "source": "The actual symbol is declared through the `#[panic_handler]` attribute.",
        "suggest": "实际符号通过 `#[panic_handler]` 属性声明。",
        "translate": ""
    },
    {
        "source": "The underlying implementation of libcore's `panic!` macro when no formatting is used.",
        "suggest": "不使用格式时，libcore 的 `panic!` 宏的基础实现。",
        "translate": ""
    },
    {
        "source": "never inline unless panic_immediate_abort to avoid code bloat at the call sites as much as possible",
        "suggest": "从不内联，除非 panic_immediate_abort 尽可能避免代码在调用站点上膨胀",
        "translate": ""
    },
    {
        "source": "needed by codegen for panic on overflow and other `Assert` MIR terminators",
        "suggest": "溢出和其他 `Assert` MIR 终结器时 panic 的代码生成所需的",
        "translate": ""
    },
    {
        "source": "Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially reduce size overhead.",
        "suggest": "使用 Arguments::new_v1 代替 format_args! (`{}`，expr) 可能会减少大小开销。",
        "translate": ""
    },
    {
        "source": "The format_args!",
        "suggest": "format_args!",
        "translate": ""
    },
    {
        "source": "macro uses str's Display trait to write expr, which calls Formatter::pad, which must accommodate string truncation and padding (even though none is used here).",
        "suggest": "宏使用 str 的 Display trait 来编写 expr，该调用将调用 Formatter::pad，该 Formatter::pad 必须容纳字符串截断和填充 (即使此处未使用)。",
        "translate": ""
    },
    {
        "source": "Using Arguments::new_v1 may allow the compiler to omit Formatter::pad from the output binary, saving up to a few kilobytes.",
        "suggest": "使用 Arguments::new_v1 可使编译器从输出二进制文件中省略 Formatter::pad，从而节省多达几千字节的空间。",
        "translate": ""
    },
    {
        "source": "needed for const-evaluated panics",
        "suggest": "常量评估的 panics 所需",
        "translate": ""
    },
    {
        "source": "needed by codegen for panic on OOB array/slice access",
        "suggest": "OOB array/slice 访问上 panic 的代码生成所需的",
        "translate": ""
    },
    {
        "source": "The underlying implementation of libcore's `panic!` macro when formatting is used.",
        "suggest": "使用格式化时 libcore 的 `panic!` 宏的基础实现。",
        "translate": ""
    },
    {
        "source": "NOTE This function never crosses the FFI boundary;",
        "suggest": "注意此函数永远不会越过 FFI 边界。",
        "translate": ""
    },
    {
        "source": "it's a Rust-to-Rust call that gets resolved to the `#[panic_handler]` function.",
        "suggest": "这是 Rust 到 Rust 调用，已解析为 `#[panic_handler]` 函数。",
        "translate": ""
    },
    {
        "source": "`panic_impl` is defined in safe Rust code and thus is safe to call.",
        "suggest": "`panic_impl` 在安全的 Rust 代码中定义，因此可以安全调用。",
        "translate": ""
    },
    {
        "source": "Internal function for `assert_eq!` and `assert_ne!` macros",
        "suggest": "`assert_eq!` 和 `assert_ne!` 宏的内联函数",
        "translate": ""
    },
    {
        "source": "needs `&mut T`, but we cannot get it.",
        "suggest": "需要 `&mut T`，但我们无法获得它。",
        "translate": ""
    },
    {
        "source": "We are stuck, we cannot swap the contents of these references.",
        "suggest": "我们被困住了，我们不能交换这些引用的内容。",
        "translate": ""
    },
    {
        "source": "We could use `Pin::get_unchecked_mut`, but that is unsafe for a reason:",
        "suggest": "我们可以使用 `Pin::get_unchecked_mut`，但这是不安全的，原因如下:",
        "translate": ""
    },
    {
        "source": "we are not allowed to use it for moving things out of the `Pin`.",
        "suggest": "我们不允许将其用于将物品移出 `Pin`。",
        "translate": ""
    },
    {
        "source": "This is a self-referential struct because the slice field points to the data field.",
        "suggest": "这是一个自引用结构体，因为切片字段指向数据字段。",
        "translate": ""
    },
    {
        "source": "We cannot inform the compiler about that with a normal reference, as this pattern cannot be described with the usual borrowing rules.",
        "suggest": "我们无法通过正常的引用将其告知编译器，因为无法使用通常的借用规则来描述此模式。",
        "translate": ""
    },
    {
        "source": "Instead we use a raw pointer, though one which is known not to be null, as we know it's pointing at the string.",
        "suggest": "取而代之的是，我们使用一个裸指针，尽管我们知道它指向的是一个不为 null 的指针。",
        "translate": ""
    },
    {
        "source": "To ensure the data doesn't move when the function returns, we place it in the heap where it will stay for the lifetime of the object, and the only way to access it would be through a pointer to it.",
        "suggest": "为了确保函数返回时数据不会移动，我们将其放置在堆中，以保留对象的生命周期，唯一的访问方法是通过指向它的指针。",
        "translate": ""
    },
    {
        "source": "we only create the pointer once the data is in place otherwise it will have already moved before we even started",
        "suggest": "我们仅在数据到位后创建指针，否则数据将在我们开始之前就已经移动",
        "translate": ""
    },
    {
        "source": "we know this is safe because modifying a field doesn't move the whole struct",
        "suggest": "我们知道这是安全的，因为修改字段不会移动整个结构体",
        "translate": ""
    },
    {
        "source": "The pointer should point to the correct location, so long as the struct hasn't moved.",
        "suggest": "只要结构体没有移动，指针应指向正确的位置。",
        "translate": ""
    },
    {
        "source": "Meanwhile, we are free to move the pointer around.",
        "suggest": "同时，我们可以随意移动指针。",
        "translate": ""
    },
    {
        "source": "Since our type doesn't implement Unpin, this will fail to compile:",
        "suggest": "由于我们的类型未实现 Unpin，因此无法编译:",
        "translate": ""
    },
    {
        "source": "is okay because we know this value is never used again after being dropped.",
        "suggest": "可以，因为我们知道此值在丢弃后再也不会使用了。",
        "translate": ""
    },
    {
        "source": "Actual drop code goes here.",
        "suggest": "实际丢弃的代码在此处。",
        "translate": ""
    },
    {
        "source": "This is okay because `field` is never considered pinned.",
        "suggest": "可以，因为 `field` 从未被视为固定。",
        "translate": ""
    },
    {
        "source": "This is okay because `field` is pinned when `self` is.",
        "suggest": "可以，因为 `self` 固定在 `field` 上。",
        "translate": ""
    },
    {
        "source": "Here we get pinned access to the `T`.",
        "suggest": "在这里，我们可以固定访问 `T`。",
        "translate": ""
    },
    {
        "source": "And here we have `&mut T` to the same data.",
        "suggest": "这里我们有 `&mut T` 到相同的数据。",
        "translate": ""
    },
    {
        "source": "This should mean the pointee `a` can never move again.",
        "suggest": "这应该意味着指针 `a` 再也无法移动了。",
        "translate": ""
    },
    {
        "source": "The address of `a` changed to `b`'s stack slot, so `a` got moved even though we have previously pinned it!",
        "suggest": "`a` 的地址更改为 `b` 的栈插槽，因此即使我们先前已将其固定，`a` 还是被移动了!",
        "translate": ""
    },
    {
        "source": "We have violated the pinning API contract.",
        "suggest": "我们违反了固定 API 契约。",
        "translate": ""
    },
    {
        "source": "This should mean the pointee can never move again.",
        "suggest": "这应该意味着指向者永远不能再移动。",
        "translate": ""
    },
    {
        "source": "Now, if `x` was the only reference, we have a mutable reference to data that we pinned above, which we could use to move it as we have seen in the previous example.",
        "suggest": "现在，如果 `x` 是唯一的引用，则对上面固定的数据有一个变量引用，就像在上一个示例中看到的那样，我们可以使用它来移动它。",
        "translate": ""
    },
    {
        "source": "do something",
        "suggest": "做一点事",
        "translate": ""
    },
    {
        "source": "consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.",
        "suggest": "消耗 `self`，因此通过 `as_mut` 重新借用 `Pin<&mut Self>`。",
        "translate": ""
    },
    {
        "source": "Types that pin data to its location in memory.",
        "suggest": "键入将数据固定到其在内存中的位置的类型。",
        "translate": ""
    },
    {
        "source": "It is sometimes useful to have objects that are guaranteed not to move, in the sense that their placement in memory does not change, and can thus be relied upon.",
        "suggest": "从对象在内存中的位置不变的意义上讲，保证对象不移动有时很有用。",
        "translate": ""
    },
    {
        "source": "A prime example of such a scenario would be building self-referential structs, as moving an object with pointers to itself will invalidate them, which could cause undefined behavior.",
        "suggest": "这种情况的一个主要示例是构建自引用结构体，因为移动带有指向自身的指针的对象会使它们无效，这可能导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "At a high level, a [`Pin<P>`] ensures that the pointee of any pointer type `P` has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped.",
        "suggest": "在较高的层次上，[`Pin<P>`] 确保任何指针类型 `P` 的指针都在内存中具有稳定的位置，这意味着它不能被移动到其他地方，并且在丢弃之前不能释放其内存。",
        "translate": ""
    },
    {
        "source": "We say that the pointee is \"pinned\".",
        "suggest": "我们说该对象是 \"pinned\"。",
        "translate": ""
    },
    {
        "source": "Things get more subtle when discussing types that combine pinned with non-pinned data;",
        "suggest": "当讨论将固定数据与非固定数据结合在一起的类型时，事情变得更加微妙。",
        "translate": ""
    },
    {
        "source": "[see below](#projections-and-structural-pinning) for more details.",
        "suggest": "[查看下文](#projections-and-structural-pinning) 了解更多详细信息。",
        "translate": ""
    },
    {
        "source": "By default, all types in Rust are movable.",
        "suggest": "默认情况下，Rust 中的所有类型都是可移动的。",
        "translate": ""
    },
    {
        "source": "Rust allows passing all types by-value, and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and moving the values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`].",
        "suggest": "Rust 允许按值传递所有类型，而普通的智能指针类型 (如 [`Box<T>`] 和 `&mut T`) 允许替换和移动它们包含的值: 可以移出 [`Box<T>`]，也可以使用 [`mem::swap`]。",
        "translate": ""
    },
    {
        "source": "wraps a pointer type `P`, so [`Pin`]`<`[`Box`]`<T>>` functions much like a regular",
        "suggest": "包装了一个指针类型 `P`，因此 [`Pin`]`<`[`Box`]`<T>>` 函数非常类似于常规",
        "translate": ""
    },
    {
        "source": "when a [`Pin`]`<`[`Box`]`<T>>` gets dropped, so do its contents, and the memory gets",
        "suggest": "当 [`Pin`]`<`[`Box`]`<T>>` 被丢弃时，它的内容也被丢弃，并且内存被丢弃",
        "translate": ""
    },
    {
        "source": "deallocated. Similarly, [`Pin`]`<&mut T>` is a lot like `&mut T`.",
        "suggest": "释放。同样，[`Pin`]`<&mut T>` 与 `&mut T` 非常相似。",
        "translate": ""
    },
    {
        "source": "However, [`Pin<P>`] does not let clients actually obtain a [`Box<T>`] or `&mut T` to pinned data, which implies that you cannot use operations such as [`mem::swap`]:",
        "suggest": "但是，[`Pin<P>`] 不允许客户端实际获得 [`Box<T>`] 或 `&mut T` 来固定数据，这意味着您不能使用 [`mem::swap`] 之类的操作:",
        "translate": ""
    },
    {
        "source": "It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler considers all types movable.",
        "suggest": "值得重申的是，[`Pin<P>`] 并不会改变 Rust 编译器认为所有类型都是可移动的这一事实。",
        "translate": ""
    },
    {
        "source": "[`mem::swap`] remains callable for any `T`.",
        "suggest": "[`mem::swap`] 仍可用于任何 `T`。",
        "translate": ""
    },
    {
        "source": "Instead, [`Pin<P>`] prevents certain *values* (pointed to by pointers wrapped in [`Pin<P>`]) from being moved by making it impossible to call methods that require `&mut T` on them (like [`mem::swap`]).",
        "suggest": "相反，[`Pin<P>`] 通过使无法调用需要 `&mut T` 的方法 (例如 [`mem::swap`]) 来防止某些 *值*(由包装在 [`Pin<P>`] 中的指针指向) 移动。",
        "translate": ""
    },
    {
        "source": "can be used to wrap any pointer type `P`, and as such it interacts with [`Deref`] and [`DerefMut`].",
        "suggest": "可用于包装任何指针类型 `P`，并因此与 [`Deref`] 和 [`DerefMut`] 交互。",
        "translate": ""
    },
    {
        "source": "A [`Pin<P>`] where `P: Deref` should be considered as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a [`Pin`]`<`[`Box`]`<T>>` is an owned pointer to a pinned `T`, and a [`Pin`]`<`[`Rc`]`<T>>` is a reference-counted pointer to a pinned `T`.",
        "suggest": "[`Pin<P>`]，其中 `P: Deref` 应该被视为固定 `P::Target` 的 \"`P`-style pointer\" - 因此，[`Pin`]`<`[`Box`]`<T>>` 是指向固定 `T` 的拥有所有权的指针，而 [`Pin`]`<`[`Rc`]`<T>>` 是指向固定 `T` 的引用计数指针。",
        "translate": ""
    },
    {
        "source": "For correctness, [`Pin<P>`] relies on the implementations of [`Deref`] and [`DerefMut`] not to move out of their `self` parameter, and only ever to return a pointer to pinned data when they are called on a pinned pointer.",
        "suggest": "为了正确起见，[`Pin<P>`] 依赖 [`Deref`] 和 [`DerefMut`] 的实现不移出其 `self` 参数，并且仅当在固定指针上调用它们时才返回指向固定数据的指针。",
        "translate": ""
    },
    {
        "source": "Many types are always freely movable, even when pinned, because they do not rely on having a stable address.",
        "suggest": "即使不固定，许多类型也始终可以自由移动，因为它们不依赖于具有稳定的地址。",
        "translate": ""
    },
    {
        "source": "This includes all the basic types (like [`bool`], [`i32`], and references) as well as types consisting solely of these types.",
        "suggest": "这包括所有基本类型 (如 [`bool`]，[`i32`] 和引用) 以及仅由这些类型组成的类型。",
        "translate": ""
    },
    {
        "source": "Types that do not care about pinning implement the [`Unpin`] auto-trait, which cancels the effect of [`Pin<P>`].",
        "suggest": "不需要固定的类型将实现 [`Unpin`] auto-trait，从而取消 [`Pin<P>`] 的作用。",
        "translate": ""
    },
    {
        "source": "For `T: Unpin`, [`Pin`]`<`[`Box`]`<T>>` and [`Box<T>`] function identically, as do [`Pin`]`<&mut T>` and `&mut T`.",
        "suggest": "对于 `T: Unpin`，[`Pin`]`<`[`Box`]`<T>>` 和 [`Box<T>`] 函数，以及 [`Pin`]`<&mut T>` 和 `&mut T` 都相同。",
        "translate": ""
    },
    {
        "source": "Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer type `P` itself that got wrapped in [`Pin<P>`].",
        "suggest": "请注意，固定和 [`Unpin`] 仅影响指向类型 `P::Target`，而不影响包装在 [`Pin<P>`] 中的指针类型 `P` 本身。",
        "translate": ""
    },
    {
        "source": "For example, whether or not [`Box<T>`] is [`Unpin`] has no effect on the behavior of [`Pin`]`<`[`Box`]`<T>>` (here, `T` is the pointed-to type).",
        "suggest": "例如，[`Box<T>`] 是否为 [`Unpin`] 对 [`Pin`]`<`[`Box`]`<T>>` 的行为没有影响 (此处 `T` 是指向类型)。",
        "translate": ""
    },
    {
        "source": "Example: self-referential struct",
        "suggest": "示例: 自我参照结构体",
        "translate": ""
    },
    {
        "source": "Before we go into more details to explain the guarantees and choices associated with `Pin<T>`, we discuss some examples for how it might be used.",
        "suggest": "在我们进一步解释 `Pin<T>` 相关的保证和选择之前，我们先讨论一些如何使用 `Pin<T>` 的示例。",
        "translate": ""
    },
    {
        "source": "Feel free to [skip to where the theoretical discussion continues](#drop-guarantee).",
        "suggest": "随时使用 [skip to where the theoretical discussion continues](#drop-guarantee)。",
        "translate": ""
    },
    {
        "source": "Example: intrusive doubly-linked list",
        "suggest": "示例: 侵入式双链表",
        "translate": ""
    },
    {
        "source": "In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself.",
        "suggest": "在侵入式双向链表中，集合实际上并未为元素本身分配内存。",
        "translate": ""
    },
    {
        "source": "Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.",
        "suggest": "分配由客户端控制，元素可以驻留在比集合短的栈框架上。",
        "translate": ""
    },
    {
        "source": "To make this work, every element has pointers to its predecessor and successor in the list.",
        "suggest": "为了使此工作有效，列表中的每个元素都有指向其前任和后任的指针。",
        "translate": ""
    },
    {
        "source": "Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers.",
        "suggest": "元素只能在固定时添加，因为四处移动元素会使指针无效。",
        "translate": ""
    },
    {
        "source": "Moreover, the [`Drop`] implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.",
        "suggest": "而且，链表元素的 [`Drop`] 实现将修补其前任和后继的指针，以将其从列表中删除。",
        "translate": ""
    },
    {
        "source": "Crucially, we have to be able to rely on [`drop`] being called.",
        "suggest": "至关重要的是，我们必须能够依靠被调用的 [`drop`]。",
        "translate": ""
    },
    {
        "source": "If an element could be deallocated or otherwise invalidated without calling [`drop`], the pointers into it from its neighboring elements would become invalid, which would break the data structure.",
        "suggest": "如果在不调用 [`drop`] 的情况下可以释放元素或使元素无效，则来自其相邻元素的指针将变为无效，这将破坏数据结构体。",
        "translate": ""
    },
    {
        "source": "Therefore, pinning also comes with a [`drop`]-related guarantee.",
        "suggest": "因此，固定还会附带 [drop] 相关的保证。",
        "translate": ""
    },
    {
        "source": "The purpose of pinning is to be able to rely on the placement of some data in memory.",
        "suggest": "固定的目的是能够依靠某些数据在内存中的放置。",
        "translate": ""
    },
    {
        "source": "To make this work, not just moving the data is restricted;",
        "suggest": "为了使这项工作有效，不仅限制了移动数据，还限制了数据的传输。",
        "translate": ""
    },
    {
        "source": "deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too.",
        "suggest": "限制用于存储数据的内存的重新分配，重新分配用途或以其他方式使之无效。",
        "translate": ""
    },
    {
        "source": "Concretely, for pinned data you have to maintain the invariant that *its memory will not get invalidated or repurposed from the moment it gets pinned until when [`drop`] is called*.",
        "suggest": "具体来说，对于固定的数据，必须保持不变，即从固定 *its memory 到调用 [`drop`]*，*its memory 都不会失效或重新使用。",
        "translate": ""
    },
    {
        "source": "Only once [`drop`] returns or panics, the memory may be reused.",
        "suggest": "只有 [`drop`] 返回或 panics，才可以重用该内存。",
        "translate": ""
    },
    {
        "source": "Memory can be \"invalidated\" by deallocation, but also by replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements off of a vector.",
        "suggest": "内存可以通过释放来成为 \"invalidated\"，也可以通过用 [`None`] 替换 [`Some(v)`] 或将 [`Vec::set_len`] 调用到 \"kill\" 来实现 vector 的某些元素。",
        "translate": ""
    },
    {
        "source": "It can be repurposed by using [`ptr::write`] to overwrite it without calling the destructor first.",
        "suggest": "可以通过使用 [`ptr::write`] 覆盖它来重新利用它，而无需先调用析构函数。",
        "translate": ""
    },
    {
        "source": "None of this is allowed for pinned data without calling [`drop`].",
        "suggest": "在不调用 [`drop`] 的情况下，不允许对固定数据进行任何此操作。",
        "translate": ""
    },
    {
        "source": "This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.",
        "suggest": "这正是上一节中的侵入式链表需要正确执行函数的一种保证。",
        "translate": ""
    },
    {
        "source": "Notice that this guarantee does *not* mean that memory does not leak!",
        "suggest": "请注意，此保证不 `*`* 表示内存不会泄漏!",
        "translate": ""
    },
    {
        "source": "It is still completely okay not ever to call [`drop`] on a pinned element (e.g., you can still call [`mem::forget`] on a [`Pin`]`<`[`Box`]`<T>>`).",
        "suggest": "永远不要在固定元素上调用 [`drop`] (例如，您仍然可以在 [`Pin`]`<`[`Box`]`<T>>` 上调用 [`mem::forget`])。",
        "translate": ""
    },
    {
        "source": "In the example of the doubly-linked list, that element would just stay in the list.",
        "suggest": "在双向链表的示例中，该元素将仅保留在列表中。",
        "translate": ""
    },
    {
        "source": "However you may not free or reuse the storage *without calling [`drop`]*.",
        "suggest": "但是，您可能无法释放或重新使用存储 *without calling [`drop`]*。",
        "translate": ""
    },
    {
        "source": "If your type uses pinning (such as the two examples above), you have to be careful when implementing [`Drop`].",
        "suggest": "如果您的类型使用固定 (例如上面的两个示例)，则在实现 [`Drop`] 时必须小心。",
        "translate": ""
    },
    {
        "source": "The [`drop`] function takes `&mut self`, but this is called *even if your type was previously pinned*!",
        "suggest": "[`drop`] 函数采用 `&mut self`，但是您以前键入此类型的名称为 *even if*!",
        "translate": ""
    },
    {
        "source": "It is as if the compiler automatically called [`Pin::get_unchecked_mut`].",
        "suggest": "好像编译器自动调用了 [`Pin::get_unchecked_mut`]。",
        "translate": ""
    },
    {
        "source": "This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on [`Pin`]`<&Self>` or [`Pin`]`<&mut Self>`) has consequences for your [`Drop`] implementation as well: if an element of your type could have been pinned, you must treat [`Drop`] as implicitly taking [`Pin`]`<&mut Self>`.",
        "suggest": "这永远不会在安全代码中引起问题，因为实现依赖于固定的类型需要不安全的代码，但是请注意，决定在您的类型中使用固定 (例如，通过在 [`Pin`]`<&Self>` 或 [`Pin`]`<&mut Self>` 上执行某些操作) 会对您造成影响以及 [`Drop`] 的实现: 如果可以固定您类型的元素，则必须将 [`Drop`] 视为隐式地采用 [`Pin`]`<&mut Self>`。",
        "translate": ""
    },
    {
        "source": "For example, you could implement `Drop` as follows:",
        "suggest": "例如，您可以按以下方式实现 `Drop`:",
        "translate": ""
    },
    {
        "source": "The function `inner_drop` has the type that [`drop`] *should* have, so this makes sure that you do not accidentally use `self`/`this` in a way that is in conflict with pinning.",
        "suggest": "函数 `inner_drop` 具有 *应该* 具有 [`drop`] 的类型，因此可以确保您不会以与固定冲突的方式意外使用 `self`/`this`。",
        "translate": ""
    },
    {
        "source": "Moreover, if your type is `#[repr(packed)]`, the compiler will automatically move fields around to be able to drop them.",
        "suggest": "此外，如果您的类型是 `#[repr(packed)]`，则编译器将自动移动字段以将其删除。",
        "translate": ""
    },
    {
        "source": "It might even do that for fields that happen to be sufficiently aligned.",
        "suggest": "它甚至可以对恰好足够对齐的字段执行此操作。",
        "translate": ""
    },
    {
        "source": "As a consequence, you cannot use pinning with a `#[repr(packed)]` type.",
        "suggest": "因此，您不能使用 `#[repr(packed)]` 类型的固定。",
        "translate": ""
    },
    {
        "source": "Projections and Structural Pinning",
        "suggest": "投影和结构固定",
        "translate": ""
    },
    {
        "source": "When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just [`Pin`]`<&mut Struct>`.",
        "suggest": "当使用固定的结构体时，就会出现一个问题，即如何以仅需 [`Pin`]`<&mut Struct>` 的方法访问该结构体的字段。",
        "translate": ""
    },
    {
        "source": "The usual approach is to write helper methods (so called *projections*) that turn [`Pin`]`<&mut Struct>` into a reference to the field, but what type should that reference have?",
        "suggest": "通常的方法是编写将 [`Pin`]`<&mut Struct>` 转换为对该字段的引用的辅助方法 (所谓的 *projection*)，但是该引用应具有哪种类型?",
        "translate": ""
    },
    {
        "source": "Is it [`Pin`]`<&mut Field>` or `&mut Field`?",
        "suggest": "是 [`Pin`]`<&mut Field>` 还是 `&mut Field`?",
        "translate": ""
    },
    {
        "source": "The same question arises with the fields of an `enum`, and also when considering container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].",
        "suggest": "对于 `enum` 的字段，以及在考虑 container/wrapper 类型 (例如 [`Vec<T>`]，[`Box<T>`] 或 [`RefCell<T>`]) 时，也会出现相同的问题。",
        "translate": ""
    },
    {
        "source": "(This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)",
        "suggest": "(此问题适用于可变引用和共享引用，我们仅在此处使用可变引用的更常见情况进行说明。)",
        "translate": ""
    },
    {
        "source": "It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns [`Pin`]`<&mut Struct>` into [`Pin`]`<&mut Field>` or `&mut Field`.",
        "suggest": "事实证明，实际上由数据结构体的作者决定针对特定字段的固定投影是将 [`Pin`]`<&mut Struct>` 转换为 [`Pin`]`<&mut Field>` 还是 `&mut Field`。",
        "translate": ""
    },
    {
        "source": "There are some constraints though, and the most important constraint is *consistency*:",
        "suggest": "但是有一些约束，最重要的约束是 *consistency*:",
        "translate": ""
    },
    {
        "source": "every field can be *either* projected to a pinned reference, *or* have pinning removed as part of the projection.",
        "suggest": "每个字段都可以 *或者* 投影到固定的引用，或者 * 可以删除固定作为投影的一部分。",
        "translate": ""
    },
    {
        "source": "If both are done for the same field, that will likely be unsound!",
        "suggest": "如果两者都在同一个领域完成，那将是不正确的!",
        "translate": ""
    },
    {
        "source": "As the author of a data structure you get to decide for each field whether pinning \"propagates\" to this field or not.",
        "suggest": "作为数据结构体的作者，您可以为每个字段决定是否将 \"propagates\" 固定到该字段。",
        "translate": ""
    },
    {
        "source": "Pinning that propagates is also called \"structural\", because it follows the structure of the type.",
        "suggest": "传播的固定也称为 \"structural\"，因为它遵循该类型的结构体。",
        "translate": ""
    },
    {
        "source": "In the following subsections, we describe the considerations that have to be made for either choice.",
        "suggest": "在以下各小节中，我们描述了两种选择都必须考虑的因素。",
        "translate": ""
    },
    {
        "source": "Pinning *is not* structural for `field`",
        "suggest": "Pinning 不是用于结构体的 `field`",
        "translate": ""
    },
    {
        "source": "It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a [`Pin`]`<&mut Field>` is never created, nothing can go wrong!",
        "suggest": "固定的结构体的字段可能没有固定，这似乎是违反直觉的，但这实际上是最简单的选择: 如果从不创建 [`Pin`]`<&mut Field>`，则不会出错!",
        "translate": ""
    },
    {
        "source": "So, if you decide that some field does not have structural pinning, all you have to ensure is that you never create a pinned reference to that field.",
        "suggest": "因此，如果您确定某个字段不具有结构固定，则只需确保您从未创建对该字段的固定引用即可。",
        "translate": ""
    },
    {
        "source": "Fields without structural pinning may have a projection method that turns [`Pin`]`<&mut Struct>` into `&mut Field`:",
        "suggest": "没有结构固定的字段可能具有将 [`Pin`]`<&mut Struct>` 转换为 `&mut Field` 的投影方法:",
        "translate": ""
    },
    {
        "source": "You may also `impl Unpin for Struct` *even if* the type of `field` is not [`Unpin`].",
        "suggest": "您也可以 `impl Unpin for Struct`，即使 `field` 的类型不是 [`Unpin`]。",
        "translate": ""
    },
    {
        "source": "What that type thinks about pinning is not relevant when no [`Pin`]`<&mut Field>` is ever created.",
        "suggest": "当没有创建 [`Pin`]`<&mut Field>` 时，该类型有关固定的想法无关紧要。",
        "translate": ""
    },
    {
        "source": "Pinning *is* structural for `field`",
        "suggest": "Pinning 是结构体的 `field`",
        "translate": ""
    },
    {
        "source": "The other option is to decide that pinning is \"structural\" for `field`, meaning that if the struct is pinned then so is the field.",
        "suggest": "另一个选择是确定钉扎是 `field` 还是 `field`，这意味着如果钉扎结构体，则字段也钉扎。",
        "translate": ""
    },
    {
        "source": "This allows writing a projection that creates a [`Pin`]`<&mut Field>`, thus witnessing that the field is pinned:",
        "suggest": "这允许编写一个创建 [`Pin`]`<&mut Field>` 的投影，从而见证该字段已固定:",
        "translate": ""
    },
    {
        "source": "However, structural pinning comes with a few extra requirements:",
        "suggest": "但是，结构固定需要一些额外的要求:",
        "translate": ""
    },
    {
        "source": "The struct must only be [`Unpin`] if all the structural fields are [`Unpin`].",
        "suggest": "如果所有结构字段均为 [`Unpin`]，则结构体必须仅为 [`Unpin`]。",
        "translate": ""
    },
    {
        "source": "This is the default, but [`Unpin`] is a safe trait, so as the author of the struct it is your responsibility *not* to add something like `impl<T> Unpin for Struct<T>`.",
        "suggest": "这是默认设置，但 [`Unpin`] 是安全的 trait，因此，作为结构体的作者，您不负责 * 添加 `impl<T> Unpin for Struct<T>` 之类的内容。",
        "translate": ""
    },
    {
        "source": "(Notice that adding a projection operation requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break the principle that you only have to worry about any of this if you use `unsafe`.)",
        "suggest": "(请注意，添加投影操作需要不安全的代码，因此 [`Unpin`] 是安全的 trait 的事实并没有违反以下原则: 仅当使用 `unsafe` 时，您才需要担心其中的任何一个。)",
        "translate": ""
    },
    {
        "source": "The destructor of the struct must not move structural fields out of its argument.",
        "suggest": "结构体的析构函数不得将结构域移出其参数。",
        "translate": ""
    },
    {
        "source": "This is the exact point that was raised in the [previous section][drop-impl]: `drop` takes `&mut self`, but the struct (and hence its fields) might have been pinned before.",
        "suggest": "这是 [上一节][drop-impl] 中提出的确切点: `drop` 使用 `&mut self`，但是结构体 (及其字段) 可能之前已被固定。",
        "translate": ""
    },
    {
        "source": "You have to guarantee that you do not move a field inside your [`Drop`] implementation.",
        "suggest": "您必须保证不要在 [`Drop`] 实现中移动字段。",
        "translate": ""
    },
    {
        "source": "In particular, as explained previously, this means that your struct must *not* be `#[repr(packed)]`.",
        "suggest": "特别是，如前所述，这意味着您的结构体 *不能* 为 `#[repr(packed)]`。",
        "translate": ""
    },
    {
        "source": "See that section for how to write [`drop`] in a way that the compiler can help you not accidentally break pinning.",
        "suggest": "有关如何编写 [`drop`] 的方法，请参见该部分，以使编译器可以帮助您避免意外破坏固定。",
        "translate": ""
    },
    {
        "source": "You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:",
        "suggest": "您必须确保坚持使用 [`Drop` 保证][drop-guarantee]:",
        "translate": ""
    },
    {
        "source": "once your struct is pinned, the memory that contains the content is not overwritten or deallocated without calling the content's destructors.",
        "suggest": "一旦固定了您的结构体，包含内容的内存就不会被覆盖或释放，而无需调用内容的析构函数。",
        "translate": ""
    },
    {
        "source": "This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of [`VecDeque<T>`] can fail to call [`drop`] on all elements if one of the destructors panics.",
        "suggest": "如 [`VecDeque<T>`] 所示，这可能很棘手: 如果析构函数 panics 之一，则 [`VecDeque<T>`] 的析构函数可能无法在所有元素上调用 [`drop`]。",
        "translate": ""
    },
    {
        "source": "This violates the [`Drop`] guarantee, because it can lead to elements being deallocated without their destructor being called.",
        "suggest": "这违反了 [`Drop`] 保证，因为它可能导致元素被释放而没有调用其析构函数。",
        "translate": ""
    },
    {
        "source": "([`VecDeque<T>`] has no pinning projections, so this does not cause unsoundness.)",
        "suggest": "([`VecDeque<T>`] 没有固定突起，因此不会引起不稳健。)",
        "translate": ""
    },
    {
        "source": "You must not offer any other operations that could lead to data being moved out of the structural fields when your type is pinned.",
        "suggest": "固定类型时，不得提供可能导致数据移出结构字段的任何其他操作。",
        "translate": ""
    },
    {
        "source": "For example, if the struct contains an [`Option<T>`] and there is a `take`-like operation with type `fn(Pin<&mut Struct<T>>) -> Option<T>`, that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means pinning cannot be structural for the field holding this data.",
        "suggest": "例如，如果结构体包含 [`Option<T>`]，并且具有类似 `fn(Pin<&mut Struct<T>>) -> Option<T>` 的 `take` 操作，则该操作可用于将 `T` 从固定的 `Struct<T>` 中移出 - 这意味着固定对于场保持而言不可能是结构性的这个数据。",
        "translate": ""
    },
    {
        "source": "For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`] had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.",
        "suggest": "对于将数据移出固定类型的更复杂的示例，请想象 [`RefCell<T>`] 是否具有方法 `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`。",
        "translate": ""
    },
    {
        "source": "Then we could do the following:",
        "suggest": "然后，我们可以执行以下操作:",
        "translate": ""
    },
    {
        "source": "This is catastrophic, it means we can first pin the content of the [`RefCell<T>`] (using `RefCell::get_pin_mut`) and then move that content using the mutable reference we got later.",
        "suggest": "这是灾难性的，这意味着我们可以先固定 [`RefCell<T>`] 的内容 (使用 `RefCell::get_pin_mut`)，然后使用稍后获得的可变引用将其移动。",
        "translate": ""
    },
    {
        "source": "For a type like [`Vec<T>`], both possibilities (structural pinning or not) make sense.",
        "suggest": "对于 [`Vec<T>`] 这样的类型，两种可能性 (无论是否为结构固定) 都是有意义的。",
        "translate": ""
    },
    {
        "source": "A [`Vec<T>`] with structural pinning could have `get_pin`/`get_pin_mut` methods to get pinned references to elements.",
        "suggest": "具有结构固定的 [`Vec<T>`] 可能具有 `get_pin`/`get_pin_mut` 方法来固定引用元素。",
        "translate": ""
    },
    {
        "source": "However, it could *not* allow calling [`pop`][Vec::pop] on a pinned [`Vec<T>`] because that would move the (structurally pinned) contents!",
        "suggest": "但是，它可能 *不允许* 在固定的 [`Vec<T>`] 上调用 [`pop`][Vec::pop]，因为那样会移动 (结构上固定的) 内容!",
        "translate": ""
    },
    {
        "source": "Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the contents.",
        "suggest": "它也不允许 [`push`][Vec::push]，它可能会重新分配并因此也移动内容。",
        "translate": ""
    },
    {
        "source": "A [`Vec<T>`] without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents are never pinned and the [`Vec<T>`] itself is fine with being moved as well.",
        "suggest": "没有结构固定的 [`Vec<T>`] 可能是 `impl<T> Unpin for Vec<T>`，因为内容永远不会固定，并且 [`Vec<T>`] 本身也可以移动。",
        "translate": ""
    },
    {
        "source": "At that point pinning just has no effect on the vector at all.",
        "suggest": "那时，固定对 vector 完全没有影响。",
        "translate": ""
    },
    {
        "source": "In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections.",
        "suggest": "在标准库中，指针类型通常不具有结构固定，因此它们不提供固定投影。",
        "translate": ""
    },
    {
        "source": "This is why `Box<T>: Unpin` holds for all `T`.",
        "suggest": "这就是 `Box<T>: Unpin` 适用于所有 `T` 的原因。",
        "translate": ""
    },
    {
        "source": "It makes sense to do this for pointer types, because moving the `Box<T>` does not actually move the `T`: the [`Box<T>`] can be freely movable (aka `Unpin`) even if the `T` is not.",
        "suggest": "对于指针类型，这样做是有意义的，因为移动 `Box<T>` 实际上不会移动 `T`: 即使 `T` 不能移动，[`Box<T>`] 也可以自由移动 (也称为 `Unpin`)。",
        "translate": ""
    },
    {
        "source": "In fact, even [`Pin`]`<`[`Box`]`<T>>` and [`Pin`]`<&mut T>` are always [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the pointers themselves can be moved without moving the pinned data.",
        "suggest": "实际上，出于相同的原因，即使 [`Pin`]`<`[`Box`]`<T>>` 和 [`Pin`]`<&mut T>` 本身也始终是 [`Unpin`]: 它们的内容 (`T`) 是固定的，但是指针本身可以移动而无需移动固定的数据。",
        "translate": ""
    },
    {
        "source": "For both [`Box<T>`] and [`Pin`]`<`[`Box`]`<T>>`, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is *not* structural.",
        "suggest": "对于 [`Box<T>`] 和 [`Pin`]`<`[`Box`]`<T>>`，内容是否固定都是完全独立于指针是否固定的，这意味着固定是 *非* 结构性的。",
        "translate": ""
    },
    {
        "source": "When implementing a [`Future`] combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call [`poll`].",
        "suggest": "当实现 [`Future`] 组合器时，通常需要对嵌套的 futures 进行结构钉扎，因为您需要将引用的钉扎到 [`poll`] 上。",
        "translate": ""
    },
    {
        "source": "But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have [`Pin`]`<&mut Self>` (such as in your own [`poll`] implementation).",
        "suggest": "但是，如果您的组合器包含不需要固定的任何其他数据，则可以使那些字段不具有结构性，因此即使您只有 [`Pin`]`<&mut Self>` (例如在您自己的 [`poll`] 实现中)，也可以使用可变引用自由地访问它们。",
        "translate": ""
    },
    {
        "source": "A pinned pointer.",
        "suggest": "固定的指针。",
        "translate": ""
    },
    {
        "source": "This is a wrapper around a kind of pointer which makes that pointer \"pin\" its value in place, preventing the value referenced by that pointer from being moved unless it implements [`Unpin`].",
        "suggest": "这是一种指针的包装，该指针使该指针 \"pin\" 成为其值，从而防止该指针引用的值被移动，除非它实现 [`Unpin`]。",
        "translate": ""
    },
    {
        "source": "See the [`pin` module] documentation for an explanation of pinning.",
        "suggest": "有关固定的说明，请参见 [`pin` module] 文档。",
        "translate": ""
    },
    {
        "source": "the `Clone` derive below causes unsoundness as it's possible to implement `Clone` for mutable references.",
        "suggest": "下面的 `Clone` 派生导致不完善，因为可以为可变引用实现 `Clone`。",
        "translate": ""
    },
    {
        "source": "See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311> for more details.",
        "suggest": "有关更多详细信息，请参见 <https://internals.rust-lang.org/t/unsoundness-in-pin/11311>。",
        "translate": ""
    },
    {
        "source": "The following implementations aren't derived in order to avoid soundness issues.",
        "suggest": "为了避免出现健全性问题，没有实现以下实现。",
        "translate": ""
    },
    {
        "source": "should not be accessible to untrusted trait implementations.",
        "suggest": "不受信任的 trait 实现不应访问。",
        "translate": ""
    },
    {
        "source": "See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311/73> for more details.",
        "suggest": "有关更多详细信息，请参见 <https://internals.rust-lang.org/t/unsoundness-in-pin/11311/73>。",
        "translate": ""
    },
    {
        "source": "Construct a new `Pin<P>` around a pointer to some data of a type that implements [`Unpin`].",
        "suggest": "围绕一个指向实现 [`Unpin`] 类型的数据的指针，创建一个新的 `Pin<P>`。",
        "translate": ""
    },
    {
        "source": "Unlike `Pin::new_unchecked`, this method is safe because the pointer `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.",
        "suggest": "与 `Pin::new_unchecked` 不同，此方法是安全的，因为指针 `P` 解引用了 [`Unpin`] 类型，从而取消了固定保证。",
        "translate": ""
    },
    {
        "source": "the value pointed to is `Unpin`, and so has no requirements around pinning.",
        "suggest": "指向的值是 `Unpin`，因此对固定没有要求。",
        "translate": ""
    },
    {
        "source": "Unwraps this `Pin<P>` returning the underlying pointer.",
        "suggest": "解包此 `Pin<P>`，返回基础指针。",
        "translate": ""
    },
    {
        "source": "This requires that the data inside this `Pin` is [`Unpin`] so that we can ignore the pinning invariants when unwrapping it.",
        "suggest": "这要求该 `Pin` 内部的数据为 [`Unpin`]，以便我们在展开包装时可以忽略固定不变式。",
        "translate": ""
    },
    {
        "source": "Construct a new `Pin<P>` around a reference to some data of a type that may or may not implement `Unpin`.",
        "suggest": "围绕引用可能会或可能不会实现 `Unpin` 的某些数据，创建一个新的 `Pin<P>`。",
        "translate": ""
    },
    {
        "source": "If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used instead.",
        "suggest": "如果 `pointer` 解引用 `Unpin` 类型，则应改用 `Pin::new`。",
        "translate": ""
    },
    {
        "source": "This constructor is unsafe because we cannot guarantee that the data pointed to by `pointer` is pinned, meaning that the data will not be moved or its storage invalidated until it gets dropped.",
        "suggest": "此构造函数是不安全的，因为我们不能保证 `pointer` 指向的数据是固定的，这意味着在丢弃数据之前，数据将不会移动或存储空间无效。",
        "translate": ""
    },
    {
        "source": "If the constructed `Pin<P>` does not guarantee that the data `P` points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.",
        "suggest": "如果构造的 `Pin<P>` 不能保证数据 `P` 指向固定的，则违反了 API 约定，并可能在以后的 (safe) 操作中导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "By using this method, you are making a promise about the `P::Deref` and `P::DerefMut` implementations, if they exist.",
        "suggest": "通过使用此方法，您正在制作有关 `P::Deref` 和 `P::DerefMut` 实现的 promise (如果存在)。",
        "translate": ""
    },
    {
        "source": "Most importantly, they must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref` will call `DerefMut::deref_mut` and `Deref::deref` *on the pinned pointer* and expect these methods to uphold the pinning invariants.",
        "suggest": "最重要的是，它们一定不能移出 `self` 参数: `Pin::as_mut` 和 `Pin::as_ref` 将调用 `DerefMut::deref_mut` 和 `Deref::deref`*on the 固定指针*，并期望这些方法支持固定不变性。",
        "translate": ""
    },
    {
        "source": "Moreover, by calling this method you promise that the reference `P` dereferences to will not be moved out of again;",
        "suggest": "此外，通过调用此方法，不会再移出引用 `P` 引用的 promise;",
        "translate": ""
    },
    {
        "source": "in particular, it must not be possible to obtain a `&mut P::Target` and then move out of that reference (using, for example [`mem::swap`]).",
        "suggest": "特别是，必须不可能先获得 `&mut P::Target`，然后再移出该引用 (例如，使用 [`mem::swap`])。",
        "translate": ""
    },
    {
        "source": "For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because while you are able to pin it for the given lifetime `'a`, you have no control over whether it is kept pinned once `'a` ends:",
        "suggest": "例如，在 `&'a mut T` 上调用 `Pin::new_unchecked` 是不安全的，因为虽然可以为给定的生命周期 `'a` 固定 `Pin::new_unchecked`，但是您无法控制 `'a` 结束后是否保持固定状态:",
        "translate": ""
    },
    {
        "source": "A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).",
        "suggest": "固定后的值必须永远固定 (除非其类型实现 `Unpin`)。",
        "translate": ""
    },
    {
        "source": "Similarly, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be aliases to the same data that are not subject to the pinning restrictions:",
        "suggest": "同样，在 `Rc<T>` 上调用 `Pin::new_unchecked` 是不安全的，因为相同数据的别名可能不受固定限制的限制:",
        "translate": ""
    },
    {
        "source": "Gets a pinned shared reference from this pinned pointer.",
        "suggest": "从此固定指针获取固定共享引用。",
        "translate": ""
    },
    {
        "source": "This is a generic method to go from `&Pin<Pointer<T>>` to `Pin<&T>`.",
        "suggest": "这是从 `&Pin<Pointer<T>>` 到 `Pin<&T>` 的通用方法。",
        "translate": ""
    },
    {
        "source": "It is safe because, as part of the contract of `Pin::new_unchecked`, the pointee cannot move after `Pin<Pointer<T>>` got created.",
        "suggest": "这是安全的，因为作为 `Pin::new_unchecked` 契约的一部分，在创建 `Pin<Pointer<T>>` 之后，指针无法移动。",
        "translate": ""
    },
    {
        "source": "implementations of `Pointer::Deref` are likewise ruled out by the contract of `Pin::new_unchecked`.",
        "suggest": "`Pointer::Deref` 的实现同样被 `Pin::new_unchecked` 的契约所排除。",
        "translate": ""
    },
    {
        "source": "see documentation on this function",
        "suggest": "请参见此函数的文档",
        "translate": ""
    },
    {
        "source": "This function is unsafe.",
        "suggest": "该函数是不安全的。",
        "translate": ""
    },
    {
        "source": "You must guarantee that you will continue to treat the pointer `P` as pinned after you call this function, so that the invariants on the `Pin` type can be upheld.",
        "suggest": "您必须保证在调用此函数后，将继续将指针 `P` 视为固定指针，以便可以保留 `Pin` 类型上的不可变变量。",
        "translate": ""
    },
    {
        "source": "If the code using the resulting `P` does not continue to maintain the pinning invariants that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.",
        "suggest": "如果使用生成的 `P` 的代码不能继续维护违反 API 约定的固定不变式，则可能会在以后的 (safe) 操作中导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used instead.",
        "suggest": "如果基础数据是 [`Unpin`]，则应改用 [`Pin::into_inner`]。",
        "translate": ""
    },
    {
        "source": "Gets a pinned mutable reference from this pinned pointer.",
        "suggest": "从此固定指针获取固定变量引用。",
        "translate": ""
    },
    {
        "source": "This is a generic method to go from `&mut Pin<Pointer<T>>` to `Pin<&mut T>`.",
        "suggest": "这是从 `&mut Pin<Pointer<T>>` 到 `Pin<&mut T>` 的通用方法。",
        "translate": ""
    },
    {
        "source": "implementations of `Pointer::DerefMut` are likewise ruled out by the contract of `Pin::new_unchecked`.",
        "suggest": "`Pointer::DerefMut` 的实现同样被 `Pin::new_unchecked` 的契约所排除。",
        "translate": ""
    },
    {
        "source": "This method is useful when doing multiple calls to functions that consume the pinned type.",
        "suggest": "当对使用固定类型的函数进行多次调用时，此方法很有用。",
        "translate": ""
    },
    {
        "source": "Assigns a new value to the memory behind the pinned reference.",
        "suggest": "为固定的引用后面的内存分配一个新值。",
        "translate": ""
    },
    {
        "source": "This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.",
        "suggest": "这会覆盖固定的数据，但是没关系: 它的析构函数在被覆盖之前就已运行，因此不会违反固定保证。",
        "translate": ""
    },
    {
        "source": "Constructs a new pin by mapping the interior value.",
        "suggest": "通过映射内部值创建一个新的引脚。",
        "translate": ""
    },
    {
        "source": "For example, if you  wanted to get a `Pin` of a field of something, you could use this to get access to that field in one line of code.",
        "suggest": "例如，如果要获取某字段的 `Pin`，则可以使用它在一行代码中访问该字段。",
        "translate": ""
    },
    {
        "source": "However, there are several gotchas with these \"pinning projections\";",
        "suggest": "但是，这些 \"pinning projections\" 有一些陷阱。",
        "translate": ""
    },
    {
        "source": "see the [`pin` module] documentation for further details on that topic.",
        "suggest": "有关该主题的更多详细信息，请参见 [`pin` module] 文档。",
        "translate": ""
    },
    {
        "source": "You must guarantee that the data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function.",
        "suggest": "您必须确保只要参数值不移动，返回的数据就不会移动 (例如，因为它是该值的字段之一)，并且还必须确保不会将其移出接收到的参数内部功能。",
        "translate": ""
    },
    {
        "source": "the safety contract for `new_unchecked` must be upheld by the caller.",
        "suggest": "调用者必须遵守 `new_unchecked` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Gets a shared reference out of a pin.",
        "suggest": "从大头针获取共享的引用。",
        "translate": ""
    },
    {
        "source": "This is safe because it is not possible to move out of a shared reference.",
        "suggest": "这是安全的，因为不可能移出共享引用。",
        "translate": ""
    },
    {
        "source": "It may seem like there is an issue here with interior mutability: in fact, it *is* possible to move a `T` out of a `&RefCell<T>`.",
        "suggest": "内部可变性似乎存在问题: 实际上，可以将 `T` 从 `&RefCell<T>` 中移出。",
        "translate": ""
    },
    {
        "source": "However, this is not a problem as long as there does not also exist a `Pin<&T>` pointing to the same data, and `RefCell<T>` does not let you create a pinned reference to its contents.",
        "suggest": "但是，只要不存在指向相同数据的 `Pin<&T>`，并且 `RefCell<T>` 不允许您创建对其内容的固定引用，这也不是问题。",
        "translate": ""
    },
    {
        "source": "See the discussion on [\"pinning projections\"] for further details.",
        "suggest": "有关更多详细信息，请参见 [\"pinning projections\"] 上的讨论。",
        "translate": ""
    },
    {
        "source": "`Pin` also implements `Deref` to the target, which can be used to access the inner value.",
        "suggest": "`Pin` 还对目标实现 `Deref`，可用于访问内部值。",
        "translate": ""
    },
    {
        "source": "However, `Deref` only provides a reference that lives for as long as the borrow of the `Pin`, not the lifetime of the `Pin` itself.",
        "suggest": "但是，`Deref` 仅提供一个引用，该引用的生命周期与 `Pin` 的借用时间一样长，而不是 `Pin` 本身的生命周期。",
        "translate": ""
    },
    {
        "source": "This method allows turning the `Pin` into a reference with the same lifetime as the original `Pin`.",
        "suggest": "这种方法可以将 `Pin` 转换为引用，并具有与原始 `Pin` 相同的生命周期。",
        "translate": ""
    },
    {
        "source": "Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.",
        "suggest": "将此 `Pin<&mut T>` 转换为具有相同生命周期的 `Pin<&T>`。",
        "translate": ""
    },
    {
        "source": "Gets a mutable reference to the data inside of this `Pin`.",
        "suggest": "获取对此 `Pin` 内部数据的可变引用。",
        "translate": ""
    },
    {
        "source": "This requires that the data inside this `Pin` is `Unpin`.",
        "suggest": "这要求该 `Pin` 内部的数据为 `Unpin`。",
        "translate": ""
    },
    {
        "source": "`Pin` also implements `DerefMut` to the data, which can be used to access the inner value.",
        "suggest": "`Pin` 还对数据实现 `DerefMut`，可用于访问内部值。",
        "translate": ""
    },
    {
        "source": "However, `DerefMut` only provides a reference that lives for as long as the borrow of the `Pin`, not the lifetime of the `Pin` itself.",
        "suggest": "但是，`DerefMut` 仅提供一个引用，该引用生命周期与 `Pin` 的借用时间一样长，而不是 `Pin` 本身的生命周期。",
        "translate": ""
    },
    {
        "source": "You must guarantee that you will never move the data out of the mutable reference you receive when you call this function, so that the invariants on the `Pin` type can be upheld.",
        "suggest": "您必须保证在调用此函数时，永远不会将数据移出收到的变量引用中，以便可以保留 `Pin` 类型的不可变变量。",
        "translate": ""
    },
    {
        "source": "If the underlying data is `Unpin`, `Pin::get_mut` should be used instead.",
        "suggest": "如果基础数据是 `Unpin`，则应改用 `Pin::get_mut`。",
        "translate": ""
    },
    {
        "source": "Construct a new pin by mapping the interior value.",
        "suggest": "通过映射内部值创建一个新的引脚。",
        "translate": ""
    },
    {
        "source": "the caller is responsible for not moving the value out of this reference.",
        "suggest": "调用方负责不将值移出该引用。",
        "translate": ""
    },
    {
        "source": "as the value of `this` is guaranteed to not have been moved out, this call to `new_unchecked` is safe.",
        "suggest": "由于保证 `this` 的值不会被移出，因此对 `new_unchecked` 的调用是安全的。",
        "translate": ""
    },
    {
        "source": "Get a pinned reference from a static reference.",
        "suggest": "从固定引用中获取固定引用。",
        "translate": ""
    },
    {
        "source": "This is safe, because `T` is borrowed for the `'static` lifetime, which never ends.",
        "suggest": "这是安全的，因为 `T` 是 `'static` 生命周期的借用，而生命周期永远不会结束。",
        "translate": ""
    },
    {
        "source": "The 'static borrow guarantees the data will not be moved/invalidated until it gets dropped (which is never).",
        "suggest": "静态借用保证数据在被丢弃之前不会被移动/失效 (永远不会)。",
        "translate": ""
    },
    {
        "source": "Get a pinned mutable reference from a static mutable reference.",
        "suggest": "从静态变量引用中获取固定的变量引用。",
        "translate": ""
    },
    {
        "source": "this means that any impl of `CoerceUnsized` that allows coercing from a type that impls `Deref<Target=impl !Unpin>` to a type that impls `Deref<Target=Unpin>` is unsound.",
        "suggest": "这意味着 `CoerceUnsized` 允许从 `Deref<Target=impl !Unpin>` 的类型强制转换为 `Deref<Target=Unpin>` 的类型的任何隐含声音都是不正确的。",
        "translate": ""
    },
    {
        "source": "Any such impl would probably be unsound for other reasons, though, so we just need to take care not to allow such impls to land in std.",
        "suggest": "但是，由于其他原因，任何这样的提示可能都不合理，因此我们只需要注意不要让这样的提示降落在 std 中。",
        "translate": ""
    },
    {
        "source": "The libcore prelude",
        "suggest": "libcore prelude",
        "translate": ""
    },
    {
        "source": "This module is intended for users of libcore which do not link to libstd as well.",
        "suggest": "该模块适用于 libcore 的用户，这些用户也未链接到 libstd。",
        "translate": ""
    },
    {
        "source": "This module is imported by default when `#![no_std]` is used in the same manner as the standard library's prelude.",
        "suggest": "当以与标准库的 prelude 相同的方式使用 `#![no_std]` 时，默认情况下将导入此模块。",
        "translate": ""
    },
    {
        "source": "The 2015 version of the core prelude.",
        "suggest": "2015 版本的核心 prelude。",
        "translate": ""
    },
    {
        "source": "The 2018 version of the core prelude.",
        "suggest": "2018 版本的核心 prelude。",
        "translate": ""
    },
    {
        "source": "The 2021 version of the core prelude.",
        "suggest": "2021 版本的核心 prelude。",
        "translate": ""
    },
    {
        "source": "Add more things.",
        "suggest": "添加更多东西。",
        "translate": ""
    },
    {
        "source": "The first version of the core prelude.",
        "suggest": "第一个版本的核心 prelude。",
        "translate": ""
    },
    {
        "source": "See the [module-level documentation](super) for more.",
        "suggest": "有关更多信息，请参见 [module-level documentation](super)。",
        "translate": ""
    },
    {
        "source": "Re-exported core operators",
        "suggest": "重导出核心运算符",
        "translate": ""
    },
    {
        "source": "Re-exported functions",
        "suggest": "重导出函数",
        "translate": ""
    },
    {
        "source": "Re-exported types and traits",
        "suggest": "重导出的类型和 traits",
        "translate": ""
    },
    {
        "source": "Re-exported built-in macros",
        "suggest": "重导出内置宏",
        "translate": ""
    },
    {
        "source": "This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.",
        "suggest": "此模块重导出基本类型，以允许其他声明的类型不可能掩盖的用法。",
        "translate": ""
    },
    {
        "source": "This is normally only useful in macro generated code.",
        "suggest": "通常，这仅在宏生成的代码中有用。",
        "translate": ""
    },
    {
        "source": "An example of this is when generating a new struct and an impl for it:",
        "suggest": "例如，当生成一个新的结构体和一个隐含的时候:",
        "translate": ""
    },
    {
        "source": "Note that the `SOME_PROPERTY` associated constant would not compile, as its type `bool` refers to the struct, rather than to the primitive bool type.",
        "suggest": "请注意，`SOME_PROPERTY` 关联的常量将无法编译，因为其类型 `bool` 指向结构体，而不是原始的 bool 类型。",
        "translate": ""
    },
    {
        "source": "A correct implementation could look like:",
        "suggest": "正确的实现可能如下所示:",
        "translate": ""
    },
    {
        "source": "Iterate using a raw pointer in increments of two elements",
        "suggest": "使用裸指针以两个元素为增量进行迭代",
        "translate": ""
    },
    {
        "source": "This loop prints \"1, 3, 5, \"",
        "suggest": "此循环打印 \"1, 3, 5, \"",
        "translate": ""
    },
    {
        "source": "Make ptr2_other an \"alias\" of ptr2, but derived from ptr1.",
        "suggest": "将 ptr2_other 设置为 ptr2 的 \"alias\"，但从 ptr1 派生。",
        "translate": ""
    },
    {
        "source": "Since ptr2_other and ptr2 are derived from pointers to different objects, computing their offset is undefined behavior, even though they point to the same address!",
        "suggest": "由于 ptr2_other 和 ptr2 是从指向不同对象的指针派生的，因此即使它们指向相同的地址，计算其偏移量也是未定义的行为!",
        "translate": ""
    },
    {
        "source": "Undefined Behavior",
        "suggest": "未定义的行为",
        "translate": ""
    },
    {
        "source": "Iterate using a raw pointer in increments of two elements (backwards)",
        "suggest": "使用裸指针以两个元素 (backwards) 为增量进行迭代",
        "translate": ""
    },
    {
        "source": "This loop prints \"5, 3, 1, \"",
        "suggest": "此循环打印 \"5, 3, 1, \"",
        "translate": ""
    },
    {
        "source": "will print \"3\"",
        "suggest": "将打印 \"3\"",
        "translate": ""
    },
    {
        "source": "while the pointer can be aligned via `offset`, it would point outside the allocation",
        "suggest": "虽然指针可以通过 `offset` 对齐，但它会指向分配之外",
        "translate": ""
    },
    {
        "source": "Returns `true` if the pointer is null.",
        "suggest": "如果指针为空，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc.",
        "suggest": "请注意，未定义大小的类型具有许多可能的空指针，因为仅考虑原始数据指针，而不考虑其长度，vtable 等。",
        "translate": ""
    },
    {
        "source": "Therefore, two pointers that are null may still not compare equal to each other.",
        "suggest": "因此，两个为空的指针可能仍不能相互比较相等。",
        "translate": ""
    },
    {
        "source": "Behavior during const evaluation",
        "suggest": "常量评估期间的行为",
        "translate": ""
    },
    {
        "source": "When this function is used during const evaluation, it may return `false` for pointers that turn out to be null at runtime.",
        "suggest": "在 const 评估期间使用此函数时，对于在运行时结果为空的指针，它可能返回 `false`。",
        "translate": ""
    },
    {
        "source": "Specifically, when a pointer to some memory is offset beyond its bounds in such a way that the resulting pointer is null, the function will still return `false`.",
        "suggest": "具体来说，当指向某个内存的指针超出其范围的偏移量 (使结果指针为空) 时，函数仍将返回 `false`。",
        "translate": ""
    },
    {
        "source": "There is no way for CTFE to know the absolute position of that memory, so we cannot tell if the pointer is null or not.",
        "suggest": "CTFE 无法知道该内存的绝对位置，因此我们无法确定指针是否为空。",
        "translate": ""
    },
    {
        "source": "Compare via a cast to a thin pointer, so fat pointers are only considering their \"data\" part for null-ness.",
        "suggest": "通过对瘦指针进行强制转换进行比较，因此胖指针仅考虑其 \"data\" 部分是否为空。",
        "translate": ""
    },
    {
        "source": "Casts to a pointer of another type.",
        "suggest": "强制转换为另一种类型的指针。",
        "translate": ""
    },
    {
        "source": "Decompose a (possibly wide) pointer into is address and metadata components.",
        "suggest": "将 (可能是很宽的) 指针分解为地址和元数据组件。",
        "translate": ""
    },
    {
        "source": "The pointer can be later reconstructed with [`from_raw_parts`].",
        "suggest": "以后可以使用 [`from_raw_parts`] 重建指针。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the pointer is null, or else returns a shared reference to the value wrapped in `Some`.",
        "suggest": "如果指针为空，则返回 `None`，否则返回 `Some` 中包装的值的共享引用。",
        "translate": ""
    },
    {
        "source": "If the value may be uninitialized, [`as_uninit_ref`] must be used instead.",
        "suggest": "如果该值可能未初始化，则必须改用 [`as_uninit_ref`]。",
        "translate": ""
    },
    {
        "source": "When calling this method, you have to ensure that *either* the pointer is NULL *or* all of the following is true:",
        "suggest": "调用此方法时，必须确保指针要么为 NULL，要么所有以下条件为真:",
        "translate": ""
    },
    {
        "source": "The pointer must be properly aligned.",
        "suggest": "指针必须正确对齐。",
        "translate": ""
    },
    {
        "source": "It must be \"dereferencable\" in the sense defined in [the module documentation].",
        "suggest": "在 [the module documentation] 中定义的意义上，它必须是 \"dereferencable\"。",
        "translate": ""
    },
    {
        "source": "The pointer must point to an initialized instance of `T`.",
        "suggest": "指针必须指向 `T` 的初始化实例。",
        "translate": ""
    },
    {
        "source": "You must enforce Rust's aliasing rules, since the returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.",
        "suggest": "您必须执行 Rust 的别名规则，因为返回的生命周期 `'a` 是任意选择的，不一定反映数据的实际生命周期。",
        "translate": ""
    },
    {
        "source": "In particular, for the duration of this lifetime, the memory the pointer points to must not get mutated (except inside `UnsafeCell`).",
        "suggest": "特别是，在此生命周期的持续时间内，指针所指向的内存一定不能被可变的 (`UnsafeCell` 内部除外)。",
        "translate": ""
    },
    {
        "source": "This applies even if the result of this method is unused!",
        "suggest": "即使未使用此方法的结果也是如此!",
        "translate": ""
    },
    {
        "source": "(The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)",
        "suggest": "(关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。)",
        "translate": ""
    },
    {
        "source": "Null-unchecked version",
        "suggest": "空未经检查的版本",
        "translate": ""
    },
    {
        "source": "If you are sure the pointer can never be null and are looking for some kind of `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can dereference the pointer directly.",
        "suggest": "如果确定指针永远不会为空，并且正在寻找某种返回 `&T` 而不是 `Option<&T>` 的 `as_ref_unchecked`，请知道您可以直接引用该指针。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` is valid for a reference if it isn't null.",
        "suggest": "调用者必须保证 `self` 对于引用有效 (如果它不为 null)。",
        "translate": ""
    },
    {
        "source": "In contrast to [`as_ref`], this does not require that the value has to be initialized.",
        "suggest": "与 [`as_ref`] 相比，这不需要将该值初始化。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` meets all the requirements for a reference.",
        "suggest": "调用者必须保证 `self` 满足引用的所有要求。",
        "translate": ""
    },
    {
        "source": "is in units of T;",
        "suggest": "以 T 为单位;",
        "translate": ""
    },
    {
        "source": "e.g., a `count` of 3 represents a pointer offset of `3 * size_of::<T>()` bytes.",
        "suggest": "例如，`count` 为 3 表示 `3 * size_of::<T>()` 字节的指针偏移量。",
        "translate": ""
    },
    {
        "source": "If any of the following conditions are violated, the result is Undefined Behavior:",
        "suggest": "如果违反以下任一条件，则结果为未定义行为:",
        "translate": ""
    },
    {
        "source": "Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object.",
        "suggest": "起始指针和结果指针都必须在同一分配对象末尾的范围之内或一个字节之内。",
        "translate": ""
    },
    {
        "source": "Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.",
        "suggest": "请注意，在 Rust 中，每个 (stack-allocated) 变量都被视为一个单独的分配对象。",
        "translate": ""
    },
    {
        "source": "The computed offset, **in bytes**, cannot overflow an `isize`.",
        "suggest": "计算的偏移量 (以字节为单位 **) 不会使 `isize` 溢出。",
        "translate": ""
    },
    {
        "source": "The offset being in bounds cannot rely on \"wrapping around\" the address space.",
        "suggest": "偏移量不能依赖 \"wrapping around\" 地址空间。",
        "translate": ""
    },
    {
        "source": "That is, the infinite-precision sum, **in bytes** must fit in a usize.",
        "suggest": "也就是说，无限精度总和 (以字节为单位) 必须适合于 usize。",
        "translate": ""
    },
    {
        "source": "The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern.",
        "suggest": "编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。",
        "translate": ""
    },
    {
        "source": "For instance, `Vec` and `Box` ensure they never allocate more than `isize::MAX` bytes, so `vec.as_ptr().add(vec.len())` is always safe.",
        "suggest": "例如，`Vec` 和 `Box` 确保它们分配的字节数永远不会超过 `isize::MAX` 字节，因此 `vec.as_ptr().add(vec.len())` 始终是安全的。",
        "translate": ""
    },
    {
        "source": "Most platforms fundamentally can't even construct such an allocation.",
        "suggest": "从根本上说，大多数平台甚至都无法构造这样的分配。",
        "translate": ""
    },
    {
        "source": "For instance, no known 64-bit platform can ever serve a request for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.",
        "suggest": "例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。",
        "translate": ""
    },
    {
        "source": "However, some 32-bit and 16-bit platforms may successfully serve a request for more than `isize::MAX` bytes with things like Physical Address Extension.",
        "suggest": "但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 `isize::MAX` 字节的请求提供服务。",
        "translate": ""
    },
    {
        "source": "As such, memory acquired directly from allocators or memory mapped files *may* be too large to handle with this function.",
        "suggest": "因此，直接从分配器获取的内存或内存映射文件 *可能* 太大而无法使用此函数进行处理。",
        "translate": ""
    },
    {
        "source": "Consider using [`wrapping_offset`] instead if these constraints are difficult to satisfy.",
        "suggest": "如果这些约束难以满足，请考虑使用 [`wrapping_offset`]。",
        "translate": ""
    },
    {
        "source": "The only advantage of this method is that it enables more aggressive compiler optimizations.",
        "suggest": "此方法的唯一优点是，它可以实现更积极的编译器优化。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `offset`.",
        "suggest": "调用者必须坚持 `offset` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Calculates the offset from a pointer using wrapping arithmetic.",
        "suggest": "使用换行算法计算与指针的偏移量。",
        "translate": ""
    },
    {
        "source": "This operation itself is always safe, but using the resulting pointer is not.",
        "suggest": "此操作本身始终是安全的，但使用结果指针则不安全。",
        "translate": ""
    },
    {
        "source": "The resulting pointer remains attached to the same allocated object that `self` points to.",
        "suggest": "结果指针仍然附加到 `self` 指向的同一分配对象。",
        "translate": ""
    },
    {
        "source": "It may *not* be used to access a different allocated object.",
        "suggest": "它可能 *不* 用于访问其他分配的对象。",
        "translate": ""
    },
    {
        "source": "In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z` the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless `x` and `y` point into the same allocated object.",
        "suggest": "换句话说，即使我们假设 `T` 的大小为 `1` 并且没有溢出，`let z = x.wrapping_offset((y as isize) - (x as isize))` 不会使 `z` 与 `y` 相同: `z` 仍附加到对象 `x` 所附加的对象，并且解引用它是 Undefined Behavior，除非 `x` 和 `y` 指向同一分配的对象。",
        "translate": ""
    },
    {
        "source": "Compared to [`offset`], this method basically delays the requirement of staying within the same allocated object: [`offset`] is immediate Undefined Behavior when crossing object boundaries;",
        "suggest": "与 [`offset`] 相比，此方法从根本上延迟了留在同一分配对象内的需求: [`offset`] 是跨越对象边界时的立即未定义行为;",
        "translate": ""
    },
    {
        "source": "`wrapping_offset` produces a pointer but still leads to Undefined Behavior if a pointer is dereferenced when it is out-of-bounds of the object it is attached to.",
        "suggest": "`wrapping_offset` 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。",
        "translate": ""
    },
    {
        "source": "can be optimized better and is thus preferable in performance-sensitive code.",
        "suggest": "可以更好地进行优化，因此在对性能敏感的代码中更可取。",
        "translate": ""
    },
    {
        "source": "The delayed check only considers the value of the pointer that was dereferenced, not the intermediate values used during the computation of the final result.",
        "suggest": "延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。",
        "translate": ""
    },
    {
        "source": "For example, `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`.",
        "suggest": "例如，`x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` 始终与 `x` 相同。",
        "translate": ""
    },
    {
        "source": "In other words, leaving the allocated object and then re-entering it later is permitted.",
        "suggest": "换句话说，允许离开已分配的对象，然后在以后重新输入它。",
        "translate": ""
    },
    {
        "source": "If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.",
        "suggest": "如果您需要越过对象边界，请将指针转换为整数，然后在该处进行算术运算。",
        "translate": ""
    },
    {
        "source": "the `arith_offset` intrinsic has no prerequisites to be called.",
        "suggest": "`arith_offset` 内联函数没有先决条件。",
        "translate": ""
    },
    {
        "source": "Calculates the distance between two pointers.",
        "suggest": "计算两个指针之间的距离。",
        "translate": ""
    },
    {
        "source": "The returned value is in units of T: the distance in bytes is divided by `mem::size_of::<T>()`.",
        "suggest": "返回的值以 T 为单位: 以字节为单位的距离除以 `mem::size_of::<T>()`。",
        "translate": ""
    },
    {
        "source": "This function is the inverse of [`offset`].",
        "suggest": "该函数是 [`offset`] 的逆函数。",
        "translate": ""
    },
    {
        "source": "Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object.",
        "suggest": "起始指针和其他指针都必须在同一分配对象末尾的范围之内或一个字节之内。",
        "translate": ""
    },
    {
        "source": "Both pointers must be *derived from* a pointer to the same object.",
        "suggest": "两个指针必须是指向同一对象的指针的 *derived。",
        "translate": ""
    },
    {
        "source": "(See below for an example.)",
        "suggest": "(请参见下面的示例。)",
        "translate": ""
    },
    {
        "source": "The distance between the pointers, in bytes, must be an exact multiple of the size of `T`.",
        "suggest": "指针之间的距离 (以字节为单位) 必须是 `T` 大小的精确倍数。",
        "translate": ""
    },
    {
        "source": "The distance between the pointers, **in bytes**, cannot overflow an `isize`.",
        "suggest": "指针之间的距离 (以字节为单位) 不会溢出 `isize`。",
        "translate": ""
    },
    {
        "source": "The distance being in bounds cannot rely on \"wrapping around\" the address space.",
        "suggest": "该距离不能依赖于 \"wrapping around\" 地址空间。",
        "translate": ""
    },
    {
        "source": "Rust types are never larger than `isize::MAX` and Rust allocations never wrap around the address space, so two pointers within some value of any Rust type `T` will always satisfy the last two conditions.",
        "suggest": "Rust 类型从不大于 `isize::MAX`，并且 Rust 分配从不环绕地址空间，因此，任何 Rust 类型 `T` 的某个值内的两个指针将始终满足最后两个条件。",
        "translate": ""
    },
    {
        "source": "The standard library also generally ensures that allocations never reach a size where an offset is a concern.",
        "suggest": "标准库通常还确保分配永远不会达到需要考虑偏移量的大小。",
        "translate": ""
    },
    {
        "source": "For instance, `Vec` and `Box` ensure they never allocate more than `isize::MAX` bytes, so `ptr_into_vec.offset_from(vec.as_ptr())` always satisfies the last two conditions.",
        "suggest": "例如，`Vec` 和 `Box` 确保它们分配的字节数永远不超过 `isize::MAX` 字节，因此 `ptr_into_vec.offset_from(vec.as_ptr())` 始终满足最后两个条件。",
        "translate": ""
    },
    {
        "source": "Most platforms fundamentally can't even construct such a large allocation.",
        "suggest": "从根本上说，大多数平台甚至都无法构建如此大的分配。",
        "translate": ""
    },
    {
        "source": "(Note that [`offset`] and [`add`] also have a similar limitation and hence cannot be used on such large allocations either.)",
        "suggest": "(请注意，[`offset`] 和 [`add`] 也具有类似的限制，因此也不能在如此大的分配上使用。)",
        "translate": ""
    },
    {
        "source": "This function panics if `T` is a Zero-Sized Type (\"ZST\").",
        "suggest": "如果 `T` 是零大小类型 (\"ZST\")，则此函数 panics。",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage:",
        "suggest": "*不正确* 用法:",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `ptr_offset_from`.",
        "suggest": "调用者必须坚持 `ptr_offset_from` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Returns whether two pointers are guaranteed to be equal.",
        "suggest": "返回两个指针是否保证相等。",
        "translate": ""
    },
    {
        "source": "At runtime this function behaves like `self == other`.",
        "suggest": "在运行时，此函数的行为类似于 `self == other`。",
        "translate": ""
    },
    {
        "source": "However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine equality of two pointers, so this function may spuriously return `false` for pointers that later actually turn out to be equal.",
        "suggest": "但是，在某些情况下 (例如，编译时评估)，并非总是可以确定两个指针是否相等，因此此函数可能会虚假地返回 `false` 来表示后来实际上相等的指针。",
        "translate": ""
    },
    {
        "source": "But when it returns `true`, the pointers are guaranteed to be equal.",
        "suggest": "但是，当它返回 `true` 时，保证指针是相等的。",
        "translate": ""
    },
    {
        "source": "This function is the mirror of [`guaranteed_ne`], but not its inverse.",
        "suggest": "该函数是 [`guaranteed_ne`] 的镜像，但不是其反函数。",
        "translate": ""
    },
    {
        "source": "There are pointer comparisons for which both functions return `false`.",
        "suggest": "有两个指针返回 `false` 的指针比较。",
        "translate": ""
    },
    {
        "source": "The return value may change depending on the compiler version and unsafe code may not rely on the result of this function for soundness.",
        "suggest": "返回值可能会有所不同，具体取决于编译器版本，并且不安全的代码可能不依赖于此函数的结果来确保完整性。",
        "translate": ""
    },
    {
        "source": "It is suggested to only use this function for performance optimizations where spurious `false` return values by this function do not affect the outcome, but just the performance.",
        "suggest": "建议仅将此函数用于性能优化，在这种情况下，此函数的虚假 `false` 返回值不会影响结果，而只会影响性能。",
        "translate": ""
    },
    {
        "source": "The consequences of using this method to make runtime and compile-time code behave differently have not been explored.",
        "suggest": "尚未探讨使用此方法使运行时和编译时代码表现不同的后果。",
        "translate": ""
    },
    {
        "source": "This method should not be used to introduce such differences, and it should also not be stabilized before we have a better understanding of this issue.",
        "suggest": "不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。",
        "translate": ""
    },
    {
        "source": "Returns whether two pointers are guaranteed to be unequal.",
        "suggest": "返回两个指针是否保证不相等。",
        "translate": ""
    },
    {
        "source": "At runtime this function behaves like `self != other`.",
        "suggest": "在运行时，此函数的行为类似于 `self != other`。",
        "translate": ""
    },
    {
        "source": "However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine the inequality of two pointers, so this function may spuriously return `false` for pointers that later actually turn out to be unequal.",
        "suggest": "但是，在某些情况下 (例如，编译时评估)，并非总是可以确定两个指针的不相等性，因此此函数可能会虚假地返回 `false` 来表示后来实际上不相等的指针。",
        "translate": ""
    },
    {
        "source": "But when it returns `true`, the pointers are guaranteed to be unequal.",
        "suggest": "但是，当它返回 `true` 时，保证指针是不相等的。",
        "translate": ""
    },
    {
        "source": "This function is the mirror of [`guaranteed_eq`], but not its inverse.",
        "suggest": "该函数是 [`guaranteed_eq`] 的镜像，但不是其反函数。",
        "translate": ""
    },
    {
        "source": "Calculates the offset from a pointer (convenience for `.offset(count as isize)`).",
        "suggest": "计算与指针的偏移量 (`.offset(count as isize)` 的便利性)。",
        "translate": ""
    },
    {
        "source": "Consider using [`wrapping_add`] instead if these constraints are difficult to satisfy.",
        "suggest": "如果这些约束难以满足，请考虑使用 [`wrapping_add`]。",
        "translate": ""
    },
    {
        "source": "Calculates the offset from a pointer (convenience for `.offset((count as isize).wrapping_neg())`).",
        "suggest": "计算与指针的偏移量 (`.offset((count as isize).wrapping_neg())` 的便利性)。",
        "translate": ""
    },
    {
        "source": "The computed offset cannot exceed `isize::MAX` **bytes**.",
        "suggest": "计算的偏移量不能超过 `isize::MAX` 个 **字节**。",
        "translate": ""
    },
    {
        "source": "For instance, `Vec` and `Box` ensure they never allocate more than `isize::MAX` bytes, so `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.",
        "suggest": "例如，`Vec` 和 `Box` 确保它们分配的字节数永远不会超过 `isize::MAX` 字节，因此 `vec.as_ptr().add(vec.len()).sub(vec.len())` 始终是安全的。",
        "translate": ""
    },
    {
        "source": "Consider using [`wrapping_sub`] instead if these constraints are difficult to satisfy.",
        "suggest": "如果这些约束难以满足，请考虑使用 [`wrapping_sub`]。",
        "translate": ""
    },
    {
        "source": "(convenience for `.wrapping_offset(count as isize)`)",
        "suggest": "(为 `.wrapping_offset(count as isize)` 带来的便利)",
        "translate": ""
    },
    {
        "source": "In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z` the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless `x` and `y` point into the same allocated object.",
        "suggest": "换句话说，即使我们假设 `T` 的大小为 `1` 并且没有溢出，`let z = x.wrapping_add((y as usize) - (x as usize))` 不会使 `z` 与 `y` 相同: `z` 仍附加到对象 `x` 所附加的对象，并且解引用它是 Undefined Behavior，除非 `x` 和 `y` 指向同一分配的对象。",
        "translate": ""
    },
    {
        "source": "Compared to [`add`], this method basically delays the requirement of staying within the same allocated object: [`add`] is immediate Undefined Behavior when crossing object boundaries;",
        "suggest": "与 [`add`] 相比，此方法从根本上延迟了留在同一分配对象内的需求: [`add`] 是跨越对象边界时的立即未定义行为;",
        "translate": ""
    },
    {
        "source": "`wrapping_add` produces a pointer but still leads to Undefined Behavior if a pointer is dereferenced when it is out-of-bounds of the object it is attached to.",
        "suggest": "`wrapping_add` 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。",
        "translate": ""
    },
    {
        "source": "For example, `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`.",
        "suggest": "例如，`x.wrapping_add(o).wrapping_sub(o)` 始终与 `x` 相同。",
        "translate": ""
    },
    {
        "source": "(convenience for `.wrapping_offset((count as isize).wrapping_neg())`)",
        "suggest": "(为 `.wrapping_offset((count as isize).wrapping_neg())` 带来的便利)",
        "translate": ""
    },
    {
        "source": "In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z` the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless `x` and `y` point into the same allocated object.",
        "suggest": "换句话说，即使我们假设 `T` 的大小为 `1` 并且没有溢出，`let z = x.wrapping_sub((x as usize) - (y as usize))` 不会使 `z` 与 `y` 相同: `z` 仍附加到对象 `x` 所附加的对象，并且解引用它是 Undefined Behavior，除非 `x` 和 `y` 指向同一分配的对象。",
        "translate": ""
    },
    {
        "source": "Compared to [`sub`], this method basically delays the requirement of staying within the same allocated object: [`sub`] is immediate Undefined Behavior when crossing object boundaries;",
        "suggest": "与 [`sub`] 相比，此方法从根本上延迟了留在同一分配对象内的需求: [`sub`] 是跨越对象边界时的立即未定义行为;",
        "translate": ""
    },
    {
        "source": "`wrapping_sub` produces a pointer but still leads to Undefined Behavior if a pointer is dereferenced when it is out-of-bounds of the object it is attached to.",
        "suggest": "`wrapping_sub` 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。",
        "translate": ""
    },
    {
        "source": "Sets the pointer value to `ptr`.",
        "suggest": "将指针值设置为 `ptr`。",
        "translate": ""
    },
    {
        "source": "In case `self` is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.",
        "suggest": "如果 `self` 是指向未定义大小类型的 (fat) 指针，则此操作将仅影响指针部分，而对于指向已确定大小类型的 (thin) 指针，其作用与简单分配相同。",
        "translate": ""
    },
    {
        "source": "The resulting pointer will have provenance of `val`, i.e., for a fat pointer, this operation is semantically the same as creating a new fat pointer with the data pointer value of `val` but the metadata of `self`.",
        "suggest": "生成的指针将具有 `val` 的出处，即对于胖指针，此操作在语义上与使用 `val` 的数据指针值但 `self` 的元数据创建新的胖指针相同。",
        "translate": ""
    },
    {
        "source": "This function is primarily useful for allowing byte-wise pointer arithmetic on potentially fat pointers:",
        "suggest": "此函数主要用于允许对潜在的胖指针进行按字节指针算术运算:",
        "translate": ""
    },
    {
        "source": "In case of a thin pointer, this operations is identical to a simple assignment.",
        "suggest": "对于细指针，此操作与简单分配相同。",
        "translate": ""
    },
    {
        "source": "In case of a fat pointer, with the current fat pointer layout implementation, the first field of such a pointer is always the data pointer, which is likewise assigned.",
        "suggest": "对于胖指针，在当前胖指针布局实现中，此类指针的第一个字段始终是数据指针，该指针同样被分配。",
        "translate": ""
    },
    {
        "source": "Reads the value from `self` without moving it.",
        "suggest": "从 `self` 读取值而不移动它。",
        "translate": ""
    },
    {
        "source": "This leaves the memory in `self` unchanged.",
        "suggest": "这将使 `self` 中的内存保持不变。",
        "translate": ""
    },
    {
        "source": "See [`ptr::read`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::read`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `read`.",
        "suggest": "调用者必须坚持 `read` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Performs a volatile read of the value from `self` without moving it.",
        "suggest": "对 `self` 的值进行易失性读取，而无需移动它。",
        "translate": ""
    },
    {
        "source": "Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.",
        "suggest": "易失性操作旨在作用于 I/O 存储器，并保证编译器不会在其他易失性操作中对易失性操作进行清除或重新排序。",
        "translate": ""
    },
    {
        "source": "See [`ptr::read_volatile`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::read_volatile`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `read_volatile`.",
        "suggest": "调用者必须坚持 `read_volatile` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Unlike `read`, the pointer may be unaligned.",
        "suggest": "与 `read` 不同，指针可能未对齐。",
        "translate": ""
    },
    {
        "source": "See [`ptr::read_unaligned`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::read_unaligned`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `read_unaligned`.",
        "suggest": "调用者必须坚持 `read_unaligned` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Copies `count * size_of<T>` bytes from `self` to `dest`.",
        "suggest": "将 `count * size_of<T>` 字节从 `self` 复制到 `dest`。",
        "translate": ""
    },
    {
        "source": "The source and destination may overlap.",
        "suggest": "源和目标可能会重叠。",
        "translate": ""
    },
    {
        "source": "this has the *same* argument order as [`ptr::copy`].",
        "suggest": "这与 [`ptr::copy`] 具有相同的参数顺序。",
        "translate": ""
    },
    {
        "source": "See [`ptr::copy`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::copy`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `copy`.",
        "suggest": "调用者必须坚持 `copy` 的安全保证。",
        "translate": ""
    },
    {
        "source": "The source and destination may *not* overlap.",
        "suggest": "源和目标可能 *不* 重叠。",
        "translate": ""
    },
    {
        "source": "this has the *same* argument order as [`ptr::copy_nonoverlapping`].",
        "suggest": "这与 [`ptr::copy_nonoverlapping`] 具有相同的参数顺序。",
        "translate": ""
    },
    {
        "source": "See [`ptr::copy_nonoverlapping`] for safety concerns and examples.",
        "suggest": "有关安全性问题和示例，请参见 [`ptr::copy_nonoverlapping`]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `copy_nonoverlapping`.",
        "suggest": "调用者必须坚持 `copy_nonoverlapping` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Computes the offset that needs to be applied to the pointer in order to make it aligned to `align`.",
        "suggest": "计算为使其与 `align` 对齐而需要应用到指针的偏移量。",
        "translate": ""
    },
    {
        "source": "If it is not possible to align the pointer, the implementation returns `usize::MAX`.",
        "suggest": "如果无法对齐指针，则实现将返回 `usize::MAX`。",
        "translate": ""
    },
    {
        "source": "It is permissible for the implementation to *always* return `usize::MAX`.",
        "suggest": "允许实现 *始终* 返回 `usize::MAX`。",
        "translate": ""
    },
    {
        "source": "Only your algorithm's performance can depend on getting a usable offset here, not its correctness.",
        "suggest": "只有算法的性能可以取决于此处是否可获得可用的偏移量，而不取决于其正确性。",
        "translate": ""
    },
    {
        "source": "The offset is expressed in number of `T` elements, and not bytes.",
        "suggest": "偏移量以 `T` 元素的数量表示，而不是以字节表示。",
        "translate": ""
    },
    {
        "source": "The value returned can be used with the `wrapping_add` method.",
        "suggest": "返回的值可以与 `wrapping_add` 方法一起使用。",
        "translate": ""
    },
    {
        "source": "There are no guarantees whatsoever that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into.",
        "suggest": "不能保证偏移指针不会溢出或超出指针所指向的分配范围。",
        "translate": ""
    },
    {
        "source": "It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.",
        "suggest": "调用者应确保返回的偏移量在对齐方式以外的所有方面都是正确的。",
        "translate": ""
    },
    {
        "source": "The function panics if `align` is not a power-of-two.",
        "suggest": "如果 `align` 不是 2 的幂，则函数 panics。",
        "translate": ""
    },
    {
        "source": "Accessing adjacent `u8` as `u16`",
        "suggest": "将相邻的 `u8` 作为 `u16` 进行访问",
        "translate": ""
    },
    {
        "source": "`align` has been checked to be a power of 2 above",
        "suggest": "`align` 已被检查为 2 以上的幂",
        "translate": ""
    },
    {
        "source": "Returns the length of a raw slice.",
        "suggest": "返回原始切片的长度。",
        "translate": ""
    },
    {
        "source": "The returned value is the number of **elements**, not the number of bytes.",
        "suggest": "返回的值是 **elements** 的数量，而不是字节数。",
        "translate": ""
    },
    {
        "source": "This function is safe, even when the raw slice cannot be cast to a slice reference because the pointer is null or unaligned.",
        "suggest": "即使原始切片由于指针为空或未对齐而无法转换为切片引用，此函数也是安全的。",
        "translate": ""
    },
    {
        "source": "this is safe because `*const [T]` and `FatPtr<T>` have the same layout.",
        "suggest": "这是安全的，因为 `*const [T]` 和 `FatPtr<T>` 具有相同的布局。",
        "translate": ""
    },
    {
        "source": "Only `std` can make this guarantee.",
        "suggest": "只有 `std` 可以做出此保证。",
        "translate": ""
    },
    {
        "source": "Returns a raw pointer to the slice's buffer.",
        "suggest": "将裸指针返回到切片的缓冲区。",
        "translate": ""
    },
    {
        "source": "This is equivalent to casting `self` to `*const T`, but more type-safe.",
        "suggest": "这等效于将 `self` 强制转换为 `*const T`，但类型安全性更高。",
        "translate": ""
    },
    {
        "source": "Returns a raw pointer to an element or subslice, without doing bounds checking.",
        "suggest": "将裸指针返回到元素或子切片，而不进行边界检查。",
        "translate": ""
    },
    {
        "source": "Calling this method with an out-of-bounds index or when `self` is not dereferencable is *[undefined behavior]* even if the resulting pointer is not used.",
        "suggest": "即使未使用生成的指针，使用越界索引或无法使用 `self` 调用此方法也是 [*[undefined 行为]*。",
        "translate": ""
    },
    {
        "source": "the caller ensures that `self` is dereferencable and `index` in-bounds.",
        "suggest": "调用方确保 `self` 是可解引用的，并且 `index` 是入站的。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the pointer is null, or else returns a shared slice to the value wrapped in `Some`.",
        "suggest": "如果指针为空，则返回 `None`，否则返回共享切片到 `Some` 中包装的值。",
        "translate": ""
    },
    {
        "source": "The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes, and it must be properly aligned.",
        "suggest": "指针必须为 [valid]，才能读取许多字节的 `ptr.len() * mem::size_of::<T>()`，并且必须正确对齐。",
        "translate": ""
    },
    {
        "source": "This means in particular:",
        "suggest": "这尤其意味着:",
        "translate": ""
    },
    {
        "source": "The entire memory range of this slice must be contained within a single allocated object!",
        "suggest": "该切片的整个存储范围必须包含在一个分配的对象中!",
        "translate": ""
    },
    {
        "source": "Slices can never span across multiple allocated objects.",
        "suggest": "切片永远不能跨越多个分配的对象。",
        "translate": ""
    },
    {
        "source": "The pointer must be aligned even for zero-length slices.",
        "suggest": "即使对于零长度的切片，指针也必须对齐。",
        "translate": ""
    },
    {
        "source": "One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data.",
        "suggest": "这样做的一个原因是，枚举布局优化可能依赖于对齐的引用 (包括任何长度的切片) 和非空值，以将它们与其他数据区分开。",
        "translate": ""
    },
    {
        "source": "You can obtain a pointer that is usable as `data` for zero-length slices using [`NonNull::dangling()`].",
        "suggest": "您可以使用 [`NonNull::dangling()`] 获得可用作零长度切片的 `data` 的指针。",
        "translate": ""
    },
    {
        "source": "The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.",
        "suggest": "切片的总大小 `ptr.len() * mem::size_of::<T>()` 不能大于 `isize::MAX`。",
        "translate": ""
    },
    {
        "source": "See the safety documentation of [`pointer::offset`].",
        "suggest": "请参见 [`pointer::offset`] 的安全文档。",
        "translate": ""
    },
    {
        "source": "See also [`slice::from_raw_parts`][].",
        "suggest": "另请参见 [`slice::from_raw_parts`][]。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `as_uninit_slice`.",
        "suggest": "调用者必须坚持 `as_uninit_slice` 的安全保证。",
        "translate": ""
    },
    {
        "source": "Equality for pointers",
        "suggest": "指针相等",
        "translate": ""
    },
    {
        "source": "Comparison for pointers",
        "suggest": "指针比较",
        "translate": ""
    },
    {
        "source": "Provides the pointer metadata type of any pointed-to type.",
        "suggest": "提供任何指向类型的指针元数据类型。",
        "translate": ""
    },
    {
        "source": "Pointer metadata",
        "suggest": "指针元数据",
        "translate": ""
    },
    {
        "source": "Raw pointer types and reference types in Rust can be thought of as made of two parts:",
        "suggest": "Rust 中的裸指针类型和引用类型可以认为是由两部分组成:",
        "translate": ""
    },
    {
        "source": "a data pointer that contains the memory address of the value, and some metadata.",
        "suggest": "包含该值的内存地址和一些元数据的数据指针。",
        "translate": ""
    },
    {
        "source": "For statically-sized types (that implement the `Sized` traits) as well as for `extern` types, pointers are said to be “thin”: metadata is zero-sized and its type is `()`.",
        "suggest": "对于静态大小的类型 (实现 `Sized` traits) 以及 `extern` 类型，指针被称为 `thin`: 元数据的大小为零，其类型为 `()`。",
        "translate": ""
    },
    {
        "source": "Pointers to [dynamically-sized types][dst] are said to be “wide” or “fat”, they have non-zero-sized metadata:",
        "suggest": "指向 [动态大小的类型][dst] 的指针被称为 `wide` 或 `fat`，它们具有非零大小的元数据:",
        "translate": ""
    },
    {
        "source": "For structs whose last field is a DST, metadata is the metadata for the last field",
        "suggest": "对于最后一个字段是 DST 的结构体，元数据是最后一个字段的元数据",
        "translate": ""
    },
    {
        "source": "For the `str` type, metadata is the length in bytes as `usize`",
        "suggest": "对于 `str` 类型，元数据是 `usize` 的长度 (以字节为单位)",
        "translate": ""
    },
    {
        "source": "For slice types like `[T]`, metadata is the length in items as `usize`",
        "suggest": "对于 `[T]` 之类的切片类型，元数据是 `usize` 中项的长度",
        "translate": ""
    },
    {
        "source": "For trait objects like `dyn SomeTrait`, metadata is [`DynMetadata<Self>`][DynMetadata] (e.g. `DynMetadata<dyn SomeTrait>`)",
        "suggest": "对于 `dyn SomeTrait` 之类的 trait 对象，元数据为 [`DynMetadata<Self>`][DynMetadata] (例如 `DynMetadata<dyn SomeTrait>`)",
        "translate": ""
    },
    {
        "source": "In the future, the Rust language may gain new kinds of types that have different pointer metadata.",
        "suggest": "在 future 中，Rust 语言可能会获得具有不同指针元数据的新型类型。",
        "translate": ""
    },
    {
        "source": "The `Pointee` trait",
        "suggest": "`Pointee` trait",
        "translate": ""
    },
    {
        "source": "The point of this trait is its `Metadata` associated type, which is `()` or `usize` or `DynMetadata<_>` as described above.",
        "suggest": "trait 的点是其 `Metadata` 关联类型，如上所述，它是 `()` 或 `usize` 或 `DynMetadata<_>`。",
        "translate": ""
    },
    {
        "source": "It is automatically implemented for every type.",
        "suggest": "它会针对每种类型自动实现。",
        "translate": ""
    },
    {
        "source": "It can be assumed to be implemented in a generic context, even without a corresponding bound.",
        "suggest": "即使没有相应的限制，也可以假定它是在泛型上下文中实现的。",
        "translate": ""
    },
    {
        "source": "Raw pointers can be decomposed into the data address and metadata components with their [`to_raw_parts`] method.",
        "suggest": "可以使用 [`to_raw_parts`] 方法将裸指针分解为数据地址和元数据组件。",
        "translate": ""
    },
    {
        "source": "Alternatively, metadata alone can be extracted with the [`metadata`] function.",
        "suggest": "或者，可以使用 [`metadata`] 函数单独提取元数据。",
        "translate": ""
    },
    {
        "source": "A reference can be passed to [`metadata`] and implicitly coerced.",
        "suggest": "可以将引用传递给 [`metadata`] 并进行隐式强制。",
        "translate": ""
    },
    {
        "source": "A (possibly-wide) pointer can be put back together from its address and metadata with [`from_raw_parts`] or [`from_raw_parts_mut`].",
        "suggest": "可以使用 [`from_raw_parts`] 或 [`from_raw_parts_mut`] 将 (possibly-wide) 指针从其地址和元数据放回原处。",
        "translate": ""
    },
    {
        "source": "The type for metadata in pointers and references to `Self`.",
        "suggest": "指针中的元数据类型，并引用 `Self`。",
        "translate": ""
    },
    {
        "source": "Keep trait bounds in `static_assert_expected_bounds_for_metadata` in `library/core/src/ptr/metadata.rs` in sync with those here:",
        "suggest": "保持 `library/core/src/ptr/metadata.rs` 中 `static_assert_expected_bounds_for_metadata` 中的 trait bounds 与此处的同步:",
        "translate": ""
    },
    {
        "source": "Pointers to types implementing this trait alias are “thin”.",
        "suggest": "实现此 trait 别名的类型的指针为 `thin`。",
        "translate": ""
    },
    {
        "source": "This includes statically-`Sized` types and `extern` types.",
        "suggest": "这包括静态 `Sized` 类型和 `extern` 类型。",
        "translate": ""
    },
    {
        "source": "don’t stabilize this before trait aliases are stable in the language?",
        "suggest": "在 trait 别名在语言中稳定之前难道不能稳定它吗?",
        "translate": ""
    },
    {
        "source": "Extract the metadata component of a pointer.",
        "suggest": "提取指针的元数据组件。",
        "translate": ""
    },
    {
        "source": "Values of type `*mut T`, `&T`, or `&mut T` can be passed directly to this function as they implicitly coerce to `*const T`.",
        "suggest": "`*mut T`，`&T` 或 `&mut T` 类型的值可以隐式强制转换为 `* const T`，因此可以直接传递给此函数。",
        "translate": ""
    },
    {
        "source": "Accessing the value from the `PtrRepr` union is safe since *const T and PtrComponents<T> have the same memory layouts.",
        "suggest": "因为 *const T 和 PtrComponents<T> 具有相同的内存布局，所以从 `PtrRepr` union 访问值是安全的。",
        "translate": ""
    },
    {
        "source": "Only std can make this guarantee.",
        "suggest": "只有 std 可以做出此保证。",
        "translate": ""
    },
    {
        "source": "Forms a (possibly-wide) raw pointer from a data address and metadata.",
        "suggest": "根据数据地址和元数据形成 (possibly-wide) 裸指针。",
        "translate": ""
    },
    {
        "source": "This function is safe but the returned pointer is not necessarily safe to dereference.",
        "suggest": "此函数是安全的，但是返回的指针对于解引用并不一定是安全的。",
        "translate": ""
    },
    {
        "source": "For slices, see the documentation of [`slice::from_raw_parts`] for safety requirements.",
        "suggest": "对于切片，请参见 [`slice::from_raw_parts`] 的文档以了解安全要求。",
        "translate": ""
    },
    {
        "source": "For trait objects, the metadata must come from a pointer to the same underlying ereased type.",
        "suggest": "对于 trait 对象，元数据必须来自指向相同基础增加类型的指针。",
        "translate": ""
    },
    {
        "source": "Performs the same functionality as [`from_raw_parts`], except that a raw `*mut` pointer is returned, as opposed to a raw `*const` pointer.",
        "suggest": "执行与 [`from_raw_parts`] 相同的功能，除了返回原始 `*mut` 指针 (与原始 `* const` 指针相反) 之外。",
        "translate": ""
    },
    {
        "source": "See the documentation of [`from_raw_parts`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`from_raw_parts`] 的文档。",
        "translate": ""
    },
    {
        "source": "Manual impl needed to avoid `T: Copy` bound.",
        "suggest": "需要避免 `T: Copy` 绑定的手动提示。",
        "translate": ""
    },
    {
        "source": "Manual impl needed to avoid `T: Clone` bound.",
        "suggest": "需要避免 `T: Clone` 绑定的手动提示。",
        "translate": ""
    },
    {
        "source": "The metadata for a `Dyn = dyn SomeTrait` trait object type.",
        "suggest": "`Dyn = dyn SomeTrait` trait 对象类型的元数据。",
        "translate": ""
    },
    {
        "source": "It is a pointer to a vtable (virtual call table) that represents all the necessary information to manipulate the concrete type stored inside a trait object.",
        "suggest": "它是指向 vtable (虚拟调用表) 的指针，该表表示操作存储在 trait 对象内部的具体类型所需的所有信息。",
        "translate": ""
    },
    {
        "source": "The vtable notably it contains:",
        "suggest": "该 vtable 尤其包含:",
        "translate": ""
    },
    {
        "source": "type size",
        "suggest": "类型大小",
        "translate": ""
    },
    {
        "source": "type alignment",
        "suggest": "类型对齐",
        "translate": ""
    },
    {
        "source": "a pointer to the type’s `drop_in_place` impl (may be a no-op for plain-old-data)",
        "suggest": "指向该类型的 `drop_in_place` impl 的指针 (对于纯旧数据，它可能是 no-op)",
        "translate": ""
    },
    {
        "source": "pointers to all the methods for the type’s implementation of the trait",
        "suggest": "指向 trait 类型实现的所有方法的指针",
        "translate": ""
    },
    {
        "source": "Note that the first three are special because they’re necessary to allocate, drop, and deallocate any trait object.",
        "suggest": "请注意，前三个是特殊的，因为它们是分配，丢弃和释放任何 trait 对象所必需的。",
        "translate": ""
    },
    {
        "source": "It is possible to name this struct with a type parameter that is not a `dyn` trait object (for example `DynMetadata<u64>`) but not to obtain a meaningful value of that struct.",
        "suggest": "可以使用不是 `dyn` trait 对象 (例如 `DynMetadata<u64>`) 的类型参数来命名此结构体，但不能获得该结构体的有意义的值。",
        "translate": ""
    },
    {
        "source": "The common prefix of all vtables.",
        "suggest": "所有 vtable 的通用前缀。",
        "translate": ""
    },
    {
        "source": "It is followed by function pointers for trait methods.",
        "suggest": "其后是 trait 方法的函数指针。",
        "translate": ""
    },
    {
        "source": "Private implementation detail of `DynMetadata::size_of` etc.",
        "suggest": "`DynMetadata::size_of` 等的私有实现详细信息",
        "translate": ""
    },
    {
        "source": "Returns the size of the type associated with this vtable.",
        "suggest": "返回与此 vtable 关联的类型的大小。",
        "translate": ""
    },
    {
        "source": "Returns the alignment of the type associated with this vtable.",
        "suggest": "返回与此 vtable 关联的类型的对齐方式。",
        "translate": ""
    },
    {
        "source": "Returns the size and alignment together as a `Layout`",
        "suggest": "将大小和对齐方式一起返回为 `Layout`",
        "translate": ""
    },
    {
        "source": "the compiler emitted this vtable for a concrete Rust type which is known to have a valid layout.",
        "suggest": "编译器针对特定的 Rust 类型发出此 vtable，已知该类型具有有效的布局。",
        "translate": ""
    },
    {
        "source": "Same rationale as in `Layout::for_value`.",
        "suggest": "与 `Layout::for_value` 中的原理相同。",
        "translate": ""
    },
    {
        "source": "Manual impls needed to avoid `Dyn: $Trait` bounds.",
        "suggest": "避免 `Dyn: $Trait` 边界所需的手动提示。",
        "translate": ""
    },
    {
        "source": "Get a raw pointer to the last element in `v`.",
        "suggest": "获取指向 `v` 中最后一个元素的裸指针。",
        "translate": ""
    },
    {
        "source": "Shorten `v` to prevent the last item from being dropped.",
        "suggest": "缩短 `v`，以防止丢弃最后一个项。",
        "translate": ""
    },
    {
        "source": "We do that first, to prevent issues if the `drop_in_place` below panics.",
        "suggest": "我们首先这样做是为了防止 `drop_in_place` 低于 panics。",
        "translate": ""
    },
    {
        "source": "Without a call `drop_in_place`, the last item would never be dropped, and the memory it manages would be leaked.",
        "suggest": "如果没有调用 `drop_in_place`，则最后一个项将永远不会被删除，并且它管理的内存也会泄漏。",
        "translate": ""
    },
    {
        "source": "Ensure that the last item was dropped.",
        "suggest": "确保丢弃了最后一项。",
        "translate": ""
    },
    {
        "source": "create a slice pointer when starting out with a pointer to the first element",
        "suggest": "从指向第一个元素的指针开始创建切片指针",
        "translate": ""
    },
    {
        "source": "assign a value at an index in the slice",
        "suggest": "在切片中的索引处分配值",
        "translate": ""
    },
    {
        "source": "this is `array[0..2]`",
        "suggest": "这是 `array[0..2]`",
        "translate": ""
    },
    {
        "source": "this is `array[2..4]`",
        "suggest": "这是 `array[2..4]`",
        "translate": ""
    },
    {
        "source": "this is `array[0..3]`",
        "suggest": "这是 `array[0..3]`",
        "translate": ""
    },
    {
        "source": "this is `array[1..4]`",
        "suggest": "这是 `array[1..4]`",
        "translate": ""
    },
    {
        "source": "The indices `1..3` of the slice overlap between `x` and `y`.",
        "suggest": "切片的索引 `1..3` 在 `x` 和 `y` 之间重叠。",
        "translate": ""
    },
    {
        "source": "Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are `[1, 2, 3]` (matching `y` before the `swap`);",
        "suggest": "合理的结果将是 `[2, 3]`，因此索引 `0..3` 为 `[1, 2, 3]` (与 `swap` 匹配的 `y`) ;",
        "translate": ""
    },
    {
        "source": "or for them to be `[0, 1]` so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).",
        "suggest": "或将它们设为 `[0, 1]`，以使索引 `1..4` 为 `[0, 1, 2]` (与 `swap` 之前的 `x` 匹配)。",
        "translate": ""
    },
    {
        "source": "This implementation is defined to make the latter choice.",
        "suggest": "定义此实现是为了做出后一种选择。",
        "translate": ""
    },
    {
        "source": "would have the same effect without requiring the unsafe block.",
        "suggest": "不需要 unsafe 块将具有相同的效果。",
        "translate": ""
    },
    {
        "source": "Create a bitwise copy of the value at `a` in `tmp`.",
        "suggest": "在 `tmp` 中的 `a` 处创建值的按位副本。",
        "translate": ""
    },
    {
        "source": "Exiting at this point (either by explicitly returning or by calling a function which panics) would cause the value in `tmp` to be dropped while the same value is still referenced by `a`.",
        "suggest": "此时退出 (通过显式返回或调用 panics 的函数) 将导致 `tmp` 中的值被丢弃，而 `a` 仍引用相同的值。",
        "translate": ""
    },
    {
        "source": "This could trigger undefined behavior if `T` is not `Copy`.",
        "suggest": "如果 `T` 不是 `Copy`，则可能触发未定义的行为。",
        "translate": ""
    },
    {
        "source": "Create a bitwise copy of the value at `b` in `a`.",
        "suggest": "在 `a` 中的 `b` 处创建值的按位副本。",
        "translate": ""
    },
    {
        "source": "This is safe because mutable references cannot alias.",
        "suggest": "这是安全的，因为可变引用不能使用别名。",
        "translate": ""
    },
    {
        "source": "As above, exiting here could trigger undefined behavior because the same value is referenced by `a` and `b`.",
        "suggest": "如上所述，退出此处可能会触发未定义的行为，因为 `a` 和 `b` 引用了相同的值。",
        "translate": ""
    },
    {
        "source": "Move `tmp` into `b`.",
        "suggest": "将 `tmp` 移至 `b`。",
        "translate": ""
    },
    {
        "source": "has been moved (`write` takes ownership of its second argument), so nothing is dropped implicitly here.",
        "suggest": "已被移动 (`write` 拥有其第二个参数的所有权)，因此此处未隐式丢弃任何内容。",
        "translate": ""
    },
    {
        "source": "now points to the same underlying memory as `s`.",
        "suggest": "现在指向与 `s` 相同的基础内存。",
        "translate": ""
    },
    {
        "source": "Assigning to `s2` causes its original value to be dropped.",
        "suggest": "分配给 `s2` 会导致其原始值被丢弃。",
        "translate": ""
    },
    {
        "source": "Beyond this point, `s` must no longer be used, as the underlying memory has been freed.",
        "suggest": "除此之外，由于已释放基础内存，因此不能再使用 `s`。",
        "translate": ""
    },
    {
        "source": "Assigning to `s` would cause the old value to be dropped again, resulting in undefined behavior.",
        "suggest": "分配给 `s` 将导致旧值再次被丢弃，从而导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "can be used to overwrite a value without dropping it.",
        "suggest": "可用于覆盖一个值而不丢弃它。",
        "translate": ""
    },
    {
        "source": "Here we attempt to take the address of a 32-bit integer which is not aligned.",
        "suggest": "在这里，我们尝试获取未对齐的 32 位整数的地址。",
        "translate": ""
    }
]
